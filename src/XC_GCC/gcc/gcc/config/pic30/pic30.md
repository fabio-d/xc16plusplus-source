;;- Machine description for GNU compiler
;;- Microchip dsPIC30 version.
;; Copyright (C) 1994, 1995, 1996, 1997 Free Software Foundation, Inc.

;; Contributed by John Elliott (john.elliott@microchip.com)

;; This file is part of GNU CC.

;; GNU CC is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 1, or (at your option)
;; any later version.

;; GNU CC is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU CC; see the file COPYING.  If not, write to
;; the Free Software Foundation, 59 Temple Place - Suite 330,
;; Boston, MA 02111-1307, USA.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;	This is the machine description for the Microchip dsPIC.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;- instruction definitions
;;
;;- See file "rtl.def" for documentation on define_insn, match_*, et. al.
;;
;; dsPIC30 specific remarks:
;;
;; 1) BITS_PER_UNIT = 8
;;
;; 2) GCC to dsPIC30 data type mappings:
;;    QImode => char (8 bits or 1 reg).
;;    HImode => short/int (16 bits or 1 reg).
;;    SImode => long (32 bits or 2 regs).
;;    DImode => long long (64 bits or 4 regs).
;;    SFmode => single precision float (32 bits or 2 regs).
;;    DFmode => double precision float (64 bits or 4 regs).
;; 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Condition code settings.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; clobber - value of cc is unknown
;; unchanged - insn does not affect cc
;; set - set to agree with the results of the operation
;; change0 - insn does not affect cc but it does modify operand 0
;;	cc only changed if the item previously set into the condition code
;;	has been modified.
;; math - value of cc has incorrect C and OV flags
;; move - value of cc has incorrect C and OV flags
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define_attr "cc" "clobber,unchanged,set,change0,math,move"
  (const_string "clobber"))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; machine specific PREDICATE_CODES

;; define_predicate automatically includes the equivalent of
;;    (ior (match_test "GET_MODE(op) == mode")
;;         (macch_test "GET_MODE(op) == VOIDmode"))
;;
;; so no need to do this.  If you don't want it, use define_special_predicate
;;

;;  {"pic30_general_operand", {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF, 
;;                             LABEL_REF, SUBREG, REG, MEM }}, 

;; 
;; pic30_general_operand does not accept any for the funky C30 pointer modes
;;
(define_predicate "pic30_general_operand"
  (match_operand 0 "general_operand")
{
  if (GET_CODE(op) == MEM) {
    rtx inner = XEXP(op,0);

    if ((GET_MODE(inner) == P24PROGmode) || (GET_MODE(inner) == P24PSVmode) ||
        (GET_MODE(inner) == P16PMPmode) || (GET_MODE(inner) == P32EXTmode) ||
        (GET_MODE(inner) == P32EDSmode) || (GET_MODE(inner) == P32PEDSmode)) {
      /* a de-reference of an extended pointer - not general */
      return 0;
    }
#if 1
  } else if (REG_P(op) && (REGNO(op) < FIRST_PSEUDO_REGISTER)) {
    /* general regs doesn't check the regclass - which is really annoying
       because 'g' does... */
    return reg_fits_class_p(op, GENERAL_REGS, 0, GET_MODE(op));
#endif
  }
  return 1;
})

(define_predicate "pic30_pushhi_operand"
  (ior (match_code "reg")
       (match_test "pic30_T_constraint(op,mode)")
       (and (match_code "mem")
            (match_test "GET_CODE(XEXP(op,0)) == REG")
            (match_test "GET_MODE(XEXP(op,0)) == machine_Pmode"))
       (and (match_code "const_int")
            (match_test "(INTVAL(op) == 0)"))
       (match_code "post_inc")
       (match_code "pre_inc")))

;;  { "pic30_psvapge_operand", { REG }}, 

(define_special_predicate "pic30_psvpage_operand"
  (and (match_code "reg")
       (match_test "REGNO(op) == PSVPAG")
       (match_test "GET_MODE(op) == QImode")))

;;  { "pic30_psv_operand", { MEM }}, 

(define_predicate "pic30_prog_operand"
  (and (match_test "pic30_extended_pointer_operand(op, P24PROGmode)")
       (match_code "post_inc,pre_dec,pre_inc,post_dec,reg,subreg,plus,symbol_ref,const")))

(define_predicate "pic30_psv_operand"
  (and (match_test "pic30_extended_pointer_operand(op, P24PSVmode)")
       (match_code "post_inc,pre_dec,pre_inc,post_dec,reg,subreg,plus,symbol_ref,const")))

(define_predicate "pic30_apsv_operand"
  (and (match_test "pic30_extended_pointer_operand(op, P16APSVmode)")
       (match_code "post_inc,pre_dec,pre_inc,post_dec,reg,subreg,plus,symbol_ref,const")))

(define_predicate "pic30_pmp_operand"
  (and (match_test "pic30_extended_pointer_operand(op, P16PMPmode)")
       (match_code "post_inc,pre_dec,pre_inc,post_dec,reg,subreg,plus,symbol_ref,const")))

(define_predicate "pic30_ext_operand"
  (and (match_test "pic30_extended_pointer_operand(op, P32EXTmode)")
       (match_code "post_inc,pre_dec,pre_inc,post_dec,reg,subreg,plus,symbol_ref,const")))

(define_predicate "pic30_eds_operand"
  (and (match_test "pic30_extended_pointer_operand(op, mode)")
       (match_code "post_inc,pre_dec,pre_inc,post_dec,reg,subreg,plus,symbol_ref,const")))

(define_predicate "pic30_df_operand"
  (and (match_test "pic30_extended_pointer_operand(op, mode)")
       (match_code "post_inc,pre_dec,pre_inc,post_dec,reg,subreg,plus,symbol_ref,const")))

;;  { "pic30_tbl_operand", { MEM }}, 
;;  unused

;;  { "pic30_register_operand", { REG, SUBREG }}, 

(define_predicate "pic30_register_operand"
  (and (match_code "reg,subreg")
       (match_test "pic30_register_operand_helper(op,mode,parf_subreg_ok)")))

(define_predicate "pic30_D_register_operand"
  (and (match_code "reg,subreg")
       (match_test "pic30_register_operand_helper(op,mode,parf_D_regs_only | parf_subreg_ok)")))

(define_predicate "pic30_strict_register_operand"
  (and (match_code "reg")
       (match_test "pic30_register_operand_helper(op,mode,0)")))

;;  { "pic30_mode1_operand", { REG, MEM, SUBREG, CONST_INT }}, 

(define_predicate "pic30_mode1_operand"
  (and (match_test "pic30_mode1MinMax_operand(op,mode,-16,15)")
       (match_code "subreg,reg,mem,const_int")))

(define_predicate "pic30_mode1_0k_operand"
  (and (match_test "pic30_mode1MinMax_operand(op,mode,0,0)")
       (match_code "subreg,reg,mem,const_int")))

(define_predicate "pic30_mode1_APSV_operand"
  (and (match_test "pic30_mode1MinMax_APSV_operand(op,mode,-16,15)")
       (match_code "subreg,reg,mem,const_int")))

;;  { "pic30_mode1P_operand", { REG, MEM, SUBREG, CONST_INT }}, 

(define_predicate "pic30_mode1P_operand"
  (and (match_test "pic30_mode1MinMax_operand(op,mode,0,31)")
       (match_code "subreg,reg,mem,const_int")))

(define_predicate "pic30_mode1P_APSV_operand"
  (and (match_test "pic30_mode1MinMax_APSV_operand(op,mode,0,31)")
       (match_code "subreg,reg,mem,const_int")))

(define_predicate "pic30_mode1P_or_1bit_APSV_operand"
  (and 
       (ior 
           (match_test "pic30_mode1MinMax_APSV_operand(op,mode,0,31)")
           (match_test "pic30_one_bit_set(mode,op,1)")
       )
       (match_code "subreg,reg,mem,const_int")))

(define_predicate "pic30_mode1P_or_1bitclr_APSV_operand"
  (and 
       (ior 
           (match_test "pic30_mode1MinMax_APSV_operand(op,mode,0,31)")
           (match_test "pic30_one_bit_set(mode,op,0)")
       )
       (match_code "subreg,reg,mem,const_int")))

;;  { "pic30_mode1PN_operand", { REG, MEM, SUBREG, CONST_INT }}, 

(define_predicate "pic30_mode1PN_operand"
  (and (match_test "pic30_mode1MinMax_operand(op,mode,-31,31)")
       (match_code "subreg,reg,mem,const_int")))

(define_predicate "pic30_mode1PN_APSV_operand"
  (and (match_test "pic30_mode1MinMax_APSV_operand(op,mode,-31,31)")
       (match_code "subreg,reg,mem,const_int")))

;;  { "pic30_mode1J_operand", { REG, MEM, SUBREG, CONST_INT }}, 

(define_predicate "pic30_mode1J_operand"
  (and (match_test "pic30_mode1MinMax_operand(op,mode,0,1023)")
       (match_code "subreg,reg,mem,const_int")))

(define_predicate "pic30_mode1J_APSV_operand"
  (and (match_test "pic30_mode1MinMax_APSV_operand(op,mode,0,1023)")
       (match_code "subreg,reg,mem,const_int")))

(define_predicate "pic30_mode1J_or_1bitclr_APSV_operand"
  (and
       (ior
           (match_test "pic30_mode1MinMax_APSV_operand(op,mode,0,1023)")
           (match_test "pic30_one_bit_set(mode,op,0)")
       )
       (match_code "subreg,reg,mem,const_int")))

;;  { "pic30_mode1JN_operand", { REG, MEM, SUBREG, CONST_INT }}, 

(define_predicate "pic30_mode1JN_operand"
  (and (match_test "pic30_mode1MinMax_operand(op,mode,-31,1023)")
       (match_code "subreg,reg,mem,const_int")))

(define_predicate "pic30_mode1JN_APSV_operand"
  (and (match_test "pic30_mode1MinMax_APSV_operand(op,mode,-31,1023)")
       (match_code "subreg,reg,mem,const_int")))

;;  { "pic30_indirect_mem_operand", { MEM }}, 

(define_predicate "pic30_indirect_mem_operand_modify"
  (and (match_code "mem")
       (match_code "post_inc,post_dec" "0")
       (match_test "GET_MODE(XEXP(op,0)) == machine_Pmode")))

(define_predicate "pic30_reg_or_indirect_mem_operand_modify"
  (ior (match_code "reg")
       (and (match_code "mem")
            (match_code "post_inc,post_dec" "0")
            (match_test "GET_MODE(XEXP(op,0)) == machine_Pmode"))))

(define_predicate "pic30_APSV_indirect_mem_operand_modify"
  (and (match_code "mem")
       (match_code "post_inc,post_dec,pre_inc,pre_dec" "0")
       (ior (match_test "GET_MODE(XEXP(op,0)) == machine_Pmode")
            (match_test "GET_MODE(XEXP(op,0)) == P16APSVmode"))))

(define_predicate "pic30_indirect_mem_operand"
  (and (match_code "mem")
       (match_code "post_inc,post_dec,pre_inc,pre_dec,reg" "0")
       (match_test "GET_MODE(XEXP(op,0)) == machine_Pmode")))

(define_predicate "pic30_DI_indirect_mem_operand"
  (and (match_code "mem")
       (match_code "post_inc,reg" "0")
       (match_test "GET_MODE(XEXP(op,0)) == machine_Pmode")))

(define_predicate "pic30_unified_indirect_mem_operand"
  (and (match_code "mem")
       (match_code "post_inc,post_dec,pre_inc,pre_dec,reg" "0")
       (match_test "GET_MODE(XEXP(op,0)) == Pmode")))

(define_predicate "pic30_APSV_indirect_mem_operand"
  (and (match_code "mem")
       (match_code "post_inc,post_dec,pre_inc,pre_dec,reg" "0")
       (ior (match_test "GET_MODE(XEXP(op,0)) == machine_Pmode")
            (match_test "GET_MODE(XEXP(op,0)) == P16APSVmode"))))

;;  { "pic30_mode3_operand", { SUBREG, REG, MEM }}, 

(define_predicate "pic30_mode3_operand"
  (and (match_code "subreg,reg,mem")
       (match_test "pic30_mode3_operand_helper(op,mode,0)")))

(define_predicate "pic30_unified_mode3_operand"
  (and (match_code "subreg,reg,mem")
       (match_test "pic30_mode3_operand_helper(op,mode,1)")))

(define_predicate "pic30_mode3_APSV_operand"
  (and (match_code "subreg,reg,mem")
       (match_test "pic30_mode3_APSV_operand_helper(op,mode)")))

;;  { "pic30_modek_operand", { MEM }}, 

(define_predicate "pic30_modek_operand"
  (and (match_code "subreg,mem")
       (match_test "pic30_modek_operand_helper(op,mode,0)")))

(define_predicate "pic30_unified_modek_operand"
  (and (match_code "subreg,mem")
       (match_test "pic30_modek_operand_helper(op,mode,1)")))

(define_predicate "pic30_modek_APSV_operand"
  (and (match_code "subreg,mem")
       (match_test "pic30_modek_APSV_operand_helper(op,mode)")))

;;  { "pic30_data_operand", { MEM }}, 

(define_predicate "pic30_data_operand"
  (and (match_test "GET_MODE(op) != QImode")
       (match_test "pic30_T_constraint(op,mode)")))

;;  { "pic30_move2_operand", { SUBREG, REG, MEM }}, 

(define_predicate "pic30_move2_operand"
  (ior (match_operand 0 "pic30_mode3_operand")
       (match_operand 0 "pic30_modek_operand")))

(define_predicate "pic30_unified_move2_operand"
  (ior (match_operand 0 "pic30_unified_mode3_operand")
       (match_operand 0 "pic30_unified_modek_operand")))

(define_predicate "pic30_move2_APSV_operand"
  (ior (match_operand 0 "pic30_mode3_APSV_operand")
       (match_operand 0 "pic30_modek_APSV_operand")))

;;  { "pic30_mode2_operand", { SUBREG, REG, MEM }}, 

(define_predicate "pic30_mode2_operand"
  (match_code "subreg,reg,mem")
{
  int fMode2Operand;
  enum rtx_code code;

  fMode2Operand = FALSE;
  if (mode == VOIDmode) mode = GET_MODE(op);
  code = GET_CODE(op);
  switch (code) {
    case SUBREG:
      fMode2Operand = pic30_register_operand(op, mode);
      break;
    case REG:
      /*
      ** Register to register
      */
      fMode2Operand = ((GET_MODE(op) == mode) &&
                       ((REGNO(op) <= WR15_REGNO) ||
                        (REGNO(op) >= FIRST_PSEUDO_REGISTER)));
      break;
    case MEM:
      fMode2Operand = pic30_indirect_mem_operand(op,mode);
      break;
    default:
        break;
  }
  return fMode2Operand;
})

(define_predicate "pic30_DI_mode2_operand"
  (match_code "subreg,reg,mem")
{
  int fMode2Operand;
  enum rtx_code code;

  fMode2Operand = FALSE;
  if (mode == VOIDmode) mode = GET_MODE(op);
  code = GET_CODE(op);
  switch (code) {
    case SUBREG:
      fMode2Operand = pic30_register_operand(op, mode);
      break;
    case REG:
      /*
      ** Register to register
      */
      fMode2Operand = ((GET_MODE(op) == mode) &&
                       ((REGNO(op) <= WR15_REGNO) ||
                        (REGNO(op) >= FIRST_PSEUDO_REGISTER)));
      break;
    case MEM:
      fMode2Operand = pic30_DI_indirect_mem_operand(op,mode);
      break;
    default:
        break;
  }
  return fMode2Operand;
})

(define_predicate "pic30_unified_mode2_operand"
  (match_code "subreg,reg,mem")
{
  int fMode2Operand;
  enum rtx_code code;

  fMode2Operand = FALSE;
  if (mode == VOIDmode) mode = GET_MODE(op);
  code = GET_CODE(op);
  switch (code) {
    case SUBREG:
      fMode2Operand = pic30_register_operand(op, mode);
      break;
    case REG:
      /*
      ** Register to register
      */
      fMode2Operand = ((GET_MODE(op) == mode) &&
                       ((REGNO(op) <= WR15_REGNO) ||
                        (REGNO(op) >= FIRST_PSEUDO_REGISTER)));
      break;
    case MEM:
      fMode2Operand = pic30_unified_indirect_mem_operand(op,mode);
      break;
    default:
        break;
  }
  return fMode2Operand;
})

(define_predicate "pic30_D_mode2_operand"
  (match_code "subreg,reg,mem")
{
  int fMode2Operand;
  enum rtx_code code;

  fMode2Operand = FALSE;
  if (mode == VOIDmode) mode = GET_MODE(op);
  code = GET_CODE(op);
  switch (code) {
    case SUBREG:
      fMode2Operand = pic30_register_operand(op, mode);
      break;
    case REG:
      /*
      ** Register to register
      */
      fMode2Operand = ((GET_MODE(op) == mode) &&
                       (((REGNO(op) <= WR15_REGNO) &&
                         (REGNO(op) & 1 == 0)) ||
                        (REGNO(op) >= FIRST_PSEUDO_REGISTER)));
      break;
    case MEM:
      fMode2Operand = pic30_indirect_mem_operand(op,mode);
      break;
    default:
        break;
  }
  return fMode2Operand;
})

(define_predicate "pic30_mode2_APSV_operand"
  (match_code "subreg,reg,mem")
{
  int fMode2Operand;
  enum rtx_code code;

  fMode2Operand = FALSE;
  if (mode == VOIDmode) mode = GET_MODE(op);
  code = GET_CODE(op);
  switch (code) {
    case SUBREG:
      fMode2Operand = pic30_register_operand(op, mode);
      break;
    case REG:
      /*
      ** Register to register
      */
      fMode2Operand = ((GET_MODE(op) == mode) &&
                       ((REGNO(op) <= WR15_REGNO) ||
                        (REGNO(op) >= FIRST_PSEUDO_REGISTER)));
      break;
    case MEM:
      fMode2Operand = pic30_indirect_mem_operand(op,mode);
      break;
    default:
        break;
  }
  return fMode2Operand;
})

(define_predicate "pic30_D_mode2_APSV_operand"
  (match_code "subreg,reg,mem")
{
  int fMode2Operand;
  enum rtx_code code;

  fMode2Operand = FALSE;
  code = GET_CODE(op);
  if (mode == VOIDmode) mode = GET_MODE(op);
  switch (code) {
    case SUBREG:
      fMode2Operand = pic30_register_operand(op, mode);
      break;
    case REG:
      /*
      ** Register to register
      */
      fMode2Operand = ((GET_MODE(op) == mode) &&
                       (((REGNO(op) <= WR15_REGNO) &&
                         (REGNO(op) & 1 == 0)) ||
                        (REGNO(op) >= FIRST_PSEUDO_REGISTER)));
      break;
    case MEM:
      fMode2Operand = pic30_indirect_mem_operand(op,mode);
      break;
    default:
        break;
  }
  return fMode2Operand;
})

;;  { "pic30_P_operand", { CONST_INT }}, 

(define_special_predicate "pic30_P_operand"
  (and (match_code "const_int")
       (match_test "INTVAL(op) >= 0")
       (match_test "INTVAL(op) <= 31")))

(define_special_predicate "pic30_N_operand"
  (and (match_code "const_int")
       (match_test "INTVAL(op) <= 0")
       (match_test "INTVAL(op) >= -31")))

;;  { "pic30_mode2_or_P_operand", {SUBREG, REG, MEM, CONST_INT }}, 

(define_predicate "pic30_mode2_or_P_operand"
  (ior (match_operand 0 "pic30_mode2_operand")
       (match_operand 0 "pic30_P_operand")))

(define_predicate "pic30_mode2_or_P_APSV_operand"
  (ior (match_operand 0 "pic30_mode2_APSV_operand")
       (match_operand 0 "pic30_P_operand")))

;;  { "pic30_immediate_1bit_operand", { CONST_INT }}, 

(define_predicate "pic30_immediate_1bit_operand"
  (and (match_code "const_int")
       (match_test "(INTVAL(op) & 0xFFFF) & ((INTVAL(op) & 0xFFFF) - 1) == 0")))

;;  { "pic30_accumulator_operand", { REG }}, 

(define_predicate "pic30_accumulator_operand"
  (and (match_code "reg")
       (match_test "IS_ACCUM_REG(REGNO(op))")))

(define_predicate "pic30_accumulator2_operand"
  (and (match_code "reg")
       (ior (match_test "IS_ACCUM_REG(REGNO(op))")
            (match_test "REGNO(op) >= FIRST_PSEUDO_REGISTER"))))

(define_predicate "pic30_accum_or_reg_operand"
  (ior (match_operand 0 "pic30_accumulator2_operand")
       (match_operand 0 "pic30_register_operand")))

; this operand allows a mode1 op with no +/-k small literal
(define_predicate "pic30_accum_or_mode1_operand"
  (ior (match_operand 0 "pic30_accumulator2_operand")
       (match_operand 0 "pic30_mode1_0k_operand")))

;;  { "pic30_awb_operand", { REG }}, 

(define_predicate "pic30_awb_operand"
  (and (match_code "reg")
       (ior (match_test "REGNO(op) >= FIRST_PSEUDO_REGISTER")
            (match_test "IS_AWB_REG(REGNO(op))"))))

;;  { "pic30_mac_input_operand", { REG }}, 

(define_predicate "pic30_mac_input_operand"
  (ior (match_code "const_int")
       (and (match_code "reg")
            (ior (match_test "REGNO(op) >= FIRST_PSEUDO_REGISTER")
                 (match_test "REGNO_REG_CLASS(REGNO(op)) == SINK_REGS")
                 (match_test "IS_PRODUCT_REG(REGNO(op))")))))

;;   { "pic30_xprefetch_operand", { REG }}, 

(define_predicate "pic30_xprefetch_operand"
  (and (match_code "reg")
       (ior (match_test "REGNO(op) >= FIRST_PSEUDO_REGISTER")
            (match_test "REGNO_REG_CLASS(REGNO(op)) == SINK_REGS")
            (match_test "IS_XPREFETCH_REG(REGNO(op))"))))

;;  { "pic30_yprefetch_operand", { REG }}, 

(define_predicate "pic30_yprefetch_operand"
  (and (match_code "reg")
       (ior (match_test "REGNO(op) >= FIRST_PSEUDO_REGISTER")
            (match_test "REGNO_REG_CLASS(REGNO(op)) == SINK_REGS")
            (match_test "IS_YPREFETCH_REG(REGNO(op))"))))

;;  { "pic30_mode2res_operand", { SUBREG, REG, MEM }}, 

(define_predicate "pic30_mode2res_operand"
  (and (match_operand 0 "pic30_mode2_operand")
       (if_then_else (match_code "mem")
                     (not (match_code "pre_inc,post_dec" "0"))
                     (match_test "1"))))

;;  { "pic30_mode2mres_operand", { SUBREG, REG, MEM }}, 

(define_predicate "pic30_mode2mres_operand"
  (and (match_operand 0 "pic30_mode2_operand")
       (if_then_else (match_code "mem")
                     (not (match_code "pre_inc,post_dec" "0"))
                     (match_test "1"))))

(define_predicate "pic30_mode2mres_APSV_operand"
  (and (match_operand 0 "pic30_mode2_APSV_operand")
       (if_then_else (match_code "mem")
                     (not (match_code "pre_inc,post_dec" "0"))
                     (match_test "1"))))

;;  { "pic30_wreg_operand",  { SUBREG, REG }}, 

(define_predicate "pic30_wreg_operand"
  (match_operand 0 "pic30_register_operand")
{  rtx inner = op;
 
   if (GET_CODE(inner) == SUBREG) inner = SUBREG_REG(inner);
   return (REG_P(inner) && IS_AREG_OR_PSEUDO_REGNO(inner));
})
   
;;  { "pic30_breg_operand",  { SUBREG, REG }}, 

(define_predicate "pic30_breg_operand"
  (match_operand 0 "pic30_register_operand")
{  rtx inner = op;
 
   if (GET_CODE(inner) == SUBREG) inner = SUBREG_REG(inner);
   return (REG_P(inner) && IS_BREG_OR_PSEUDO_REGNO(inner));
})
   
;;  { "pic30_creg_operand", { SUBREG, REG }}, 

(define_predicate "pic30_creg_operand"
  (match_operand 0 "pic30_register_operand")
{  rtx inner = op;
 
   if (GET_CODE(inner) == SUBREG) inner = SUBREG_REG(inner);
   return (REG_P(inner) && IS_CREG_OR_PSEUDO_REGNO(inner));
})
   
;;  { "pic30_ereg_operand", { SUBREG, REG }}, 

(define_predicate "pic30_ereg_operand"
  (match_operand 0 "pic30_register_operand")
{  rtx inner = op;
 
   if (GET_CODE(inner) == SUBREG) inner = SUBREG_REG(inner);
   return (REG_P(inner) && IS_EREG_OR_PSEUDO_REGNO(inner));
})

;;  { "pic30_near_operand", { MEM }}, 

(define_predicate "pic30_near_operand"
  (match_test "pic30_U_constraint(op,mode)"))

(define_predicate "pic30_sfr_operand"
  (and (match_test "pic30_U_constraint(op,mode)")
       (match_test "pic30_sfr_operand_helper(op)")))

;;  { "pic30_T_operand", { MEM }}, 

(define_predicate "pic30_T_operand"
  (and (match_code "mem")
       (match_test "pic30_T_constraint(op,mode)")))

(define_predicate "pic30_UT_operand"
  (ior (match_operand 0 "pic30_T_operand")
       (match_operand 0 "pic30_near_operand")))

;;  { "pic30_code_operand", { MEM }}, 

(define_predicate "pic30_code_operand"
  (and (match_code "mem")
       (match_test "pic30_program_space_operand_p(XEXP(op,0))")))

;;  { "pic30_reg_or_code_operand", { SUBREG, REG, MEM }}, 

(define_predicate "pic30_reg_or_code_operand"
  (ior (match_operand 0 "pic30_register_operand")
       (match_operand 0 "pic30_code_operand")))

;;  { "pic30_reg_or_near_operand", { SUBREG, REG, MEM }}, 

(define_predicate "pic30_reg_or_near_operand"
  (ior (match_operand 0 "pic30_register_operand")
       (match_operand 0 "pic30_near_operand")))

;;  { "pic30_mode2_or_near_operand", { SUBREG, REG, MEM }},

(define_predicate "pic30_mode2_or_near_operand"
  (ior (match_operand 0 "pic30_mode2_operand")
       (match_operand 0 "pic30_near_operand")))

;;  { "pic30_reg_imm_or_near_operand", { SUBREG, REG, MEM, CONST_INT }}, 

(define_predicate "pic30_reg_imm_or_near_operand"
  (ior (match_operand 0 "immediate_operand")
       (match_operand 0 "pic30_register_operand")
       (match_operand 0 "pic30_near_operand")))

;;  { "pic30_R_operand", { MEM }},

(define_predicate "pic30_R_operand"
  (match_test "pic30_R_constraint(op)"))

(define_predicate "pic30_R_APSV_operand"
  (match_test "pic30_R_constraint(op)"))

;;  { "pic30_reg_or_R_operand", { SUBREG, REG, MEM }}, 

(define_predicate "pic30_reg_or_R_operand"
  (ior (match_operand 0 "pic30_register_operand")
       (match_operand 0 "pic30_R_operand")))

(define_predicate "pic30_reg_or_R_APSV_operand"
  (ior (match_operand 0 "pic30_register_operand")
       (match_operand 0 "pic30_R_APSV_operand")))

;;  { "pic30_rR_or_near_operand", { SUBREG, REG, MEM }}, 

(define_predicate "pic30_rR_or_near_operand"
  (ior (match_operand 0 "pic30_reg_or_R_operand")
       (match_operand 0 "pic30_near_operand")))

(define_predicate "pic30_rR_or_near_APSV_operand"
  (ior (match_operand 0 "pic30_reg_or_R_APSV_operand")
       (match_operand 0 "pic30_near_operand")))

;;  { "pic30_wreg_or_near_operand", { SUBREG, REG, MEM }}, 

(define_predicate "pic30_wreg_or_near_operand"
  (ior (match_operand 0 "pic30_wreg_operand")
       (match_operand 0 "pic30_near_operand")))

;;  { "pic30_reg_or_imm_operand", { SUBREG, REG, CONST_INT }}, 

(define_predicate "pic30_reg_or_imm_operand"
  (ior (match_operand 0 "pic30_register_operand")
       (match_operand 0 "immediate_operand")))

;;  { "pic30_imm2to15_operand", { CONST_INT }}, 

(define_special_predicate "pic30_imm2to15_operand"
  (and (match_operand 0 "immediate_operand")
       (match_test "INTVAL(op) >= 2")
       (match_test "INTVAL(op) <= 15")))

;;  { "pic30_imm8_operand", { CONST_INT }}, 

(define_special_predicate "pic30_imm8_operand"
  (and (match_operand 0 "immediate_operand")
       (match_test "INTVAL(op) == 8")))

(define_special_predicate "pic30_reg_or_lit8"
  (ior (match_operand 0 "pic30_register_operand")
       (and (match_operand 0 "immediate_operand")
            (match_test "INTVAL(op) >= 0")
            (match_test "INTVAL(op) < 256"))))

;;  { "pic30_imm16plus_operand", { CONST_INT }}, 

(define_special_predicate "pic30_imm16plus_operand"
  (and (match_operand 0 "immediate_operand")
       (match_test "INTVAL(op) >= 16")))

;;  { "pic30_M_operand", { CONST_INT }}, 

(define_special_predicate "pic30_M_operand"
  (and (match_code "const_int")
       (match_test "INTVAL(op) <= 0")
       (match_test "INTVAL(op) >= -1023")))

;;  { "pic30_J_operand", { CONST_INT }}, 

(define_special_predicate "pic30_J_operand"
  (and (match_code "const_int")
       (match_test "INTVAL(op) >= 0")
       (match_test "INTVAL(op) <= 1023")))

(define_special_predicate "pic30_OJM_operand"
  (and (match_code "const_int")
       (match_test "INTVAL(op) >= -511")
       (match_test "INTVAL(op) <= 511")))

;;  { "pic30_JN_operand", { CONST_INT }}, 

(define_special_predicate "pic30_JN_operand"
  (ior (match_operand 0 "pic30_J_operand")
       (match_operand 0 "pic30_N_operand")))

;;  { "pic30_JM_operand", { CONST_INT }}, 

(define_special_predicate "pic30_JM_operand"
  (ior (match_operand 0 "pic30_J_operand")
       (match_operand 0 "pic30_M_operand")))

;;  { "pic30_math_operand", { REG, MEM, SUBREG, CONST_INT }}, 

(define_special_predicate "pic30_math_operand"
  (ior (match_operand 0 "pic30_mode1_operand")
       (match_operand 0 "pic30_JN_operand")))

(define_special_predicate "pic30_JMmath_operand"
  (ior (match_operand 0 "pic30_mode1_operand")
       (match_operand 0 "pic30_JM_operand")))

(define_special_predicate "pic30_math_APSV_operand"
  (ior (match_operand 0 "pic30_mode1_APSV_operand")
       (match_operand 0 "pic30_JN_operand")))

;;  { "pic30_inc_imm_operand", { CONST_INT }}, 

(define_special_predicate "pic30_inc_imm_operand"
  (and (match_operand 0 "immediate_operand")
       (match_test "INTVAL(op) >= -2")
       (match_test "INTVAL(op) <= 2")))
      
;;  { "pic30_near_math_operand", { REG, MEM, SUBREG,  CONST_INT }}, 

(define_special_predicate "pic30_near_math_operand"
  (ior (match_operand 0 "pic30_math_operand")
       (match_operand 0 "pic30_wreg_or_near_operand")))

;;  { "pic30_near_mode2_operand", { REG, MEM, SUBREG }}, 

(define_predicate "pic30_near_mode2_operand"
  (ior (match_operand 0 "pic30_mode2_operand")
       (match_operand 0 "pic30_wreg_or_near_operand")))
   
(define_predicate "pic30_near_mode2_APSV_operand"
  (ior (match_operand 0 "pic30_mode2_APSV_operand")
       (match_operand 0 "pic30_wreg_or_near_operand")))
   
;;  { "pic30_near_mode1PN_operand", { REG, MEM, SUBREG,  CONST_INT }}, 

(define_predicate "pic30_near_mode1PN_operand"
  (ior (match_operand 0 "pic30_mode1PN_operand")
       (match_operand 0 "pic30_wreg_or_near_operand")))

(define_predicate "pic30_near_mode1PN_APSV_operand"
  (ior (match_operand 0 "pic30_mode1PN_APSV_operand")
       (match_operand 0 "pic30_wreg_or_near_operand")))

;;  { "pic30_move_operand", { SUBREG, REG, MEM }}, 

(define_predicate "pic30_move_operand"
  (ior (match_operand 0 "pic30_mode3_operand")
       (match_operand 0 "pic30_modek_operand")
       (match_operand 0 "pic30_near_operand")
       (match_operand 0 "pic30_data_operand")))

(define_predicate "pic30_movedi_operand"
  (ior (match_operand 0 "pic30_mode2_operand")
       (match_operand 0 "pic30_modek_operand")
       (match_operand 0 "pic30_near_operand")
       (match_operand 0 "pic30_data_operand")))

(define_predicate "pic30_moveb_operand"
  (ior (match_operand 0 "pic30_mode3_operand")
       (match_operand 0 "pic30_near_operand")
       (match_operand 0 "pic30_data_operand")))

(define_predicate "pic30_moveb_APSV_operand"
  (ior (match_operand 0 "pic30_mode3_APSV_operand")
       (match_operand 0 "pic30_near_operand")
       (match_operand 0 "pic30_data_operand")))

(define_predicate "pic30_move_APSV_operand"
  (ior (match_operand 0 "pic30_mode3_APSV_operand")
       (match_operand 0 "pic30_modek_APSV_operand")
       (match_operand 0 "pic30_near_operand")
       (match_operand 0 "pic30_data_operand")))

(define_predicate "pic30_move_d_operand"
  (ior (match_test      "pic30_mode1MinMax_operand(op,mode,0,0)")
       (match_operand 0 "pic30_data_operand")
       (match_operand 0 "pic30_modek_operand")))

;;  { "pic30_invalid_address_operand", { SYMBOL_REF, LABEL_REF, CONST }}, 

(define_predicate "pic30_invalid_address_operand"
  (match_test "1")
{
  switch (GET_CODE(op)) {
    default: return FALSE;
    case MEM: return pic30_invalid_address_operand(XEXP(op,0), mode);
    case LABEL_REF:  return 0;
    case SYMBOL_REF:
      if ((PIC30_HAS_NAME_P(XSTR(op,0), PIC30_PROG_FLAG)) ||
          (PIC30_HAS_NAME_P(XSTR(op,0), PIC30_AUXFLASH_FLAG))) {
        const char *real_name = pic30_strip_name_encoding_helper(XSTR(op,0));
        tree sym=0;

        sym = maybe_get_identifier(real_name);
        if (sym) sym = lookup_name(sym);
        if (sym) error("%JInappropriate program address '%s'", sym, real_name);
        else error("Inappropriate program address '%s'", real_name);
        return 1;
      }
      break;
    case CONST:
      op = XEXP (op, 0);
      if (((GET_CODE (XEXP (op, 0)) == SYMBOL_REF) ||
           (GET_CODE (XEXP (op, 0)) == LABEL_REF)) &&
          (GET_CODE (XEXP (op, 1)) == CONST_INT))
      return pic30_invalid_address_operand(XEXP(op,0), mode);
  }
  return 0;
})

;;  { "pic30_symbolic_address_operand", { SYMBOL_REF, LABEL_REF, CONST }}, 

(define_special_predicate "pic30_symbolic_address_operand"
  (match_test "1")
{
  int done;

  do {
    done = 1;
    switch (GET_CODE (op)) {
      case SUBREG:
        if (GET_MODE(op) != mode) break;
        op = XEXP(op,0);
        /* allow the cast from modes that do not require special handling */
        switch (GET_CODE(op)) {
          case SYMBOL_REF:
          case LABEL_REF: 
            switch (GET_MODE(op)) {
              default:  /* the outer type must match */
                        break;
              case QImode:
              case HImode:
              case SImode:
              case DImode:
              case SFmode:
              case DFmode:
              case P16APSVmode:
                mode = VOIDmode;
                break;
            }
            break;
          default:
            /* other operations do not require special handling, regardless of
               mode */
	    mode = VOIDmode;
            break;
        }
        done = 0;
        break;
      case SYMBOL_REF:
      case LABEL_REF:
        if ((mode == P24PSVmode) ||
            (mode == P24PROGmode) ||
            (mode == VOIDmode)) {
          int string_constant = 0;

          if (GET_CODE(op) == SYMBOL_REF) {
            tree exp;
            exp = SYMBOL_REF_DECL(op);

            /* I assume this can only happen in there is no SYMBOL_REF
               which means that this is coming from IV cost anaylis? */
            if (exp == 0) return TRUE;

            string_constant = ((TREE_CODE(exp) == STRING_CST) &&
                               (TARGET_CONST_IN_CODE || TARGET_CONST_IN_PSV));
          }
          if (((mode == VOIDmode) || (GET_MODE(op) == mode)) &&
              (string_constant || pic30_builtin_tblpsv_arg_p(NULL,op)))
            return TRUE;
        }
        if ((mode == P16APSVmode) || (mode == VOIDmode)) {
          if (pic30_has_space_operand_p(op,PIC30_APSV_FLAG)) return TRUE;
          if (pic30_data_space_operand_p(GET_MODE(op),op,0)) return TRUE;
        }
        if ((mode == P32DFmode) || (mode == VOIDmode)) {
          if (pic30_has_space_operand_p(op,PIC30_PACKEDFLASH_FLAG)) return TRUE;
        }
        if ((mode == P32EXTmode) || (mode == VOIDmode)) {
          if (pic30_has_space_operand_p(op,PIC30_EXT_FLAG)) return TRUE;
        }
        if ((mode == P16PMPmode) || (mode == VOIDmode)) {
          if (pic30_has_space_operand_p(op,PIC30_PMP_FLAG)) return TRUE;
        }
        if ((mode == P32EDSmode) ||
            (mode == P32PEDSmode) ||
            (mode == VOIDmode)) {
#if 0
          /* IV cost analysis sometimes makes an 'empty' symbol to validate
             the costs, and sym would be null.  

             I don't really think we need this code anyway, we are just 
             checking to see if it is a string... what else would it be? */
          tree sym = SYMBOL_REF_DECL(op);

          if (GET_CODE(op) == SYMBOL_REF) {
            if (TREE_CODE(sym) == STRING_CST) return TRUE;
          }
#endif
          /* these pointers are compatible with a multitude of spaces */
          if (pic30_eds_space_operand_p(op)) return TRUE;
        }
        if (mode == STACK_Pmode) return TRUE;
        if (mode == FN_Pmode) return TRUE;
        if (mode == Pmode) return TRUE;
        break;
      case CONST:
        op = XEXP (op, 0);
        if ((mode == P24PSVmode) ||
            (mode == P24PROGmode) ||
            (mode == VOIDmode)) {
          if (((GET_CODE (XEXP (op, 0)) == SYMBOL_REF ||
                    GET_CODE (XEXP (op, 0)) == LABEL_REF) &&
                   ((mode == VOIDmode) || (GET_MODE(XEXP(op,0)) == mode)) &&
                   (pic30_builtin_tblpsv_arg_p(NULL,op))) &&
                  GET_CODE (XEXP (op, 1)) == CONST_INT) return TRUE;
        }
        if ((mode == P16PMPmode) || (mode == P32EXTmode) || 
            (mode == P32DFmode)) {
          op = XEXP(op,0);
          done = 0;
          break;
        } else {
          return (((GET_CODE (XEXP (op, 0)) == SYMBOL_REF ||
                    GET_CODE (XEXP (op, 0)) == LABEL_REF)) &&
                  GET_CODE (XEXP (op, 1)) == CONST_INT);
        }
      default:
        break;
    }
  } while (!done);
  return FALSE;
})

;;  { "pic30_call_address_operand", { SYMBOL_REF, LABEL_REF, CONST, REG }}, 

(define_predicate "pic30_call_address_operand"
  (ior (match_code "reg")
       (match_operand 0 "pic30_symbolic_address_operand")))

(define_predicate "pic30_reg_or_symbolic_address"
  (ior (match_operand 0 "pic30_register_operand")
       (match_operand 0 "pic30_symbolic_address_operand")))

(define_predicate "pic30_reg_or_symbolic_address_or_immediate"
  (ior (match_operand 0 "pic30_register_operand")
       (ior (match_operand 0 "immediate_operand")
            (match_operand 0 "pic30_symbolic_address_operand"))))

;;  { "pic30_reg_or_zero_operand", { SUBREG, REG, CONST_INT }}, 

(define_special_predicate "pic30_reg_or_zero_operand"
  (ior (match_test "op == CONST0_RTX(mode)")
       (match_operand 0 "pic30_register_operand")))
 
;;  { "pic30_rR_or_zero_operand", { SUBREG, REG, MEM, CONST_INT }}, 

(define_special_predicate "pic30_rR_or_zero_operand"
  (ior (match_test "op == CONST0_RTX(mode)")
       (match_operand 0 "pic30_reg_or_R_operand")))

;;  { "pic30_O_operand", { CONST_INT }}, 

(define_special_predicate "pic30_O_operand"
  (match_test "op == CONST0_RTX(mode)"))

;;  { "pic30_I_operand", { CONST_INT }}, 

(define_special_predicate "pic30_I_operand"
  (match_test "op == CONST1_RTX(mode)"))

;;  { "pic30_PN_operand", { CONST_INT }}, 

(define_special_predicate "pic30_PN_operand"
  (ior (match_operand 0 "pic30_P_operand")
       (match_operand 0 "pic30_N_operand")))

;;  { "pic30_JMNP_operand", { CONST_INT }},

(define_special_predicate "pic30_JMNP_operand"
  (ior (match_operand 0 "pic30_JM_operand")
       (match_operand 0 "pic30_PN_operand")))

;;  { "pic30_reg_or_P_operand", { SUBREG, REG, CONST_INT }}, 

(define_special_predicate "pic30_reg_or_P_operand"
  (ior (match_operand 0 "pic30_register_operand")
       (match_operand 0 "pic30_N_operand")))

;;  { "pic30_rR_or_JN_operand", { MEM, SUBREG, REG, CONST_INT }}, 

(define_special_predicate "pic30_rR_or_JN_operand"
  (ior (match_operand 0 "pic30_reg_or_R_operand")
       (match_operand 0 "pic30_JN_operand")))

(define_special_predicate "pic30_rR_or_JN_APSV_operand"
  (ior (match_operand 0 "pic30_reg_or_R_APSV_operand")
       (match_operand 0 "pic30_JN_operand")))

;;  { "pic30_rR_or_JMNP_operand", { MEM, SUBREG, REG, CONST_INT }},

(define_special_predicate "pic30_rR_or_JMNP_operand"
  (ior (match_operand 0 "pic30_reg_or_R_operand")
       (match_operand 0 "pic30_JMNP_operand")))

(define_special_predicate "pic30_rR_or_JMNP_APSV_operand"
  (ior (match_operand 0 "pic30_reg_or_R_APSV_operand")
       (match_operand 0 "pic30_JMNP_operand")))

;;  { "pic30_Q_operand", { MEM }}, 

(define_predicate "pic30_Q_operand"
  (match_test "pic30_Q_constraint(op)"))

(define_predicate "pic30_any_QR_operand"
  (match_test "1")
  {
    int disp;
    if (pic30_Q_constraint_displacement(op,&disp)) return 1;
    if (pic30_R_constraint(op)) return 1;
    return disp != INT_MAX;
  })

(define_predicate "pic30_RQ_operand"
  (ior (match_test "pic30_R_constraint(op)")
       (match_test "pic30_Q_constraint(op)")))

/*
 * for movmem and the like, do not accept other address spaces
 *   this will fall through to the libcall method
 */
(define_predicate "pic30_memory_operand"
  (and (match_code "mem")
       (match_test "MEM_ADDR_SPACE(op) == ADDR_SPACE_GENERIC")
       (match_operand 0 "memory_operand")))

(define_predicate "pic30_RTU_operand"
  (and (match_code "mem")
       (ior (match_operand 0 "pic30_R_operand")
            (match_operand 0 "pic30_near_operand")
            (match_operand 0 "pic30_data_operand"))))

(define_predicate "pic30_unified_mode2k_operand"
  (ior (match_operand 0 "pic30_unified_mode2_operand")
       (match_operand 0 "pic30_unified_modek_operand")))
  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_mode_iterator M32BIT [SI SF P24PSV P24PROG P32EDS P32PEDS P32EXT P32DF])
(define_mode_iterator M64BIT [DI DF])

;; Uses of UNSPEC in this file:

(define_constants
 [(UNSPEC_POPHI		1) ; pop HI
  (UNSPEC_PUSHSHADOW	2) ; push.s -- push shadowed registers
  (UNSPEC_POPSHADOW	3) ; pop.s -- pop shadowed registers
 ]
)

;; UNSPEC_VOLATILE:

(define_constants
 [
  (UNSPECV_BLOCKAGE	        0) ; block insn movement
  (UNSPECV_PA		        1) ; enable/disable PA
  (UNSPECV_IV		        2) ; interrupt vector
  (UNSPECV_PP		        3) ; pre-prologue
  (UNSPECV_NOP		        4) ; '__builtin_nop' instruction
  
  
  
  
  (UNSPECV_DIVSD	        9) ; '__builtin_divsd' instruction
  (UNSPECV_DIVUD               10) ; '__builtin_divud' instruction
  (UNSPECV_MULSS               11) ; '__builtin_mulss' instruction
  (UNSPECV_MULSU               12) ; '__builtin_mulsu' instruction
  (UNSPECV_MULUS               13) ; '__builtin_mulus' instruction
  (UNSPECV_MULUU               14) ; '__builtin_muluu' instruction
  (UNSPECV_READSFR             15) ; '__builtin_readsfr' instruction
  (UNSPECV_DISI                16) ; disi instruction
  (UNSPECV_WRITESFR            17) ; '__builtin_writesfr' instruction
  (UNSPECV_WRITEDISICNT        18) ; 
  (UNSPECV_SAC                 19) ; __builtin_sac
  (UNSPECV_SACR                20) ; __builtin_sacr
  (UNSPECV_FBCL                21) ; __builtin_fbcl
  (UNSPECV_LAC                 22) ; __builtin_lac
  (UNSPECV_SFTAC               23) ; __builtin_sftac
  (UNSPECV_RRNC                24) ; rrnc
  (UNSPECV_TBLADDRESS          25) ; __builtin_tbladdress
  (UNSPECV_SETPSV              26) ; set psv
  (UNSPECV_WRITEOSCCONH        27) ; __builtin_write_OSCCONH
  (UNSPECV_WRITENVM            28) ; __builtin_write_NVM
  (UNSPECV_MODSD               29) ; __builtin_modsd
  (UNSPECV_MODUD               30) ; __builtin_modud
  (UNSPECV_DIVMODSD            31) ; __builtin_divmodsd
  (UNSPECV_DIVMODUD            32) ; __builtin_divmodud
  (UNSPECV_DSPMULT             33) ; __builtin_mpy, etc
  (UNSEPCV_GENLABEL            34) ; __builtin_unique_id
  (UNSPECV_WRITEOSCCONL        35) ; __builtin_write_OSCCONL
  (UNSPECV_TBLRDL              36) ; __builtin_tblrdl
  (UNSPECV_TBLRDH              37) ; __builtin_tblrd7
  (UNSPECV_TBLWTL              38) ; __builtin_tblwtl
  (UNSPECV_TBLWTH              39) ; __builtin_tblwth
  (UNSPEC_SAVE_CONSTPSV        40)
  (UNSPECV_UNPACKEDS           41)
  (UNSPECV_P24PROGPTR          42)
  (UNSPECV_UNPACKMPSV          43)  
  (UNSPECV_UNPACKMPROG         44)  
  (UNSPECV_DIVF                45)
  (UNSPECV_WRITERTCWEN         46)
  (UNSPECV_PSVRDPSV            47) ; psv pointer access
  (UNSPECV_PSVRDPROG           48) ; psv pointer access
  (UNSPECV_PMPRD               49) ; PMP read
  (UNSPECV_PMPWT               50) ; PMP write
  (UNSPECV_EXTRD               51) ; EXT read
  (UNSPECV_EXTWT               52) ; EXT write
  (UNSPECV_WHILEPMMODE         53) ; while (!PMMODEbits.busy)
  (UNSPECV_PMDIN1RD            54) ; read PMPDIN1
  (UNSPECV_PMDIN1WT            55) ; write PMPDIN1
  (UNSPECV_SETPMMODE           56) 
  (UNSPECV_CLRPMMODE           57)
  (UNSPECV_TBLRDLB             58) ; __builtin_tblrdlb
  (UNSPECV_TBLRDHB             59) ; __builtin_tblrdhb
  (UNSPECV_TBLWTLB             60) ; __builtin_tblwtlb
  (UNSPECV_TBLWTHB             61) ; __builtin_tblwthb
  (UNSPECV_USEPSV              62) ; any operation that uses the PSV
  (UNSPECV_EDSRD               63) ;  EDS read
  (UNSPECV_EDSWT               64) ;  EDS write
  (UNSPECV_PEDSRD              65) ;  PEDS read  (paged)
  (UNSPECV_PEDSWT              66) ;  PEDS write (paged)
  (UNSPECV_SETNVPSV            67) ; set psv nonvolatile
  (UNSPECV_SETDSW              68) ; set dsw 
  (UNSPECV_SETNVDSW            69) ; set dsw nonvolatile
  (UNSPECV_OFFSET              70)  
  (UNSPECV_PAGE                71)  
  (UNSPECV_NOEDSRD             72)
  (UNSPECV_NOEDSWT             72)
  (UNSPECV_WRITEPWMCON         73) ; __builtin_write_PWMCON
  (UNSPECV_WRITECRTOTP         74) ; __builtin_write_CRYOTP
  (UNSPEC_SECTION_BEGIN        75)
  (UNSPEC_SECTION_END          76)
  (UNSPEC_SECTION_SIZE         77)
  (UNSPECV_SET_ISR_STATE       78)
  (UNSPEC_GET_ISR_STATE        79)
  (UNSPECV_ENABLE_ISR          80)
  (UNSPECV_DISABLE_ISR         81)
  (UNSPECV_ENABLE_ISR_GIE      82)
  (UNSPECV_DISABLE_ISR_GIE     83)
  (UNSPEC_EXTRACT_GIE          84)
  (UNSPEC_INSERT_GIE           85)
  (UNSPEC_EDSSTACKADDR         86)
  (UNSPECV_ENTER               87)
  (UNSPECV_EXIT                88)
  (UNSPEC_SATURATE             89)
  (UNSPECV_SETSAT              90)
  (UNSPEC_MPY                  91)
  (UNSPEC_FIXSIGN              92)
  (UNSPECV_SOFTWARE_BREAK      93)
  (UNSPECV_WRITEDATAFLASH      94) ; __builtin_write_DATAFLASH
  (UNSPEC_ADDR_LOW             95)
  (UNSPEC_ADDR_HI              96)
  (UNSPEC_ADDR                 97)
  (UNSPECV_PWRSAV              98)
  (UNSPECV_CLRWDT              99)
  (UNSPEC_ACCL                 100)
  (UNSPEC_ACCH                 101)
  (UNSPEC_ACCU                 102)
  (UNSPECV_ASSERT_PSV          103)
  (UNSPECV_SACD                104) ; __builtin_sacd
  (UNSPECV_LACD                105) ; __builtin_lacd
  (UNSPEC_EDSCONSTADDR         106)
  (UNSPECV_WRITEWRLOCK         107)
  (UNSPECV_PSVCONVERT          108)
  (UNSPEC_FF1L                 109)
  (UNSPEC_ASHIFTSI_LOW         110)
  (UNSPECV_TEMP                199)
 ]
)

;; Hard registers (SFRs) && other constants

(define_constants
 [
  (FPREG	   14) ; Frame-pointer hard register number
  (SPREG	   15) ; Stack-pointer hard register number
  (RCOUNT	   16) ; Repeat-count hard register number
  (A_REGNO         17)
  (B_REGNO         18)
  (PSVPAG          19) ; PSVPAG or DSRPAG
  (PMADDR          20) 
  (PMMODE          21)
  (PMDIN1          22)
  (PMDIN2          23)
  (DSWPAG          24)
  (CORCON          36) ; Any part of CORCON
 ]
)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Instruction scheduling
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Memory access attribute.
;; We only care about loads and stores.
;; use -- indirect memory load
;; def -- store to register
;; Everything else is 'etc'.
;;
;; For dealing with RAW stalls, we use the following truth table,
;; where D denotes a store to a wreg (definition), and U denotes an
;; indirect load of a source operand (use).
;;
;;           type   description
;; +---+---+
;; | D | U | 
;; +---+---+
;; | F | F | etc    Insn does not load indirect, does not store to wreg
;; | F | T | use    Insn loads indirect
;; | T | F | def    Insn stores to wreg
;; | T | T | defuse Insn loads indirect, and stores to wreg
;; +---+---+
;;
;; RAW stalls occur when D is followed by U.

(define_automaton "dsPIC30F")

(define_cpu_unit "sched_raw" "dsPIC30F")

(define_insn_reservation "insn_def" 0
  (eq_attr "type" "def")
  "sched_raw")

(define_insn_reservation "insn_use" 1
  (eq_attr "type" "use")
  "sched_raw")

(define_insn_reservation "insn_defuse" 2
  (eq_attr "type" "defuse")
  "sched_raw")

(define_insn_reservation "insn_etc" 0
  (eq_attr "type" "etc")
  "nothing")

;; Insn type.

(define_attr "type" 
  "def,use,defuse,etc"
  (const_string "etc"))

;
; exch
;

(define_insn "exch"
 [(parallel [(set (match_operand:HI 0 "pic30_register_operand" "+r")
                  (match_operand:HI 1 "pic30_register_operand" "+r"))
             (set (match_dup 1)
                  (match_dup 0))]
 )]
 ""
 "*
{
  if (REGNO(operands[1]) == REGNO(operands[0])) {
    return \"; exch %0,%1\";
  } if (pic30_errata_mask & exch_errata) {
    return \"push %0\;mov %1,%0\;pop %1\";
  } else {
    return \"exch %0,%1\";
  }
}"
 [
   (set_attr "type" "etc")
 ]
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;; dsp instructions
; DSP instructions
;

; ********* to support builtins

(define_insn "addac_hi"
  [(set (match_operand: HI          0 "pic30_accumulator_operand" "=w")
        (plus:HI (match_operand: HI 1 "pic30_accumulator_operand" "w") 
                 (match_operand: HI 2 "pic30_accumulator_operand" "w")))]
  "(REGNO(operands[1]) != REGNO(operands[2]))"
  "add %0"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "etc")
  ]
)

(define_insn "addac2_hi"
  [(set (match_operand: HI          0 "pic30_accumulator_operand" "=w")
        (plus:HI (match_dup 0)
                 (match_operand: HI 1 "pic30_accumulator_operand" "w")))]
  "(REGNO(operands[1]) != REGNO(operands[0]))"
  "add %0"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "etc")
  ]
)

(define_insn "addacr_shiftrt_hi"
  [(set (match_operand: HI      0 "pic30_accumulator_operand" "=w")
        (plus:HI
           (ashiftrt:HI 
             (match_operand: HI 1 "pic30_mode3_operand"       " rRS<>")
             (match_operand: HI 2 "immediate_operand"         " Z"))
           (match_operand:HI    3 "pic30_accumulator_operand" " 0"))
  )]
  "((INTVAL(operands[2]) >= 0) && (CONST_OK_FOR_LETTER_P(INTVAL(operands[2]),'Z')))"
  "add %1, #%2, %0"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "defuse")
  ]
)

(define_insn "addacr_shiftrt_hi_errata"
  [(set (match_operand: HI      0 "pic30_accumulator_operand" "=w,w")
        (plus:HI 
           (ashiftrt:HI 
             (match_operand: HI 1 "pic30_mode3_operand"       " r,RS<>")
             (match_operand: HI 2 "immediate_operand"         " Z,Z"))
           (match_operand:HI    3 "pic30_accumulator_operand" " 0,0")))
   (clobber (match_scratch: HI  4                             "=X,r"))
  ]
  "((INTVAL(operands[2]) >= 0) && (CONST_OK_FOR_LETTER_P(INTVAL(operands[2]),'Z')))"
  "@
   add %1, #%2, %0
   mov %1,%4\;add %4,#%2,%0"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "etc,defuse")
  ]
)

(define_insn "addacr_shiftlt_hi"
  [(set (match_operand: HI               0 "pic30_accumulator_operand" "=w")
        (plus:HI
           (ashift:HI (match_operand: HI 1 "pic30_mode3_operand"       " RS<>r")
                      (match_operand: HI 2 "immediate_operand"         " i"))
           (match_operand:HI    3 "pic30_accumulator_operand"          "0")))]
  "((INTVAL(operands[2]) >= 0) && (CONST_OK_FOR_LETTER_P(INTVAL(operands[2]),'Z')))"
  "add %1, #%J2, %0"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "defuse")
  ]
)

(define_insn "addacr_shiftlt_hi_errata"
  [(set (match_operand: HI      0 "pic30_accumulator_operand" "=w,w")
        (plus:HI
           (ashift:HI 
             (match_operand: HI 1 "pic30_mode3_operand"       " r,RS<>")
             (match_operand: HI 2 "immediate_operand"         " i,i"))
           (match_operand:HI    3 "pic30_accumulator_operand" " 0,0")))
   (clobber (match_scratch:HI   4                             "=X,r"))
  ]
  "(INTVAL(operands[2]) >= 0)"
  "@
   add %1, #%J2, %0
   mov %1,%4\;add %4,#%J2,%0"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "etc,defuse")
  ]
)

(define_insn "addacr_noshift_hi"
  [(set (match_operand: HI    0 "pic30_accumulator_operand" "=w")
        (plus:HI
           (match_operand: HI 1 "pic30_mode3_operand"       " RS<>r")
           (match_operand:HI  2 "pic30_accumulator_operand" " 0")))]
  ""
  "add %1, #0, %0"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "defuse")
  ]
)

(define_insn "addacr_noshift1_hi"
  [(set (match_operand: HI    0 "pic30_accumulator_operand" "=w")
        (plus:HI
           (match_operand:HI  1 "pic30_accumulator_operand" " 0")
           (match_operand: HI 2 "pic30_mode3_operand"       " RS<>r")))]
  ""
  "add %2, #0, %0"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "defuse")
  ]
)

(define_insn "addacr_noshift_hi_errata"
  [(set (match_operand: HI    0 "pic30_accumulator_operand" "=w,w")
        (plus:HI
           (match_operand: HI 1 "pic30_mode3_operand"       " r,RS<>")
           (match_operand:HI  2 "pic30_accumulator_operand" " 0,0")))
   (clobber (match_scratch:HI 3                             "=X,r"))
  ]
  ""
  "@
   add %1, #0, %0
   mov %1,%3\;add %3,#0,%0"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "etc,defuse")
  ]
)

(define_insn "addacr_noshift1_hi_errata"
  [(set (match_operand: HI    0 "pic30_accumulator_operand" "=w,w")
        (plus:HI
           (match_operand:HI  1 "pic30_accumulator_operand" " 0,0")
           (match_operand: HI 2 "pic30_mode3_operand"       " r,RS<>")))
   (clobber (match_scratch:HI 3                             "=X,r"))
  ]
  ""
  "@
   add %2, #0, %0
   mov %2,%3\;add %3,#0,%0"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "etc,defuse")
  ]
)

(define_insn "addacr_shiftrt1_hi"
  [(set (match_operand: HI      0 "pic30_accumulator_operand" "=w")
        (plus:HI 
           (match_dup 0)
           (ashiftrt:HI 
             (match_operand: HI 1 "pic30_mode3_operand"       " RS<>r")
             (match_operand: HI 2 "immediate_operand"         " Z"))))]
  "((INTVAL(operands[2]) >= 0) && !(pic30_errata_mask & psv_errata) && (CONST_OK_FOR_LETTER_P(INTVAL(operands[2]), 'Z')))"
  "add %1, #%2, %0"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "defuse")
  ]
)

(define_insn "addacr_shiftrt1_hi_errata"
  [(set (match_operand: HI      0 "pic30_accumulator_operand" "=w,w")
        (plus:HI 
           (match_dup 0)
           (ashiftrt:HI 
             (match_operand: HI 1 "pic30_mode3_operand"       " r,RS<>")
             (match_operand: HI 2 "immediate_operand"         " Z,Z"))))
   (clobber (match_scratch:HI   3                             "=X,r"))
  ]
  "((INTVAL(operands[2]) >= 0) && (pic30_errata_mask & psv_errata) && (CONST_OK_FOR_LETTER_P(INTVAL(operands[2]), 'Z')))"
  "@
   add %1, #%2, %0
   mov %1,%3\;add %3,#%2,%0"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "etc,defuse")
  ]
)

(define_insn "addacr_shiftlt1_hi"
  [(set (match_operand: HI      0 "pic30_accumulator_operand" "=w")
        (plus:HI
           (ashift:HI 
             (match_operand: HI 1 "pic30_mode3_operand"       " RS<>r")
             (match_operand: HI 2 "immediate_operand"         " i"))
           (match_dup 0)))]
  "((INTVAL(operands[2]) >= 0) && !(pic30_errata_mask & psv_errata))"
  "add %1, #%J2, %0"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "defuse")
  ]
)

(define_insn "addacr_shiftlt1_hi_errata"
  [(set (match_operand: HI      0 "pic30_accumulator_operand" "=w,w")
        (plus:HI
           (ashift:HI 
             (match_operand: HI 1 "pic30_mode3_operand"       " r,RS<>")
             (match_operand: HI 2 "immediate_operand"         " i,i"))
           (match_dup 0)))
   (clobber (match_scratch: HI  3                             "=X,r"))
  ]
  "((INTVAL(operands[2]) >= 0) && (pic30_errata_mask & psv_errata))"
  "@
   add %1, #%J2, %0
   mov %1,%3\;add %3,#%J2,%0"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "etc,defuse")
  ]
)

(define_insn "clrac_gen_hi"
  [(set (match_operand: HI 0 "pic30_accumulator_operand" "=w,w,w,w,w,w,w,w,w")
        (const_int 0))
   (set (match_operand: HI 1 "pic30_mac_input_operand"   "=z,B,B,z,z,z,z,z,B")
        (mem:HI
          (match_operand: HI 2 "pic30_xprefetch_operand" " x,B,B,x,x,x,x,x,B")))
   (set (match_operand: HI 3 "pic30_xprefetch_operand"   "=2,B,B,2,B,B,2,B,B")
        (plus:HI
          (match_dup 3)
          (match_operand: HI 4 "immediate_operand"       " Y,i,i,Y,i,i,Y,i,i")))
   (set (match_operand: HI 5 "pic30_mac_input_operand"   "=z,z,z,B,B,z,z,z,B")
        (mem:HI
          (match_operand: HI 6 "pic30_yprefetch_operand" " y,y,y,B,B,y,y,y,B")))
   (set (match_operand: HI 7 "pic30_yprefetch_operand"   "=6,6,B,B,B,B,B,6,B")
        (plus:HI
          (match_dup 7)
          (match_operand: HI 8 "immediate_operand"       " Y,Y,i,i,i,i,i,Y,i")))
  ]
  ""
  "@
   clr %0, [%2]+=%4, %1, [%6]+=%8, %5
   clr %0, [%6]+=%8, %5
   clr %0, [%6], %5
   clr %0, [%2]+=%4, %1
   clr %0, [%2], %1
   clr %0, [%2], %1, [%6], %5
   clr %0, [%2]+=%4, %1, [%6], %5
   clr %0, [%2], %1, [%6]+=%8, %5
   clr %0"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "defuse,defuse,defuse,defuse,defuse,defuse,defuse,defuse,etc")
  ]
)

(define_insn "clracawb_gen_hi"
  [(set (match_operand: HI 0 "pic30_accumulator_operand" "=w,w,w,w,w,w,w,w,w")
        (const_int 0))
   (set (match_operand: HI 1 "pic30_mac_input_operand"   "=z,B,B,z,z,z,z,z,B")
        (mem:HI
          (match_operand: HI 2 "pic30_xprefetch_operand" " x,B,B,x,x,x,x,x,B")))
   (set (match_operand: HI 3 "pic30_xprefetch_operand"   "=2,B,B,2,B,B,2,B,B")
        (plus:HI
          (match_dup 3)
          (match_operand: HI 4 "immediate_operand"       " Y,i,i,Y,i,i,Y,i,i")))
   (set (match_operand: HI 5 "pic30_mac_input_operand"   "=z,z,z,B,B,z,z,z,B")
        (mem:HI
          (match_operand: HI 6 "pic30_yprefetch_operand" " y,y,y,B,B,y,y,y,B")))
   (set (match_operand: HI 7 "pic30_yprefetch_operand"   "=6,6,B,B,B,B,B,6,B")
        (plus:HI
          (match_dup 7)
          (match_operand: HI 8 "immediate_operand"       " Y,Y,i,i,i,i,i,Y,i")))
   (set (match_operand: HI 9 "pic30_awb_operand"         "=v,v,v,v,v,v,v,v,v")
        (unspec:HI [
          (match_operand:HI 10 "pic30_accumulator_operand" " w,w,w,w,w,w,w,w,w")
          (const_int 0)
        ] UNSPECV_SAC))
  ]
  "(REGNO(operands[0]) != REGNO(operands[10]))"
  "@
   clr %0, [%2]+=%4, %1, [%6]+=%8, %5, %9
   clr %0, [%6]+=%8, %5, %9
   clr %0, [%6], %5, %9
   clr %0, [%2]+=%4, %1, %9
   clr %0, [%2], %1, %9
   clr %0, [%2], %1, [%6], %5, %9
   clr %0, [%2]+=%4, %1, [%6], %5, %9
   clr %0, [%2], %1, [%6]+=%8, %5, %9
   clr %0, %9"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "defuse,defuse,defuse,defuse,defuse,defuse,defuse,defuse,etc")
  ]
)

(define_insn "ed_hi"
 [
  (set (match_operand:HI 0 "pic30_accumulator_operand" "=w,w,w,w")
       (unspec:HI [
           (match_operand:HI 1 "pic30_mac_input_operand" "z,z,z,z")
           (match_dup 1)
         ] UNSPECV_DSPMULT))
  (set (match_operand:HI 2 "pic30_mac_input_operand" "=z,z,z,z")
       (minus: HI
         (mem: HI (match_operand:HI 3 "pic30_xprefetch_operand" "x,x,x,x"))
         (mem: HI (match_operand:HI 4 "pic30_yprefetch_operand" "y,y,y,y"))))
  (set (match_operand:HI 5 "pic30_xprefetch_operand" "=3,3,B,B")
       (plus: HI
         (match_dup 5)
         (match_operand: HI 6 "immediate_operand" "Y,Y,i,i")))
  (set (match_operand:HI 7 "pic30_yprefetch_operand" "=4,B,B,4")
       (plus: HI
         (match_dup 7)
         (match_operand: HI 8 "immediate_operand" "Y,i,i,Y")))
 ]
 ""
 "@
  ed %1*%1, %0, [%3]+=%6, [%4]+=%8, %2
  ed %1*%1, %0, [%3]+=%6, [%4], %2
  ed %1*%1, %0, [%3], [%4], %2
  ed %1*%1, %0, [%3], [%4]+=%8, %2"
 [
   (set_attr "cc" "unchanged")
   (set_attr "type" "defuse,defuse,defuse,defuse")
 ]
)

(define_insn "edac_hi"
 [
  (set (match_operand:HI 0 "pic30_accumulator_operand" "=w,w,w,w")
       (plus: HI
         (match_operand:HI 1 "pic30_accumulator_operand" "0,0,0,0")
         (unspec:HI [
             (match_operand:HI 2 "pic30_mac_input_operand" "z,z,z,z")
             (match_dup 2)
           ] UNSPECV_DSPMULT)))
  (set (match_operand:HI 3 "pic30_mac_input_operand" "=z,z,z,z")
       (minus: HI
         (mem: HI (match_operand:HI 4 "pic30_xprefetch_operand" "x,x,x,x"))
         (mem: HI (match_operand:HI 5 "pic30_yprefetch_operand" "y,y,y,y"))))
  (set (match_operand:HI 6 "pic30_xprefetch_operand" "=4,4,B,B")
       (plus: HI
         (match_dup 6)
         (match_operand: HI 7 "immediate_operand" "Y,Y,i,i")))
  (set (match_operand:HI 8 "pic30_yprefetch_operand" "=5,B,B,5")
       (plus: HI
         (match_dup 8)
         (match_operand: HI 9 "immediate_operand" "Y,i,i,Y")))
 ]
 ""
 "@
  edac %2*%2, %0, [%4]+=%7, [%5]+=%9, %3
  edac %2*%2, %0, [%4]+=%6, [%5], %3
  edac %2*%2, %0, [%4], [%5], %3
  edac %2*%2, %0, [%4], [%5]+=%9, %3"
 [
   (set_attr "cc" "unchanged")
   (set_attr "type" "defuse,defuse,defuse,defuse")
 ]
)

(define_insn "fbcl_hi"
 [ 
  (set (match_operand:HI 0 "pic30_register_operand" "=r,r")
       (unspec: HI [
                     (match_operand: HI 1 "pic30_mode2_operand" "r,R<>")
                   ] UNSPECV_FBCL))
 ]
 ""
 "fbcl %1, %0"
 [
  (set_attr "cc" "clobber")
  (set_attr "type" "etc,defuse")
 ]
)

(define_insn "lac_hi"
  [
  (set (match_operand:HI    0 "pic30_accumulator_operand" "=w,w")
       (unspec:HI [
         (match_operand: HI 1 "pic30_mode3_operand"       " r,RS<>")
         (match_operand: HI 2 "immediate_operand"         " Z,Z")
       ] UNSPECV_LAC))
  ]
  "(!(pic30_errata_mask & psv_errata) && (CONST_OK_FOR_LETTER_P(INTVAL(operands[2]), 'Z')))"
  "lac %1, #%2, %0"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "etc,use")
  ]
)

(define_insn "lac_si"
  [
  (set (match_operand:HI    0 "pic30_accumulator_operand" "=w")
       (unspec:HI [
         (match_operand: SI 1 "pic30_register_operand"    " r")
         (match_operand: HI 2 "immediate_operand"         " Z")
       ] UNSPECV_LACD))
  ]
  "(!(pic30_errata_mask & psv_errata) && (CONST_OK_FOR_LETTER_P(INTVAL(operands[2]), 'Z')))"
  "*
   {
     int n = INTVAL(operands[2]);
     if(n == 0) {
       return \"lac %d1, #0, %0\;mov %1,%m0L\";
     } else {
       return \"lac %d1, #0, %0\;mov %1,%m0L\;sftac %0,#%2\";
     }
   }
  "

  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "defuse")
  ]
)

(define_insn "lac_error"
  [
  (set (match_operand:HI    0 "pic30_accumulator_operand" "=w")
       (unspec:HI [
         (match_operand: HI 1 "pic30_accumulator_operand" " w")
         (match_operand: HI 2 "immediate_operand"         " Z")
       ] UNSPECV_LAC))
  ]
  "CONST_OK_FOR_LETTER_P(INTVAL(operands[2]), 'Z')"
  "*
   {
     error(\"Argument 0 should not be an accumulator register\");
     return \"cannot generate instruction\";
   }
  "
)

(define_insn "lac_hi_errata"
  [
  (set (match_operand:HI    0 "pic30_accumulator_operand" "=w,w")
       (unspec:HI [
         (match_operand: HI 1 "pic30_mode3_operand"       " r,RS<>")
         (match_operand: HI 2 "immediate_operand"         " Z,Z")
       ] UNSPECV_LAC))
  (clobber (match_scratch:HI 3                            "=X,r"))
  ]
  "((pic30_errata_mask & psv_errata) && CONST_OK_FOR_LETTER_P(INTVAL(operands[2]), 'Z'))"
  "@
   lac %1, #%2, %0
   mov %1,%3\;lac %3,#%2,%0"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "etc,use")
  ]
)

(define_insn "lac_si_errata"
  [
  (set (match_operand:HI    0 "pic30_accumulator_operand" "=w,w")
       (unspec:HI [
         (match_operand: SI 1 "pic30_mode3_operand"       " r,RS<>")
         (match_operand: HI 2 "immediate_operand"         " Z,Z")
       ] UNSPECV_LACD))
  (clobber (match_scratch:SI 3                            "=X,&r"))
  ]
  "((pic30_errata_mask & psv_errata) && CONST_OK_FOR_LETTER_P(INTVAL(operands[2]), 'Z'))"
  "*
   {
     int n = INTVAL(operands[2]);
     switch(which_alternative) {
       default: gcc_assert(0);

       case 0:
         if(n == 0) {
           return \"lac %d1, #0, %0\;mov %1,%m0L\";
         } else {
           return \"lac %d1, #0, %0\;mov %1,%m0L\;sftac %0,#%2\";
         }
         break;
       case 1:
         if(n == 0) {
           return \"mov.d %1, %3\;lac %d3, #0, %0\;mov %3,%m0L\";
         } else {
           return \"mov.d %1, %3\;lac %d3, #0, %0\;mov %3,%m0L\;sftac %0,#%2\";
         }
         break;

     }
  }"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "etc,use")
  ]
)

(define_insn "acclhi"
  [
   (set (match_operand: HI   0 "pic30_register_operand"   "=r")
        (unspec:HI [
          (match_operand: HI 1 "pic30_accumulator_operand" "w")
        ] UNSPEC_ACCL))
  ]
  ""
  "mov %m1L,%0"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "def")
  ]
)

(define_insn "acchhi"
  [
   (set (match_operand: HI   0 "pic30_register_operand"   "=r")
        (unspec:HI [
          (match_operand: HI 1 "pic30_accumulator_operand" "w")
        ] UNSPEC_ACCH))
  ]
  ""
  "mov %m1H,%0"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "def")
  ]
)

(define_insn "accuhi"
  [
   (set (match_operand: HI   0 "pic30_register_operand"   "=r")
        (unspec:HI [
          (match_operand: HI 1 "pic30_accumulator_operand" "w")
        ] UNSPEC_ACCU))
  ]
  ""
  "mov %m1U,%0"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "def")
  ]
)

(define_insn "sac_gen_hi"
  [
   (set (match_operand: HI   0 "pic30_mode3_operand"      "=RS<>,r")
        (unspec:HI [
          (match_operand: HI 1 "pic30_accumulator_operand" "w,   w")
          (match_operand: HI 2 "immediate_operand"         "Z,   Z")
        ] UNSPECV_SAC))
  ]
  "CONST_OK_FOR_LETTER_P(INTVAL(operands[2]), 'Z')"
  "sac %1, #%2, %0"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "etc,def")
  ]
)

(define_insn "sac_si"
  [
   (set (match_operand: SI 0 "pic30_register_operand"       "=a,r,r")
      (unspec:SI [
        (match_operand: HI 1 "pic30_accumulator_operand" " w,w     ,w")
        (match_operand: HI 2 "immediate_operand"         " Z,Z     ,Z")
      ] UNSPECV_SACD))
   (clobber
        (match_scratch: HI 3                             "=X,a     ,r"))
  ]
  "CONST_OK_FOR_LETTER_P(INTVAL(operands[2]), 'Z')"
  "*
   {
     int n = INTVAL(operands[2]);
     if(n == 0) {
       return \"mov %m1L,%0\;mov %m1H,%d0\";
     } else if(n == -1) {
       return \"sac %1,#%2,%d0\;\"
              \"sl %m1L,%0\";
     } else if (n < -1) {
       return \"sac %1,#%2,%d0\;\"
              \"mov %m1L,%0\;\"
              \"sl %0,#%J2,%0\";
     } else if (n == 1) {
       switch(which_alternative) {
         default: gcc_assert(0);
      
         case 0: return \"lsr %m1H,%0\;\"
                        \"mov %m1L,%0\;\"
                        \"rrc %0,%0\;\"
                        \"sac %1,#1,%d0\";

         case 1: return \"lsr %m1H,%3\;\"
                        \"mov %m1L,%0\;\"
                        \"rrc %0,%0\;\"
                        \"sac %1,#1,%d0\";

         case 2: return \"mov %m1H,%3\;\"
                        \"lsr %3,%3\;\"
                        \"mov %m1L,%0\;\"
                        \"rrc %0,%0\;\"
                        \"sac %1,#1,%d0\";
       }
     } else if (n > 1) {
       return \"mov %m1H, %d0\;\"
              \"sl %d0,#16-%2,%0\;\"
              \"mov %m1L, %d0\;\"
              \"lsr %d0,#%2,%d0\;\"
              \"ior %d0,%0,%0\;\"
              \"sac %1,#%2,%d0\";
     }
   }
  "
  [
    (set_attr "cc" "unchanged, change0, change0")
    (set_attr "type" "defuse")
  ]
)

(define_insn "sacr_gen_hi"
  [
   (set (match_operand: HI 0 "pic30_mode3_operand"                    "=RS<>,r")
        (unspec:HI [
                     (match_operand: HI 1 "pic30_accumulator_operand" "w,w")
		     (match_operand: HI 2 "immediate_operand"         "Z,Z")
                   ] UNSPECV_SACR))
  ]
  "CONST_OK_FOR_LETTER_P(INTVAL(operands[2]), 'Z')"
  "sac.r %1, #%2, %0"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "etc,def")
  ]
)

(define_insn "mac_gen_hi"
  [(set (match_operand: HI 0 "pic30_accumulator_operand"  "=w,w,w,w,w,w,w,w,w")
        (plus:HI 
          (match_operand: HI 1 "pic30_accumulator_operand" "0,0,0,0,0,0,0,0,0")
          (mult:HI 
            (match_operand:HI 2 "pic30_mac_input_operand"  "z,z,z,z,z,z,z,z,z")
            (match_operand:HI 3 "pic30_mac_input_operand"  "z,z,z,z,z,z,z,z,z")
            )))
   (set (match_operand: HI 4 "pic30_mac_input_operand"    "=z,B,B,z,z,z,z,z,B")
        (mem:HI
          (match_operand: HI 5 "pic30_xprefetch_operand"   "x,B,B,x,x,x,x,x,B")))
   (set (match_operand: HI 6 "pic30_xprefetch_operand"    "=5,B,B,5,B,B,5,B,B")
        (plus:HI
          (match_dup 6)
          (match_operand: HI 7 "immediate_operand"        " Y,i,i,Y,i,i,Y,i,i")))
   (set (match_operand: HI 8 "pic30_mac_input_operand"    "=z,z,z,B,B,z,z,z,B")
        (mem:HI
          (match_operand: HI 9 "pic30_yprefetch_operand"  " y,y,y,B,B,y,y,y,B")))
   (set (match_operand: HI 10 "pic30_yprefetch_operand"   "=9,9,B,B,B,B,B,9,B")
        (plus:HI
          (match_dup 10)
          (match_operand: HI 11 "immediate_operand"      "  Y,Y,i,i,i,i,i,Y,i")))
  ]
  "" 
  "* 
   {
     static const char *mac_options[] = {
       \"mac %2*%3, %0, [%5]+=%7, %4, [%9]+=%11, %8\",  /* 0 */
       \"mac %2*%3, %0, [%9]+=%11, %8\",                /* 1 */
       \"mac %2*%3, %0, [%9], %8\",                     /* 2 */
       \"mac %2*%3, %0, [%5]+=%7, %4\",                 /* 3 */
       \"mac %2*%3, %0, [%5], %4\",                     /* 4 */
       \"mac %2*%3, %0, [%5], %4, [%9], %8\",           /* 5 */
       \"mac %2*%3, %0, [%5]+=%7, %4, [%9], %8\",       /* 6 */
       \"mac %2*%3, %0, [%5], %4, [%9]+=%11, %8\",      /* 7 */
       \"mac %2*%3, %0\",                               /* 8 */
       \"mac %3*%2, %0, [%5]+=%7, %4, [%9]+=%11, %8\",
       \"mac %3*%2, %0, [%9]+=%11, %8\",
       \"mac %3*%2, %0, [%9], %8\",
       \"mac %3*%2, %0, [%5]+=%7, %4\",
       \"mac %3*%2, %0, [%5], %4\",
       \"mac %3*%2, %0, [%5], %4, [%9], %8\",
       \"mac %3*%2, %0, [%5]+=%7, %4, [%9], %8\",
       \"mac %3*%2, %0, [%5], %4, [%9]+=%11, %8\",
       \"mac %3*%2, %0\" };

     if (REGNO(operands[1]) < REGNO(operands[2])) {
       return mac_options[which_alternative];
     } else {
       return mac_options[which_alternative+9];
     }
   }
  "
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "defuse,defuse,defuse,defuse,defuse,defuse,defuse,defuse,etc")
  ]
)

;
; GCC had trouble respecting the pre-condition; for now restrict the
;   register choices so that u and t don't overlap... this can be improved.
;   also for msc_gen_hi and msc_awbgen_hi
;
(define_insn  "macawb_gen_hi"
  [(set (match_operand: HI 0 "pic30_accumulator_operand"   "=w,w,w,w,w,w,w,w,w")
        (plus:HI
          (match_operand: HI 1 "pic30_accumulator_operand"  "0,0,0,0,0,0,0,0,0")
          (mult:HI
            (match_operand:HI 2 "pic30_mac_input_operand"  " u,u,u,u,u,u,u,u,u")
            (match_operand:HI 3 "pic30_mac_input_operand"  " t,t,t,t,t,t,t,t,t")
   )))
   (set (match_operand: HI 4 "pic30_mac_input_operand"     "=z,B,B,z,z,z,z,z,B")
        (mem:HI
          (match_operand: HI 5 "pic30_xprefetch_operand"   " x,B,B,x,x,x,x,x,B")
   ))
   (set (match_operand: HI 6 "pic30_xprefetch_operand"     "=5,B,B,5,B,B,5,B,B")
        (plus:HI
          (match_dup 6)
          (match_operand: HI 7 "immediate_operand"         " Y,i,i,Y,i,i,Y,i,i")
   ))
   (set (match_operand: HI 8 "pic30_mac_input_operand"     "=z,z,z,B,B,z,z,z,B")
        (mem:HI
          (match_operand: HI 9 "pic30_yprefetch_operand"   " y,y,y,B,B,y,y,y,B")
   ))
   (set (match_operand: HI 10 "pic30_yprefetch_operand"    "=9,9,B,B,B,B,B,9,B")
        (plus:HI
          (match_dup 10)
          (match_operand: HI 11 "immediate_operand"        " Y,Y,i,i,i,i,i,Y,i")
   ))
   (set (match_operand: HI 12 "pic30_awb_operand"         "=v,v,v,v,v,v,v,v,v")
        (unspec:HI [
          (match_operand:HI 13 "pic30_accumulator_operand" " w,w,w,w,w,w,w,w,w")
          (const_int 0)
        ] UNSPECV_SAC))
  ]
  "(REGNO(operands[1]) != REGNO(operands[2]))"
  "*
   {
     const char *mac_options[] = { 
       \"mac %2*%3, %0, [%5]+=%7, %4, [%8]+=%11, %8, %12\",              /* 0 */
       \"mac %2*%3, %0, [%9]+=%11, %8, %12\",                            /* 1 */
       \"mac %2*%3, %0, [%9], %8, %12\",                                 /* 2 */
       \"mac %2*%3, %0, [%5]+=%7, %4, %12\",                             /* 3 */
       \"mac %2*%3, %0, [%5], %4, %12\",                                 /* 4 */
       \"mac %2*%3, %0, [%5], %4, [%9], %8, %12\",                       /* 5 */
       \"mac %2*%3, %0, [%5]+=%7, %4, [%9], %8, %12\",                   /* 6 */
       \"mac %2*%3, %0, [%5], %4, [%9]+=%11, %8, %12\",                  /* 7 */
       \"mac %2*%3, %0, %12\",                                           /* 8 */
       \"mac %3*%2, %0, [%5]+=%7, %4, [%9]+=%11, %8, %12\",
       \"mac %3*%2, %0, [%9]+=%11, %8, %12\",
       \"mac %3*%2, %0, [%9], %8, %12\",
       \"mac %3*%2, %0, [%5]+=%7, %4, %12\",
       \"mac %3*%2, %0, [%5], %4, %12\",
       \"mac %3*%2, %0, [%5], %4, [%9], %8, %12\",
       \"mac %3*%2, %0, [%5]+=%7, %4, [%9], %8, %12\",
       \"mac %3*%2, %0, [%5], %4, [%9]+=%11, %8, %12\",
       \"mac %3*%2, %0, %12\" };

     if (REGNO(operands[1]) < REGNO(operands[2])) {
       return mac_options[which_alternative];
     } else {
       return mac_options[which_alternative+9];
     }
   }
  "
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "defuse,defuse,defuse,defuse,defuse,defuse,defuse,defuse,etc")
  ]
)

;
;  if an AWB is not specified, then it doesn't matter which accumulator we use
;    since the accumulator portion is only there to specify which ACC is 
;    written back
;
(define_insn "movsac_gen_hi"
  [ (set (match_operand: HI 0 "pic30_mac_input_operand"  "=z,B,B,z,z,z,z,z,B")
        (mem:HI
          (match_operand: HI 1 "pic30_xprefetch_operand" " x,B,B,x,x,x,x,x,B")))
   (set (match_operand: HI 2 "pic30_xprefetch_operand"   "=1,B,B,1,X,X,1,B,B")
        (plus:HI
          (match_dup 2)
          (match_operand: HI 3 "immediate_operand"       " Y,i,i,Y,i,i,Y,i,i")))
   (set (match_operand: HI 4 "pic30_mac_input_operand"   "=z,z,z,B,B,z,z,z,B")
        (mem:HI
          (match_operand: HI 5 "pic30_yprefetch_operand" " y,y,y,B,B,y,y,y,B")))
   (set (match_operand: HI 6 "pic30_yprefetch_operand"   "=5,5,B,B,B,B,B,5,B")
        (plus:HI
          (match_dup 6)
          (match_operand: HI 7 "immediate_operand"       " Y,Y,i,i,i,i,i,Y,i")))
  ]
  ""
  "@
   movsac A, [%1]+=%3, %0, [%5]+=%7, %4
   movsac A, [%5]+=%7, %4
   movsac A, [%5], %4
   movsac A, [%1]+=%3, %0
   movsac A, [%1], %0
   movsac A, [%1], %0, [%5], %4
   movsac A, [%1]+=%3, %0, [%5], %4
   movsac A, [%1], %0, [%5]+=%7, %4
   movsac A" 
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "defuse,defuse,defuse,defuse,defuse,defuse,defuse,defuse,etc")
  ] 
) 

;
;  this is an odd instruction
;
(define_insn "movsacawb_gen_hi"
  [(set (match_operand: HI 0 "pic30_mac_input_operand"   "=z,B,B,z,z,z,z,z,B")
        (mem:HI
          (match_operand: HI 1 "pic30_xprefetch_operand" " x,B,B,x,x,x,x,x,B")))
   (set (match_operand: HI 2 "pic30_xprefetch_operand"   "=1,B,B,1,B,B,1,B,B")
        (plus:HI
          (match_dup 2)
          (match_operand: HI 3 "immediate_operand"       " Y,i,i,Y,i,i,Y,i,i")))
   (set (match_operand: HI 4 "pic30_mac_input_operand"   "=z,z,z,B,B,z,z,z,B")
        (mem:HI
          (match_operand: HI 5 "pic30_yprefetch_operand" " y,y,y,B,B,y,y,y,B")))
   (set (match_operand: HI 6 "pic30_yprefetch_operand"   "=5,5,B,B,B,B,B,5,B")
        (plus:HI
          (match_dup 6)
          (match_operand: HI 7 "immediate_operand"       " Y,Y,i,i,i,i,i,Y,i")))
   (set (match_operand: HI 8 "pic30_awb_operand"         "=v,v,v,v,v,v,v,v,v")
        (unspec:HI [
          (match_operand: HI 9 "pic30_accumulator_operand" " w,w,w,w,w,w,w,w,w")
          (const_int 0)
        ] UNSPECV_SAC))
  ]
  ""
  "@
   movsac %A9, [%1]+=%3, %0, [%5]+=%7, %4, %8
   movsac %A9, [%5]+=%7, %4, %8
   movsac %A9, [%5], %4, %8
   movsac %A9, [%1]+=%3, %0, %8
   movsac %A9, [%1], %0, %8
   movsac %A9, [%1], %0, [%5], %4, %8
   movsac %A9, [%1]+=%3, %0, [%5], %4, %8
   movsac %A9, [%1], %0, [%5]+=%7, %4, %8
   movsac %A9, %8"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "defuse,defuse,defuse,defuse,defuse,defuse,defuse,defuse,etc")
  ]
)

;      (unspec:HI [
;          (match_operand:HI 1 "pic30_mac_input_operand"  " z,z,z,z,z,z,z,z,z")
;          (match_operand:HI 2 "pic30_mac_input_operand"  " z,z,z,z,z,z,z,z,z")
;        ] UNSPECV_DSPMULT))

(define_insn "mpy_gen_hi"
  [(set (match_operand: HI 0 "pic30_accumulator_operand" "=w,w,w,w,w,w,w,w,w")
        (unspec:HI [
            (match_operand:HI 1 "pic30_mac_input_operand"  " z,z,z,z,z,z,z,z,z")
            (match_operand:HI 2 "pic30_mac_input_operand"  " z,z,z,z,z,z,z,z,z")
          ] UNSPECV_DSPMULT))
   (set (match_operand: HI 3 "pic30_mac_input_operand"   "=z,B,B,z,z,z,z,z,B")
        (mem:HI
          (match_operand: HI 4 "pic30_xprefetch_operand" " x,B,B,x,x,x,x,x,B")))
   (set (match_operand: HI 5 "pic30_xprefetch_operand"   "=4,B,B,4,B,B,4,B,B")
        (plus:HI
          (match_dup 5)
          (match_operand: HI 6 "immediate_operand"       " Y,i,i,Y,i,i,Y,i,i")))
   (set (match_operand: HI 7 "pic30_mac_input_operand"   "=z,z,z,B,B,z,z,z,B")
        (mem:HI
          (match_operand: HI 8 "pic30_yprefetch_operand" " y,y,y,B,B,y,y,y,B")))
   (set (match_operand: HI 9 "pic30_yprefetch_operand"   "=8,8,B,B,B,B,B,8,B")
        (plus:HI
          (match_dup 9)
          (match_operand: HI 10 "immediate_operand"      " Y,Y,i,i,i,i,i,Y,i")))
  ]
  "" 
  "* 
   {
     const char *mpy_options[] = {
       \"mpy %1*%2, %0, [%4]+=%6, %3, [%8]+=%10, %7\", /* 0 */
       \"mpy %1*%2, %0, [%8]+=%10, %7\",               /* 1 */
       \"mpy %1*%2, %0, [%8], %7\",                    /* 2 */
       \"mpy %1*%2, %0, [%4]+=%6, %3\",                /* 3 */
       \"mpy %1*%2, %0, [%4], %3\",                    /* 4 */
       \"mpy %1*%2, %0, [%4], %3, [%8], %7\",          /* 5 */
       \"mpy %1*%2, %0, [%4]+=%6, %3, [%8], %7\",      /* 6 */
       \"mpy %1*%2, %0, [%4], %3, [%8]+=%10, %7\",     /* 7 */
       \"mpy %1*%2, %0\",                              /* 8 */
       \"mpy %2*%1, %0, [%4]+=%6, %3, [%8]+=%10, %7\",
       \"mpy %2*%1, %0, [%8]+=%10, %7\",
       \"mpy %2*%1, %0, [%8], %7\",
       \"mpy %2*%1, %0, [%4]+=%6, %3\",
       \"mpy %2*%1, %0, [%4], %3\",
       \"mpy %2*%1, %0, [%4], %3, [%8], %7\",
       \"mpy %2*%1, %0, [%4]+=%6, %3, [%8], %7\",
       \"mpy %2*%1, %0, [%4], %3, [%8]+=%10, %7\",
       \"mpy %2*%1, %0\"};

     if (REGNO(operands[1]) < REGNO(operands[2])) {
       return mpy_options[which_alternative];
     } else { 
       return mpy_options[which_alternative+9];
     }
   }
  "
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "defuse,defuse,defuse,defuse,defuse,defuse,defuse,defuse,etc")
  ]
)

(define_insn "mpyn_gen_hi"
  [(set (match_operand: HI 0 "pic30_accumulator_operand" "=w,w,w,w,w,w,w,w,w")
        (unspec:HI [
           (neg:HI
             (match_operand:HI 1 "pic30_mac_input_operand"" z,z,z,z,z,z,z,z,z"))
           (match_operand:HI 2 "pic30_mac_input_operand"  " z,z,z,z,z,z,z,z,z")
          ] UNSPECV_DSPMULT))
   (set (match_operand: HI 3 "pic30_mac_input_operand"   "=z,B,B,z,z,z,z,z,B")
        (mem:HI
          (match_operand: HI 4 "pic30_xprefetch_operand" " x,B,B,x,x,x,x,x,B")))
   (set (match_operand: HI 5 "pic30_xprefetch_operand"   "=4,B,B,4,B,B,4,B,B")
        (plus:HI
          (match_dup 5)
          (match_operand: HI 6 "immediate_operand"       " Y,i,i,Y,i,i,Y,i,i")))
   (set (match_operand: HI 7 "pic30_mac_input_operand"   "=z,z,z,B,B,z,z,z,B")
        (mem:HI
          (match_operand: HI 8 "pic30_yprefetch_operand" " y,y,y,B,B,y,y,y,B")))
   (set (match_operand: HI 9 "pic30_yprefetch_operand"   "=8,8,B,B,B,B,B,8,B")
        (plus:HI
          (match_dup 9)
          (match_operand: HI 10 "immediate_operand"      " Y,Y,i,i,i,i,i,Y,i")))
  ]
  "(REGNO(operands[1]) < REGNO(operands[2]))"
  "*
   {
     const char *mpy_options[] = {
       \"mpy.n %1*%2, %0, [%4]+=%6, %3, [%8]+=%10, %7\", /* 0 */
       \"mpy.n %1*%2, %0, [%8]+=%10, %7\",               /* 1 */
       \"mpy.n %1*%2, %0, [%8], %7\",                    /* 2 */
       \"mpy.n %1*%2, %0, [%4]+=%6, %3\",                /* 3 */
       \"mpy.n %1*%2, %0, [%4], %3\",                    /* 4 */
       \"mpy.n %1*%2, %0, [%4], %3, [%8], %7\",          /* 5 */
       \"mpy.n %1*%2, %0, [%4]+=%6, %3, [%8], %7\",      /* 6 */
       \"mpy.n %1*%2, %0, [%4], %3, [%8]+=%10, %7\",     /* 7 */
       \"mpy.n %1*%2, %0\",                              /* 8 */
       \"mpy.n %2*%1, %0, [%4]+=%6, %3, [%8]+=%10, %7\",
       \"mpy.n %2*%1, %0, [%8]+=%10, %7\",
       \"mpy.n %2*%1, %0, [%8], %7\",
       \"mpy.n %2*%1, %0, [%4]+=%6, %3\",
       \"mpy.n %2*%1, %0, [%4], %3\",
       \"mpy.n %2*%1, %0, [%4], %3, [%8], %7\",
       \"mpy.n %2*%1, %0, [%4]+=%6, %3, [%8], %7\",
       \"mpy.n %2*%1, %0, [%4], %3, [%8]+=%10, %7\",
       \"mpy.n %2*%1, %0\"};

     if (REGNO(operands[1]) < REGNO(operands[2])) {
       return mpy_options[which_alternative];
     } else {
       return mpy_options[which_alternative+9];
     }
   }
  "
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "defuse,defuse,defuse,defuse,defuse,defuse,defuse,defuse,etc")
  ]
)

(define_insn "msc_gen_hi"
  [(set (match_operand: HI 0 "pic30_accumulator_operand"   "=w,w,w,w,w,w,w,w,w")
        (minus:HI 
          (match_operand: HI 1 "pic30_accumulator_operand"  "0,0,0,0,0,0,0,0,0")
          (unspec:HI [
            (match_operand:HI 2 "pic30_mac_input_operand"  " u,u,u,u,u,u,u,u,u")
            (match_operand:HI 3 "pic30_mac_input_operand"  " t,t,t,t,t,t,t,t,t")
          ] UNSPECV_DSPMULT)))
   (set (match_operand: HI 4 "pic30_mac_input_operand"     "=z,B,B,z,z,z,z,z,B")
        (mem:HI
          (match_operand: HI 5 "pic30_xprefetch_operand"   " x,B,B,x,x,x,x,x,B")
   ))
   (set (match_operand: HI 6 "pic30_xprefetch_operand"     "=5,B,B,5,B,B,5,B,B")
        (plus:HI
          (match_dup 6)
          (match_operand: HI 7 "immediate_operand"         " Y,i,i,Y,i,i,Y,i,i")
   ))
   (set (match_operand: HI 8 "pic30_mac_input_operand"     "=z,z,z,B,B,z,z,z,B")
        (mem:HI
          (match_operand: HI 9 "pic30_yprefetch_operand"   " y,y,y,B,B,y,y,y,B")
   ))
   (set (match_operand: HI 10 "pic30_yprefetch_operand"    "=9,9,B,B,B,B,B,9,B")
        (plus:HI
          (match_dup 10)
          (match_operand: HI 11 "immediate_operand"        " Y,Y,i,i,i,i,i,Y,i")
   ))
  ]
  "" 
  "* 
   {
     const char *msc_options[] = {
       \"msc %2*%3, %0, [%5]+=%7, %4, [%9]+=%11, %8\",
       \"msc %2*%3, %0, [%9]+=%11, %8\",
       \"msc %2*%3, %0, [%9], %8\",
       \"msc %2*%3, %0, [%5]+=%7, %4\",
       \"msc %2*%3, %0, [%5], %4\",
       \"msc %2*%3, %0, [%5], %4, [%9], %8\",
       \"msc %2*%3, %0, [%5]+=%7, %4, [%9], %8\",
       \"msc %2*%3, %0, [%5], %4, [%9]+=%11, %8\",
       \"msc %2*%3, %0\",
       \"msc %3*%2, %0, [%5]+=%7, %4, [%9]+=%11, %8\",
       \"msc %3*%2, %0, [%9]+=%11, %8\",
       \"msc %3*%2, %0, [%9], %8\",
       \"msc %3*%2, %0, [%5]+=%7, %4\",
       \"msc %3*%2, %0, [%5], %4\",
       \"msc %3*%2, %0, [%5], %4, [%9], %8\",
       \"msc %3*%2, %0, [%5]+=%7, %4, [%9], %8\",
       \"msc %3*%2, %0, [%5], %4, [%9]+=%11, %8\",
       \"msc %3*%2, %0\"};

     if (REGNO(operands[1]) < REGNO(operands[2])) {
       return msc_options[which_alternative];
     } else { 
       return msc_options[which_alternative+9];
     }
   }
  "
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "defuse,defuse,defuse,defuse,defuse,defuse,defuse,defuse,etc")
  ]
)

(define_insn "mscawb_gen_hi"
  [(set (match_operand: HI 0 "pic30_accumulator_operand"   "=w,w,w,w,w,w,w,w,w")
        (minus:HI
          (match_operand: HI 1 "pic30_accumulator_operand"  "0,0,0,0,0,0,0,0,0")
          (unspec:HI [
            (match_operand:HI 2 "pic30_mac_input_operand"  " u,u,u,u,u,u,u,u,u")
            (match_operand:HI 3 "pic30_mac_input_operand"  " t,t,t,t,t,t,t,t,t")
          ] UNSPECV_DSPMULT)))
   (set (match_operand: HI 4 "pic30_mac_input_operand"     "=z,B,B,z,z,z,z,z,B")
        (mem:HI
          (match_operand: HI 5 "pic30_xprefetch_operand"   " x,B,B,x,x,x,x,x,B")
   ))
   (set (match_operand: HI 6 "pic30_xprefetch_operand"     "=5,B,B,5,B,B,5,B,B")
        (plus:HI
          (match_dup 6)
          (match_operand: HI 7 "immediate_operand"         " Y,i,i,Y,i,i,Y,i,i")
   ))
   (set (match_operand: HI 8 "pic30_mac_input_operand"     "=z,z,z,B,B,z,z,z,B")
        (mem:HI
          (match_operand: HI 9 "pic30_yprefetch_operand"   " y,y,y,B,B,y,y,y,B")
   ))
   (set (match_operand: HI 10 "pic30_yprefetch_operand"    "=9,9,B,B,B,B,B,9,B")
        (plus:HI
          (match_dup 10)
          (match_operand: HI 11 "immediate_operand"        " Y,Y,i,i,i,i,i,Y,i")
   ))
   (set (match_operand: HI 12 "pic30_awb_operand"         "=v,v,v,v,v,v,v,v,v")
        (unspec:HI [
          (match_operand:HI 13 "pic30_accumulator_operand" " w,w,w,w,w,w,w,w,w")
          (const_int 0)
        ] UNSPECV_SAC)
   )
  ]
  ""
  "*
   {
     const char *msc_options[] = {
       \"msc %2*%3, %0, [%5]+=%7, %4, [%9]+=%11, %8, %12\",
       \"msc %2*%3, %0, [%9]+=%11, %8, %12\",
       \"msc %2*%3, %0, [%9], %8, %12\",
       \"msc %2*%3, %0, [%5]+=%7, %4, %12\",
       \"msc %2*%3, %0, [%5], %4, %12\",
       \"msc %2*%3, %0, [%5], %4, [%9], %8, %12\",
       \"msc %2*%3, %0, [%5]+=%7, %4, [%9], %8, %12\",
       \"msc %2*%3, %0, [%5], %4, [%9]+=%11, %8, %12\",
       \"msc %2*%3, %0, %12\",
       \"msc %3*%2, %0, [%5]+=%7, %4, [%9]+=%11, %8, %12\",
       \"msc %3*%2, %0, [%9]+=%11, %8, %12\",
       \"msc %3*%2, %0, [%9], %8, %12\",
       \"msc %3*%2, %0, [%5]+=%7, %4, %12\",
       \"msc %3*%2, %0, [%5], %4, %12\",
       \"msc %3*%2, %0, [%5], %4, [%9], %8, %12\",
       \"msc %3*%2, %0, [%5]+=%7, %4, [%9], %8, %12\",
       \"msc %3*%2, %0, [%5], %4, [%9]+=%11, %8, %12\",
       \"msc %3*%2, %0, %12\"};

     if (REGNO(operands[1]) < REGNO(operands[2])) {
       return msc_options[which_alternative];
     } else {
       return msc_options[which_alternative+9];
     }
   }
  " 
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "defuse,defuse,defuse,defuse,defuse,defuse,defuse,defuse,etc")
  ]
)

(define_insn "sftac_gen_hi"
  [(set (match_operand: HI 0 "pic30_accumulator_operand" "=w,w")
        (unspec:HI [
                     (match_operand: HI 1 "pic30_accumulator_operand" "0,0")
                     (match_operand: HI 2 "pic30_reg_or_imm_operand" "r,W")
                   ] UNSPECV_SFTAC)
   )]
  ""
  "@
   sftac %0, %2
   sftac %0, #%2"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "etc")
  ]
)

(define_insn "sftac_error"
  [(set (match_operand: HI 0 "pic30_accumulator_operand" "=w")
        (ashift:HI
           (match_operand: HI 1 "general_operand" "")
           (match_operand: HI 2 "general_operand" "")))]
  ""
  "*
   {
     error(\"Automatic generation of DSP instructions not yet supported; \"
           \"use __builtin_sftac() instead\");
     return \"cannot generate instruction\";
   }
  "
)

(define_insn "subac_hi"
  [(set (match_operand: HI 0 "pic30_accumulator_operand"  "=w")
        (minus:HI (match_operand: HI 1 "pic30_accumulator_operand" "w")
                  (match_operand: HI 2 "pic30_accumulator_operand" "w")))]
  "(REGNO(operands[2]) != REGNO(operands[1]))"
  "sub %0"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "etc")
  ]
)

; ********* to support automagic generation

(define_insn "movhi_accumulator"
  [(set (match_operand:HI 0 "pic30_accumulator_operand" "=w")
        (match_operand: HI 1 "pic30_mode3_operand" "RS<>r"))]
  ""
  "lac %1, #0, %0"
)  

(define_insn "movhi_accumulator2"
  [(set (match_operand:HI 0 "general_operand" "")
        (match_operand:HI 1 "pic30_accumulator_operand" "w"))]
  ""
  "*
    /* sac %1, #0, %0 */
    {
     error(\"Automatic generation of DSP instructions not yet supported; \"
           \"use __builtin_sac() instead\");
     return \"cannot generate instruction\";
    }
  "
)

;(define_insn "movhi_accumulator3"
;  [(set (match_operand:HI 0 "pic30_accumulator_operand" "=w")
;        (match_operand:HI 1 "immediate_operand" "i"))]
;  ""
;  "*
;   {
;     if (INTVAL(operands[1]) == 0) {
;       return \"clr %0\";
;     } else {
;       return \"lac %1, #0, %0\";
;     }
;   }
;  "
;)

(define_insn "addab_error"
  [(set (match_operand: HI          0 "pic30_accumulator_operand" "=w")
        (plus:HI (match_operand:HI 1 "pic30_mode3_operand" "RS<>r")
                 (match_operand:HI 2 "pic30_mode3_operand" "RS<>r")))]
  ""
  "*
   {
     error(\"Automatic generation of DSP instructions not yet supported; \"
           \"use __builtin_addab() instead\");
     return \"cannot generate instruction\";
   }
  "
)

(define_insn "auto_mac"
  [(set (match_operand:HI 0 "pic30_accumulator_operand" "=w")
        (plus:HI
          (match_operand:HI 1 "pic30_accumulator_operand" "0")
          (subreg:HI
            (mult:SI
              (sign_extend:SI
                (match_operand: HI 2 "pic30_mac_input_operand" "z"))
              (sign_extend:SI
                (match_operand: HI 3 "pic30_mac_input_operand" "z"))) 0)))]
  ""
  "*
   {
     error(\"Automatic generation of DSP instructions not yet supported; \"
           \"use __builtin_mac() instead\");
#if 0
     if (REGNO(operands[2]) < REGNO(operands[3])) {
       return \"mac %2*%3, %0\";
     } else {
       return \"mac %3*%2, %0\";
     }
#endif
     return \"cannot generate instruction\";
   }
  "
)

(define_insn "auto_mac1"
  [(set (match_operand:HI 0 "pic30_accumulator_operand" "=w")
        (plus:HI
          (subreg:HI
            (mult:SI
              (sign_extend:SI
                (match_operand: HI 1 "pic30_mac_input_operand" "z"))
              (sign_extend:SI
                (match_operand: HI 2 "pic30_mac_input_operand" "z"))) 0)
          (match_operand:HI 3 "pic30_accumulator_operand" "0")))]
  ""
  "*
   {
     error(\"Automatic generation of DSP instructions not yet supported; \"
           \"use __builtin_mac() instead\");
     return \"cannot generate instruction\";
   }
  "
)

(define_insn "auto_mpy"
  [(set (match_operand:HI 0 "pic30_accumulator_operand" "=w")
        (neg: HI
          (subreg:HI
            (mult:SI
              (sign_extend:SI
                (match_operand: HI 1 "pic30_mac_input_operand" "z"))
              (sign_extend:SI
                (match_operand: HI 2 "pic30_mac_input_operand" "z"))) 0)))]
  ""
  "*
   {
     error(\"Automatic generation of DSP instructions not yet supported; \"
           \"use __builtin_mpy() instead\");
     return \"cannot generate instruction\";
   }
  "
)

(define_insn "auto_msc"
  [(set (match_operand:HI 0 "pic30_accumulator_operand" "=w")
        (minus:HI
          (match_operand:HI 1 "pic30_accumulator_operand" "0")
          (subreg:HI
            (mult:SI
              (sign_extend:SI
                (match_operand: HI 2 "pic30_mac_input_operand" "z"))
              (sign_extend:SI
                (match_operand: HI 3 "pic30_mac_input_operand" "z"))) 0)))]
  ""
  "*
   {
     error(\"Automatic generation of DSP instructions not yet supported; \"
           \"use __builtin_msc() instead\");
     return \"cannot generate instruction\";
   }
  "
)

(define_insn "auto_msc1"
  [(set (match_operand:HI 0 "pic30_accumulator_operand" "=w")
        (minus:HI
          (subreg:HI
            (mult:SI
              (sign_extend:SI
                (match_operand: HI 1 "pic30_mac_input_operand" "z"))
              (sign_extend:SI
                (match_operand: HI 2 "pic30_mac_input_operand" "z"))) 0)
          (match_operand:HI 3 "pic30_accumulator_operand" "0")))]
  ""
  "*
   {
     error(\"Automatic generation of DSP instructions not yet supported; \"
           \"use __builtin_msc() instead\");
     return \"cannot generate instruction\";
   }
  "
)

(define_insn "auto_sftacr"
  [(set (match_operand:HI 0 "pic30_accumulator_operand" "=w")
        (ashiftrt:HI
          (match_dup 0)
          (match_operand:HI 1 "immediate_operand"       "W")))]
  "(INTVAL(operands[1]) > 0)"
  "*
   {
     /* sftac %0, #%1 */
     error(\"Automatic generation of DSP instructions not yet supported; \"
           \"use __builtin_sftac() instead\");
     return \"cannot generate instruction\";
   }
  "
)

(define_insn "auto_sftacl"
  [(set (match_operand:HI 0 "pic30_accumulator_operand" "=w")
        (ashift:HI 
          (match_dup 0)
          (match_operand:HI 1 "immediate_operand"       "W")))]
  "(INTVAL(operands[1]) > 0)"
  "*
   {
     error(\"Automatic generation of DSP instructions not yet supported; \"
           \"use __builtin_sftac() instead\");
     return \"cannot generate instruction\";
   }
  "
)

(define_insn "addacr_hi"
  [(set (match_operand: HI 0 "pic30_accumulator_operand" "=w")
        (plus:HI
           (match_operand: HI 1 "pic30_mode3_operand" "RS<>r")
           (match_operand: HI 2 "pic30_accumulator_operand" "0")))]
  ""
  "*
   {
     /* add %1, %0 */
     error(\"Automatic generation of DSP instructions not yet supported; \"
           \"use __builtin_add() instead\");
     return \"cannot generate instruction\";
   }
  "
)

(define_insn "addacr1_hi"
  [(set (match_operand: HI 0 "pic30_accumulator_operand" "=w")
        (plus:HI
           (match_operand: HI 1 "pic30_accumulator_operand" "0")
           (match_operand: HI 2 "pic30_mode3_operand" "RS<>r")))]
  ""
  "*
   {
     /* add %2, %0 */
     error(\"Automatic generation of DSP instructions not yet supported; \"
           \"use __builtin_add() instead\");
     return \"cannot generate instruction\";
   }
  "
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; __builtin_unique_id

(define_insn "unique_id"
  [(set (match_operand:HI 0 "pic30_register_operand" "=r")
        (unspec_volatile:HI [ (match_operand 1 "immediate_operand" "i")
                              (match_operand:HI 2 "immediate_operand" "i")
                            ] UNSEPCV_GENLABEL))]
  ""
  "*
   {  static char buffer[80];
      char *label;

      label = (char *)(INTVAL(operands[1]));
      sprintf(buffer,\".global %s\n%s:\n\tmov #%ld,%%0\",
              label,label,INTVAL(operands[2]));
      return buffer;
   }
  "
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; __builtin_tblrdl, __builtin_tblrdh, __builtin_tblwtl, __builtin_tblwth

(define_insn "tblrdl"
  [(set (match_operand:HI 0 "pic30_mode2_operand" "=rR<>")
        (unspec_volatile:HI 
          [(match_operand:HI 1 "pic30_register_operand" "r")] UNSPECV_TBLRDL
        )
    )]
  ""
  "tblrdl.w [%1], %0"
  [
    (set_attr "type" "def")
  ]
)

(define_insn "tblrdlb"
  [(set (match_operand:QI 0 "pic30_mode2_operand" "=rR<>")
        (unspec_volatile:QI
          [(match_operand:HI 1 "pic30_register_operand" "r")] UNSPECV_TBLRDLB
        )
    )]
  ""
  "tblrdl.b [%1], %0"
  [
    (set_attr "type" "def")
  ]
)

(define_insn "tblrdh"
  [(set (match_operand:HI 0 "pic30_mode2_operand" "=rR<>") 
        (unspec_volatile:HI 
          [(match_operand:HI 1 "pic30_register_operand" "r")] UNSPECV_TBLRDH
        )
    )]
  ""
  "tblrdh.w [%1], %0"
  [
    (set_attr "type" "def")
  ]
)

(define_insn "tblrdhb"
  [(set (match_operand:QI 0 "pic30_mode2_operand" "=rR<>")
        (unspec_volatile:QI
          [(match_operand:HI 1 "pic30_register_operand" "r")] UNSPECV_TBLRDHB
        )
    )]
  ""
  "tblrdh.b [%1], %0"
  [
    (set_attr "type" "def")
  ]
)

(define_insn "tblwtl"
  [(unspec_volatile:HI 
     [(match_operand:HI 0 "pic30_register_operand" "r")
      (match_operand:HI 1 "pic30_mode2_operand" "rR<>")] UNSPECV_TBLWTL
   )
  ]
  ""
  "tblwtl.w %1, [%0]"
  [
    (set_attr "type" "use")
  ]
)

(define_insn "tblwtlb"
  [(unspec_volatile:QI
     [(match_operand:HI 0 "pic30_register_operand" "r")
      (match_operand:QI 1 "pic30_mode2_operand" "rR<>")] UNSPECV_TBLWTLB
   )
  ]
  ""
  "tblwtl.b %1, [%0]"
  [
    (set_attr "type" "use")
  ]
)

(define_insn "tblwth"
  [(unspec_volatile:HI  
     [(match_operand:HI 0 "pic30_register_operand" "r")
      (match_operand:HI 1 "pic30_mode2_operand" "rR<>")] UNSPECV_TBLWTH
   )
  ]
  ""
  "tblwth.w %1, [%0]"
  [
    (set_attr "type" "use")
  ]
)

(define_insn "tblwthb"
  [(unspec_volatile:QI
     [(match_operand:HI 0 "pic30_register_operand" "r")
      (match_operand:QI 1 "pic30_mode2_operand" "rR<>")] UNSPECV_TBLWTHB
   )
  ]
  ""
  "tblwth.b %1, [%0]"
  [
    (set_attr "type" "use")
  ]
)

(define_mode_iterator MODES32 [SI SF P32PEDS P32EDS P24PSV P24PROG P32EXT])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; stackpush
;; These patterns are used for passing arguments on the stack.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define_insn "*pushqi"
  [(set (match_operand:QI 0 "push_operand"   "=>")
        (match_operand:QI 1 "pic30_general_operand" "r"))]
  ""
  "*
   if (pic30_ecore_target() && TARGET_EDS) {
     return \"movpag #1,DSWPAG\;mov %1,[w15++]\";
   } else {
     return \"mov %1,[w15++]\";
   }
  "
  [
   (set_attr "cc" "unchanged")
   (set_attr "type" "def")
  ]
)

(define_insn "pushqi1"
  [(set (mem:HI (post_inc:HI (reg:HI SPREG)))
                (subreg:HI (match_operand:QI 0 "register_operand" "r") 0))]
  ""
  "*
   if (pic30_ecore_target() && TARGET_EDS) {
     return \"movpag #1,DSWPAG\;push %0\";
   } else {
     return \"push %0\";
   }
  "
  [ 
    (set_attr "cc" "unchanged")
    (set_attr "type" "def")
  ]
)
 
(define_insn "*pushminus1hi"
  [(set (match_operand:HI 0 "push_operand"   "=>")
	(const_int -1))]
  ""
  "*
   if (pic30_ecore_target() && TARGET_EDS) {
     return \"movpag #1,DSWPAG\;setm %0\";
   } else {
     return \"setm %0\";
   }
  "
  [
   (set_attr "cc" "unchanged")
   (set_attr "type" "def")
  ]
)

(define_insn "pushhi1"
  [(set (mem:HI (post_inc:HI (reg:HI SPREG)))
                (match_operand:HI 0 "register_operand" "r"))]
  "0"
  "push %0"
  [ 
    (set_attr "cc" "unchanged")
    (set_attr "type" "def")
  ]
)
 
(define_insn "pushhi"
  [(set (match_operand:HI 0 "push_operand"   "=>,>,>,>")
        (match_operand:HI 1 "pic30_pushhi_operand" "r,R>,O,T"))]
  ""
  "*
   if (pic30_ecore_target() && TARGET_EDS) {
     switch (which_alternative) {
       default: gcc_assert(0);
  
       case 0: return \"movpag #1,DSWPAG\;mov %1,%0\";
               break;
       case 1: return \"movpag #1,DSWPAG\;mov %1,%0\";
               break;
       case 2: return \"movpag #1,DSWPAG\;clr %0\";
               break;
       case 3: return \"movpag #1,DSWPAG\;push %1\";
               break;
     }
   } else {
     switch (which_alternative) {
       default: gcc_assert(0);

       case 0: return \"mov %1,%0\";
               break;
       case 1: return \"mov %1,%0\";
               break;
       case 2: return \"clr %0\";
               break;
       case 3: return \"push %1\";
               break;
     }
  }
  "
  [
   (set_attr "cc" "unchanged")
   (set_attr "type" "def,defuse,def,def")
  ]
)

(define_insn "pushsi1"
  [(set (mem:SI (post_inc:HI (reg:HI SPREG)))
                (match_operand:SI 0 "register_operand" "r"))]
  ""
  "*
   if (pic30_ecore_target() && TARGET_EDS) {
     return \"movpag #1,DSWPAG\;push.d %0\";
   } else {
     return \"push.d %0\";
   }
  "
  [ 
    (set_attr "cc" "unchanged")
    (set_attr "type" "def")
  ]
)
 
(define_insn "push<mode>"
  [(set (match_operand:MODES32 0 "push_operand"   "=>")
        (match_operand:MODES32 1 "pic30_register_operand" "r"))]
  ""
  "*
   if (pic30_ecore_target() && TARGET_EDS) {
     return \"movpag #1,DSWPAG\;mov.d %1,[w15++]\";
   } else {
     return \"mov.d %1,[w15++]\";
   }
  "
  [
   (set_attr "cc" "unchanged")
   (set_attr "type" "def")
  ]
)

(define_insn "pushdi1"
  [(set (mem:DI (post_inc:HI (reg:HI SPREG)))
                (match_operand:DI 0 "register_operand" "r"))]
  ""
  "*
   if (pic30_ecore_target() && TARGET_EDS) {
     return \"movpag #1,DSWPAG\;push.d %0\;push.d %t0\";
   } else {
     return \"push.d %0\;push.d %t0\";
   }
  "
  [ 
    (set_attr "cc" "unchanged")
    (set_attr "type" "def")
  ]
)
 
(define_insn "*pushdi"
  [(set (match_operand:DI 0 "push_operand"   "=>")
        (match_operand:DI 1 "pic30_register_operand" "r"))]
  ""
  "*
   if (pic30_ecore_target() && TARGET_EDS) {
     return \"movpag #1,DSWPAG\;mov.d %1,[w15++]\;mov.d %t1,[w15++]\";
   } else { 
     return \"mov.d %1,[w15++]\;mov.d %t1,[w15++]\";
   }
  "
  [
   (set_attr "cc" "unchanged")
   (set_attr "type" "def")
  ]
)

(define_insn "pushsf1"
  [(set (mem:SF (post_inc:HI (reg:HI SPREG)))
                (match_operand:SF 0 "register_operand" "r"))]
  ""
  "*
   if (pic30_ecore_target() && TARGET_EDS) {
     return \"movpag #1,DSWPAG\;push.d %0\";
   } else {
     return \"push.d %0\";
   }
  "
  [ 
    (set_attr "cc" "unchanged")
    (set_attr "type" "def")
  ]
)
 
(define_insn "*pushsf"
  [(set (match_operand:SF 0 "push_operand"   "=>")
        (match_operand:SF 1 "pic30_register_operand" "r"))]
  ""
  "*
   if (pic30_ecore_target() && TARGET_EDS) {
     return \"movpag #1,DSWPAG\;mov.d %1,[w15++]\";
   } else {
     return \"mov.d %1,[w15++]\";
   }
  "
  [
   (set_attr "cc" "unchanged")
   (set_attr "type" "def")
  ]
)

(define_insn "pushdf1"
  [(set (mem:DF (post_inc:HI (reg:HI SPREG)))
                (match_operand:DF 0 "register_operand" "r"))]
  "0"
  "push.d %0\;push.d %t0"
  [ 
    (set_attr "cc" "unchanged")
    (set_attr "type" "def")
  ]
)
 
(define_insn "pushdf"
  [(set (match_operand:DF 0 "push_operand"   "=>")
        (match_operand:DF 1 "pic30_register_operand" "r"))]
  ""
  "*
   if (pic30_ecore_target() && TARGET_EDS) {
     return \"movpag #1,DSWPAG\;mov.d %1,[w15++]\;mov.d %t1,[w15++]\";
   } else {
     return \"mov.d %1,[w15++]\;mov.d %t1,[w15++]\";
   }
  "
  [
   (set_attr "cc" "unchanged")
   (set_attr "type" "def")
  ]
)

(define_insn "pushshadow"
  [(unspec [(const_int 0)] UNSPEC_PUSHSHADOW)
   (use (reg:HI 0))
   (use (reg:HI 1))
   (use (reg:HI 2))
   (use (reg:HI 3))
  ]
  ""
  "push.s"
  [
    (set_attr "type" "etc")
  ]
)

(define_insn "popshadow"
  [(unspec [(const_int 0)] UNSPEC_POPSHADOW)
   (clobber (reg:HI 0))
   (clobber (reg:HI 1))
   (clobber (reg:HI 2))
   (clobber (reg:HI 3))
  ]
  ""
  "pop.s"
  [
    (set_attr "type" "etc")
    (set_attr "cc" "clobber")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; stackpop
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_insn "popqi"
  [(set (match_operand:QI 0 "pic30_register_operand" "=r")
        (match_operand:QI 1 "pop_operand"       "<"))]
  ""
  "*
   if (pic30_ecore_target() && TARGET_EDS) {
     return \"movpag #1,DSRPAG\;mov %1,%0\";
   } else {
     return \"mov %1,%0\";
   }
  "
  [
   (set_attr "cc" "change0")
   (set_attr "type" "defuse")
  ]
)

(define_insn "pophi"
  [(set (match_operand:HI 0 "pic30_general_operand" "=r,<,O,T")
        (match_operand:HI 1 "pop_operand"    " <,<,<,<"))]
  ""
  "*
   if (pic30_ecore_target() && TARGET_EDS) {
     switch (which_alternative) {
       default: gcc_assert(0);
       case 0: return \"movpag #1,DSRPAG\;mov %1,%0\";
       case 1: return \"movpag #1,DSRPAG\;mov %1,%0\";
       case 2: return \"movpag #1,DSRPAG\;clr %0\";
       case 3: return \"movpag #1,DSRPAG\;pop %0\";
     } 
   } else {
     switch (which_alternative) {
       default: gcc_assert(0);
       case 0: return \"mov %1,%0\";
       case 1: return \"mov %1,%0\";
       case 2: return \"clr %0\";
       case 3: return \"pop %0\";
     } 
   }
  "
  [
   (set_attr "cc" "change0, change0, change0, change0")
   (set_attr "type" "defuse,defuse,defuse,defuse")
  ]
)

(define_insn "pophi_unspec"
  [(set (unspec:HI [(match_operand:HI 0 "pic30_general_operand" "=r<,T")]
                   UNSPEC_POPHI)
        (mem:HI (pre_dec:HI (reg:HI SPREG))))
   (clobber (match_dup 0))
  ]
  ""
  "*
   if (pic30_ecore_target() && TARGET_EDS) {
     switch (which_alternative) {
       default: gcc_assert(0);
       case 0: return \"movpag #1,DSRPAG\;mov [--w15],%0\";
       case 1: return \"movpag #1,DSRPAG\;pop %0\";
     }
   } else {
     switch (which_alternative) {
       default: gcc_assert(0);
       case 0: return \"mov [--w15],%0\";
       case 1: return \"pop %0\";
     }
   }
  "
  [
   (set_attr "cc" "change0")
   (set_attr "type" "defuse,defuse")
  ]
)

(define_insn "popsi"
  [(set (match_operand:SI 0 "pic30_register_operand" "=r")
        (match_operand:SI 1 "pop_operand"       "<"))
  ]
  ""
  "*
   if (pic30_ecore_target() && TARGET_EDS) {
     return \"movpag #1,DSRPAG\;mov.d %1,%0\";
   } else {
     return \"mov.d %1,%0\";
   }
  "
  [
   (set_attr "cc" "change0")
   (set_attr "type" "defuse")
  ]
)

(define_insn "popdi"
  [(set (match_operand:DI 0 "pic30_register_operand" "=r")
        (match_operand:DI 1 "pop_operand"       "<"))]
  ""
  "*
   if (pic30_ecore_target() && TARGET_EDS) {
     return \"movpag #1,DSRPAG\;mov.d %1,%t0\;mov.d %1,%0\";
   } else {
     return \"mov.d %1,%t0\;mov.d %1,%0\";
   }
  "
  [
   (set_attr "cc" "change0")
   (set_attr "type" "defuse")
  ]
)

(define_insn "popsf"
  [(set (match_operand:SF 0 "pic30_register_operand" "=r")
        (match_operand:SF 1 "pop_operand"       "<"))]
  ""
  "*
   if (pic30_ecore_target() && TARGET_EDS) {
     return \"movpag #1,DSRPAG\;mov.d %1,%0\";
   } else {
     return \"mov.d %1,%0\";
   }
  "
  [
   (set_attr "cc" "change0")
   (set_attr "type" "defuse")
  ]
)
   
(define_insn "popdf"
  [(set (match_operand:DF 0 "pic30_register_operand" "=r")
        (match_operand:DF 1 "pop_operand"       "<"))]
  ""
  "*
   if (pic30_ecore_target() && TARGET_EDS) {
     return \"movpag #1,DSRPAG\;mov.d %1,%t0\;mov.d %1,%0\";
   } else {
     return \"mov.d %1,%t0\;mov.d %1,%0\";
   }
  "
  [
   (set_attr "cc" "change0")
   (set_attr "type" "defuse")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; stackcheck
;; If STACK_CHECK_BUILTIN is zero, and you define a named pattern called
;; check_stack in your 'md' file, GCC will call that pattern with one
;; argument which is the address to compare the stack value against.
;; You must arrange for this pattern to report an error if the stack
;; pointer is out of range.
;; (define_insn "check_stack"
;;   [(match_operand 0 "pic30_register_operand" "r")
;;    (clobber (match_scratch:HI 1 "=r"))]
;;   ""
;;   "mov .BOS,%1\;cpsge %0,%1\;reset")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Test operations.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_insn "tstqi_DATA"
  [(set (cc0)
        (compare
           (match_operand:QI 0 "pic30_near_mode2_operand" "U,r,R<>")
           (const_int 0))
   )
  ]
  ""
  "cp0.b %0"
  [
   (set_attr "cc" "set")
   (set_attr "type" "etc,etc,use")
  ]
)

(define_insn "tstqi_APSV"
  [(set (cc0)
        (compare
           (match_operand:QI 0 "pic30_near_mode2_APSV_operand" "U,r,R<>")
           (const_int 0))
   )
  ]
  ""
  "cp0.b %0"
  [
   (set_attr "cc" "set")
   (set_attr "type" "etc,etc,use")
  ]
)

(define_expand "tstqi"
  [(set (cc0)
        (compare
          (match_operand:QI 0 "pic30_near_mode2_APSV_operand" "U,r,R<>")
          (const_int 0))
   )
  ]
  ""
  "
{
  if (pic30_near_mode2_operand(operands[0],GET_MODE(operands[0])))
    emit(gen_tstqi_DATA(operands[0]));
  else
    emit(gen_tstqi_APSV(operands[0]));
  DONE;
}")


(define_insn "tsthi_DATA"
  [(set (cc0)
        (compare
          (match_operand:HI 0 "pic30_near_mode2_operand" "U,r,R<>")
          (const_int 0))
   )
  ]
  ""
  "cp0 %0"
  [
   (set_attr "cc" "set")
   (set_attr "type" "etc,etc,use")
  ]
)

(define_insn "tsthi_APSV"
  [(set (cc0)
        (compare
          (match_operand:HI 0 "pic30_near_mode2_APSV_operand" "U,r,R<>")
          (const_int 0))
   )
  ]
  ""
  "cp0 %0"
  [
   (set_attr "cc" "set")
   (set_attr "type" "etc,etc,use")
  ]
)

(define_expand "tsthi"
  [(set (cc0)
        (compare
          (match_operand:HI 0 "pic30_near_mode2_operand" "U,r,R<>")
          (const_int 0))
   )
  ]
  ""
"
{
  if (pic30_near_mode2_operand(operands[0],GET_MODE(operands[0])))
    emit(gen_tsthi_DATA(operands[0]));
  else
    emit(gen_tsthi_APSV(operands[0]));
  DONE;
}")

(define_insn "tstsi"
  [(set (cc0)
        (match_operand:SI 0 "pic30_register_operand" "r"))]
  ""
  "sub %0,#0,[w15]\;subb %d0,#0,[w15]"
  [
    (set_attr "cc" "set")
    (set_attr "type" "etc")
  ]
)

(define_insn "tstdi"
  [(set (cc0)
        (match_operand:DI 0 "pic30_register_operand" "r"))]
  ""
  "sub %0,#0,[w15]\;subb %d0,#0,[w15]\;subb %t0,#0,[w15]\;subb %q0,#0,[w15]"
  [
    (set_attr "cc" "set")
    (set_attr "type" "etc")
  ]
)

; With dsPIC30 floats, testing the most significant word does not suffice,
; since -0.0 == 0.0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Block moves.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Argument 0 is the destination
;; Argument 1 is the source
;; Argument 2 is the length
;; Argument 3 is the alignment
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_expand "movstrhi"
  [(parallel [(set (match_operand:BLK 0 "pic30_memory_operand" "")
		   (match_operand:BLK 1 "pic30_memory_operand" ""))
	      (use (match_operand:HI 2 "const_int_operand" ""))
	      (use (match_operand:HI 3 "const_int_operand" ""))
	      (clobber (match_dup 4))
	      (clobber (match_dup 5))
   	      (clobber (reg:HI RCOUNT))
  ])]
  ""
  "{
     rtx addr0;
     rtx addr1;
     int n;
     
     if (GET_CODE (operands[2]) != CONST_INT) FAIL;
     n = INTVAL(operands[2]);
     if (n < 1) FAIL;
     switch (INTVAL(operands[3]))
     {
     case 1:
       if (n > 16383) FAIL;
       break;
     default:
       if ((n > (16383*2)) || (n & 1)) FAIL;
       break;
     }
     
     addr0 = copy_to_mode_reg(Pmode, XEXP (operands[0], 0));
     addr1 = copy_to_mode_reg(Pmode, XEXP (operands[1], 0));

     operands[4] = addr0;
     operands[5] = addr1;
     operands[0] = change_address(operands[0], VOIDmode, addr0);
     operands[1] = change_address(operands[1], VOIDmode, addr1);
   }"
)

;
;  This pattern should restore the src/ dest ptrs before finishing
;
(define_insn "movmemhi"
  [(set (match_operand:BLK 0 "pic30_memory_operand"  "=R,m,R,R,m,R,m")
        (match_operand:BLK 1 "pic30_memory_operand"   "R,R,m,R,R,m,m"))
   (use (match_operand:HI 2 "immediate_operand" "J,J,J,i,i,i,i"))
   (use (match_operand:HI 3 "const_int_operand" ""))
   (clobber (reg:HI RCOUNT))
   (clobber (match_scratch:HI 4  "=X,&r,&r,&r,&r,&r,&r"))
   (clobber (match_scratch:HI 5  "=X,X,X,X,&r,&r,&r"))
  ]
  "((pic30_errata_mask & ecc_errata) == 0)"
  "*
   { /* my calculation says maximum string size is ~120 */
     static char buffer[160];
     char *c = buffer;
     char *op0 = (char *)\"[%r0++]\";
     char *op1 = (char *)\"[%r1++]\";
     char *restore_with_sub_0=0;
     char *restore_with_sub_1=0;
     char *restore_w14=0;
     char *sub_value = 0;  /* != 0 => use register */
     int repeat_repeat;
     int repeat_count;

     repeat_count = INTVAL(operands[2]);
     switch (which_alternative) {
     default: break;
     case 0:  /* both registers */
              /* literal <= 10 bits */
              restore_with_sub_0 = \"%r0\";
              restore_with_sub_1 = \"%r1\";
              break;
     case 1:  /* op0 is memory, take its address */
              /* literal <= 10 bits */
              if (pic30_T_constraint(operands[0],VOIDmode) ||
                  pic30_U_constraint(operands[0],VOIDmode)) {
                c += sprintf(c,\"mov #%%0,%%4\;\");
                op0 = \"[%4++]\";
              } else if (pic30_S_constraint(operands[0]) ||
                         pic30_Q_constraint(operands[0])) {
                /* [Wn + X] */
                rtx Wn, X;

                Wn = XEXP(XEXP(operands[0],0),0);
                X = XEXP(XEXP(operands[0],0),1);
                if (REG_P(X))
                  c += sprintf(c,\"add w%d,w%d,%%4\;\", REGNO(Wn), REGNO(X));
                else {
                  if (CONST_OK_FOR_LETTER_P(INTVAL(X),'P')) {
                    c += sprintf(c,\"add w%d,#%ld,%%4\;\",REGNO(Wn),INTVAL(X));
                  } else if (CONST_OK_FOR_LETTER_P(INTVAL(X),'N')) {
                    c += sprintf(c,\"sub w%d,#%ld,%%4\;\",
                                   REGNO(Wn),-1*INTVAL(X));
                  } else {
                    c += sprintf(c,\"mov #%ld,%%4\;\",INTVAL(X));
                    c += sprintf(c,\"add w%d,%%4,%%4\;\", REGNO(Wn));
                  }
                }
                op0 = \"[%4++]\";
              } else {
                gcc_assert(0);
              } 
              restore_with_sub_1 = \"%r1\";
              break;
     case 2:  /* op1 is memory, take its address */
              /* literal <= 10 bits */
              if (pic30_T_constraint(operands[1],VOIDmode) ||
                  pic30_U_constraint(operands[1],VOIDmode)) {
                c += sprintf(c,\"mov #%%1,%%4\;\");
                op1 = \"[%4++]\";
              } else if (pic30_S_constraint(operands[1]) ||
                         pic30_Q_constraint(operands[1])) {
                /* [Wn + X] */
                rtx Wn, X;

                Wn = XEXP(XEXP(operands[1],0),0);
                X = XEXP(XEXP(operands[1],0),1);
                if (REG_P(X))
                  c += sprintf(c,\"add w%d,w%d,%%4\;\", REGNO(Wn), REGNO(X));
                else {
                  if (CONST_OK_FOR_LETTER_P(INTVAL(X),'P')) {
                    c += sprintf(c,\"add w%d,#%ld,%%4\;\",REGNO(Wn),INTVAL(X));
                  } else if (CONST_OK_FOR_LETTER_P(INTVAL(X),'N')) {
                    c += sprintf(c,\"sub w%d,#%ld,%%4\;\",
                                   REGNO(Wn),-1*INTVAL(X));
                  } else {
                    c += sprintf(c,\"mov #%ld,%%4\;\",INTVAL(X));
                    c += sprintf(c,\"add w%d,%%4,%%4\;\", REGNO(Wn));
                  }
                }
                op1 = \"[%4++]\";
              } else {
                gcc_assert(0);
              } 
              restore_with_sub_0 = \"%r0\";
              break;
     case 6:  /* op0 and op1 are memory, take their addresses */
              if (pic30_T_constraint(operands[0],VOIDmode) || 
                  pic30_U_constraint(operands[0],VOIDmode)) {
                c += sprintf(c,\"mov #%%0,%%4\;\");
                op0 = \"[%4++]\";
              } else if (pic30_S_constraint(operands[0]) ||
                         pic30_Q_constraint(operands[0])) {
                /* [Wn + X] */
                rtx Wn, X;
  
                Wn = XEXP(XEXP(operands[0],0),0);  
                X = XEXP(XEXP(operands[0],0),1);
                if (REG_P(X)) 
                  c += sprintf(c,\"add w%d,w%d,%%4\;\", REGNO(Wn), REGNO(X));
                else {
                  if (CONST_OK_FOR_LETTER_P(INTVAL(X),'P')) {
                    c += sprintf(c,\"add w%d,#%ld,%%4\;\",REGNO(Wn),INTVAL(X));
                  } else if (CONST_OK_FOR_LETTER_P(INTVAL(X),'N')) {
                    c += sprintf(c,\"sub w%d,#%ld,%%4\;\",
                                   REGNO(Wn),-1*INTVAL(X));
                  } else {
                    c += sprintf(c,\"mov #%ld,%%4\;\",INTVAL(X));
                    c += sprintf(c,\"add w%d,%%4,%%4\;\", REGNO(Wn));
                  }
                }
                op0 = \"[%4++]\";
              } else {
                gcc_assert(0);
              }
              if (pic30_T_constraint(operands[1],VOIDmode) ||
                  pic30_U_constraint(operands[1],VOIDmode)) {
                c += sprintf(c,\"mov #%%1,%%5\;\");
                op1 = \"[%5++]\";
              }  else if (pic30_S_constraint(operands[1]) ||
                         pic30_Q_constraint(operands[1])) {
                /* [Wn + X] */
                rtx Wn, X;

                Wn = XEXP(XEXP(operands[1],0),0);
                X = XEXP(XEXP(operands[1],0),1);
                if (REG_P(X))
                  c += sprintf(c,\"add w%d,w%d,%%5\;\", REGNO(Wn), REGNO(X));
                else {
                  if (CONST_OK_FOR_LETTER_P(INTVAL(X),'P')) {
                    c += sprintf(c,\"add w%d,#%ld,%%5\;\",REGNO(Wn),INTVAL(X));
                  } else if (CONST_OK_FOR_LETTER_P(INTVAL(X),'N')) {
                    c += sprintf(c,\"sub w%d,#%ld,%%5\;\",
                                   REGNO(Wn),-1*INTVAL(X));
                  } else {
                    c += sprintf(c,\"mov #%ld,%%5\;\",INTVAL(X));
                    c += sprintf(c,\"add w%d,%%5,%%5\;\", REGNO(Wn));
                  }
                }
                op1 = \"[%5++]\";
              } else {
                gcc_assert(0);
              }
              break;
     case 3:  /* op0 and op1 are registers */
              /* literal > 10 bits, save repeat count in reg */
              restore_with_sub_0 = \"%r0\";
              restore_with_sub_1 = \"%r1\";
              c += sprintf(c,\"mov #%%2,%%4\;\");
              sub_value =\"%4\";
              break;
     case 4:  /* op0 is memory, take its address */
              /* literal > 10 bits, save repeat count in reg */
              if (pic30_T_constraint(operands[0],VOIDmode) ||
                  pic30_U_constraint(operands[0],VOIDmode)) {
                c += sprintf(c,\"mov #%%0,%%4\;\");
                op0 = \"[%4++]\";
              } else if (pic30_S_constraint(operands[0]) ||
                         pic30_Q_constraint(operands[0])) {
                /* [Wn + X] */
                rtx Wn, X;

                Wn = XEXP(XEXP(operands[0],0),0);
                X = XEXP(XEXP(operands[0],0),1);
                if (REG_P(X))
                  c += sprintf(c,\"add w%d,w%d,%%4\;\", REGNO(Wn), REGNO(X));
                else {
                  if (CONST_OK_FOR_LETTER_P(INTVAL(X),'P')) {
                    c += sprintf(c,\"add w%d,#%ld,%%4\;\",REGNO(Wn),INTVAL(X));
                  } else if (CONST_OK_FOR_LETTER_P(INTVAL(X),'N')) {
                    c += sprintf(c,\"sub w%d,#%ld,%%4\;\",
                                   REGNO(Wn),-1*INTVAL(X));
                  } else {
                    c += sprintf(c,\"mov #%ld,%%4\;\",INTVAL(X));
                    c += sprintf(c,\"add w%d,%%4,%%4\;\", REGNO(Wn));
                  }
                }
                op0 = \"[%4++]\";
              } else {
                gcc_assert(0);
              }
              if (pic30_T_constraint(operands[2],VOIDmode) ||
                  pic30_U_constraint(operands[2],VOIDmode)) {
                c += sprintf(c,\"mov #%%2,%%5\;\");
              } else {
                c += sprintf(c,\"mov %%2,%%5\;\");
              }
              sub_value = \"%5\";
              restore_with_sub_1 = \"%r1\";
              break;
     case 5:  /* op1 is memory, take its address */
              /* literal > 10 bits, save repeat count in reg */
              if (pic30_T_constraint(operands[1],VOIDmode) ||
                  pic30_U_constraint(operands[1],VOIDmode)) {
                c += sprintf(c,\"mov #%%1,%%4\;\");
                op1 = \"[%4++]\";
              } else if (pic30_S_constraint(operands[1]) ||
                         pic30_Q_constraint(operands[1])) {
                /* [Wn + X] */
                rtx Wn, X;

                Wn = XEXP(XEXP(operands[1],0),0);
                X = XEXP(XEXP(operands[1],0),1);
                if (REG_P(X))
                  c += sprintf(c,\"add w%d,w%d,%%4\;\", REGNO(Wn), REGNO(X));
                else {
                  if (CONST_OK_FOR_LETTER_P(INTVAL(X),'P')) {
                    c += sprintf(c,\"add w%d,#%ld,%%4\;\",REGNO(Wn),INTVAL(X));
                  } else if (CONST_OK_FOR_LETTER_P(INTVAL(X),'N')) {
                    c += sprintf(c,\"sub w%d,#%ld,%%4\;\",
                                   REGNO(Wn),-1*INTVAL(X));
                  } else {
                    c += sprintf(c,\"mov #%ld,%%4\;\",INTVAL(X));
                    c += sprintf(c,\"add w%d,%%4,%%4\;\", REGNO(Wn));
                  }
                }
                op1 = \"[%4++]\";
              } else {
                gcc_assert(0);
              }
              restore_with_sub_0 = \"%r0\";
              if (pic30_T_constraint(operands[2],VOIDmode) ||
                  pic30_U_constraint(operands[2],VOIDmode)) {
                c += sprintf(c,\"mov #%%2,%%5\;\");
              } else {
                c += sprintf(c,\"mov %%2,%%5\;\");
              }
              sub_value = \"%5\";
              break;
     }
     
     switch (INTVAL(operands[3]))
     {
       case 1:
         /* 
         ** Byte operation
         */
         repeat_repeat =  repeat_count - 16383;
         if (repeat_repeat < 0) repeat_repeat = 0;
	 if (repeat_repeat) {
           c += sprintf(c,\"repeat #16383-1\;mov.b %s,%s\;\", op1, op0);
           c += sprintf(c,\"repeat #%d-1\;mov.b %s,%s\", repeat_count,op1, op0);
         } else c += sprintf(c,\"repeat #%d-1\;mov.b %s,%s\", 
                             repeat_count, op1, op0);
         break;
     default: {
         int repeat_remainder;
	 /* 
	 ** Word operation
	 */
         /* repeat count is expressed in bytes */
         repeat_remainder = (repeat_count & 1);
         repeat_count = repeat_count / 2;
         repeat_repeat =  repeat_count - 16383;
         if (repeat_repeat < 0) repeat_repeat = 0;
	 if (repeat_repeat) {
           c += sprintf(c,\"repeat #16383-1\;mov %s,%s\;\", op1, op0);
           c += sprintf(c,\"repeat #%d-1\;mov %s,%s\", 
                        repeat_count, op1, op0);
         } else c += sprintf(c,\"repeat #%d-1\;mov %s,%s\", 
                             repeat_count, op1, op0);
         if (repeat_remainder) {
           if (pic30_psrd_psrd_errata(operands[1],NULL)) {
             c += sprintf(c,\"\;nop\");
           }
           c += sprintf(c,\"\;mov.b %s,%s\", op1,op0);
         } break;
       }
     }
     if (restore_with_sub_0) {
       if (sub_value) {
         c += sprintf(c,\"\;sub %s, %s, %s\", 
                      restore_with_sub_0, sub_value, restore_with_sub_0);
       } else c += sprintf(c,\"\;sub #%%2, %s\", restore_with_sub_0);
     }
     if (restore_with_sub_1) {
       if (sub_value) {
         c += sprintf(c,\"\;sub %s, %s, %s\", 
                      restore_with_sub_1, sub_value, restore_with_sub_1);
       } else c += sprintf(c,\"\;sub #%%2, %s\", restore_with_sub_1);
     }
     if (restore_w14) {
       c += sprintf(c, \"\;mov %s,w14\", restore_w14);
     }
     return buffer;
   } "
  [
     (set_attr "type" "use")
  ]
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Block clear.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Argument 0 is the destination
;; Argument 1 is the length
;; Argument 2 is the alignment
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define_insn "setmemhi"
  [
   (set (match_operand:BLK 0 "pic30_memory_operand"  "=R,m,R,m,R,m,R,m,R,m,R,m")
        (match_operand     2 "pic30_reg_or_imm_operand" 
                                                     "O,O,O,O,i,i,i,i,r,r,r,r"))
   (use (match_operand:HI 1 "immediate_operand" "J,J,i,i,J,J,i,i,J,J,i,i"))
   (use (match_operand:HI 3 "const_int_operand" ""))
   (clobber (reg:HI RCOUNT))
   (clobber (match_scratch:HI 4  "=X,&r,&r,&r,X,&r,&r,&r,X,&r,&r,&r"))
   (clobber (match_scratch:HI 5  "=X,X,X,&r,X,X,X,&r,X,X,X,&r"))
   (clobber (match_scratch:HI 6  "=X,X,X,X,&r,&r,&r,&r,&r,&r,&r,&r"))
  ]
  ""
  "*
   { /* my calculation says maximum string size is ~120 */
     static char buffer[160];
     char *c = buffer;
     char *op0 = \"[%r0++]\";
     char *op1 = \"\";
     char *restore_with_sub_0=0;
     char *restore_w14=0;
     char *sub_value = 0;  /* != 0 => use register */
     unsigned char byte;
     int repeat_repeat;
     int repeat_count;
     char *set_instr = \"mov\";
     int word_size = INTVAL(operands[3]);

     repeat_count = INTVAL(operands[1]);
     if (const_int_operand(operands[2],VOIDmode)) {
       if (INTVAL(operands[2]) == 0) {
         set_instr = \"clr\";
       } else {
         /* the middle four are the same as the bottom four, just that we don't
            need a clobber register for the value */
         gcc_assert(which_alternative > 3);
         which_alternative -= 4;
         if (INTVAL(operands[3]) != 1) {
           /* repeat bytes */
           /* first convert char to unsigned char */
           /* since we are doing bit operations */
           byte = INTVAL(operands[2]) & 0xFF;
           c += sprintf(c,\"mov #%ld,%%6\;\", (byte << 8) + byte);
         } else {
           c += sprintf(c,\"mov #%ld,%%6\;\", INTVAL(operands[2]));
         }
         op1=\"%6,\";
       }
     } else {
       /* register already */
       /* the top four are the same as the bottom four, just that we don't
          need a clobber register for the value */
       gcc_assert(which_alternative > 7);
       which_alternative -= 8;
       op1 = \"%2,\";
       if (repeat_count < 4) {
         word_size = 1;
       } else {
         c += sprintf(c,\"sl %%2,#8,%%6\;ior.b %%2,%%6,%%6\;\");
         op1=\"%6,\";
     }
     }

     switch (which_alternative) {
     default: break;
     case 0:  /* op0 is register */
              /* literal <= 10 bits */
              restore_with_sub_0 = \"%r0\";
              break;
     case 1:  /* op0 is memory, take its address */
              /* literal <= 10 bits */
              if (pic30_T_constraint(operands[0],VOIDmode) ||
                  pic30_U_constraint(operands[0],VOIDmode)) {
                c += sprintf(c,\"mov #%%0,%%4\;\");
                op0 = \"[%4++]\";
              } else if (pic30_S_constraint(operands[0]) ||
                         pic30_Q_constraint(operands[0])) {
                /* [Wn + X] */
                rtx Wn, X;

                Wn = XEXP(XEXP(operands[0],0),0);
                X = XEXP(XEXP(operands[0],0),1);
                {
                  if (REG_P(X))
                    c += sprintf(c,\"add w%d,w%d,%%4\;\", REGNO(Wn), REGNO(X));
                  else {
                    if (CONST_OK_FOR_LETTER_P(INTVAL(X),'P')) {
                      c += sprintf(c,\"add w%d,#%ld,%%4\;\",REGNO(Wn),INTVAL(X));
                    } else if (CONST_OK_FOR_LETTER_P(INTVAL(X),'N')) {
                      c += sprintf(c,\"sub w%d,#%ld,%%4\;\",
                                     REGNO(Wn),-1*INTVAL(X));
                    } else {
                      c += sprintf(c,\"mov w%d,%%4\;\", REGNO(Wn));
                      if (INTVAL(X) < 0)
                        c += sprintf(c,\"sub #%ld,%%4\;\",-1*INTVAL(X));
                      else c += sprintf(c,\"add #%ld,%%4\;\",INTVAL(X));
                    }
                  }
                  op0 = \"[%4++]\";
                }
              } else {
                gcc_assert(0);
              } 
              break;
     case 2:  /* op0 is a register */
              /* literal > 10 bits, save repeat count in reg */
              restore_with_sub_0 = \"%r0\";
              c += sprintf(c,\"mov #%%1,%%4\;\");
              sub_value =\"%4\";
              break;
     case 3:  /* op0 is memory, take its address */
              /* literal > 10 bits, save repeat count in reg */
              if (pic30_T_constraint(operands[0],VOIDmode) ||
                  pic30_U_constraint(operands[0],VOIDmode)) {
                c += sprintf(c,\"mov #%%0,%%4\;\");
                op0 = \"[%4++]\";
              } else if (pic30_S_constraint(operands[0]) ||
                         pic30_Q_constraint(operands[0])) {
                /* [Wn + X] */
                rtx Wn, X;

                Wn = XEXP(XEXP(operands[0],0),0);
                X = XEXP(XEXP(operands[0],0),1);
                {
                  if (REG_P(X))
                    c += sprintf(c,\"add w%d,w%d,%%4\;\", REGNO(Wn), REGNO(X));
                  else {
                    if (CONST_OK_FOR_LETTER_P(INTVAL(X),'P')) {
                      c += sprintf(c,\"add w%d,#%ld,%%4\;\",REGNO(Wn),INTVAL(X));
                    } else if (CONST_OK_FOR_LETTER_P(INTVAL(X),'N')) {
                      c += sprintf(c,\"sub w%d,#%ld,%%4\;\",
                                     REGNO(Wn),-1*INTVAL(X));
                    } else {
                      c += sprintf(c,\"mov w%d,%%4\;\", REGNO(Wn));
                      if (INTVAL(X) < 0)
                        c += sprintf(c,\"sub #%ld,%%4\;\",-1*INTVAL(X));
                      else c += sprintf(c,\"add #%ld,%%4\;\",INTVAL(X));
                    }
                  }
                  op0 = \"[%4++]\";
                }
              } else {
                gcc_assert(0);
              }
              break;
     }
     
     switch (word_size) 
     {
       case 1:
         /* 
         ** Byte operation
         */
         repeat_repeat =  repeat_count - 16383;
         if (repeat_repeat < 0) repeat_repeat = 0;
	 if (repeat_repeat) {
           c += sprintf(c, \"repeat #16383-1\;%s.b %s%s\;\", 
                           set_instr, op1, op0);
           c += sprintf(c,\"repeat #%d-1\;%s.b %s%s\", 
                           repeat_count, set_instr, op1, op0);
         } else c += sprintf(c,\"repeat #%d-1\;%s.b %s%s\", 
                             repeat_count, set_instr, op1, op0);
         break;
       default: {
         int repeat_remainder;
	 /* 
	 ** Word operation
	 */
         /* repeat count is expressed in bytes */
         repeat_remainder = (repeat_count & 1);
         repeat_count = repeat_count / 2;
         repeat_repeat =  repeat_count - 16383;
         if (repeat_repeat < 0) repeat_repeat = 0;
	 if (repeat_repeat) {
           c += sprintf(c,\"repeat #16383-1\;%s %s%s\;\", 
                           set_instr, op1, op0);
           c += sprintf(c,\"repeat #%d-1\;%s %s%s\", 
                        repeat_count, set_instr, op1, op0);
         } else c += sprintf(c,\"repeat #%d-1\;%s %s%s\", 
                             repeat_count, set_instr, op1, op0);
         if (repeat_remainder) 
           c += sprintf(c,\"\;%s.b %s%s\", set_instr, op1, op0);
         break;
       }
     }
     if (restore_with_sub_0) {
       if (sub_value) {
         c += sprintf(c,\"\;sub %s, %s, %s\", 
                      restore_with_sub_0, sub_value, restore_with_sub_0);
       } else c += sprintf(c,\"\;sub #%%1, %s\", restore_with_sub_0);
     }
     if (restore_w14) {
       c += sprintf(c, \"\;mov %s,w14\", restore_w14);
     }
     return buffer;
   } "
  [
     (set_attr "type" "use")
  ]
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; compare instructions.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_insn "any_branch"
  [(set (pc)
       (if_then_else (match_operator 0 "comparison_operator"
                      [(cc0) (const_int 0)])
                     (label_ref (match_operand 1 "" ""))
                     (pc)))]
  ""
  "* 
   return pic30_conditional_branch(GET_CODE(operands[0]), operands[1]);
  "
  [(set_attr "cc" "unchanged")]
)

(define_mode_iterator CMPMODES [QI HI SI DI QQ HQ UQQ UHQ SQ USQ DQ UDQ TQ UTQ HA UHA SA USA DA UDA TA UTA])

(define_expand "cbranch<mode>4"
 [(set (cc0)
       (compare (match_operand:CMPMODES 1 "pic30_mode1PN_operand" "")
                (match_operand:CMPMODES 2 "pic30_mode1PN_operand" "")))
  (set (pc)
       (if_then_else (match_operator 0 "comparison_operator"
                      [(cc0) (const_int 0)])
                     (label_ref (match_operand 3 "" ""))
                     (pc)))]
  ""
  { /* The optimizer will coalesce this if possible, right? */
    rtx reg_1 = force_reg (GET_MODE(operands[1]), operands[1]);

    emit(
      gen_cmp<mode>(reg_1,operands[2])
    );
    emit(
      gen_any_branch(operands[0], operands[3])
    );
    DONE;
  }
) 

;;;;;;;;;;;;;;;;;;
;; quarter integer
;;;;;;;;;;;;;;;;;;

(define_insn "*cmpqi_imm"
  [(set (cc0)
        (compare (match_operand:QI 0 "pic30_register_operand" "r")
                 (match_operand:QI 1 "pic30_M_operand"  "M")))
   (clobber (match_dup 0))]
  ""
  "add.b #%J1,%0"
  [
    (set_attr "cc" "set")
    (set_attr "type" "etc")
  ]
)

(define_insn "cmpqi3_sfr0"
  [(set (cc0)
        (compare (match_operand:QI 0 "pic30_reg_or_near_operand" "U,r")
                    (match_operand:QI 1 "pic30_wreg_operand" "a,r")))]
  ""
  "@
   cp.b %0
   sub.b %0,%1,[w15]"
  [
    (set_attr "cc" "set,set")
    (set_attr "type" "etc,etc")
  ]
)

;
; RAW stall on 1/3
;
(define_insn "cmpqi3_2sfr"
  [(set (cc0)
        (compare 
           (match_operand:QI 0 "pic30_wreg_or_near_operand" "?r,U, U,  r")
           (match_operand:QI 1 "pic30_wreg_or_near_operand" "U, a, ?r, r")))
   (clobber (match_scratch:HI 2 "=r,X,r,X"))]
  ""
  "@
   mov #%1,%2\;sub.b %0,[%2],[w15]
   cp.b %0
   mov #%0,%2\;sub.b %0,[%2],[w15]
   cp.b %0,%1"
  [
    (set_attr "cc" "set")
    (set_attr "type" "etc")
  ])

(define_expand "cmpqi"
 [(set (cc0)
       (compare (match_operand:QI 0 "pic30_near_mode1PN_operand" "")
                (match_operand:QI 1 "pic30_near_mode1PN_APSV_operand" "")))
  (match_dup 2)]
  ""
  "{
      rtx (*gen)(rtx,rtx);

      if (pic30_near_mode1PN_operand(operands[1],GET_MODE(operands[1]))) {
        gen = gen_cmpqi_normal_DATA;
      } else {
        gen = gen_cmpqi_normal_APSV;
      }
      if (pic30_near_operand(operands[0],QImode) &&
          pic30_near_operand(operands[1],QImode)) {
  
        operands[2] = gen_reg_rtx(QImode);
        
        emit_insn(gen_movqi_gen_DATA(operands[2],operands[1]));
        emit_insn(gen_cmpqi3_sfr0(operands[0],operands[2]));
      } else if (pic30_near_operand(operands[1],QImode)) {
        if (pic30_wreg_operand(operands[0],QImode))
          emit_insn(gen_cmpqi3_2sfr(operands[0],operands[1]));
        else { 
          rtx pop; 

          operands[2] = gen_reg_rtx(HImode);
          pop = gen_rtx_MEM(QImode, operands[2]);
          emit_insn(gen_movhi_address(operands[2],  XEXP(operands[1],0)));
          emit_insn(gen(operands[0],pop));
        }
      }
      else if (pic30_near_operand(operands[0],QImode)) {
        if (pic30_wreg_operand(operands[1],QImode))
          emit_insn(gen_cmpqi3_sfr0(operands[0],operands[1]));
        else {
          rtx pop;

          operands[2] = gen_reg_rtx(HImode);
          pop = gen_rtx_MEM(QImode, operands[2]);
          emit_insn(gen_movhi_address(operands[2], XEXP(operands[0],0)));
          emit_insn(gen(pop,operands[1]));
        }
      } else {
        emit_insn(gen(operands[0],operands[1]));
      }
      DONE;
   }
  "
)

(define_insn "cmpqi_normal_DATA"
  [(set (cc0)
        (compare (match_operand:QI 0 "pic30_mode2_operand"
                                "r,r,  R<>,r,r")
                 (match_operand:QI 1 "pic30_mode1PN_operand"
                                "r,R<>,r,  P,N")))]
  ""
  "@
   sub.b %0,%1,[w15]
   sub.b %0,%1,[w15]
   subr.b %1,%0,[w15]
   sub.b %0,#%1,[w15]
   add.b %0,#%J1,[w15]"
  [
   (set_attr "cc" "set")
   (set_attr "type" "etc,use,use,etc,etc")
  ]
)

(define_insn "cmpqi_normal_APSV"
  [(set (cc0)
        (compare (match_operand:QI 0 "pic30_mode2_operand"
                                "r,r,  R<>,r,r")
                 (match_operand:QI 1 "pic30_mode1PN_APSV_operand"
                                "r,R<>,r,  P,N")))]
  ""
  "@
   sub.b %0,%1,[w15]
   sub.b %0,%1,[w15]
   subr.b %1,%0,[w15]
   sub.b %0,#%1,[w15]
   add.b %0,#%J1,[w15]"
  [
   (set_attr "cc" "set")
   (set_attr "type" "etc,use,use,etc,etc")
  ]
)

;;;;;;;;;;;;;;;;;;
;; half integer
;;;;;;;;;;;;;;;;;;

(define_insn "cmphi_imm"
  [(set (cc0)
        (compare (match_operand:HI 0 "pic30_register_operand" "r")
                 (match_operand:HI 1 "pic30_M_operand"  "M")))
   (clobber (match_dup 0))]
  ""
  "add #%J1,%0"
  [(set_attr "cc" "set")])

(define_insn "cmphi_sfr0"
  [(set (cc0)
        (compare (match_operand:HI 0 "pic30_reg_or_near_operand" "U,r")
                    (match_operand:HI 1 "pic30_register_operand" "a,r")))]
  ""
  "@
   cp %0
   sub %0,%1,[w15]"
  [
    (set_attr "cc" "set")
  ]
)

;        (compare (match_operand:HI 0 "pic30_reg_or_near_operand" "Ur")

(define_insn "cmpzhi_sfr0"
  [(set (cc0)
        (compare (match_operand:HI 0 "pic30_mode2_or_near_operand" "R<>,Ur")
                    (const_int 0)))]
  ""
  "cp0 %0"
  [
    (set_attr "cc" "set")
    (set_attr "type" "use,etc")
  ]
)

(define_insn "cmphi_DATA"
  [(set (cc0)
        (compare (match_operand:HI 0 "pic30_mode2_operand"
                                "r,r,  R<>,r,r")
                 (match_operand:HI 1 "pic30_mode1PN_operand"
                                "r,R<>,r,  P,N")))]
  ""
  "@
   sub %0,%1,[w15]
   sub %0,%1,[w15]
   subr %1,%0,[w15]
   sub %0,#%1,[w15]
   add %0,#%J1,[w15]"
  [
   (set_attr "cc" "set")
   (set_attr "type" "etc,use,use,etc,etc")
  ]
)

(define_insn "cmphi_APSV"
  [(set (cc0)
        (compare (match_operand:HI 0 "pic30_mode2_operand"
                                "r,r,  R<>,r,r")
                 (match_operand:HI 1 "pic30_mode1PN_APSV_operand"
                                "r,R<>,r,  P,N")))]
  ""
  "@
   sub %0,%1,[w15]
   sub %0,%1,[w15]
   subr %1,%0,[w15]
   sub %0,#%1,[w15]
   add %0,#%J1,[w15]"
  [
   (set_attr "cc" "set")
   (set_attr "type" "etc,use,use,etc,etc")
  ]
)

(define_expand "cmphi"
  [(set (cc0)
        (compare (match_operand:HI 0 "pic30_mode2_operand"
                                "r,r,  R<>,r,r")
                 (match_operand:HI 1 "pic30_mode1PN_APSV_operand"
                                "r,R<>,r,  P,N")))]
  ""
  "
{
  if (pic30_mode1PN_operand(operands[1],GET_MODE(operands[1])))
    emit_insn(gen_cmphi_DATA(operands[0],operands[1]));
  else
    emit_insn(gen_cmphi_APSV(operands[0],operands[1]));
  DONE;
}")

(define_insn "*cmpp16apsv_imm"
  [(set (cc0)
        (compare (match_operand:P16APSV 0 "pic30_register_operand" "r")
                 (match_operand:P16APSV 1 "pic30_M_operand"  "M")))
   (clobber (match_dup 0))]
  ""
  "add #%J1,%0"
  [
    (set_attr "cc" "set")
    (set_attr "type" "etc")
  ])

(define_insn "*cmpp16apasv_sfr0"
  [(set (cc0)
        (compare
          (match_operand:P16APSV 0 "pic30_reg_or_near_operand" "U,r")
          (match_operand:P16APSV 1 "pic30_register_operand" "a,r")))]
  ""
  "@
   cp %0
   sub %0,%1,[w15]"
  [
    (set_attr "cc" "set")
    (set_attr "type" "etc")
  ])

(define_insn "cmpp16apsv_DATA"
  [(set (cc0)
        (compare (match_operand:P16APSV 0 "pic30_mode2_operand"
                                "r,r,  R<>,r,r")
                 (match_operand:P16APSV 1 "pic30_mode1PN_operand"
                                "r,R<>,r,  P,N")))]
  ""
  "@
   sub %0,%1,[w15]
   sub %0,%1,[w15]
   subr %1,%0,[w15]
   sub %0,#%1,[w15]
   add %0,#%J1,[w15]"
  [
   (set_attr "cc" "set")
   (set_attr "type" "etc,use,use,etc,etc")
  ]
)

(define_insn "cmpp16apsv_APSV"
  [(set (cc0)
        (compare (match_operand:P16APSV 0 "pic30_mode2_operand"
                                "r,r,  R<>,r,r")
                 (match_operand:P16APSV 1 "pic30_mode1PN_APSV_operand"
                                "r,R<>,r,  P,N")))]
  ""
  "@
   sub %0,%1,[w15]
   sub %0,%1,[w15]
   subr %1,%0,[w15]
   sub %0,#%1,[w15]
   add %0,#%J1,[w15]"
  [
   (set_attr "cc" "set")
   (set_attr "type" "etc,use,use,etc,etc")
  ]
)

(define_expand "cmpp16apsv"
  [(set (cc0)
        (compare (match_operand:P16APSV 0 "pic30_mode1PN_operand"
                                "r,r,  R<>,r,P,r,N")
                 (match_operand:P16APSV 1 "pic30_mode1PN_APSV_operand"
                                "r,R<>,r,  P,r,N,r")))]
  ""
  "
{
  if (pic30_mode1PN_operand(operands[1],GET_MODE(operands[1])))
    emit_insn(gen_cmpp16apsv_DATA(operands[0],operands[1]));
  else
    emit_insn(gen_cmpp16apsv_APSV(operands[0],operands[1]));
  DONE;
}")

;;;;;;;;;;;;;;;;;;
;; single integer
;;;;;;;;;;;;;;;;;;
(define_insn "cmpsi_DATA"
  [(set (cc0)
        (compare (match_operand:SI 0 "pic30_mode2mres_operand" "r,r,R,r,>")
                 (match_operand:SI 1 "pic30_mode2mres_operand" "r,R,r,>,r")))]
  ""
  "*
{
  static char *patterns[] = {
     \"sub %0,%1,[w15]\;subb %d0,%d1,[w15]\",
     \"sub %0,%I1,[w15]\;subb %d0,%D1,[w15]\",
     \"subr %1,%I0,[w15]\;subbr %d1,%D0,[w15]\",
     \"sub %0,%1,[w15]\;subb %d0,%1,[w15]\",
     \"subr %1,%0,[w15]\;subbr %d1,%0,[w15]\"
  };

  static char *pre_patterns[] = {
    \"add %r1,#4,%r1\;sub %0,%I1,[w15]\;subb %d0,%D1,[w15]\",
    \"add %r0,#4,%r0\;subr %1,%I0,[w15]\;subbr %d1,%D0,[w15]\"
  };

  static char *psv_psv_patterns[] = {
     \"sub %0,%1,[w15]\;subb %d0,%d1,[w15]\",
     \"sub %0,%I1,[w15]\;nop\;subb %d0,%D1,[w15]\",
     \"subr %1,%I0,[w15]\;nop\;subbr %d1,%D0,[w15]\",
     \"sub %0,%1,[w15]\;nop\;subb %d0,%1,[w15]\",
     \"subr %1,%0,[w15]\;nop\;subbr %d1,%0,[w15]\"
  };

  static char *psv_psv_pre_patterns[] = {
    \"add %r1,#4,%r1\;sub %0,%I1,[w15]\;nop\;subb %d0,%D1,[w15]\",
    \"add %r0,#4,%r0\;subr %1,%I0,[w15]\;nop\;subbr %d1,%D0,[w15]\"
  };

  if (pic30_psrd_psrd_errata(operands[0],operands[1])) {
    pic30_rtx_nops++;
    if (pic30_pre_modify(operands[0]) || pic30_pre_modify(operands[1])) {
      return psv_psv_pre_patterns[which_alternative - 3];
    } else return psv_psv_patterns[which_alternative];
  } else {
    if (pic30_pre_modify(operands[0]) || pic30_pre_modify(operands[1])) {
      return pre_patterns[which_alternative - 3];
    } else return patterns[which_alternative];
  }
}"
  [
    (set_attr "cc" "set")
    (set_attr "type" "etc,use,use,use,use")
  ])


(define_insn "cmpsi_errata_APSV"
  [(set 
     (cc0)
     (compare 
       (match_operand:SI 0 "pic30_mode2mres_operand"      "r,r,R,r,>")
       (match_operand:SI 1 "pic30_mode2mres_APSV_operand" "r,R,r,>,r")))
   (clobber (match_scratch:HI 2                          "=X,&r,&r,&r,&r"))
  ]
  "(pic30_errata_mask & psv_errata)"
  "*
{
  static char *patterns[] = {
     \"sub %0,%1,[w15]\;subb %d0,%d1,[w15]\",
     \"sub %0,%I1,[w15]\;mov %D1,%2\;subb %d0,%2,[w15]\",
     \"subr %1,%I0,[w15]\;mov %D0,%2\;subbr %d1,%2,[w15]\",
     \"sub %0,%1,[w15]\;mov %1,%2\;subb %d0,%2,[w15]\",
     \"subr %1,%0,[w15]\;mov %d1,%2\;subb %0,%2,[w15]\"
  };
 
  static char *pre_patterns[] = {
     \"add %r1,#4,%r1\;sub %0,%I1,[w15]\;mov %D1,%2\;subb %d0,%2,[w15]\",
     \"add %r0,#4,%r0\;subr %1,%I0,[w15]\;mov %d1,%2\;subbr %2,%D0,[w15]\"
  };

  static char *psv_psv_patterns[] = {
     \"sub %0,%1,[w15]\;subb %d0,%d1,[w15]\",
     \"sub %0,%I1,[w15]\;nop\;mov %D1,%2\;subb %d0,%2,[w15]\",
     \"subr %1,%I0,[w15]\;nop\;mov %D0,%2\;subbr %d1,%2,[w15]\",
     \"sub %0,%1,[w15]\;nop\;mov %1,%2\;subb %d0,%2,[w15]\",
     \"subr %1,%0,[w15]\;nop\;mov %d1,%2\;subb %0,%2,[w15]\"
  };
 
  static char *psv_psv_pre_patterns[] = {
     \"add %r1,#4,%r1\;sub %0,%I1,[w15]\;nop\;mov %D1,%2\;subb %d0,%2,[w15]\",
     \"add %r0,#4,%r0\;subr %1,%I0,[w15]\;nop\;mov %d1,%2\;subbr %2,%D0,[w15]\"
  };

  if (pic30_psrd_psrd_errata(operands[0],operands[1])) {
    pic30_rtx_nops++;
    if (pic30_pre_modify(operands[0]) || pic30_pre_modify(operands[1])) {
      return psv_psv_pre_patterns[which_alternative - 3];
    } else return psv_psv_patterns[which_alternative];
  } else {
    if (pic30_pre_modify(operands[0]) || pic30_pre_modify(operands[1])) {
      return pre_patterns[which_alternative - 3];
    } else return patterns[which_alternative];
  }
}"
  [
    (set_attr "cc" "set")
    (set_attr "type" "etc,use,use,use,use")
  ])

(define_insn "cmpsi_noerrata_APSV"
  [(set 
     (cc0)
       (compare 
          (match_operand:SI 0 "pic30_mode2mres_operand"      "r,r,R,r,>")
          (match_operand:SI 1 "pic30_mode2mres_APSV_operand" "r,R,r,>,r")))]
  "(!(pic30_errata_mask & psv_errata))"
  "*
{
  static char *patterns[] = {
     \"sub %0,%1,[w15]\;subb %d0,%d1,[w15]\",
     \"sub %0,%I1,[w15]\;subb %d0,%D1,[w15]\",
     \"subr %1,%I0,[w15]\;subbr %d1,%D0,[w15]\",
     \"sub %0,%1,[w15]\;subb %d0,%1,[w15]\",
     \"subr %0,%1,[w15]\;subbr %d1,%0,[w15]\"
  };
  
  static char *pre_patterns[] = {
     \"add %r1,#4,%r1\;sub %0,%I1,[w15]\;subb %d0,%D1,[w15]\",
     \"add %r0,#4,%r0\;subr %1,%I0,[w15]\;subbr %d1,%D0,[w15]\"
  };

  static char *psv_psv_patterns[] = {
     \"sub %0,%1,[w15]\;subb %d0,%d1,[w15]\",
     \"sub %0,%I1,[w15]\;nop\;subb %d0,%D1,[w15]\",
     \"subr %1,%I0,[w15]\;nop\;subbr %d1,%D0,[w15]\",
     \"sub %0,%1,[w15]\;nop\;subb %d0,%1,[w15]\",
     \"subr %0,%1,[w15]\;nop\;subbr %d1,%0,[w15]\"
  };
  
  static char *psv_psv_pre_patterns[] = {
     \"add %r1,#4,%r1\;sub %0,%I1,[w15]\;nop\;subb %d0,%D1,[w15]\",
     \"add %r0,#4,%r0\;subr %1,%I0,[w15]\;nop\;subbr %d1,%D0,[w15]\"
  };

  if (pic30_psrd_psrd_errata(operands[0],operands[1])) {
    pic30_rtx_nops++;
    if (pic30_pre_modify(operands[0]) || pic30_pre_modify(operands[1])) {
      return pre_patterns[which_alternative - 3];
    } else return psv_psv_patterns[which_alternative];
  } else {
    if (pic30_pre_modify(operands[0]) || pic30_pre_modify(operands[1])) {
      return pre_patterns[which_alternative - 3];
    } else return patterns[which_alternative];
  }
}"
  [
    (set_attr "cc" "set")
    (set_attr "type" "etc,use,use,use,use")
  ])

(define_insn "cmpsi_zero"
  [(set (cc0)
        (compare (match_operand:SI 0 "pic30_register_operand" "r")
                 (match_operand:SI 1 "pic30_O_operand"        "O")))]
  ""
  "sub %0,#0,[w15]\;subb %d0,#0,[w15]"
   
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "etc")
  ])

(define_insn "cmpsi_immNP"
  [(set (cc0)
        (compare (match_operand:SI 0 "pic30_register_operand"  "r,r,r")
                 (match_operand:SI 1 "immediate_operand"       "P,N,i")))]
  "(((-31 <= INTVAL(operands[1])) && (INTVAL(operands[1]) <= 31)) ||
    ((0xFFE1 <= INTVAL(operands[1])) && (INTVAL(operands[1]) <= 0xFFFF))) &&
   (INTVAL(operands[1]) != 0)"
  "@
   sub %0,#%1,[w15]\;subb %d0,#0,[w15]
   add %0,#%J1,[w15]\;addc %d0,#0,[w15]
   add %0,#%j1,[w15]\;subb %d0,#0,[w15]"
  [
    (set_attr "cc" "set")
    (set_attr "type" "etc")
  ])

(define_insn "cmpsi_imm"
  [(set (cc0)
        (compare (match_operand:SI 0 "pic30_register_operand"  "r")
                 (match_operand:SI 1 "immediate_operand"       "i")))
	         (clobber (match_scratch:HI 2                "=&r"))]
  "((1<INTVAL(operands[1])) && (INTVAL(operands[1])<65536))"
  "mov #%1,%2\;sub %0,%2,[w15]\;subb %d0,#0,[w15]"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "*cmpsihi3"
  [(set (cc0)
        (compare (match_operand:SI   0 "pic30_register_operand" "r")
                 (zero_extend:SI 
                   (match_operand:HI 1 "pic30_register_operand" "r"))))]
  ""
  "sub %0,%1,[w15]\;subb %d0,#0,[w15]"
  [
    (set_attr "cc" "set")
    (set_attr "type" "etc")
  ])

(define_expand "cmpsi"
  [(set (cc0)
        (compare (match_operand:SI 0 "pic30_mode2mres_operand" "")
                 (match_operand:SI 1 "pic30_mode2mres_APSV_operand" "")))]
  ""
  "
{
  if (pic30_mode2mres_APSV_operand(operands[1],GET_MODE(operands[1]))) {
    if (pic30_errata_mask & psv_errata) {
      emit(
        gen_cmpsi_errata_APSV(operands[0],operands[1])
      );
    } else {
      emit(
        gen_cmpsi_noerrata_APSV(operands[0],operands[1])
      );
    }
  } else if (pic30_mode2mres_operand(operands[1], GET_MODE(operands[1]))) {
    emit(
      gen_cmpsi_DATA(operands[0],operands[1])
    );
  } else if (immediate_operand(operands[1],VOIDmode)) {
    rtx reg_0 = force_reg(GET_MODE(operands[0]),operands[0]);
    if (INTVAL(operands[1]) == 0) {
      emit(
        gen_cmpsi_zero(reg_0, operands[1])
      );
    } else {
      rtx reg = force_reg(GET_MODE(operands[0]),operands[1]);
      emit( 
        gen_cmpsi_DATA(reg_0, reg)
      );
    }
  }
  DONE;
}")


;;;;;;;;;;;;;;;;;;
;; double integer
;;;;;;;;;;;;;;;;;;

(define_insn "cmpdi_gen"
  [(set (cc0)
        (compare (match_operand:DI 0 "pic30_register_operand"    "r,r")
                 (match_operand:DI 1 "pic30_reg_or_zero_operand" "r,O")))]
  ""
  "@
   cp %0,%1\;cpb %d0,%d1\;cpb %t0,%t1\;cpb %q0,%q1
   sub %0,#0,[w15]\;subb %d0,#0,[w15]\;subb %t0,#0,[w15]\;subb %q0,#0,[w15]"
  [
    (set_attr "cc" "set")
    (set_attr "type" "etc")
  ])

(define_expand "cmpdi"
  [(set (cc0)
        (compare (match_operand:DI 0 "general_operand" "")
                 (match_operand:DI 1 "general_operand" "")))]
  ""
  "
{ rtx op0 = operands[0];
  rtx op1 = operands[1];

  if (!pic30_register_operand(operands[0], DImode))
    op0 = force_reg(DImode, operands[0]);
  if (!pic30_reg_or_zero_operand(operands[1], DImode))
    op1 = force_reg(DImode, operands[1]);
  emit(
    gen_cmpdi_gen(op0, op1)
  );
  DONE;
}"
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; truncation instructions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_insn "truncsip24psv2"
   [(set (match_operand:P24PSV 0 "pic30_reg_or_R_operand" "=r,r,R,R")
         (truncate:P24PSV 
           (match_operand:SI 1 "pic30_reg_or_R_operand"   " r,R,r,R")))]
   ""
   "*
 {
    const char *patterns[] = { 
      \"mov.d %1,%0\",
      \"mov.d %1,%0\",
      \"mov.d %1,%0\",
      \"mov.d %1,%0\"
    };
 
    const char *psrd_psrd_movd_patterns[] = {
      \"mov.d %1,%0\",
      \"mov %1,%0\;mov %Q1,%d0\",
      \"mov.d %1,%0\",
      \"mov %I1,%I0\;mov %D1,%D0\"
    };
 
    if ((pic30_errata_mask & psrd_psrd_errata_movd) == 0) {
      return patterns[which_alternative];
    } else {
      /* check for early clobber */
      int src_regno,dst_regno,mode_n_regs;
      int overlap;
 
      dst_regno = REGNO(operands[0]);
      mode_n_regs = pic30_class_max_nregs(W_REGS,GET_MODE(operands[0]));
 
      switch (which_alternative) {
        default: /* no overlap possible */
                 break;
        case 2: {
          src_regno = REGNO(XEXP(operands[1],0));
          overlap = src_regno-dst_regno;
          switch (overlap) {
            default: /* no overlap */
              break;
            case 0:  /* src == dst */
              return \"mov %Q1,%d0\;mov %1,%0\";
            case 1:  /* src == dst+1 */
              break;
          }
          break;
        }
      }
      return psrd_psrd_movd_patterns[which_alternative];
    }
 }"
   [
     (set_attr "type" "def,defuse,etc,use")
   ]
)

(define_insn "truncsip24prog2"
  [(set (match_operand:P24PROG 0 "pic30_reg_or_R_operand" "=r,r,R,R")
        (truncate:P24PROG
          (match_operand:SI 1 "pic30_reg_or_R_operand"   " r,R,r,R")))]
  ""
  "*
{
   const char *patterns[] = {
     \"mov.d %1,%0\",
     \"mov.d %1,%0\",
     \"mov.d %1,%0\",
     \"mov.d %1,%0\"
   };

   const char *psrd_psrd_movd_patterns[] = {
     \"mov.d %1,%0\",
     \"mov %1,%0\;mov %Q1,%d0\",
     \"mov.d %1,%0\",
     \"mov %I1,%I0\;mov %D1,%D0\"
   };

   if ((pic30_errata_mask & psrd_psrd_errata_movd) == 0) {
     return patterns[which_alternative];
   } else {
     /* check for early clobber */
     int src_regno,dst_regno,mode_n_regs;
     int overlap;

     dst_regno = REGNO(operands[0]);
     mode_n_regs = pic30_class_max_nregs(W_REGS,GET_MODE(operands[0]));

     switch (which_alternative) {
       default: /* no overlap possible */
                break;
       case 2: {
         src_regno = REGNO(XEXP(operands[1],0));
         overlap = src_regno-dst_regno;
         switch (overlap) {
           default: /* no overlap */
             break;
           case 0:  /* src == dst */
             return \"mov %Q1,%d0\;mov %1,%0\";
           case 1:  /* src == dst+1 */
             break;
         }
         break;
       }
     }
     return psrd_psrd_movd_patterns[which_alternative];
   }
}"
  [
    (set_attr "type" "def,defuse,etc,use")
  ]
)

(define_insn "truncsip32eds2"
  [(set (match_operand:P32EDS 0 "pic30_register_operand"   "=r,r")
        (truncate:P32EDS
          (match_operand:SI 1 "pic30_register_operand"     " r,0")))]
  ""
  "@
   rlc %1,[w15]\;rlc %d1,%d0\;mov %1,%0\;bclr %0,#15
   rlc %1,[w15]\;rlc %d1,%d0\;bclr %0,#15"
  [
    (set_attr "type" "def")
  ]
)

(define_insn "truncsip32peds2"
  [(set (match_operand:P32PEDS 0 "pic30_register_operand"   "=r")
        (truncate:P32PEDS
          (match_operand:SI 1 "pic30_register_operand"       "r")))]
  ""
  "rlc %1,[w15]\;rlc %d1,%d0\;mov %1,%0\;bclr %0,#15"
  [
    (set_attr "type" "def")
  ]
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; zero extension instructions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_insn "zero_extendqihi2_DATA"
  [(set (match_operand:HI    0 "pic30_register_operand" "=r,r")
        (zero_extend:HI 
           (match_operand:QI 1 "pic30_mode2_operand"     "r,R<>")))
  ]
  ""
  "ze %1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,defuse")
  ]
)

(define_insn "zero_extendqihi2_APSV"
  [(set (match_operand:HI   0 "pic30_register_operand"  "=r,r")
        (zero_extend:HI 
          (match_operand:QI 1 "pic30_mode2_APSV_operand" "r,R<>")))]
  ""
  "ze %1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "defuse")
  ]
)

(define_expand "zero_extendqihi2"
  [(set (match_operand:HI 0 "pic30_register_operand"       "=r,r")
        (zero_extend:HI 
           (match_operand:QI 1 "pic30_mode2_APSV_operand"  " r,R<>")) )]
  ""
  "
{
  if (pic30_mode2_operand(operands[1],GET_MODE(operands[1])))
    emit(gen_zero_extendqihi2_DATA(operands[0],operands[1]));
  else {
    rtx from = operands[1];
    emit(gen_zero_extendqihi2_APSV(operands[0],from));
  }
  DONE;
}")

(define_insn "zero_extendqisi2"
  [(set (match_operand:SI   0 "pic30_register_operand" "=r,r")
        (zero_extend:SI 
          (match_operand:QI 1 "pic30_mode2_operand"    " r,R<>")))
  ]
  ""
  "ze %1,%0\;clr %d0"
  [
    (set_attr "cc" "math")
    (set_attr "type" "def,defuse")
  ]
)

(define_insn "zero_extendqidi2"
  [(set (match_operand:DI   0 "pic30_register_operand" "=r,r")
        (zero_extend:DI 
          (match_operand:QI 1 "pic30_register_operand" " r,<>R")))
  ]
  ""
  "ze %1,%0\;clr %d0\;mul.uu %t0,#0,%t0"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def,defuse")
  ]
)

(define_insn "zero_extendhiP24PSV2"
  [(set (match_operand:P24PSV 0 "pic30_register_operand" "=r")
        (zero_extend:P24PSV 
           (match_operand:HI  1 "pic30_register_operand" " r")))
  ]
  ""
  "*
   {
     int idDst;

     if (REGNO(operands[0]) == REGNO(operands[1]))
     {
       return \"mov #0,%d0\";
     }
     else
     {
       idDst = REGNO(operands[0]);
       if (idDst & 1)
         return \"mov %1,%0\;mov #0,%d0\";
       else
         return \"mul.uu %1,#1,%0\";
     }
   }"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def")
  ]
)

(define_insn "zero_extendhip32eds2"
  [(set (match_operand:P32EDS 0 "pic30_register_operand"      "=r,r")
        (zero_extend:P32EDS 
          (match_operand:HI 1 "pic30_reg_or_symbolic_address" " r,q")))
  ]
  ""
  "@
   lsr %1,#15,%d0\;mov %1,%0\;bclr %0,#15
   mov #edsoffset(%1), %0\;mov #edspage(%1), %d0"
  [
    (set_attr "type" "def")
  ]
)

(define_insn "zero_extendhip32peds2"
  [(set (match_operand:P32PEDS 0 "pic30_register_operand"     "=r,r")
        (zero_extend:P32PEDS
          (match_operand:HI 1 "pic30_reg_or_symbolic_address" " r,q")))
  ]
  ""
  "@
   lsr %1,#15,%d0\;mov %1,%0\;bclr %0,#15
   mov #edsoffset(%1), %0\;mov #edspage(%1), %d0"
  [
    (set_attr "type" "def")
  ]
)

(define_insn "zero_extendsip32eds2"
  [(set (match_operand:P32EDS 0 "pic30_register_operand"   "=r,r")
        (zero_extend:P32EDS
          (match_operand:SI 1 "pic30_register_operand"      "r,0")))
  ]
  ""
  "@
   rlc %1,[w15]\;rlc %d1,%d0\;mov %1,%0\;bclr %0,#15
   rlc %1,[w15]\;rlc %d1,%d0\;bclr %0,#15"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def")
  ]
)

(define_insn "zero_extendsip32peds2"
  [(set (match_operand:P32PEDS 0 "pic30_register_operand" "=r")
        (zero_extend:P32PEDS
          (match_operand:SI 1 "pic30_register_operand"     "r")))
  ]
  ""
  "rlc %1,[w15]\;rlc %d1,%d0\;mov %1,%0\;bclr %0,#15"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def")
  ]
)

(define_insn "extendsip32eds2"
  [(set (match_operand:P32EDS 0 "pic30_register_operand" "=r,r")
        (sign_extend:P32EDS
          (match_operand:SI 1 "pic30_register_operand"    "r,0")))
  ]
  ""
  "@
   rlc %1,[w15]\;rlc %d1,%d0\;mov %1,%0\;bclr %0,#15
   rlc %1,[w15]\;rlc %d1,%d0\;bclr %0,#15"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def")
  ]
)

(define_insn "extendsip32peds2"
  [(set (match_operand:P32PEDS 0 "pic30_register_operand" "=r")
        (sign_extend:P32PEDS
          (match_operand:SI 1 "pic30_register_operand"     "r")))
  ]
  ""
  "rlc %1,[w15]\;rlc %d1,%d0\;mov %1,%0\;bclr %0,#15"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def")
  ]
)

(define_insn "zero_extendhisi2"
  [(set (match_operand:SI   0 "pic30_register_operand" "=r")
        (zero_extend:SI 
          (match_operand:HI 1 "pic30_register_operand" " r")))
  ]
  ""
  "*
   {
     int idDst;

     if (REGNO(operands[0]) == REGNO(operands[1]))
     {
       return \"clr %d0\";
     }
     else
     {
       idDst = REGNO(operands[0]);
       if (idDst & 1)
         return \"mov %1,%0\;mov #0,%d0\";
       else
         return \"mul.uu %1,#1,%0\";
     }
   }"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def")
  ]
)

(define_insn "extendp32edssi2"
  [(set (match_operand:SI 0 "pic30_register_operand" "=r")
        (subreg:SI
          (match_operand:P32EDS 1 "pic30_register_operand" "r") 0))
  ]
  ""
  "sl %1,%0\;asr %d1,%d0\;rrc %0,%0"
  [
   (set_attr "cc" "clobber")
    (set_attr "type" "def")
  ]
)


;;
;; nop extentsions because thse modes are the same size
;;
;; hi

(define_insn "zero_extendp16apsvhi2"
  [(set (match_operand:HI       0 "register_operand" "=r")
        (zero_extend:HI 
          (match_operand:P16APSV 1 "register_operand" "0")))]
  ""
  "; nop %1,%0"
)

(define_insn "zero_extendhip16apsv2"
  [(set (match_operand:P16APSV 0 "register_operand" "=r")
        (zero_extend:P16APSV 
          (match_operand:HI    1 "register_operand" " 0")))]
  ""
  "; nop %1,%0"
)

;; si

(define_insn "zero_extendp24psvsi2"
  [(set (match_operand:SI       0 "register_operand" "=r")
        (zero_extend:SI 
          (match_operand:P24PSV 1 "register_operand" " 0")))]
  ""
  "; nop %1,%0"
)

(define_insn "zero_extendp24progsi2"
  [(set (match_operand:SI        0 "register_operand" "=r")
        (zero_extend:SI 
          (match_operand:P24PROG 1 "register_operand" " 0")))]
  ""
  "; nop %1,%0"
)

(define_insn "zero_extendp32extsi2"
  [(set (match_operand:SI       0 "register_operand" "=r")
        (zero_extend:SI 
          (match_operand:P32EXT 1 "register_operand" " 0")))]
  ""
  "; nop %1,%0"
)

(define_insn "extendp32extsi2"
  [(set (match_operand:SI       0 "register_operand" "=r")
        (sign_extend:SI 
          (match_operand:P32EXT 1 "register_operand" " 0")))]
  ""
  "; nop %1,%0"
)

(define_insn "zero_extendsip24psv2"
  [(set (match_operand:P24PSV   0 "register_operand" "=r")
        (zero_extend:P24PSV 
          (match_operand:SI     1 "register_operand" " 0")))]
  ""
  "; nop %1,%0"
)

(define_insn "zero_extendsip24prog2"
  [(set (match_operand:P24PROG   0 "register_operand" "=r")
        (zero_extend:P24PROG 
          (match_operand:SI      1 "register_operand" " 0")))]
  ""
  "; nop %1,%0"
)

(define_insn "zero_extendsip32ext2"
  [(set (match_operand:P32EXT   0 "register_operand" "=r")
        (zero_extend:P32EXT 
          (match_operand:SI     1 "register_operand" " 0")))]
  ""
  "; nop %1,%0"
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; sign extension instructions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_insn "extendqihi2_DATA"
  [(set (match_operand:HI   0 "pic30_register_operand" "=r,r")
        (sign_extend:HI 
          (match_operand:QI 1 "pic30_mode2_operand"    " r,R<>"))
   )
  ]
  ""
  "se %1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,defuse")
  ]
)

(define_insn "extendqihi2_APSV"
  [(set (match_operand:HI   0 "pic30_register_operand"  "=r,r")
        (sign_extend:HI 
          (match_operand:QI 1 "pic30_mode2_APSV_operand" "r,R<>"))
   )
  ]
  ""
  "se %1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,defuse")
  ]
)

(define_expand "extendqihi2"
 [(set (match_operand:HI 0 "pic30_register_operand"                   "=r,r")
        (sign_extend:HI (match_operand:QI 1 "pic30_mode2_APSV_operand" "r,R<>"))
   )
  ]
  ""
  "
{
  if (pic30_mode2_operand(operands[1], GET_MODE(operands[1]))) 
    emit(gen_extendqihi2_DATA(operands[0], operands[1]));
  else
    emit(gen_extendqihi2_APSV(operands[0], operands[1]));
  DONE;
}")

(define_insn "extendqisi2"
  [(set (match_operand:SI   0 "pic30_register_operand" "=r,r")
        (sign_extend:SI 
          (match_operand:QI 1 "pic30_mode2_operand"     "r,R<>")))
  ]
  ""
  "se %1,%0\;asr %0,#15,%d0"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def,defuse")
  ]
)

(define_insn "extendqidi2"
  [(set (match_operand:DI   0 "pic30_register_operand" "=r,r")
        (sign_extend:DI 
          (match_operand:QI 1 "pic30_mode2_operand"    " r,R<>")))
  ]
  ""
  "se %1,%0\;asr %0,#15,%d0\;mul.su %d0,#1,%t0"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def,defuse")
  ]
)

(define_insn "extendhisi2"
  [(set (match_operand:SI 0 "pic30_register_operand"   "=r")
        (sign_extend:SI 
           (match_operand:HI 1 "pic30_register_operand" "r")) 
   )
  ]
  ""
  "*
{
  int idSrc, idDst;

  idDst = REGNO(operands[0]);
  idSrc = REGNO(operands[1]);
  if (idDst == idSrc) {
    return \"asr %0,#15,%d0\";
  } else {
    if (idDst & 1)
      return \"mov %1,%0\;asr %0,#15,%d0\";
    else return \"mul.su %1,#1,%0\";
  }
}"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "extendhip32ext2"
  [(set (match_operand:P32EXT 0 "pic30_register_operand" "=r")
        (sign_extend:P32EXT 
          (match_operand:HI   1 "pic30_register_operand" " r")))
  ]
  ""
  "*
   {
     int idSrc, idDst;

     idDst = REGNO(operands[0]);
     idSrc = REGNO(operands[1]);
     if (idDst == idSrc) {
       return \"lsr %0,#15,%d0\";
     } else {
       if (idDst & 1)
         return \"mov %1,%0\;lsr %0,#15,%d0\";
       else return \"mul.uu %1,#1,%0\";
     }
   }"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def")
  ]
)

(define_insn "zero_extendhip32ext2"
  [(set (match_operand:P32EXT 0 "pic30_register_operand" "=r")
        (zero_extend:P32EXT 
          (match_operand:HI   1 "pic30_register_operand" " r")))
  ]
  ""
  "*
   {
     int idSrc, idDst;

     idDst = REGNO(operands[0]);
     idSrc = REGNO(operands[1]);
     if (idDst == idSrc) {
       return \"lsr %0,#15,%d0\";
     } else {
       if (idDst & 1)
         return \"mov %1,%0\;lsr %0,#15,%d0\";
       else return \"mul.uu %1,#1,%0\";
     }
   }"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def")
  ]
)

(define_insn "extendhip32eds_stack"
  [(set (match_operand: P32EDS 0 "pic30_register_operand"    "=r")
        (unspec:P32EDS [
          (match_operand:HI 1    "pic30_register_operand"    " r")
        ] UNSPEC_EDSSTACKADDR))]
  ""
  "mul.uu %1,#1,%0\;rlc %1,[w15]\;rlc %d0,%d0"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def")
  ]
)

(define_insn "extendhip32peds_stack"
  [(set (match_operand: P32PEDS 0 "pic30_register_operand"    "=r")
        (unspec:P32PEDS [
          (match_operand:HI 1    "pic30_register_operand"    " r")
        ] UNSPEC_EDSSTACKADDR))]
  ""
  "mul.uu %1,#1,%0\;rlc %1,[w15]\;rlc %d0,%d0"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def")
  ]
)

(define_insn "extendhip32eds2"
  [(set (match_operand: P32EDS 0 "pic30_register_operand"    "=r")
        (sign_extend:P32EDS
          (match_operand:HI 1    "pic30_register_operand"    " r")))]
  ""
  "mul.uu %1,#1,%0\;btsc %0,#15\;mov #__const_psvpage,%d0"
  [
    (set_attr "type" "def")
  ]
)

(define_insn "extendhip32eds2_const"
  [(set (match_operand: P32EDS 0 "pic30_register_operand"         "=r,r,r")
        (unspec: P32EDS [
          (match_operand:HI 1    "pic30_reg_or_symbolic_address"  " 0,r,q")
        ] UNSPEC_EDSCONSTADDR))]
  ""
  "@
   mov #__const_psvpage,%d0
   mov %1,%0\;mov #__const_psvpage,%d0
   mov #edsoffset(%1),%0\;mov #__const_psvpage,%d0"
  [
    (set_attr "type" "def")
  ]
)

(define_insn "extendhip32peds2"
  [(set (match_operand: P32PEDS 0 "pic30_register_operand"    "=r")
        (sign_extend:P32PEDS
          (match_operand:HI 1    "pic30_register_operand"     " r")))]
  ""
  "mul.su %1,#1,%0"
  [
    (set_attr "type" "def")
  ]
)

(define_insn "extendhip32peds2_const"
  [(set (match_operand: P32PEDS 0 "pic30_register_operand"    "=r,r")
        (unspec: P32PEDS [
          (match_operand:HI 1    "pic30_register_operand"    " 0,r")
        ] UNSPEC_EDSCONSTADDR))]
   ""
   "@
    mov #__const_psvpage,%d0
    mov %1,%0\;mov #__const_psvpage,%d0"
   [
     (set_attr "type" "def")
   ]
)

(define_insn "extendhidi2"
  [(set (match_operand:DI 0 "pic30_register_operand"                "=r,r")
        (sign_extend:DI (match_operand:HI 1 "pic30_register_operand" "0,r")) )]
  ""
  "@
   asr %0,#15,%d0\;mul.su %d0,#1,%t0
   mul.su %1,#1,%0\;mul.su %d0,#1,%t0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "extendsidi2"
  [(set (match_operand:DI 0 "pic30_register_operand"    "=r,r")
        (sign_extend:DI 
            (match_operand:SI 1 "pic30_register_operand" "0,r")) 
   )
  ]
  ""
  "@
   asr %d0,#15,%t0\;mov %t0,%q0
   mov.d %1,%0\;asr %d0,#15,%t0\;mov %t0,%q0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "zero_extendhidi2"
  [(set (match_operand:DI 0 "pic30_register_operand"                "=r,r")
        (zero_extend:DI 
           (match_operand:HI 1 "pic30_register_operand"              "0,r"))
   )
  ]
  ""
  "@
   clr %d0\;mul.uu %t0,#0,%t0
   mul.uu %1,#1,%0\;mul.uu %t0,#0,%t0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "zero_extendsidi2"
  [(set (match_operand:DI 0 "pic30_register_operand"  "=r,r,&r,r,r")
        (zero_extend:DI 
            (match_operand:SI 1 "pic30_mode2_operand"  "0,r, R,<,>")) 
   )
  ]
  ""
  "*
  {
   static char *patterns[] = {
     \"mul.uu %t0,#0,%t0\",
     \"mov.d %1,%0\;mul.uu %t0,#0,%t0\",
     \"mov.d %1,%0\;mul.uu %t0,#0,%t0\",
     \"mov.d %1,%0\;mul.uu %t0,#0,%t0\",
     \"mov.d %1,%0\;mul.uu %t0,#0,%t0\"
   };

   static char *psrd_psrd_movd_patterns[] = {
     \"mul.uu %t0,#0,%t0\",
     \"mov.d %1,%0\;mul.uu %t0,#0,%t0\",
     \"mov %1,%0\;mov %Q1,%d0\;mul.uu %t0,#0,%t0\",
     \"mov %1,%0\;mov %1,%d0\;mul.uu %t0,#0,%t0\",
     \"mov %1,%0\;mov %1,%d0\;mul.uu %t0,#0,%t0\"
   };

   if ((pic30_errata_mask & psrd_psrd_errata_movd) == 0) {
     return patterns[which_alternative];
   } else {
     /* check for early clobber */
     int src_regno,dst_regno,mode_n_regs;
     int overlap; 
 
     dst_regno = REGNO(operands[0]);
     mode_n_regs = pic30_class_max_nregs(W_REGS,GET_MODE(operands[0]));
 
     switch (which_alternative) {
       default: /* no overlap possible */
                break;
       case 2: {
         src_regno = REGNO(XEXP(operands[1],0));
         overlap = src_regno-dst_regno;
         switch (overlap) {
           default: /* no overlap */
             break;
           case 0:  /* src == dst */
             return \"mov %Q1,%d0\;mul.uu %t0,#0,%t0\;mov %1,%0\";
           case 1:  /* src == dst+1 */
             return\"mov %1,%0\;mul.uu %t0,#0,%t0\;mov %Q1,%d0\";
           case 2:  /* src == dst+2 */
             break;
           case 3:  /* src == dst+3 */
             break;
         }
         break;
       }
       case 3: {
         if (pic30_pre_modify(operands[1])) {
           /* pre-decrement */
           return \"sub %r1,#4,%r1\;mov [%r1],%0\;mov [%r1+2],%d0\;\"
                  \"mul.uu %t0,#0,%t0\";
         } else if (pic30_pre_modify(operands[1])) {
           /* pre-increment */
           return \"add %r1,#4,%r1\;mov [%r1],%0\;mov [%r1+2],%d0\;\"
                  \"mul.uu %t0,#0,%t0\";
         }
         break;
       }
     } 
     return psrd_psrd_movd_patterns[which_alternative];
   }
  }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def,def,defuse,defuse,defuse")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Move instructions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Invalid move

(define_insn "*movqi_invalid_1"
  [(set (match_operand:QI 0 "pic30_register_operand"  "=r")
        (match_operand:QI 1 "pic30_code_operand" "g"))]
  ""
  "*
   {
     error(\"invalid address space for operand\");
     return \"cannot generate instruction\";
   }
  "
)

(define_insn "*movqi_invalid_2"
  [(set (match_operand:QI 0 "pic30_code_operand" "=g")
        (match_operand:QI 1 "pic30_register_operand"    "r"))]
  ""
  "*
   {
     error(\"invalid address space for operand\");
     return \"cannot generate instruction\";
   }
  "
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 8-bit moves
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_insn "*movqi_const0"
  [(set (match_operand:QI 0 "pic30_mode2_operand" "=r,R<>")
	(const_int 0))]
  ""
  "@
   clr.b %0
   clr.b %0"
  [
    (set_attr "cc" "change0,change0")
    (set_attr "type" "def,etc")
  ]
)

(define_insn "*movqi_const1"
  [(set (match_operand:QI 0 "pic30_mode2_operand" "=r,R<>")
	(const_int -1))]
  ""
  "@
   setm.b %0
   setm.b %0"
  [
    (set_attr "cc" "change0,change0")
    (set_attr "type" "def,etc")
  ]
)

(define_insn "*movqi_const0sfr"
  [(set (match_operand:QI 0 "pic30_near_operand" "=U")
	(const_int 0))]
  ""
  "clr.b %0"
  [
    (set_attr "cc" "change0")
  ]
)

(define_insn "*movqi_const1sfr"
  [(set (match_operand:QI 0 "pic30_near_operand" "=U")
	(const_int -1))]
  ""
  "setm.b %0"
  [
    (set_attr "cc" "change0")
  ]
)

(define_insn "movqi_rimm"
  [(set (match_operand:QI 0 "pic30_register_operand" "=r")
        (match_operand:QI 1 "immediate_operand" "i"))]
  ""
  "mov.b #%1,%0"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "def")
  ]
)

; general case
(define_insn "movqi_gen_DATA"
  [(set (match_operand:QI 0 "pic30_move_operand"
                 "=r<>,RS,r<>, R,   r<>,RS,r<>, R,   Q,r,a,!U,d")
        (match_operand:QI 1 "pic30_move_operand"
                  "r,  r, <>RS,<>RS,r,  r, RS<>,RS<>,r,Q,U,a, U"))
  ]
  ""
  "*
{  rtx w0 = gen_rtx_REG(HImode, WR0_REGNO);

   switch (which_alternative) {
     default: gcc_assert(0);
     case 0:  return \"mov.b %1,%0\";
     case 1:  return \"mov.b %1,%0\";
     case 2:  return \"mov.b %1,%0\";
     case 3:  return \"mov.b %1,%0\";
     case 4:  return \"mov.b %1,%0\";
     case 5:  return \"mov.b %1,%0\";
     case 6:  return \"mov.b %1,%0\";
     case 7:  return \"mov.b %1,%0\";
     case 8:  return \"mov.b %1,%0\";
     case 9:  return \"mov.b %1,%0\";
     case 10: return \"mov.b %1,WREG\";
     case 11: return \"mov.b WREG,%0\";
     case 12: if (pic30_errata_mask & ecc_errata) {
                /* ATP we can do better */
                return \"mov #%1,%0\;nop\;mov.b [%0],%0\";
              } 
              return \"mov #%1,%0\;mov.b [%0],%0\";
  }
}
"
  [(set_attr "cc"
	"change0,change0,change0,change0,change0,change0,change0,change0,change0,change0,move,change0,change0")
   (set_attr "type"
	"defuse,etc,defuse,use,def,etc,defuse,use,use,use,def,etc,def")
  ]
)

(define_insn "movqi_gen_APSV"
  [(set (match_operand:QI 0 "pic30_mode3_APSV_operand"
                "=r<>,RS,r<>, R,  r<>,RS,r<>, R,   Q,r,a,U,?d")
        (match_operand:QI 1 "pic30_move_APSV_operand"
                 "r,  r,<>RS,<>RS,r,  r, RS<>,RS<>,r,Q,U,a, U"))
    (use (reg:HI PSVPAG))
  ]
  ""
  "*
{  rtx w0 = gen_rtx_REG(HImode, WR0_REGNO);

   switch (which_alternative) {
     default: gcc_assert(0);
     case 0:  return \"mov.b %1,%0\";
     case 1:  return \"mov.b %1,%0\";
     case 2:  return \"mov.b %1,%0\";
     case 3:  return \"mov.b %1,%0\";
     case 4:  return \"mov.b %1,%0\";
     case 5:  return \"mov.b %1,%0\";
     case 6:  return \"mov.b %1,%0\";
     case 7:  return \"mov.b %1,%0\";
     case 8:  return \"mov.b %1,%0\";
     case 9:  return \"mov.b %1,%0\";
     case 10: return \"mov.b %1,WREG\";
     case 11: return \"mov.b WREG,%0\";
     case 12: if (pic30_errata_mask & ecc_errata) {
                /* ATP we can do better */
                return \"mov #%1,%0\;nop\;mov.b [%0],%0\";
              } 
              return \"mov #%1,%0\;mov.b [%0],%0\";
  }
}
"
  [(set_attr "cc"
        "change0,change0,change0,change0,change0,change0,change0,change0,change0,change0,move,change0,change0")
   (set_attr "type"
	"defuse,etc,defuse,use,def,etc,defuse,use,use,use,def,etc,def")
  ]
)

(define_insn "movqi_gen_a_DATA"
  [(set (match_operand:QI 0 "pic30_move_operand"
		"=r<>,R,r<>, R,   r<>,RS,r<>,RS, Q,r,U")
        (match_operand:QI 1 "pic30_move2_operand"
		 "r,  r,<>RS,<>RS,r,  r, R<>,R<>,r,Q,a"))
  ]
  ""
  "*
{  rtx w0 = gen_rtx_REG(HImode, WR0_REGNO);
   switch (which_alternative) {
     default: gcc_assert(0);
     case 0:  return \"mov.b %1,%0\";
     case 1:  return \"mov.b %1,%0\";
     case 2:  return \"mov.b %1,%0\";
     case 3:  return \"mov.b %1,%0\";
     case 4:  return \"mov.b %1,%0\";
     case 5:  return \"mov.b %1,%0\";
     case 6:  return \"mov.b %1,%0\";
     case 7:  return \"mov.b %1,%0\";
     case 8:  return \"mov.b %1,%0\";
     case 9:  return \"mov.b %1,%0\";
     case 10: return \"mov.b WREG,%0\";
  }
}
"
  [(set_attr "cc"
	"change0,change0,change0,change0,change0,change0,change0,change0,change0,change0,change0")
   (set_attr "type"
	"def,etc,defuse,use,def,etc,defuse,use,etc,defuse,etc")
  ]
)

(define_insn "movqi_gen_a_APSV"
  [(set (match_operand:QI 0 "pic30_move_operand"
		"=r<>,R,r<>, R,   r<>,RS,r<>,RS, Q,r,U")
        (unspec:QI [
           (match_operand:QI 1 "pic30_move2_APSV_operand"
		 "r,  r,<>RS,<>RS,r,  r, R<>,R<>,r,Q,a")
           (reg:HI PSVPAG)] UNSPECV_USEPSV))
  ]
  ""
  "*
{  rtx w0 = gen_rtx_REG(HImode, WR0_REGNO);
   switch (which_alternative) {
     default: gcc_assert(0);
     case 0:  return \"mov.b %1,%0\";
     case 1:  return \"mov.b %1,%0\";
     case 2:  return \"mov.b %1,%0\";
     case 3:  return \"mov.b %1,%0\";
     case 4:  return \"mov.b %1,%0\";
     case 5:  return \"mov.b %1,%0\";
     case 6:  return \"mov.b %1,%0\";
     case 7:  return \"mov.b %1,%0\";
     case 8:  return \"mov.b %1,%0\";
     case 9:  return \"mov.b %1,%0\";
     case 10: return \"mov.b WREG,%0\";
  }
}
"
  [(set_attr "cc"
	"change0,change0,change0,change0,change0,change0,change0,change0,change0,change0,change0")
   (set_attr "type"
	"def,etc,defuse,use,def,etc,defuse,use,etc,defuse,etc")
  ]
)



(define_insn "movqi_gen_b"
  [(set (match_operand:QI 0 "pic30_move2_operand"
		"=r<>,R,r<>, R,   r<>,RS,r<>,RS, Q,r,a,r")
        (match_operand:QI 1 "pic30_move_operand"
		 "r,  r,<>RS,<>RS,r,  r, R<>,R<>,r,Q,U,U"))
  ]
  ""
  "*
{  
   switch (which_alternative) {
     default: gcc_assert(0);
     case 0:  return \"mov.b %1,%0\";
     case 1:  return \"mov.b %1,%0\";
     case 2:  return \"mov.b %1,%0\";
     case 3:  return \"mov.b %1,%0\";
     case 4:  return \"mov.b %1,%0\";
     case 5:  return \"mov.b %1,%0\";
     case 6:  return \"mov.b %1,%0\";
     case 7:  return \"mov.b %1,%0\";
     case 8:  return \"mov.b %1,%0\";
     case 9:  return \"mov.b %1,%0\";
     case 10: return \"mov.b %1,WREG\";
     case 11: if (REGNO(operands[0]) == WR0_REGNO) 
                return \"mov.b %1,WREG\";
              else if (pic30_errata_mask & ecc_errata) { 
                // ATP we can do better
                return \"mov #%1,%0\;nop\;mov.b [%0],%0\";
              }
              return \"mov #%1,%0\;mov.b [%0],%0\";
  }
}
"
  [(set_attr "cc"
	"change0,change0,change0,change0,change0,change0,change0,change0,change0,change0,move,change0")
   (set_attr "type"
	"def,etc,defuse,use,def,etc,defuse,use,etc,defuse,def,def")
  ]
)

;; If one of the operands is immediate and the other is not a register,
;; then we should emit two insns, using a scratch register.  This will produce
;; better code in loops if the source operand is invariant, since
;; the source reload can be optimised out.  During reload we cannot
;; use change_address or force_reg which will allocate new pseudo regs.

;; Unlike most other insns, the move insns can`t be split with
;; different predicates, because register spilling and other parts of
;; the compiler, have memoized the insn number already.

(define_expand "movqi"
  [(set (match_operand:QI 0 "pic30_general_operand" "")
        (match_operand:QI 1 "pic30_general_operand" ""))]
  ""
  "
{
  if (pic30_emit_move_sequence(operands, QImode)) DONE;
  if (pic30_move_operand(operands[1],GET_MODE(operands[1]))) {
     emit(gen_movqi_gen_DATA(operands[0],operands[1]));
     DONE;
  } else if (pic30_move_APSV_operand(operands[1],GET_MODE(operands[1]))) {
     emit(gen_movqi_gen_APSV(operands[0],operands[1]));
     DONE;
  }
}")

;; Invalid move

(define_insn "*movhi_invalid_1"
  [(set (match_operand:HI 0 "pic30_register_operand" "=r")
        (match_operand:HI 1 "pic30_code_operand"  "g"))]
  ""
  "*
   {
        error(\"invalid address space for operand\");
        return \"cannot generate instruction\";
   }
")

(define_insn "*movhi_invalid_2"
  [(set (match_operand:HI 0 "pic30_code_operand" "=g")
        (match_operand:HI 1 "pic30_register_operand"  "r"))]
  ""
  "*
   {
        error(\"invalid address space for operand\");
        return \"cannot generate instruction\";

   }
")

(define_insn "*movhi_invalid_3"
  [(set (match_operand:HI 0 "pic30_move_operand" "")
        (mem: HI (match_operand:HI 1 "pic30_invalid_address_operand"  "")))]
  ""
  "*
   {
        error(\"invalid address space for operand\");
        return \"cannot generate instruction\";
   }
")

(define_insn "*movhi_invalid_4"
  [(set (mem (match_operand:P24PROG 0 "pic30_prog_operand" ""))
        (match_operand 1 "general_operand" ""))]
  ""
  "*
   {
     error(\"invalid address space for destination\");
     return \"cannot generate instruction\";
   }
")

(define_insn "*movhi_invalid_5"
  [(set (mem (match_operand:P24PSV 0 "pic30_psv_operand" ""))
        (match_operand 1 "general_operand" ""))]
  ""
  "*
   {
     error(\"invalid address space for destination\");
     return \"cannot generate instruction\";

   }
")

(define_insn "*movhi_invalid_6"
  [(set (mem (match_operand:P32DF 0 "pic30_df_operand" ""))
        (match_operand 1 "general_operand" ""))]
  ""
  "*
   {
     error(\"invalid address space for destination\");
     return \"cannot generate instruction\";
   }
")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 16-bit moves
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;
;; immediate zero
;;;;;;;;;;;;;;;;;

(define_insn "*movhi_const0sfr"
  [(set (match_operand:HI 0 "pic30_near_operand" "=U")
	(const_int 0))]
  ""
  "clr %0"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "etc")
  ]
)

(define_insn "*movhi_const1sfr"
  [(set (match_operand:HI 0 "pic30_near_operand" "=U")
	(const_int -1))]
  ""
  "setm %0"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "etc")
  ]
)

(define_insn "movhi_const0"
  [(set (match_operand:HI 0 "pic30_mode2_operand" "=r,R<>")
	(const_int 0))]
  ""
  "@
   clr %0
   clr %0"
  [
   (set_attr "cc" "change0,change0")
   (set_attr "type" "def,etc")
  ]
)

(define_insn "movp16apsv_const0"
  [(set (match_operand:P16APSV 0 "pic30_mode2_operand" "=r,R<>")
	(const_int 0))]
  ""
  "@
   clr %0
   clr %0"
  [
   (set_attr "cc" "change0,change0")
   (set_attr "type" "def,etc")
  ]
)

(define_insn "*movhi_const1"
  [(set (match_operand:HI 0 "pic30_mode2_operand" "=r,R<>")
	(const_int -1))]
  ""
  "@
   setm %0
   setm %0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,etc")
  ]
)

(define_insn "*movp16apsv_const1"
  [(set (match_operand:P16APSV 0 "pic30_mode2_operand" "=r,R<>")
	(const_int -1))]
  ""
  "@
   setm %0
   setm %0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,etc")
  ]
)

;;;;;;;;;;;;;;;;;;;;
;; general immediate
;;;;;;;;;;;;;;;;;;;;

(define_insn "movqi_address"
  [(set (match_operand:QI 0 "pic30_register_operand"              "=r")
        (subreg:QI
          (match_operand:HI 1 "pic30_symbolic_address_operand"    " q") 0))
  ]
  ""
  "mov #%1,%0"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "def")
  ]
)

(define_insn "movhi_address"
  [(set (match_operand:HI 0 "pic30_register_operand"         "=r")
        (match_operand:HI 1 "pic30_reg_or_symbolic_address"  " rq"))
  ]
  ""
  "*
{ rtx sym;

  if (pic30_symbolic_address_operand(operands[1], GET_MODE(operands[1]))) {
    /* this can be converted to a register copy, so check for symref first */
    sym = pic30_program_space_operand_p(operands[1]);
    if (sym) {
      tree fndecl = GET_CODE(sym) == SYMBOL_REF ? SYMBOL_REF_DECL(sym) : 0;
      tree fndecl_attrib;
      char *access=0;
      int slot = 0;

      if (fndecl) {
        if ((fndecl_attrib =
              lookup_attribute(IDENTIFIER_POINTER(pic30_identBoot[0]),
                               DECL_ATTRIBUTES(fndecl)))) {
          access=\"boot\";
        } else if ((fndecl_attrib = lookup_attribute(
                                    IDENTIFIER_POINTER(pic30_identSecure[0]),
                                    DECL_ATTRIBUTES(fndecl)))) {
          access=\"secure\";
        }
      }
      if (access) {
        if (TREE_VALUE(fndecl_attrib)) {
          if (TREE_CODE(TREE_VALUE(TREE_VALUE(fndecl_attrib))) == INTEGER_CST) {
            slot = TREE_INT_CST_LOW(TREE_VALUE(TREE_VALUE(fndecl_attrib)));
          } else access = 0;
        } else access = 0;
      }
      if (access) {
        static char buffer[25];
        sprintf(buffer,\"mov #%s(%d),%%0\", access, slot);
        return buffer;
      } else {
        return \"mov #handle(%1),%0\";
      }
    } else {
      return \"mov #%1,%0\";
    }
  } else return \"mov %1,%0\";
}"
 [
  (set_attr "cc" "change0")
  (set_attr "type" "def")
 ]
)

(define_insn "movp16apsv_address"
  [(set (match_operand:P16APSV 0 "pic30_register_operand"         "=r")
        (match_operand:P16APSV 1 "pic30_symbolic_address_operand" " rq"))]
  ""
  "*
{ rtx sym;

  if (pic30_symbolic_address_operand(operands[1], GET_MODE(operands[1]))) {
    /* this can be converted to a register copy, so check for symref first */
    sym = pic30_program_space_operand_p(operands[1]);
    if (sym) {
      tree fndecl = GET_CODE(sym) == SYMBOL_REF ? SYMBOL_REF_DECL(sym) : 0;
      tree fndecl_attrib;
      char *access=0;
      int slot = 0;

      if (fndecl) {
        if ((fndecl_attrib =
              lookup_attribute(IDENTIFIER_POINTER(pic30_identBoot[0]),
                               DECL_ATTRIBUTES(fndecl)))) {
          access=\"boot\";
        } else if ((fndecl_attrib = lookup_attribute(
                                    IDENTIFIER_POINTER(pic30_identSecure[0]),
                                    DECL_ATTRIBUTES(fndecl)))) {
          access=\"secure\";
        }
      }
      if (access) {
        if (TREE_VALUE(fndecl_attrib)) {
          if (TREE_CODE(TREE_VALUE(TREE_VALUE(fndecl_attrib))) == INTEGER_CST) {
            slot = TREE_INT_CST_LOW(TREE_VALUE(TREE_VALUE(fndecl_attrib)));
          } else access = 0;
        } else access = 0;
      }
      if (access) {
        static char buffer[25];
        sprintf(buffer,\"mov #%s(%d),%%0\", access, slot);
        return buffer;
      } else {
        return \"mov #handle(%1),%0\";
      }
    } else {
      return \"mov #%1,%0\";
    }
  } else return \"mov %1,%0\";
}"
 [
   (set_attr "cc" "change0")
   (set_attr "type" "def")
 ]
)

(define_insn "movhi_imm"
  [(set (match_operand:HI 0 "pic30_register_operand" "=r")
        (match_operand:HI 1 "immediate_operand"      " i"))
  ]
  ""
  "mov #%1,%0"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "def")
  ]
)

(define_insn "movP16APSV_imm"
  [(set (match_operand:P16APSV 0 "pic30_register_operand" "=r")
        (match_operand:P16APSV 1 "immediate_operand"      " i"))
  ]
  ""
  "mov #%1,%0"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "def")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; builtin move directives
;;;;;;;;;;;;;;;;;;;;;;;;;;

; not 'def' becuase the last instruction generated does not cause a RAW stall
(define_insn "readsfr"
  [(set (match_operand:HI   0 "pic30_register_operand" "=r")
        (unspec_volatile:HI [
          (match_operand:HI 1 "pic30_register_operand" " r")
         ] UNSPECV_READSFR))
  ]
  ""
  "*
   if (pic30_errata_mask & psrd_psrd_errata) {
       pic30_rtx_nops++;
      /* this errata should not be needed for this device; but the user
          asked for it... make it psrd_psrd safe */
      return \"push SR\;\"
             \"bset SR,#5\;\"
             \"bset SR,#6\;\"
             \"bset SR,#7\;\"
             \"mov [%1],[w15]\;\"
             \"pop SR\;\"
             \"mov [%1],%0\";
   } else {
      return \"push SR\;\"
             \"bset SR,#5\;\"
             \"bset SR,#6\;\"
             \"bset SR,#7\;\"
             \"mov [%1],[w15]\;\"
             \"mov [%1],%0\;\"
             \"pop SR\";
   }
  "
  [
    (set_attr "cc"   "clobber")
    (set_attr "type" "etc")
  ]
)

(define_insn "writesfr"
  [(unspec_volatile:HI [
     (match_operand:HI 0 "pic30_register_operand" "r")
     (match_operand:HI 1 "pic30_register_operand" "r")
  ] UNSPECV_WRITESFR)]
  ""
  "push SR\;bset SR,#5\;bset SR,#6\;bset SR,#7\;mov %0,%0\;mov %0,%0\;mov %1,[%0]\;pop SR"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "tbladdress"
  [(set (match_operand:SI 0 "pic30_register_operand"          "=r")
        (unspec:SI [
          (match_operand:HI 1 "pic30_symbolic_address_operand" "q")
         ] UNSPECV_TBLADDRESS))
  ]
  ""
  "mov #tbloffset(%1),%0\;mov #tblpage(%1),%d0"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "def")
  ]
)

(define_expand "tblpage"
  [(set (match_operand:HI 0 "pic30_register_operand"        "=r")
        (tblpage:HI 
           (match_operand 1 "pic30_symbolic_address_operand" "q")))]
  ""
  "{ char *t = pic30_section_base(operands[1],1,0);

     emit_insn(
       gen_tblpage_helper(operands[0], GEN_INT((HOST_WIDE_INT)t))
     );
     DONE;
   }
  "
)

(define_insn "tblpage_helper"
  [(set (match_operand:HI 0 "pic30_register_operand" "=r")
        (tblpage:HI 
           (match_operand 1 "immediate_operand"      " i")))
  ]
  ""
  "*
   { static char result[256];

     char *o1 = (char*)INTVAL(operands[1]);
     sprintf(result,\"mov #tblpage(%s),%%0\", o1);
     return result;
   }"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "def")
  ]
)

(define_expand "edspage"
  [(set (match_operand:HI 0 "pic30_register_operand"        "=r")
        (edspage:HI 
           (match_operand 1 "pic30_symbolic_address_operand" "q")
           (match_operand 2 "immediate_operand" "i")))]
  ""
  "{ char *t = pic30_section_base(operands[1],1,0);

     emit_insn(
       gen_edspage_helper(operands[0], GEN_INT((HOST_WIDE_INT)t),operands[2])
     );
     DONE;
   }
  "
)

(define_insn "movpag"
  [(set (reg:HI PSVPAG)
        (edspage:HI
           (match_operand 0 "pic30_reg_or_symbolic_address" "r,q")
           (match_operand 1 "immediate_operand"             "i,i")))]
  "pic30_ecore_target()"
  "*
   {  
      if (INTVAL(operands[1])) {
        error(\"Page offset not accepted\");
        return \"cannot generate instruction\";
      }
      if (which_alternative == 1) {
        char *t = pic30_section_base(operands[0],1,0);
        static char result[80];

        sprintf(result,\"movpag #edspage(%s),DSRPAG\", t);
        return result;
      } else {
        return \"movpag %0,DSRPAG\";
      }
   }"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "etc")
  ]
)

(define_insn "edspage_helper"
  [(set (match_operand:HI 0 "pic30_register_operand" "=r")
        (edspage:HI 
           (match_operand 1 "immediate_operand"   "i")
           (match_operand 2 "immediate_operand"   "i")))]
  ""
  "*
   { static char result[256];
     char *e = result;
     char *o1;

     /* immedidate operand matches a symbol_ref */
     if (pic30_symbolic_address_operand(operands[1],VOIDmode)) {
        o1 = pic30_section_base(operands[1],1,0);
     } else o1 = (char*)INTVAL(operands[1]);
     e += sprintf(result,\"mov #edspage(%s),%%0\", 
                  pic30_strip_name_encoding_helper(o1));
     if (INTVAL(operands[2]))
       sprintf(e,\"\;add %%0,#%ld,%%0\", INTVAL(operands[2]));
     return result;
   }"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "def")
  ]
)

(define_expand "edsoffset"
  [(set (match_operand:HI 0 "pic30_register_operand"        "=r")
        (edsoffset:HI
           (match_operand 1 "pic30_symbolic_address_operand" "q")))]
  ""
  "{ char *t = pic30_section_base(operands[1],0,0);

     emit_insn(
       gen_edsoffset_helper(operands[0], GEN_INT((HOST_WIDE_INT)t))
     );
     DONE;
   }
  "
)

(define_insn "edsoffset_helper"
  [(set (match_operand:HI 0 "pic30_register_operand" "=r")
        (edsoffset:HI
           (match_operand 1 "immediate_operand"   "i")))]
  ""
  "*
   { static char result[256];

     char *o1 = (char*)INTVAL(operands[1]);
     sprintf(result,\"mov #edsoffset(%s),%%0\", o1);
     return result;
   }"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "def")
  ]
)

(define_insn "tbloffset"
  [(set (match_operand:HI 0 "pic30_register_operand"        "=r")
        (tbloffset:HI 
           (match_operand 1 "pic30_symbolic_address_operand" "q")))]
  ""
  "mov #tbloffset(%1),%0"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "def")
  ]
)

(define_expand "psvpage"
  [(set (match_operand:HI 0 "pic30_register_operand"        "=r")
        (psvpage:HI 
           (match_operand 1 "pic30_symbolic_address_operand" "q")))
  ]
  ""
  "{ char *t = pic30_section_base(operands[1],0,0);

     emit_insn(
       gen_psvpage_helper(operands[0], GEN_INT((HOST_WIDE_INT)t))
     );
     DONE;
   }"
)

(define_insn "psvpage_helper"
  [(set (match_operand:HI 0 "pic30_register_operand" "=r")
        (psvpage:HI 
           (match_operand 1 "immediate_operand"      " g")))
  ]
  ""
  "*
   { static char result[256];

     char *o1 = (char*)INTVAL(operands[1]);
     sprintf(result,\"mov #psvpage(%s),%%0\", o1);
     return result;
   }"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "def")
  ]
)

(define_insn "psvoffset"
  [(set (match_operand:HI 0 "pic30_register_operand"        "=r")
        (psvoffset:HI  
           (match_operand 1 "pic30_symbolic_address_operand" "q")))
  ]
  ""
  "mov #psvoffset(%1),%0"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "def")
  ]
)

(define_insn "dmaoffset"
  [(set (match_operand:HI 0 "pic30_register_operand"        "=r")
        (dmaoffset:HI 
          (match_operand  1 "pic30_symbolic_address_operand" "q")))
  ]
  ""
  "mov #dmaoffset(%1),%0"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "def")
  ]
)

(define_insn "dmapage"
  [(set (match_operand:HI 0 "pic30_register_operand"        "=r")
        (dmapage:HI 
          (match_operand  1 "pic30_symbolic_address_operand" "q")))
  ]
  ""
  "mov #dmapage(%1),%0"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "def")
  ]
)

(define_insn "addr_low"
  [(set (match_operand:HI 0 "pic30_register_operand"       "=r,r")
        (addr_low:HI
           (match_operand 1 "pic30_reg_or_symbolic_address" "q,r")))]
  ""
  "@
   mov #addr_lo(%1),%0
   mov %1,%0"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "def")
  ]
)

(define_insn "addr_high"
  [(set (match_operand:HI 0 "pic30_register_operand"       "=r,r")
        (addr_high:HI
           (match_operand 1 "pic30_reg_or_symbolic_address" "q,r")))]
  ""
  "@
   mov #addr_hi(%1),%0
   mov %d1,%0"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "def")
  ]
)

(define_insn "addr_long"
  [(set (match_operand:SI 0 "pic30_register_operand"       "=r,r")
        (addr_long:SI
           (match_operand 1 "pic30_reg_or_symbolic_address" "q,r")))]
  ""
  "@
   mov #addr_lo(%1),%0\;mov #addr_hi(%1),%d0
   mov %1,%0\;clr %d0"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "def")
  ]
)

;;;;;;;;;;;;;;;
;; general case
;;;;;;;;;;;;;;;

(define_insn "movacchi"
  [(set (match_operand:HI 0 "pic30_register_operand"    "=r")
        (match_operand:HI 1 "pic30_accumulator_operand" " w"))]
  "pic30_integer_mac_support"
  "mov %m1L,%0"
)

(define_insn "movhiacc"
  [(set (match_operand:HI 0 "pic30_accumulator_operand" "=w")
        (match_operand:HI 1 "pic30_register_operand"    " r"))]
  "pic30_integer_mac_support"
  "mov %1,%m0L"
)


(define_insn "movhi_gen"
  [(set (match_operand:HI 0 
           "pic30_move_operand" "=r<>, R,   r<>,R,S,S,  Q,r,r,T,a,U")
        (match_operand:HI 1
	   "pic30_move_operand" " RS<>,RS<>,r,  r,r,<>R,r,Q,T,r,U,U"))
  ]
  ""
  "*
   { 
     char *format[] = {
       \"mov %1,%0\",
       \"mov %1,%0\",
       \"mov %1,%0\",
       \"mov %1,%0\",
       \"mov %1,%0\",
       \"mov %1,%0\",
       \"mov %1,%0\",
       \"mov %1,%0\",
       \"mov %1,%0\",
       \"mov %1,%0\",
       \"mov %1,WREG\",
       \"push %1\;pop %0\" 
     };

     #define IDENT_EXTERNAL(t) \
       ((t) == pic30_identExternal[0] || (t) == pic30_identExternal[1])

     if ((which_alternative == 8) || (which_alternative == 10)) {
       tree decl = 0;
       if (GET_CODE(XEXP(operands[1],0)) == SYMBOL_REF)
         decl = SYMBOL_REF_DECL(XEXP(operands[1],0));
       if (decl) {
         tree attr = lookup_attribute(IDENTIFIER_POINTER(pic30_identSpace[0]),
                                      DECL_ATTRIBUTES(decl));
         if (attr &&
             (TREE_CODE(TREE_VALUE(TREE_VALUE(attr))) == CALL_EXPR)) {
           tree id;
           id = TREE_OPERAND(CALL_EXPR_FN(TREE_VALUE(TREE_VALUE(attr))),0);
           if (IDENT_EXTERNAL(DECL_NAME(id))) return \"mov #%1,%0\";
         }
       }
     }
     return format[which_alternative];
   }"
  [
    (set_attr "cc"
              "change0,change0,change0,change0,change0,change0,change0,change0,change0,change0,move,change0")
   (set_attr "type" 
             "defuse,use,def,etc,etc,use,etc,defuse,def,etc,def,etc")
  ]
)

(define_insn "movhi_gen_APSV"
  [(set (match_operand:HI 0 
             "pic30_move_operand"      "=r<>, R,   r<>,R,S,S,  Q,r,r,T,a")
        (unspec:HI [
          (match_operand:HI 1
	     "pic30_move_APSV_operand"  "RS<>,RS<>,r,  r,r,<>R,r,Q,T,r,U")
          (reg:HI PSVPAG)] UNSPECV_USEPSV))
  ]
  ""
  "*
   { 
     char *format[] = {
       \"mov %1,%0\",
       \"mov %1,%0\",
       \"mov %1,%0\",
       \"mov %1,%0\",
       \"mov %1,%0\",
       \"mov %1,%0\",
       \"mov %1,%0\",
       \"mov %1,%0\",
       \"mov %1,%0\",
       \"mov %1,%0\",
       \"mov %1,WREG\" 
     };

     #define IDENT_EXTERNAL(t) \
       ((t) == pic30_identExternal[0] || (t) == pic30_identExternal[1])

     if ((which_alternative == 8) || (which_alternative == 10)) {
       tree decl = 0;
       if (GET_CODE(XEXP(operands[1],0)) == SYMBOL_REF)
         decl = SYMBOL_REF_DECL(XEXP(operands[1],0));
       if (decl) {
         tree attr = lookup_attribute(IDENTIFIER_POINTER(pic30_identSpace[0]),
                                      DECL_ATTRIBUTES(decl));
         if (attr &&
             (TREE_CODE(TREE_VALUE(TREE_VALUE(attr))) == CALL_EXPR)) {
           tree id;
           id = TREE_OPERAND(CALL_EXPR_FN(TREE_VALUE(TREE_VALUE(attr))),0);
           if (IDENT_EXTERNAL(DECL_NAME(id))) return \"mov #%1,%0\";
         }
       }
     }
     return format[which_alternative];
   }"
  [
    (set_attr "cc"
              "change0,change0,change0,change0,change0,change0,change0,change0,change0,change0,move")
    (set_attr "type" 
              "defuse,use,def,use,use,use,use,defuse,def,etc,def")
  ]
)

;(define_insn "movhi_lastresort"
; [
;   (set (match_operand:HI     0 "pic30_register_operand" "=&r")
;        (mem:HI 
;           (plus:HI 
;            (match_operand:HI 1 "pic30_register_operand" " r")
;            (match_operand:HI 2 "immediate_operand"      " i"))))
;  ]
;  ""
;  "mov %2,%0\;mov [%1+%0],%0"
;)
         
(define_insn "movP16PMP_gen"
  [(set (match_operand:P16PMP 0
           "pic30_move_operand" "=r<>, R,   r<>,R,S,S,  Q,r,r,T,a")
        (match_operand:P16PMP 1
           "pic30_move_operand"  "RS<>,RS<>,r,  r,r,<>R,r,Q,T,r,U"))]
  ""
  "@
   mov %1,%0
   mov %1,%0
   mov %1,%0
   mov %1,%0
   mov %1,%0
   mov %1,%0
   mov %1,%0
   mov %1,%0
   mov %1,%0
   mov %1,%0
   mov %1,WREG"
  [
    (set_attr "cc"
              "change0,change0,change0,change0,change0,change0,change0,change0,change0,change0,move")
    (set_attr "type" 
              "defuse,use,def,etc,etc,use,etc,defuse,def,etc,def")
  ])

(define_insn "movP16PMP_gen_APSV"
  [(set (match_operand:P16PMP 0
           "pic30_move_operand"      "=r<>, R,   r<>,R,S,S,  Q,r,r,T,a")
        (unspec:P16PMP [
          (match_operand:P16PMP 1
           "pic30_move_APSV_operand"  "RS<>,RS<>,r,  r,r,<>R,r,Q,T,r,U")
          (reg:HI PSVPAG)] UNSPECV_USEPSV))]
  ""
  "@
   mov %1,%0
   mov %1,%0
   mov %1,%0
   mov %1,%0
   mov %1,%0
   mov %1,%0
   mov %1,%0
   mov %1,%0
   mov %1,%0
   mov %1,%0
   mov %1,WREG"
  [
    (set_attr "cc"
              "change0,change0,change0,change0,change0,change0,change0,change0,change0,change0,move")
    (set_attr "type" 
              "defuse,use,def,etc,etc,use,etc,defuse,def,etc,def")
  ])


;; If one of the operands is immediate and the other is not a register,
;; then we should emit two insns, using a scratch register.  This will produce
;; better code in loops if the source operand is invariant, since
;; the source reload can be optimised out.  During reload we cannot
;; use change_address or force_reg which will allocate new pseudo regs.

;; Unlike most other insns, the move insns can`t be split with
;; different predicates, because register spilling and other parts of
;; the compiler, have memoized the insn number already.

(define_expand "movhi"
  [(set (match_operand:HI 0 "pic30_move_operand" "")
        (match_operand:HI 1 "pic30_move_operand" ""))]
  ""
  "
  { int result = pic30_emit_move_sequence(operands, HImode);

    if (result > 0) DONE;
  }"
)

(define_insn "movp16apsv_gen"
  [(set (match_operand:P16APSV 0 
           "pic30_move_operand" "=r<>, R,   r<>,R,S,S,  Q,r,r,T,a")
        (match_operand:P16APSV 1
	   "pic30_move_operand"  "RS<>,RS<>,r,  r,r,<>R,r,Q,T,r,U"))]
  ""
  "*
   { 
     char *format[] = {
       \"mov %1,%0\",
       \"mov %1,%0\",
       \"mov %1,%0\",
       \"mov %1,%0\",
       \"mov %1,%0\",
       \"mov %1,%0\",
       \"mov %1,%0\",
       \"mov %1,%0\",
       \"mov %1,%0\",
       \"mov %1,%0\",
       \"mov %1,WREG\" 
     };

     #define IDENT_EXTERNAL(t) \
       ((t) == pic30_identExternal[0] || (t) == pic30_identExternal[1])

     if ((which_alternative == 8) || (which_alternative == 10)) {
       tree decl = 0;
       if (GET_CODE(XEXP(operands[1],0)) == SYMBOL_REF)
         decl = SYMBOL_REF_DECL(XEXP(operands[1],0));
       if (decl) {
         tree attr = lookup_attribute(IDENTIFIER_POINTER(pic30_identSpace[0]),
                                      DECL_ATTRIBUTES(decl));
         if (attr &&
             (TREE_CODE(TREE_VALUE(TREE_VALUE(attr))) == CALL_EXPR)) {
           tree id;

           id = TREE_OPERAND(CALL_EXPR_FN(TREE_VALUE(TREE_VALUE(attr))),0);
           if (IDENT_EXTERNAL(DECL_NAME(id))) return \"mov #%1,%0\";
         }
       }
     }
     return format[which_alternative];
   }"
  [
    (set_attr "cc"
              "change0,change0,change0,change0,change0,change0,change0,change0,change0,change0,move")
    (set_attr "type" "defuse,use,def,use,use,use,use,defuse,def,etc,def")
  ]
)

(define_insn "movp16apsv_gen_APSV"
  [(set (match_operand:P16APSV 0 
           "pic30_move_operand"      "=r<>, R,   r<>,R,S,S,  Q,r,r,T,a")
        (unspec:P16APSV [
          (match_operand:P16APSV 1
	   "pic30_move_APSV_operand"  "RS<>,RS<>,r,  r,r,<>R,r,Q,T,r,U")
          (reg:HI PSVPAG)] UNSPECV_USEPSV))]
  ""
  "*
   { 
     char *format[] = {
       \"mov %1,%0\",
       \"mov %1,%0\",
       \"mov %1,%0\",
       \"mov %1,%0\",
       \"mov %1,%0\",
       \"mov %1,%0\",
       \"mov %1,%0\",
       \"mov %1,%0\",
       \"mov %1,%0\",
       \"mov %1,%0\",
       \"mov %1,WREG\" 
     };

     #define IDENT_EXTERNAL(t) \
       ((t) == pic30_identExternal[0] || (t) == pic30_identExternal[1])

     if ((which_alternative == 8) || (which_alternative == 10)) {
       tree decl = 0;
       if (GET_CODE(XEXP(operands[1],0)) == SYMBOL_REF)
         decl = SYMBOL_REF_DECL(XEXP(operands[1],0));
       if (decl) {
         tree attr = lookup_attribute(IDENTIFIER_POINTER(pic30_identSpace[0]),
                                      DECL_ATTRIBUTES(decl));
         if (attr &&
             (TREE_CODE(TREE_VALUE(TREE_VALUE(attr))) == CALL_EXPR)) {
           tree id;

           id = TREE_OPERAND(CALL_EXPR_FN(TREE_VALUE(TREE_VALUE(attr))),0);
           if (IDENT_EXTERNAL(DECL_NAME(id))) return \"mov #%1,%0\";
         }
       }
     }
     return format[which_alternative];
   }"
  [
    (set_attr "cc"
              "change0,change0,change0,change0,change0,change0,change0,change0,change0,change0,move")
     (set_attr "type" "defuse,use,def,use,use,use,use,defuse,def,etc,def")
  ]
)

(define_expand "movp16apsv"
  [(set (match_operand:P16APSV 0 "pic30_move_operand" "")
        (match_operand:P16APSV 1 "pic30_move_operand" ""))]
  ""
  "
{ int result = pic30_emit_move_sequence(operands, P16APSVmode);

  if (result > 0) DONE;
}")

;;
;; Reload can generate a partial load of a larger item
;;   Recognize the instruction. - Bug in nullstone cse -O[23]
;;

(define_insn "movhi_reload_lo"
  [(set (match_operand:HI    0 "pic30_move_operand" "=r,RS,r,R,a,T,r")
        (subreg:HI 
           (match_operand:SI 1 "pic30_move_operand" " r,r,RS,R,U,r,T") 0))]
  ""
  "@
   mov %1,%0
   mov %1,%0
   mov %1,%0
   mov %1,%0
   mov %1,WREG
   mov %1,%0
   mov %1,%0"
  [
    (set_attr "cc" "change0,change0,change0,change0,move,change0,change0")
    (set_attr "type" "def,use,defuse,use,def,etc,def")
  ]
)

(define_insn "movhi_reload_hi"
  [(set (match_operand:HI 0 "pic30_reg_or_near_operand"   "=a,r")
        (subreg:HI 
           (match_operand:SI 1 "pic30_UT_operand" "U,T") 2))]
  ""
  "@
   mov %1+2,WREG
   mov %1+2,%0"
  [
   (set_attr "cc" "move,change0")
   (set_attr "type" "def,def")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 24-bit moves
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  
(define_expand "movp24prog_address"
  [(set 
     (match_operand:P24PROG 0 "pic30_move_operand"             "=r,R,<>,QSTU")
     (match_operand:P24PROG 1 "pic30_symbolic_address_operand" " q,q,q ,q"))
  ]
  ""
  "
{
  rtx op2 = 0;

  if (!reload_in_progress) op2 = gen_reg_rtx(GET_MODE(operand0));
  emit_insn(
    gen_tbloffset(
      simplify_gen_subreg(HImode, op2 ? op2 : operand0, GET_MODE(operand0), 0), 
      operand1)
  );
  emit_insn(
    gen_tblpage(
      simplify_gen_subreg(HImode, op2 ? op2 : operand0, GET_MODE(operand0), 2),
      operand1)
  );
  if (op2) 
    emit_insn(
      gen_movp24prog_gen(operand0,op2)
    );
  DONE;
}")

;
; for RAW scheduling variants 2-4 are not "uses" because the 1st instruction
;   would not cause a stall
;
(define_insn_and_split "movp24psv_address"
  [(set (match_operand:P24PSV 0 "pic30_move_operand"             "=r,R,<>,QSTU")
        (match_operand:P24PSV 1 "pic30_symbolic_address_operand" " q,q,q,q")
   )
   (clobber (match_scratch:HI 2                                  "=X,&r,&r,&r"))]
  ""
  "@
   mov #tbloffset(%1),%0\;mov #tblpage(%1),%d0
   mov #tbloffset(%1),%2\;mov %2,%I0\;mov #tblpage(%1),%2\;mov %2,%D0
   mov #tbloffset(%1),%2\;mov %2,%0\;mov #tblpage(%1),%2\;mov %2,%0
   mov #tbloffset(%1),%2\;mov %2,%0\;mov #tblpage(%1),%2\;mov %2,%0+2"
  "reload_completed && REG_P(operands[0])"
  [(set (match_operand:HI 3 "pic30_register_operand" "=r")
        (tblpage:HI (match_operand 4 "immediate_operand" "i")))
   (set (match_operand:HI 5 "pic30_register_operand" "=r")
        (tbloffset:HI (match_dup 1)))]
  "operands[3] = gen_rtx_REG(HImode, REGNO(operands[0])+1);
   operands[4] = GEN_INT((HOST_WIDE_INT)pic30_section_base(operands[1],1,0));
   operands[5] = gen_rtx_REG(HImode, REGNO(operands[0]));"
  [
    (set_attr "type" "def,etc,etc,etc")
  ]
)  

;
; for RAW scheduling variants 2-4 are not "uses" because the 1st instruction
;   would not cause a stall
;
(define_insn "movp16pmp_address"
  [(set (match_operand:P16PMP 0 "pic30_move_operand"             "=r,R,<>,QSTU")
        (match_operand:P16PMP 1 "pic30_symbolic_address_operand" " q,q,q ,q"))
   (clobber (match_scratch:HI 2                                  "=X,&r,&r,&r"))
  ]
  ""
  "*
   { static char result[256];

     switch (which_alternative) {
       default: gcc_assert(0);
       case 0: sprintf(result,\"mov #%%1,%%0\");
               break;
       case 1: sprintf(result, \"mov #%%1,%%2\;mov %%2,%%0\");
               break;
       case 2: sprintf(result, \"mov #%%1,%%2\;mov %%2,%%0\");
               break;
       case 3: sprintf(result, \"mov #%%1,%%2\;mov %%2,%%0\");
               break;
     }
     return result;
   }
  "
  [
    (set_attr "type" "def,etc,etc,etc")
  ]
)

;
; for RAW scheduling variants 2-4 are not "uses" because the 1st instruction
;   would not cause a stall
;
(define_insn "movEDS_address_page"
  [(set (match_operand:HI     0 "pic30_move_operand" "=r,R,<>,QSTU")
        (edspage: HI
          (match_operand     1 "immediate_operand"   " i,i,i,i")
          (match_operand     2 "immediate_operand"   " i,i,i,i"))
   )
   (clobber (match_scratch:HI 3                      "=X,&r,&r,&r"))
  ]
  ""
  "*
   { static char result[256];
     char *o1 = pic30_strip_name_encoding_helper((char*)INTVAL(operands[1]));
     char *e = result;
     int excess = 0;
     
     if (INTVAL(operands[2]) != 0) {
       /* an excess was specified */
       excess = INTVAL(operands[2]);
     }
     switch (which_alternative) {
       default: gcc_assert(0);
       case 0: e += sprintf(result,\"mov #edspage(%s),%%0\", o1);
               if (excess) sprintf(e,\"\;add %%0,#%d,%%0\", excess);
               break;
       case 1: if (excess) 
                 sprintf(result, \"mov #edspage(%s),%%3\;add %%3,#%d,%%0\",
                         o1, excess);
               else
                 sprintf(result, \"mov #edspage(%s),%%3\;mov %%3,%%0\", o1);
               break;
       case 2: if (excess) 
                 sprintf(result, \"mov #edspage(%s),%%3\;add %%3,#%d,%%0\",
                         o1, excess);
               else
                 sprintf(result, \"mov #edspage(%s),%%3\;mov %%3,%%0\",o1);
               break;
       case 3: if (excess) 
                 sprintf(result, \"mov #edspage(%s),%%3\;add %%3,#%d,%%3\;\"
                                 \"mov %%3,%%0\", o1, excess);
               else
                 sprintf(result, \"mov #edspage(%s),%%3\;mov %%3,%%0\",o1);
               break;
     }
     return result;
   }
  "
  [
    (set_attr "type" "def,etc,etc,etc")
  ]
)

;
; for RAW scheduling variants 2-4 are not "uses" because the 1st instruction
;   would not cause a stall
;
(define_insn "movEDS_address_offset"
  [(set (match_operand:HI     0 "pic30_move_operand" "=r,R,<>,QSTU")
        (edsoffset: HI
          (match_operand      1 "immediate_operand"  " i,i,i,i"))
   )
   (clobber (match_scratch:HI 2                      "=X,&r,&r,&r"))
  ]
  ""
  "*
   { static char result[256];
     char *o1 = (char*)INTVAL(operands[1]);

     switch (which_alternative) {
       default: gcc_assert(0);
       case 0: sprintf(result,\"mov #edsoffset(%s),%%0\", o1);
               break;
       case 1: sprintf(result,\"mov #edsoffset(%s),%%2\;mov %%2,%%0\", o1);
               break;
       case 2: sprintf(result,\"mov #edsoffset(%s),%%2\;mov %%2,%%0\", o1);
               break;
       case 3: sprintf(result,\"mov #edsoffset(%s),%%2\;mov %%2,%%0\", o1);
               break;
     }
     return result;
   }
  "
  [
    (set_attr "type" "def,etc,etc,etc")
  ]
)

(define_expand "movp32eds_address"
  [(set (match_operand:P32EDS 0 "pic30_move_operand"             "=r,R,<>,QSTU")
        (match_operand:P32EDS 1 "pic30_symbolic_address_operand" " q,q,q ,q")
   )
  ]
  ""
  "{ rtx excess;
     char *t = pic30_section_base(operands[1],0,&excess);
     emit_insn(
       gen_movEDS_address_offset(
         simplify_gen_subreg(HImode, operands[0], GET_MODE(operands[0]), 0),
	 GEN_INT((HOST_WIDE_INT)t))
     );
     t = pic30_section_base(operands[1],1,&excess);
     if (pic30_register_operand(operands[0], P32EDSmode)) {
       emit_insn(
         gen_edspage_helper(
           simplify_gen_subreg(HImode, operands[0], GET_MODE(operands[0]), 2), 
           GEN_INT((HOST_WIDE_INT)t), excess)
       );
     } else {
       emit_insn(
         gen_movEDS_address_page(
           simplify_gen_subreg(HImode, operands[0], GET_MODE(operands[0]), 2),
           GEN_INT((HOST_WIDE_INT)t), excess)
       );
     }
     DONE;
   }
  "
)

(define_expand "movp32peds_address"
  [(set (match_operand:P32PEDS 0 "pic30_move_operand"            "=r,R,<>,QSTU")
        (match_operand:P32PEDS 1 "pic30_symbolic_address_operand" "q,q,q, q")
   )
  ]
  ""
  "{ char *t = pic30_section_base(operands[1],0,0);
     emit_insn(
       gen_movEDS_address_offset(
         simplify_gen_subreg(HImode, operands[0], GET_MODE(operands[0]), 0),
         GEN_INT((HOST_WIDE_INT)t))
     );
     t = pic30_section_base(operands[1],1,0);
     emit_insn(
       gen_movEDS_address_page(
         simplify_gen_subreg(HImode, operands[0], GET_MODE(operands[0]), 2),
         GEN_INT((HOST_WIDE_INT)t), GEN_INT(0))
     );
     DONE;
   } 
  "
)

(define_insn "movp32df_address"
  [(set (match_operand:P32DF 0 "pic30_move_operand"             "=r")
        (match_operand:P32DF 1 "pic30_symbolic_address_operand"  "q")
   )
  ]
  ""
  "mov #packed_lo(%1),%0\;mov #packed_hi(%1),%d0"
  [
    (set_attr "type" "def")
  ]
)

(define_expand "movp32ext_address"
  [(set (match_operand:P32EXT 0 "pic30_move_operand"             "=rR<>QSTU")
        (match_operand:P32EXT 1 "pic30_symbolic_address_operand" " q"))]
  ""
  "{
     if (pic30_address_of_external(operands[0],operands[1])) {
       DONE;
     } else FAIL;
   }
  "
)

;(define_insn "movP32DF_gen"
;  [(set (match_operand:P32DF 0 "pic30_move_operand" "=r,r,  R<>,Q,r, TU,r")
;        (match_operand:P32DF 1 "pic30_move_operand"  "r,R<>,r,  r,TU,r, Q"))
;  ]
;  ""
;  "*
;   {
;     switch (which_alternative) {
;        default: gcc_assert(0);
;        case 0: /* r = r */
;                return \"mov.d %1,%0\";
;        case 1: /* r = R<> */
;                return \"mov.d %1,%0\";
;        case 2: /* R<> = r */
;                return \"mov.d %1,%0\";
;        case 3: /* Q = r */
;                return \"mov %1,%0\;mov %d1,%Q0\";
;        case 4: /* r = TU */
;                return \"mov %1,%0\;mov %Q1,%d0\";
;        case 5: /* TU = r */
;                return \"mov %1,%0\;mov %d1,%Q0\";
;        case 6: /* r = Q */
;                if (pic30_psrd_psrd_errata(operands[1],NULL)) {
;                  pic30_rtx_nops++;
;                if (REGNO(operands[0]) == REGNO(XEXP(operands[1],0))) {
;                    return \"mov %1,%0\;nop\;mov %Q1,%d0\";
;                } else {
;                    return \"mov %Q1,%d0\;nop\;mov %1,%0\";
;                }
;                } else {
;                if (REGNO(operands[0]) == REGNO(XEXP(operands[1],0))) {
;                  return \"mov %1,%0\;mov %Q1,%d0\";
;                } else {
;                  return \"mov %Q1,%d0\;mov %1,%0\";
;                }
;     }
;                }
;  }"
;  [
;    (set_attr "cc" "clobber")
;    (set_attr "type" "def,defuse,use,use,def,etc,defuse")
;  ]
;)

(define_expand "movp24prog"
  [(set (match_operand:P24PROG 0 "pic30_general_operand" "")
        (match_operand:P24PROG 1 "pic30_general_operand" ""))]
  ""
  "
  {
     if (pic30_emit_move_sequence(operands, P24PROGmode)) DONE;
  }"
)

(define_expand "movp24psv"
  [(set (match_operand:P24PSV 0 "pic30_general_operand" "")
        (match_operand:P24PSV 1 "pic30_general_operand" ""))]
  ""
  "
  {
    if (pic30_emit_move_sequence(operands, P24PSVmode)) DONE;
  }"
)

(define_expand "movp16pmp"
  [(set (match_operand:P16PMP 0 "pic30_general_operand" "")
        (match_operand:P16PMP 1 "pic30_general_operand" ""))]
  ""
  "
  {
    if (pic30_emit_move_sequence(operands, P16PMPmode)) DONE;
  }"
)

(define_expand "movp32eds"
  [(set (match_operand:P32EDS 0 "pic30_general_operand" "")
        (match_operand:P32EDS 1 "pic30_general_operand" ""))]
  ""
  "
  {
    if (pic30_emit_move_sequence(operands, P32EDSmode)) DONE;
  }"
)

(define_expand "movp32peds"
  [(set (match_operand:P32PEDS 0 "pic30_general_operand" "")
        (match_operand:P32PEDS 1 "pic30_general_operand" ""))]
  ""
  "
  {
    if (pic30_emit_move_sequence(operands, P32PEDSmode)) DONE;
  }"
)

(define_expand "movp32df"
  [(set (match_operand:P32DF 0 "pic30_general_operand" "")
        (match_operand:P32DF 1 "pic30_general_operand" ""))]
  ""
  "
  {
    if (pic30_emit_move_sequence(operands, P32DFmode)) DONE;
  }"
)

(define_expand "movp32ext"
  [(set (match_operand:P32EXT 0 "pic30_general_operand" "")
        (match_operand:P32EXT 1 "pic30_general_operand" ""))]
  ""
  "
  {
    if (pic30_emit_move_sequence(operands, P32EXTmode)) DONE;
  }"
)

(define_insn "set_vpsv"
   [(set (reg:HI PSVPAG)
         (unspec_volatile: HI
           [(match_operand:HI 0 "pic30_register_operand" "r")] UNSPECV_SETPSV))]
   ""
   "*
    {
      if (pic30_ecore_target()) return \"mov %0,_DSRPAG\;nop\";
      if (pic30_eds_target()) return \"mov %0,_DSRPAG\";
      return \"mov %0,_PSVPAG\";
    }"
   [
     (set_attr "type" "etc")
   ]
)

(define_insn "assert_psv"
   [(set (reg:HI PSVPAG)
            (match_operand:HI 0 "pic30_register_operand" "r"))
    (clobber (match_operand:HI 1 "pic30_register_operand" "=B"))]
   ""
   "
   \; assert PSV page"
   [
     (set_attr "type" "etc")
   ]
)

(define_insn "set_nvpsv"
   [(set (reg:HI PSVPAG)
         (match_operand:HI 0 "pic30_register_operand" "r"))]
   ""
   "*
    {
      if (pic30_ecore_target()) return \"mov %0,_DSRPAG\;nop\";
      if (pic30_eds_target()) return \"mov %0,_DSRPAG\";
      return \"mov %0,_PSVPAG\";
    }"
   [
     (set_attr "type" "etc")
   ]
)

(define_insn "set_unpsv"
   [(set (reg:HI PSVPAG)
         (subreg:HI
            (match_operand:P32PEDS 0 "pic30_register_operand" "r") 2))]
   ""
   "*
    {
      if (pic30_ecore_target()) return \"mov %d0,_DSRPAG\;nop\";
      if (pic30_eds_target()) return \"mov %d0,_DSRPAG\";
      return \"mov %d0,_PSVPAG\";
    }"
   [
     (set_attr "type" "etc")
   ]
)

(define_insn "set_unpsv2"
   [(set (reg:HI PSVPAG)
         (subreg:HI
            (plus:P32EDS
               (match_operand:P32PEDS 0 "pic30_register_operand" "r")
               (match_operand:P32PEDS 1 "immediate_operand"      "i")) 2))]
   ""
   "*
    {
      if (pic30_ecore_target()) return \"mov %d0,_DSRPAG\;nop\";
      if (pic30_eds_target()) return \"mov %d0,_DSRPAG\";
      return \"mov %d0,_PSVPAG\";
    }"
   [
     (set_attr "type" "etc")
   ]
)

(define_expand "set_psv"
  [(set (reg:HI PSVPAG)
        (match_operand:HI 0 "pic30_register_operand" "r"))]
  ""
  "
   if (TARGET_TRACK_PSVPAG) {
     emit_insn(
       gen_set_nvpsv(operand0)
     );
   } else {
     emit_insn(
       gen_set_vpsv(operand0)
     );
   }
   DONE;
  "
)

(define_insn "set_vdsw"
   [(set (reg:HI DSWPAG)
         (unspec_volatile: HI
           [(match_operand:HI 0 "pic30_register_operand" "r")] 
           UNSPECV_SETDSW))]
   "pic30_eds_target()"
   "mov %0,_DSWPAG"
   [
     (set_attr "type" "etc")
   ]
)

(define_insn "set_nvdsw"
   [(set (reg:HI DSWPAG)
         (match_operand:HI 0 "pic30_register_operand" "r"))]
         
   "pic30_eds_target()"
   "mov %0,_DSWPAG"
   [
     (set_attr "type" "etc")
   ]
)

(define_expand "set_dsw"
   [(set (reg:HI DSWPAG)
         (match_operand:HI 0 "pic30_register_operand" "r"))]
   "pic30_eds_target()"
   "
   if (TARGET_TRACK_PSVPAG) {
     emit_insn(
       gen_set_nvdsw(operand0)
     );
   } else {
     emit_insn(
       gen_set_vdsw(operand0)
     );
   }
   DONE;
")

(define_insn "copy_psv"
   [(set (match_operand:HI 0 "pic30_register_operand" "=r")
         (reg:HI PSVPAG))]
   ""
   "*
    {
      if (pic30_eds_target()) return \"mov _DSRPAG,%0\";
      return \"mov _PSVPAG,%0\";
    }"
  [
    (set_attr "type" "def")
  ]
)

(define_insn "copy_dsw"
   [(set (match_operand:HI 0 "pic30_register_operand" "=r")
         (reg:HI DSWPAG))]
   "pic30_eds_target()"
   "mov _DSWPAG,%0"
   [
     (set_attr "type" "def")
   ]
)

(define_insn "set_PMADDR_DATA"
  [(set (reg:P16PMP PMADDR)
        (match_operand: P16PMP 0 "pic30_mode2_operand" "r,R<>"))]
  ""
  "@
   mov %0,_PMADDR
   push %0\;pop _PMADDR"
  [
    (set_attr "type" "etc,use")
  ]
)

(define_insn "set_PMADDR_APSV"
  [(set (reg:P16PMP PMADDR)
        (match_operand: P16PMP 0 "pic30_mode2_APSV_operand" "r,R<>"))]
  ""
  "@
   mov %0,_PMADDR
   push %0\;pop _PMADDR"
  [
    (set_attr "type" "etc,use")
  ]
)

(define_expand "set_PMADDR"
  [(set (reg:P16PMP PMADDR)
        (match_operand: P16PMP 0 "pic30_mode2_APSV_operand" "r,R<>"))]
  ""
  "
{
  if (pic30_mode2_operand(operands[0], GET_MODE(operands[0]))) 
    emit(gen_set_PMADDR_DATA(operands[0]));
  else
    emit(gen_set_PMADDR_APSV(operands[0]));
  DONE;
}")

(define_insn "while_PMMODE_busy"
  [
   (unspec_volatile:HI  [(const_int 0)] UNSPECV_WHILEPMMODE)
   (use (reg:P16PMP PMADDR))
  ]
  ""
  "btsc _PMMODE, #15\;bra . - 2"
  [
    (set_attr "type" "etc")
  ]
)

(define_insn "bitset_PMMODE"
  [ 
   (set (reg:HI PMMODE)
        (unspec_volatile:HI 
          [(reg:HI PMMODE)
           (match_operand 0 "const_int_operand"      "i")] UNSPECV_SETPMMODE))
  ]
  "((INTVAL(operands[0]) >= 0) && (INTVAL(operands[0]) <= 15))"
  "bset _PMMODE,#%0"
  [
    (set_attr "type" "etc")
  ]
)

(define_insn "bitclr_PMMODE"
  [ 
   (set (reg:HI PMMODE)
        (unspec_volatile:HI 
          [(reg:HI PMMODE)
           (match_operand 0 "const_int_operand"      "i")] UNSPECV_CLRPMMODE))
   (clobber (reg:P16PMP PMADDR))
  ]
  "((INTVAL(operands[0]) >= 0) && (INTVAL(operands[0]) <= 15))"
  "bclr _PMMODE,#%0"
  [
    (set_attr "type" "etc")
  ]
)

(define_insn "get_PMDIN1qi"
  [
   (set (match_operand:QI 0 "pic30_mode2_operand" "=r,R<>")
        (unspec_volatile:QI [ (reg:QI PMDIN1)
                              (reg:P16PMP PMADDR) ] UNSPECV_PMDIN1RD))
  ]
  ""
  "@
   mov _PMDIN1,%0
   push _PMDIN1\;pop %0"
  [
    (set_attr "type" "def,etc")
  ]
)

(define_insn "get_PMDIN1hi"
  [
   (set (match_operand: HI 0 "pic30_mode2_operand" "=r,R<>")
        (unspec_volatile:HI [ (reg:HI PMDIN1)
                              (reg:P16PMP PMADDR) ] UNSPECV_PMDIN1RD))
  ]
  ""
  "@
   mov _PMDIN1,%0
   push _PMDIN1\;pop %0"
  [
    (set_attr "type" "def,etc")
  ]
)

(define_insn "set_PMDIN1qi_DATA"
  [
   (set (reg:QI PMDIN1)
        (unspec_volatile:QI [ 
          (match_operand:QI 0 "pic30_mode2_operand" "r,R<>")
          (reg:P16PMP PMADDR) 
        ] UNSPECV_PMDIN1WT))
  ]
  ""
  "@
   mov %0,_PMDIN1
   push %0\;pop _PMDIN1"
  [
    (set_attr "type" "etc,use")
  ]
)

(define_insn "set_PMDIN1qi_APSV"
  [
   (set (reg:QI PMDIN1)
        (unspec_volatile:QI [ 
          (match_operand:QI 0 "pic30_mode2_APSV_operand" "r,R<>")
          (reg:P16PMP PMADDR) 
        ] UNSPECV_PMDIN1WT))
  ]
  ""
  "@
   mov %0,_PMDIN1
   push %0\;pop _PMDIN1"
)

(define_expand "set_PMDIN1qi"
  [
   (set (reg:QI PMDIN1)
        (unspec_volatile:QI [
          (match_operand:QI 0 "pic30_mode2_APSV_operand" "r,R<>")
          (reg:P16PMP PMADDR)
        ] UNSPECV_PMDIN1WT))
  ]
  ""
  "
{
  if (pic30_mode2_operand(operands[0], GET_MODE(operands[0]))) 
    emit(gen_set_PMDIN1qi_DATA(operands[0]));
  else
    emit(gen_set_PMDIN1qi_APSV(operands[0]));
  DONE;
}")

(define_insn "set_PMDIN1hi_DATA"
  [
   (set (reg:HI PMDIN1)
        (unspec_volatile:HI [ 
          (match_operand:HI 0 "pic30_mode2_operand" "r,R<>")
          (reg:P16PMP PMADDR) 
        ] UNSPECV_PMDIN1WT))
  ]
  ""
  "@
   mov %0,_PMDIN1
   push %0\;pop _PMDIN1"
  [
    (set_attr "type" "etc,use")
  ]
) 

(define_insn "set_PMDIN1hi_APSV"
  [
   (set (reg:HI PMDIN1)
        (unspec_volatile:HI [ 
          (match_operand:HI 0 "pic30_mode2_APSV_operand" "r,R<>")
          (reg:P16PMP PMADDR) 
        ] UNSPECV_PMDIN1WT))
  ]
  ""
  "@
   mov %0,_PMDIN1
   push %0\;pop _PMDIN1"
  [
    (set_attr "type" "etc,use")
  ]
) 

(define_expand "set_PMDIN1hi"
  [
   (set (reg:HI PMDIN1)
        (unspec_volatile:HI [
          (match_operand:HI 0 "pic30_mode2_APSV_operand" "r,R<>")
          (reg:P16PMP PMADDR)
        ] UNSPECV_PMDIN1WT))
  ]
  ""
  "
{
  if (pic30_mode2_operand(operands[0], GET_MODE(operands[0]))) 
    emit(gen_set_PMDIN1hi_DATA(operands[0]));
  else
    emit(gen_set_PMDIN1hi_APSV(operands[0]));
  DONE;
}")

(define_insn "rotlhi_DATA"
  [(set (match_operand:HI 0 "pic30_mode2_operand"   "=r,r,  R<>,R<>")
        (rotate:HI 
           (match_operand:HI 1 "pic30_mode2_operand" "r,R<>,r,  R<>")
           (const_int 1)))
  ]
  ""
  "@
   rlnc %1,%0
   rlnc %1,%0
   rlnc %1,%0
   rlnc %1,%0"
  [ 
    (set_attr "cc" "math") 
    (set_attr "type" "etc,defuse,use,use")
  ]
)

(define_insn "rotlhi_APSV"
  [(set (match_operand:HI 0 "pic30_mode2_operand"       "=r,r,  R<>,R<>")
        (rotate:HI 
          (match_operand:HI 1 "pic30_mode2_APSV_operand" "r,R<>,r,  R<>")
          (const_int 1)))
  ]
  ""
  "@
   rlnc %1,%0
   rlnc %1,%0
   rlnc %1,%0
   rlnc %1,%0"
  [ 
    (set_attr "cc" "math") 
    (set_attr "type" "def,defuse,use,use")
  ]
)

(define_expand "rotlhi3"
  [(set (match_operand:HI 0 "pic30_mode2_operand" "=rR<>")
        (rotatert:HI (match_operand:HI 1 "pic30_mode2_APSV_operand" "rR<>")
                     (match_operand:HI 2 "immediate_operand" "i")))]
  ""
  "
{  if (INTVAL(operands[2]) == 1) {
     if (pic30_mode2_operand(operands[1],GET_MODE(operands[1])))
       emit_insn(gen_rotlhi_DATA(operands[0], operands[1]));
     else
       emit_insn(gen_rotlhi_APSV(operands[0], operands[1]));
     DONE;
   } else FAIL;
}")

(define_insn "rotrhi_DATA"
  [(set (match_operand:HI 0 "pic30_mode2_operand"   "=r,r,  R<>,R<>")
        (rotatert:HI 
           (match_operand:HI 1 "pic30_mode2_operand" "r,R<>,r,  R<>")
           (const_int 1)))
  ]
  ""
  "@
   rrnc %1,%0
   rrnc %1,%0
   rrnc %1,%0
   rrnc %1,%0"
  [ 
    (set_attr "cc" "math") 
    (set_attr "type" "def,defuse,use,use")
  ]
)

(define_insn "rotrhi_APSV"
  [(set (match_operand:HI 0 "pic30_mode2_operand"        "=r,r,  R<>,R<>")
        (rotatert:HI 
           (match_operand:HI 1 "pic30_mode2_APSV_operand" "r,R<>,r,  R<>")
           (const_int 1)))
  ]
  ""
  "@
   rrnc %1,%0
   rrnc %1,%0
   rrnc %1,%0
   rrnc %1,%0"
  [ 
    (set_attr "cc" "math") 
    (set_attr "type" "def,defuse,use,use") 
  ]
)

(define_expand "rotrhi3"
  [(set (match_operand:HI 0 "pic30_mode2_operand" "=rR<>")
        (rotatert:HI (match_operand:HI 1 "pic30_mode2_APSV_operand" "rR<>")
                     (match_operand:HI 2 "immediate_operand" "i")))]
  ""
  "
{  if (INTVAL(operands[2]) == 1) {
     if (pic30_mode2_operand(operands[1],GET_MODE(operands[1])))
       emit_insn(gen_rotrhi_DATA(operands[0], operands[1]));
     else
       emit_insn(gen_rotrhi_APSV(operands[0], operands[1]));
     DONE;
   } else FAIL;
}")

;
; 24-bit unpack instruction
;   a pointer is 23..15.....0
;                page  offset
;   but for PSV access it must be
;                24..16 15 14...0
;                page   1  offset

(define_insn "unpack_EDS"
  [(set (match_operand:P32EDS 0 "pic30_register_operand" "=r")
        (unspec_volatile:P32EDS
          [(match_operand:P32EDS 1 "pic30_register_operand" "0")]
            UNSPECV_UNPACKEDS))]
  ""
  "btss %0,#15\;inc %d0,%d0"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def")
  ]
)

(define_insn "unpack_MPSV_DATA"
   [(set (match_operand:SI 0 "pic30_mode2_operand"       "=r,R,r,r,R,R")
         (unspec_volatile:SI 
           [(match_operand:P24PSV 1 "pic30_mode2_operand" "0,0,r,R,r,R")] 
             UNSPECV_UNPACKMPSV))]
   ""
   "@
    btsts.c %0,#15\;rlc %d0,%d0
    btsts.c %I0,#15\;rlc %0,%D0
    mov %1,%0\;btsts.c %0,#15\;rlc %d1,%d0
    mov %I1,%0\;btsts.c %0,#15\;rlc %D1,%d0
    mov %1,%0\;btsts.c %I0,#15\;rlc %d1,%D0
    mov %I1,%0\;btsts.c %I0,#15\;rlc %D1,%D0"
   [
     (set_attr "cc" "clobber")
     (set_attr "type" "def,use,def,defuse,use,use")
   ]
)

(define_insn "unpack_MPSV_APSV"
   [(set (match_operand:SI 0 "pic30_mode2_operand"            "=r,R,r,r,R,R")
         (unspec_volatile:SI 
           [(match_operand:P24PSV 1 "pic30_mode2_APSV_operand" "0,0,r,R,r,R")] 
             UNSPECV_UNPACKMPSV))]
   ""
   "@
    btsts.c %0,#15\;rlc %d0,%d0
    btsts.c %I0,#15\;rlc %0,%D0
    mov %1,%0\;btsts.c %0,#15\;rlc %d1,%d0
    mov %I1,%0\;btsts.c %0,#15\;rlc %D1,%d0
    mov %1,%0\;btsts.c %I0,#15\;rlc %d1,%D0
    mov %I1,%0\;btsts.c %I0,#15\;rlc %D1,%D0"
   [
     (set_attr "cc" "clobber")
     (set_attr "type" "def,use,def,defuse,use,use")
   ]
)

(define_expand "unpack_MPSV"
   [(set (match_operand:SI 0 "pic30_mode2_operand"       "=r,R,r,r,R,R")
         (unspec_volatile:SI
           [(match_operand:P24PSV 1 "pic30_mode2_APSV_operand" "0,0,r,R,r,R")]
             UNSPECV_UNPACKMPSV))]
   ""
   "
{
   if (pic30_mode2_operand(operands[1],GET_MODE(operands[1])))
     emit(gen_unpack_MPSV_DATA(operands[0],operands[1]));
   else
     emit(gen_unpack_MPSV_APSV(operands[0],operands[1]));
   DONE;
}")

(define_insn "unpack_MPROG_DATA"
   [(set (match_operand:SI 0 "pic30_mode2_operand"        "=r,R,r,r,R,R")
         (unspec_volatile:SI 
           [(match_operand:P24PROG 1 "pic30_mode2_operand" "0,0,r,R,r,R")] 
             UNSPECV_UNPACKMPROG))]
   ""
   "@
    btsts.c %0,#15\;rlc %d0,%d0
    btsts.c %I0,#15\;rlc %0,%D0
    mov %1,%0\;btsts.c %0,#15\;rlc %d1,%d0
    mov %I1,%0\;btsts.c %0,#15\;rlc %D1,%d0
    mov %1,%0\;btsts.c %I0,#15\;rlc %d1,%D0
    mov %I1,%0\;btsts.c %I0,#15\;rlc %D1,%D0"
   [
     (set_attr "cc" "clobber")
     (set_attr "type" "def,use,def,defuse,use,use")
   ]
)

(define_insn "unpack_MPROG_APSV"
   [(set (match_operand:SI 0 "pic30_mode2_operand"             "=r,R,r,r,R,R")
         (unspec_volatile:SI 
           [(match_operand:P24PROG 1 "pic30_mode2_APSV_operand" "0,0,r,R,r,R")] 
             UNSPECV_UNPACKMPROG))]
   ""
   "@
    btsts.c %0,#15\;rlc %d0,%d0
    btsts.c %I0,#15\;rlc %0,%D0
    mov %1,%0\;btsts.c %0,#15\;rlc %d1,%d0
    mov %I1,%0\;btsts.c %0,#15\;rlc %D1,%d0
    mov %1,%0\;btsts.c %I0,#15\;rlc %d1,%D0
    mov %I1,%0\;btsts.c %I0,#15\;rlc %D1,%D0"
   [
     (set_attr "cc" "clobber")
     (set_attr "type" "def,use,def,defuse,use,use")
   ]
)

(define_expand "unpack_MPROG"
   [(set (match_operand:SI 0 "pic30_mode2_operand"       "=r,R,r,r,R,R")
         (unspec_volatile:SI
           [(match_operand:P24PROG 1 "pic30_mode2_APSV_operand" "0,0,r,R,r,R")]
             UNSPECV_UNPACKMPROG))]
   ""
   "
{
  if (pic30_mode2_operand(operands[1],GET_MODE(operands[1]))) 
    emit(gen_unpack_MPROG_DATA(operands[0],operands[1]));
  else
    emit(gen_unpack_MPROG_APSV(operands[0],operands[1]));
  DONE;
}")

;
;  24-bit read instructions:
;
;    [PTRMODE]read_[READMODE]
;
;    P24PROGread_hi  (read a HI via a P24PROG pointer)
;
;  These patterns are (at least) a use because of the mem
;
(define_insn "P24PROGread_qi"
  [(set (match_operand:QI 0 "pic30_mode2_operand"              "=r,R<>")
        (unspec_volatile:QI
          [(mem:QI (match_operand:HI 1 "pic30_register_operand" "r,r"))
           (reg:HI PSVPAG)]
          UNSPECV_PSVRDPROG))
  ]
  ""
  "@
   mov.b [%1],%0
   mov.b [%1],%0"
  [
    (set_attr "type" "defuse,use")
  ]
)

(define_insn "P24PROGread_hi"
  [(set (match_operand:HI 0 "pic30_mode2_operand"              "=r,R<>")
        (unspec_volatile:HI
          [(mem:HI (match_operand:HI 1 "pic30_register_operand" "r,r"))
           (reg:HI PSVPAG)]
          UNSPECV_PSVRDPROG))
  ]
  ""
  "@
   mov [%1],%0
   mov [%1],%0"
  [
    (set_attr "type" "defuse,use")
  ]
)

(define_insn "P24PROGread_p16apsv"
  [(set (match_operand:P16APSV 0 "pic30_mode2_operand"              "=r,R<>")
        (unspec_volatile:P16APSV
          [(mem:P16APSV (match_operand:HI 1 "pic30_register_operand" "r,r"))
           (reg:HI PSVPAG)]
          UNSPECV_PSVRDPROG))
  ]
  ""
  "@
   mov [%1],%0
   mov [%1],%0"
  [
    (set_attr "type" "defuse,use")
  ]
)

(define_insn "P24PROGread_p16pmp"
  [(set (match_operand:P16PMP 0 "pic30_mode2_operand"              "=r,R<>")
        (unspec_volatile:P16PMP
          [(mem:P16PMP (match_operand:HI 1 "pic30_register_operand" "r,r"))
           (reg:HI PSVPAG)]
          UNSPECV_PSVRDPROG))
  ]
  ""
  "@
   mov [%1],%0
   mov [%1],%0"
  [
    (set_attr "type" "defuse,use")
  ]
)

(define_insn "P24PSVread_<mode>"
  [(set (match_operand:M32BIT 0 "pic30_mode2_operand"             "=&r,R")
        (unspec_volatile:M32BIT
          [(mem:M32BIT (match_operand:HI 1 "pic30_register_operand" "r,r"))
           (reg:HI PSVPAG)]
          UNSPECV_PSVRDPSV))
  ]
  ""
  "*
   {
     static char *patterns[] = {
       \"mov [%1++],%0\;mov [%1--],%d0\",
       \"mov [%1++],%I0\;mov [%1--],%D0\"
     };

     static char *psv_psv_patterns[] = {
       \"mov [%1++],%0\;nop\;mov [%1--],%d0\",
       \"mov [%1++],%I0\;nop\;mov [%1--],%D0\"
     };

     if (pic30_errata_mask & psrd_psrd_errata) {
       pic30_rtx_nops++;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     }
   }"
  [
    (set_attr "type" "defuse,use")
  ]
)

(define_insn "P24PROGread_<mode>"
  [(set (match_operand:M32BIT 0 "pic30_mode2_operand"             "=&r,R")
        (unspec_volatile:M32BIT
          [(mem:M32BIT (match_operand:HI 1 "pic30_register_operand" "r,r"))
           (reg:HI PSVPAG)]
          UNSPECV_PSVRDPROG))
   (clobber (reg:HI PSVPAG))
   (clobber (match_dup 1))
  ]
  ""
  "*
   {
     char *results[] = {
                       \"mov [%1++],%0\;btss %1,#15\;inc _PSVPAG\;\"
                           \"bset %1,#15\;mov [%1],%d0\",
                       \"mov [%1++],%I0\;btss %1,#15\;inc _PSVPAG\;\"
                           \"bset %1,#15\;mov [%1],%D0\"
                     };
     char *edsresults[] = {
                       \"mov [%1++],%0\;btss %1,#15\;inc _DSRPAG\;\"
                           \"bset %1,#15\;mov [%1],%d0\",
                       \"mov [%1++],%I0\;btss %1,#15\;inc _DSRPAG\;\"
                           \"bset %1,#15\;mov [%1],%D0\"
                     };

     if (pic30_eds_target()) return edsresults[which_alternative];
     return results[which_alternative];
   }"
  [
    (set_attr "type" "defuse,use")
  ]
)

(define_insn "P24PROGread_<mode>"
  [(set (match_operand:M64BIT 0 "pic30_mode2_operand"             "=&r,R")
        (unspec_volatile:M64BIT
          [(mem:M64BIT (match_operand:HI 1 "pic30_register_operand" "r,r"))
           (reg:HI PSVPAG)]
          UNSPECV_PSVRDPROG))
   (clobber (reg:HI PSVPAG))
   (clobber (match_dup 1))
  ]
  ""
  "*
   {
     char *results[] = {
                       \"mov [%1++],%0\;btss %1,#15\;inc _PSVPAG\;\"
                           \"bset %1,#15\;mov [%1++],%d0\;btss %1,#15\;\"
                           \"inc _PSVPAG\;bset %1,#15\;mov [%1++],%t0\;\"
                           \"btss %1,#15\;inc _PSVPAG\;bset %1,#15\;\"
                           \"mov [%1],%q0\",
                       \"mov [%1++],%I0\;btss %1,#15\;inc _PSVPAG\;\"
                           \"bset %1,#15\;mov [%1++],%I0\;btss %1,#15\;\"
                           \"inc _PSVPAG\;bset %1,#15\;mov [%1++],%I0\;\"
                          \"btss %1,#15\;inc _PSVPAG\;bset %1,#15\;mov [%1],%0\"
                     };
     char *edsresults[] = {
                       \"mov [%1++],%0\;btss %1,#15\;inc _DSRPAG\;\"
                           \"bset %1,#15\;mov [%1++],%d0\;btss %1,#15\;\"
                           \"inc _DSRPAG\;bset %1,#15\;mov [%1++],%t0\;\"
                           \"btss %1,#15\;inc _DSRPAG\;bset %1,#15\;\"
                           \"mov [%1],%q0\",
                       \"mov [%1++],%I0\;btss %1,#15\;inc _DSRPAG\;\"
                           \"bset %1,#15\;mov [%1++],%I0\;btss %1,#15\;\"
                           \"inc _DSRPAG\;bset %1,#15\;mov [%1++],%I0\;\"
                          \"btss %1,#15\;inc _PSVPAG\;bset %1,#15\;mov [%1],%0\"
                     };
     if (pic30_eds_target()) return edsresults[which_alternative];
     return results[which_alternative];
   }"
  [
    (set_attr "type" "defuse,use")
  ]
)

(define_insn "P24PSVread_<mode>"
  [(set (match_operand:M64BIT 0 "pic30_mode2_operand"             "=&r,R")
        (unspec_volatile:M64BIT
          [(mem:M64BIT (match_operand:HI 1 "pic30_register_operand" "r,r"))
           (reg:HI PSVPAG)]
          UNSPECV_PSVRDPSV))
   (clobber (match_dup 1))
  ]
  ""
  "*
   {
     static char *patterns[] = {
       \"mov [%1++],%0\;mov [%1++],%d0\;mov [%1++],%t0\;mov [%1],%q0\",
       \"mov [%1++],%I0\;mov [%1++],%I0\;mov [%1++],%I0\;mov [%1],%0\"
     };

     static char *psv_psv_patterns[] = {
       \"mov [%1++],%0\;nop\;mov [%1++],%d0\;nop\;mov [%1++],%t0\;nop\;mov [%1],%q0\",
       \"mov [%1++],%I0\;nop\;mov [%1++],%I0\;nop\;mov [%1++],%I0\;nop\;mov [%1],%0\"
     };

     if (pic30_errata_mask & psrd_psrd_errata) {
       pic30_rtx_nops += 3;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     }
   }"
  [
    (set_attr "type" "defuse,use")
  ]
)

; EDSread

(define_insn "P32EDSread_qi"
  [(set (match_operand:QI 0 "pic30_mode2_operand"   "=r,r,  R<>,R<>")
        (unspec_volatile:QI
          [(match_operand:QI 1 "pic30_mode2_operand" "r,R<>,r,  R<>")
           (reg:HI PSVPAG)]
          UNSPECV_EDSRD))
  ]
  ""
  "@
   mov.b %1,%0
   mov.b %1,%0
   mov.b %1,%0
   mov.b %1,%0"
  [
    (set_attr "type" "def,defuse,use,use")
  ]
)

(define_insn "P32EDSread_hi"
  [(set (match_operand:HI 0 "pic30_mode2_operand"   "=r,r,  R<>,R<>")
        (unspec_volatile:HI
          [(match_operand:HI 1 "pic30_mode2_operand" "r,R<>,r,  R<>")
           (reg:HI PSVPAG)]
          UNSPECV_EDSRD))
  ]
  ""
  "@
   mov %1,%0
   mov %1,%0
   mov %1,%0
   mov %1,%0"
  [
    (set_attr "type" "def,defuse,use,use")
  ]
)

(define_insn "P32EDSread_p16apsv"
  [(set (match_operand:P16APSV 0 "pic30_mode2_operand"   "=r,r,  R<>,R<>")
        (unspec_volatile:P16APSV
          [(match_operand:P16APSV 1 "pic30_mode2_operand" "r,R<>,r,  R<>")
           (reg:HI PSVPAG)]
          UNSPECV_EDSRD))
  ]
  ""
  "@
   mov %1,%0
   mov %1,%0
   mov %1,%0
   mov %1,%0"
  [
    (set_attr "type" "def,defuse,use,use")
  ]
)

(define_insn "P32EDSread_p16pmp"
  [(set (match_operand:P16PMP 0 "pic30_mode2_operand"   "=r,r,  R<>,R<>")
        (unspec_volatile:P16PMP
          [(match_operand:P16PMP 1 "pic30_mode2_operand" "r,R<>,r,  R<>")
           (reg:HI PSVPAG)]
          UNSPECV_EDSRD))
  ]
  ""
  "@
   mov %1,%0
   mov %1,%0
   mov %1,%0
   mov %1,%0"
  [
    (set_attr "type" "def,defuse,use,use")
  ]
)

; The general process for incrementing an EDS pointer (PAGE:offset) in 
;   current devices is
;
;  mov x, [offset]            ; read (or write) data
;  inc2 offset, offset        ; increment for next offset
;  bra nc,1f                  ; carry clear we are finished
;  bset offset,#15            ; put us back into EDS range
;  inc PAGE                   ; update PAGE
;  1:

;
;  for RAW stall detection watch out for implicit mems
;

(define_insn "P32EDSread_eds_<mode>"
  [(set (match_operand:M32BIT 0 "pic30_mode2_operand"      "=&r,R")
        (unspec_volatile:M32BIT
          [(match_operand:HI 1 "pic30_register_operand" " r,r")
           (reg:HI PSVPAG)]
          UNSPECV_EDSRD))
   (clobber (reg:HI PSVPAG))
   (clobber (match_dup 1))
  ]
  ""
  "*
   {
     char *edsresults[] = { 
                       \"mov [%1],%0\;inc2 %1,%1\;bra nc,.L1_%=\;\"
                           \"bset %1,#15\;inc _DSRPAG\;\"
                           \".L1_%=: mov [%1],%d0\",
                       \"mov [%1],%I0\;inc2 %1,%1\;bra nc,.L1_%=\;\"
                           \"bset %1,#15\;inc _DSRPAG\;\"
                           \".L1_%=: mov [%1],%D0\"
                     };

     return edsresults[which_alternative];
   }"
  [
    (set_attr "type" "defuse,use")
  ]
)

(define_insn "P32EDSread_noeds_<mode>"
  [(set (match_operand:M32BIT 0 "pic30_mode2_operand"      "=&r,R")
        (unspec_volatile:M32BIT
          [(match_operand:HI 1 "pic30_register_operand" " r,r")
           (reg:HI PSVPAG)]
          UNSPECV_NOEDSRD))
   (clobber (reg:HI PSVPAG))
   (clobber (match_dup 1))
  ]
  ""
  "*
   {
     char *results[] = { 
                       \"mov [%1],%0\;inc2 %1,%1\;bra nc,.L1_%=\;\"
                           \"bset %1,#15\;inc _PSVPAG\;\"
                           \".L1_%=: mov [%1],%d0\",
                       \"mov [%1],%I0\;inc2 %1,%1\;bra nc,.L1_%=\;\"
                           \"bset %1,#15\;inc _PSVPAG\;\"
                           \".L1_%=: mov [%1],%D0\"
                     };

     return results[which_alternative];
   }"
  [
    (set_attr "type" "defuse,use")
  ]
)

(define_expand "P32EDSread_<mode>"
  [(set (match_operand:M32BIT 0 "pic30_mode2_operand" "=&r,R")
        (unspec_volatile:M32BIT
          [(match_operand:M32BIT 1 "pic30_R_operand" " R,R")
           (reg:HI PSVPAG)]
          UNSPECV_EDSRD))]
  ""
  "
{
  if (pic30_eds_target()) {
    emit(gen_P32EDSread_eds_<mode>(operands[0],XEXP(operands[1],0)));
  } else {
    emit(gen_P32EDSread_noeds_<mode>(operands[0],XEXP(operands[1],0)));
  }
  DONE;
}")

(define_insn "P32EDSread_eds_<mode>"
  [(set (match_operand:M64BIT 0 "pic30_register_operand"   "=&r")
        (unspec_volatile:M64BIT
          [(match_operand:HI 1 "pic30_register_operand" " r")
           (reg:HI PSVPAG)]
          UNSPECV_EDSRD))
   (clobber (reg:HI PSVPAG))
   (clobber (match_dup 1))
  ]
  ""
  "*
   {
     char *edsresults[] = {
                     \"mov [%1],%0\;inc2 %1,%1\;bra nc,.L1_%=\;\"
                         \"bset %1,#15\;inc _DSRPAG\;\"
                         \".L1_%=: \"
                     \"mov [%1],%d0\;inc2 %1,%1\;bra nc,.L2_%=\;\"
                         \"bset %1,#15\;inc _DSRPAG\;\"
                         \".L2_%=: \"
                     \"mov [%1],%t0\;inc2 %1,%1\;bra nc,.L3_%=\;\"
                         \"bset %1,#15\;inc _DSRPAG\;\"
                         \".L3_%=: \"
                     \"mov [%1],%q0\",
                     \"mov [%1],%I0\;inc2 %1,%1\;bra nc,.L1_%=\;\"
                         \"bset %1,#15\;inc _DSRPAG\;\"
                         \".L1_%=: \"
                     \"mov [%1],%I0\;inc2 %1,%1\;bra nc,.L2_%=\;\"
                         \"bset %1,#15\;inc _DSRPAG\;\"
                         \".L2_%=: \"
                     \"mov [%1],%I0\;inc2 %1,%1\;bra nc,.L3_%=\;\"
                         \"bset %1,#15\;inc _DSRPAG\;\"
                         \".L3_%=: \"
                     \"mov [%1],%0\"
                   };

     return edsresults[0];
   }"
   [
      (set_attr "type" "defuse")
   ]
)

(define_insn "P32EDSread_noeds_<mode>"
  [(set (match_operand:M64BIT 0 "pic30_register_operand"   "=&r")
        (unspec_volatile:M64BIT
          [(match_operand:HI 1 "pic30_register_operand" " r")
           (reg:HI PSVPAG)]
          UNSPECV_NOEDSRD))
   (clobber (reg:HI PSVPAG))
   (clobber (match_dup 1))
  ]
  ""
  "*
   {
     char *results[] = {
                     \"mov [%1],%0\;inc2 %1,%1\;bra nc,.L1_%=\;\"
                         \"bset %1,#15\;inc _PSVPAG\;\"
                         \".L1_%=: \"
                     \"mov [%1],%d0\;inc2 %1,%1\;bra nc,.L2_%=\;\"
                         \"bset %1,#15\;inc _PSVPAG\;\"
                         \".L2_%=: \"
                     \"mov [%1],%t0\;inc2 %1,%1\;bra nc,.L3_%=\;\"
                         \"bset %1,#15\;inc _PSVPAG\;\"
                         \".L3_%=: \"
                     \"mov [%1],%q0\",
                     \"mov [%1],%I0\;inc2 %1,%1\;bra nc,.L1_%=\;\"
                         \"bset %1,#15\;inc _PSVPAG\;\"
                         \".L1_%=: \"
                     \"mov [%1],%I0\;inc2 %1,%1\;bra nc,.L2_%=\;\"
                         \"bset %1,#15\;inc _PSVPAG\;\"
                         \".L2_%=: \"
                     \"mov [%1],%I0\;inc2 %1,%1\;bra nc,.L3_%=\;\"
                         \"bset %1,#15\;inc _PSVPAG\;\"
                         \".L3_%=: \"
                     \"mov [%1],%0\"
                   };

     return results[0];
   }"
  [
    (set_attr "type" "defuse")
  ]
)

(define_expand "P32EDSread_<mode>"
  [(set (match_operand:M64BIT 0 "pic30_register_operand" "=&r")
        (unspec_volatile:M64BIT
          [(match_operand:M64BIT 1 "pic30_R_operand" " R")
           (reg:HI PSVPAG)]
          UNSPECV_EDSRD))
  ]
  ""
  "
{
   if (pic30_eds_target()) {
     emit(gen_P32EDSread_eds_<mode>(operands[0],XEXP(operands[1],0)));
   } else {
     emit(gen_P32EDSread_noeds_<mode>(operands[0],XEXP(operands[1],0)));
   }
   DONE;
}"
)

; P32EDSwrite

(define_insn "P32EDSwrite_qi"
  [(set (match_operand:QI 0 "pic30_R_operand" "=R")
        (unspec_volatile:QI
          [(match_operand:QI 1 "pic30_mode2_operand" "rR<>")
           (reg:HI DSWPAG)]
          UNSPECV_EDSWT))
  ]
  ""
  "mov.b %1,%0"
  [
    (set_attr "type" "use")
  ]
)
(define_insn "P32EDSwrite_p16pmp"
  [(set (match_operand:P16PMP 0 "pic30_R_operand" "=R")
        (unspec_volatile:P16PMP
          [(match_operand:P16PMP 1 "pic30_mode2_operand" "rR<>")
           (reg:HI DSWPAG)]
          UNSPECV_EDSWT))
  ]
  ""
  "mov %1,%0"
  [
    (set_attr "type" "use")
  ]
)

(define_insn "P32EDSwrite_p16apsv"
  [(set (match_operand:P16APSV 0 "pic30_R_operand" "=R")
        (unspec_volatile:P16APSV
          [(match_operand:P16APSV 1 "pic30_mode2_operand" "rR<>")
           (reg:HI DSWPAG)]
          UNSPECV_EDSWT))
  ]
  ""
  "mov %1,%0"
  [
    (set_attr "type" "use")
  ]
)

(define_insn "P32EDSwrite_hi"
  [(set (match_operand:HI 0 "pic30_R_operand" "=R")
        (unspec_volatile:HI
          [(match_operand:HI 1 "pic30_mode2_operand" "rR<>")
           (reg:HI DSWPAG)]
          UNSPECV_EDSWT))
  ]
  ""
  "mov %1,%0"
  [
    (set_attr "type" "use")
  ]
)

(define_insn "P32EDSwrite_eds_<mode>"
  [(set (mem:M32BIT (match_operand:HI 0 "pic30_register_operand" "r,r"))
        (unspec_volatile:M32BIT
          [(match_operand:M32BIT 1 "pic30_mode2_operand" "r,R")
           (reg:HI DSWPAG)]
          UNSPECV_EDSWT))
   (clobber (reg:HI DSWPAG))
   (clobber (match_dup 0))
  ]
  ""
  "*
   {
     char *edsresults[] = { 
                     \"mov %1,[%0]\;inc2 %0,%0\;bra nc,.L1_%=\;\"
                         \"bset %0,#15\;inc _DSWPAG\;\"
                         \".L1_%=: mov %d1,[%0]\",
                     \"mov %I1,[%0]\;inc2 %0,%0\;bra nc,.L1_%=\;\"
                         \"bset %0,#15\;inc _DSWPAG\;\"
                         \".L1_%=: mov %D1,[%0]\",
                   };
     return edsresults[which_alternative];
   }"
  [
    (set_attr "type" "use")
  ]
)

(define_insn "P32EDSwrite_noeds_<mode>"
  [(set (match_operand:M32BIT 0 "pic30_R_operand" "=R,R")
        (unspec_volatile:M32BIT
          [(match_operand:M32BIT 1 "pic30_mode2_operand" "r,R")]
          UNSPECV_EDSWT))
   (clobber (reg:HI DSWPAG))
  ]
  ""
  "*
   {
     char *results[] = { \"mov %1,%I0\;mov %d1,%D0\",
                         \"mov %I1,%I0\;mov %D1,%D0\" };

     char *psv_psv_results[] = { \"mov %1,%I0\;mov %d1,%D0\",
                                 \"mov %I1,%I0\;nop\;mov %D1,%D0\" };
                     
     if (pic30_psrd_psrd_errata(operands[0],NULL)) {
       pic30_rtx_nops++;
       return psv_psv_results[which_alternative];
     } else {
       return results[which_alternative];
     }
   }"
  [
    (set_attr "type" "use")
  ]
)

(define_expand "P32EDSwrite_<mode>"
  [(set (match_operand:M32BIT 0 "pic30_R_operand" "=R,R")
        (unspec_volatile:M32BIT
          [(match_operand:M32BIT 1 "pic30_mode2_operand" "r,R")
           (reg:HI DSWPAG)]
          UNSPECV_EDSWT))
  ]
  ""
  "
   {
     if (pic30_eds_target()) {
       emit(gen_P32EDSwrite_eds_<mode>(XEXP(operands[0],0),operands[1]));
     } else {
       emit(gen_P32EDSwrite_noeds_<mode>(operands[0],operands[1]));
     }
     DONE;
   }"
)

(define_insn "P32EDSwrite_eds_<mode>"
  [(set (mem:M64BIT (match_operand:HI 0 "pic30_register_operand" "r,r"))
        (unspec_volatile:M64BIT
          [(match_operand:M64BIT 1 "pic30_mode2_operand"         "r,R")
           (reg:HI DSWPAG)]
          UNSPECV_EDSWT))
   (clobber (reg:HI DSWPAG))
   (clobber (match_dup 0))
   (clobber (match_dup 1))
  ]
  ""
  "*
   {
     char *edsresults[] = {
                     \"mov %1,[%0]\;inc2 %0,%0\;bra nc,.L1_%=\;\"
                         \"bset %0,#15\;inc _DSWPAG\;\"
                         \".L1_%=: \"
                     \"mov %d1,[%0]\;inc2 %0,%0\;bra nc,.L2_%=\;\"
                         \"bset %0,#15\;inc _DSWPAG\;\"
                         \".L2_%=: \"
                     \"mov %t1,[%0]\;inc2 %0,%0\;bra nc,.L3_%=\;\"
                         \"bset [%0],#15\;inc _DSWPAG\;\"
                         \".L3_%=: \"
                     \"mov %q1,[%0]\",
                     \"mov %I1,[%0]\;inc2 %0,%0\;bra nc,.L1_%=\;\"
                         \"bset %0,#15\;inc _DSWPAG\;\"
                         \".L1_%=: \"
                     \"mov %I1,[%0]\;inc2 %0,%0\;bra nc,.L2_%=\;\"
                         \"bset %0,#15\;inc _DSWPAG\;\"
                         \".L2_%=: \"
                     \"mov %I1,[%0]\;inc2 %0,%0\;bra nc,.L3_%=\;\"
                         \"bset %0,#15\;inc _DSWPAG\;\"
                         \".L3_%=: \"
                     \"mov %1,[%0]\"
                   };

     return edsresults[which_alternative];
  }"
  [
    (set_attr "type" "use")
  ]
)

(define_insn "P32EDSwrite_noeds_<mode>"
  [(set (match_operand:M64BIT 0 "pic30_R_operand"       "=R,R")
        (unspec_volatile:M64BIT
          [(match_operand:M64BIT 1 "pic30_mode2_operand" "r,R")]
          UNSPECV_EDSWT))
   (clobber (reg:HI DSWPAG))
   (clobber (match_dup 0))
   (clobber (match_dup 1))
  ]
  ""
  "*
   {
     char *results[] ={ 
        \"mov.d %1,%I0\;mov.d %t1,%D0\",
        \"mov %I1,%I0\;mov %I1,%I0\;mov %I1,%I0\;mov %I1,%I0\"
     };

     char *psv_psv_results[] ={ 
        \"mov.d %1,%I0\;mov.d %t1,%D0\",
        \"mov %I1,%I0\;nop\;mov %I1,%I0\;nop\;mov %I1,%I0\;nop\;mov %I1,%I0\"
     };

     if (pic30_psrd_psrd_errata(operands[0],NULL)) {
       pic30_rtx_nops+=3;
       return psv_psv_results[which_alternative];
     } else {
       return results[which_alternative];
     }
   }"
  [
    (set_attr "type" "use")
  ]
)

(define_expand "P32EDSwrite_<mode>"
  [(set (match_operand:M64BIT 0 "pic30_R_operand" "=R,R")
        (unspec_volatile:M64BIT
          [(match_operand:M64BIT 1 "pic30_mode2_operand" "r,R")
           (reg:HI DSWPAG)]
          UNSPECV_EDSWT))
  ]
  ""
  "
  {
    if (pic30_eds_target()) {
      emit(gen_P32EDSwrite_eds_<mode>(XEXP(operands[0],0),operands[1]));
    } else {
      emit(gen_P32EDSwrite_noeds_<mode>(operands[0],operands[1]));
    }
    DONE;
  }"
)

; PEDSread

(define_insn "P32PEDSread_qi"
  [(set (match_operand:QI 0 "pic30_mode2_operand" "=r,R")
        (unspec_volatile:QI
          [(match_operand:QI 1 "pic30_R_operand"   "R,R")
           (reg:HI PSVPAG)]
          UNSPECV_PEDSRD))
  ]
  ""
  "@
   mov.b %1,%0
   mov.b %1,%0"
  [
    (set_attr "type" "defuse,use")
  ]
)

(define_insn "P32PEDSread_hi"
  [(set (match_operand:HI 0 "pic30_mode2_operand" "=r,R<>")
        (unspec_volatile:HI
          [(match_operand:HI 1 "pic30_R_operand"   "R,R")
           (reg:HI PSVPAG)]
          UNSPECV_PEDSRD))
  ]
  ""
  "@
   mov %1,%0
   mov %1,%0"
  [
    (set_attr "type" "defuse,use")
  ]
)

(define_insn "P32PEDSuread_hi"
  [(set (match_operand:HI 0 "pic30_mode2_operand"     "=rR<>,r")
        (unspec_volatile:HI
          [(match_operand 1 "pic30_unified_mode2k_operand"  "R<>,Q")
           (reg:HI PSVPAG)]
          UNSPECV_PEDSRD))
  ]
  ""
  "@
   mov %1,%0
   mov %1,%0"
  [
    (set_attr "type" "defuse,use")
  ]
)

(define_insn "P32PEDSread_p16apsv"
  [(set (match_operand:P16APSV 0 "pic30_mode2_operand" "=r,R<>")
        (unspec_volatile:P16APSV
          [(match_operand:P16APSV 1 "pic30_R_operand"  " R,R")
           (reg:HI PSVPAG)]
          UNSPECV_PEDSRD))
  ]
  ""
  "@
   mov %1,%0
   mov %1,%0"
  [
    (set_attr "type" "defuse,use")
  ]
)

(define_insn "P32PEDSread_p16pmp"
  [(set (match_operand:P16PMP 0 "pic30_mode2_operand" "=r,R<>")
        (unspec_volatile:P16PMP
          [(match_operand:P16PMP 1 "pic30_R_operand"   "R,R")
           (reg:HI PSVPAG)]
          UNSPECV_PEDSRD))
  ]
  ""
  "@
   mov %1,%0
   mov %1,%0"
  [
    (set_attr "type" "defuse,use")
  ]
)

; The general process for incrementing an PEDS pointer (PAGE:offset) in 
;   current devices is straightforward as the data they are pointing to 
;   does not cross a page
 
/*VRT: Need optimized fix for psrd psrd*/
(define_insn "P32PEDSread_<mode>"
  [(set (match_operand:M32BIT 0 "pic30_mode2_operand" "=&r,R")
        (unspec_volatile:M32BIT
          [(match_operand:M32BIT 1 "pic30_R_operand"    "R,R")
           (reg:HI PSVPAG)]
          UNSPECV_PEDSRD))
  ]
  ""
  "*
   {
     static char *patterns[] = {
       \"mov %I1,%0\;mov %D1,%d0\",
       \"mov %I1,%I0\;mov %D1,%D0\"
     };

     static char *psv_psv_patterns[] = {
       \"mov %I1,%0\;mov %D1,%d0\",
       \"mov %I1,%I0\;nop\;mov %D1,%D0\"
     };
     
     if (pic30_psrd_psrd_errata(operands[1],NULL)) {
       pic30_rtx_nops++;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     }
   }"
  [
    (set_attr "type" "defuse,use")
  ]
)

/*VRT: Need optimized fix for psrd psrd*/
(define_insn "P32PEDSuread_<mode>"
  [(set (match_operand:M32BIT 0 "pic30_mode2_operand"     "=&r,R,&r")
        (unspec_volatile:M32BIT
          [(match_operand 1 "pic30_unified_mode2k_operand"  " R,R, Q")
           (reg:HI PSVPAG)]
          UNSPECV_PEDSRD))
  ]
  ""
  "*
   {
     static char *patterns[] = {
       \"mov %I1,%0\;mov %D1,%d0\",
       \"mov %I1,%I0\;mov %D1,%D0\",
       \"mov %1,%0\;mov %Q1,%d0\"
     };

     static char *psv_psv_patterns[] = {
       \"mov %I1,%0\;mov %D1,%d0\",
       \"mov %I1,%I0\;nop\;mov %D1,%D0\",
       \"mov %1,%0\;nop\;mov %Q1,%d0\"
     };
 
     if (pic30_psrd_psrd_errata(operands[1],NULL)) {
       pic30_rtx_nops++;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     }
   }"
  [
    (set_attr "type" "defuse,use,defuse")
  ]
)

/*VRT: Need optimized fix for psrd psrd*/
(define_insn "P32PEDSread_<mode>"
  [(set (match_operand:M64BIT 0 "pic30_mode2_operand" "=&r,R")
        (unspec_volatile:M64BIT
          [(match_operand:M64BIT 1 "pic30_R_operand"    "R,R")
           (reg:HI PSVPAG)]
          UNSPECV_PEDSRD))
   (clobber (match_dup 1))
  ]
  ""
  "*
   {
     static char *patterns[] = {
       \"mov.d %I1,%0\;mov.d %D1,%t0\",
       \"mov %I1,%I0\;mov %I1,%I0\;mov %I1,%I0\;mov %1,%0\"
     };

     static char *psv_psv_movd_patterns[] = {
       \"mov %I1,%0\;mov %I1,%d0\;mov %I1,%t0\;mov %1,%q0\"
       \"mov %I1,%I0\;mov %I1,%I0\;mov %I1,%I0\;mov %1,%0\"
     };

     static char *psv_psv_patterns[] = {
       \"mov.d %I1,%0\;nop\;mov.d %D1,%t0\",
       \"mov %I1,%I0\;nop\;mov %I1,%I0\;nop\;mov %I1,%I0\;nop\;mov %1,%0\"
     };

     if (pic30_psrd_psrd_errata_movd(operands[1],NULL)) {
       return psv_psv_movd_patterns[which_alternative];
     } else if (pic30_psrd_psrd_errata(operands[1],NULL)) {
       pic30_rtx_nops+=3;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     };
   }"
  [
    (set_attr "type" "defuse,use")
  ]
)

; P32PEDSwrite

(define_insn "P32PEDSwrite_qi"
  [(set (match_operand:QI 0 "pic30_R_operand"       "=R")
        (unspec_volatile:QI
          [(match_operand:QI 1 "pic30_mode2_operand" "rR<>")
           (reg:HI DSWPAG)]
          UNSPECV_PEDSWT))
  ]
  ""
  "mov.b %1,%0"
  [
    (set_attr "type" "use")
  ]
)
(define_insn "P32PEDSwrite_p16pmp"
  [(set (match_operand:P16PMP 0 "pic30_R_operand"       "=R")
        (unspec_volatile:P16PMP
          [(match_operand:P16PMP 1 "pic30_mode2_operand" "rR<>")
           (reg:HI DSWPAG)]
          UNSPECV_PEDSWT))
  ]
  ""
  "mov %1,%0"
  [
    (set_attr "type" "use")
  ]
)

(define_insn "P32PEDSwrite_p16apsv"
  [(set (match_operand:P16APSV 0 "pic30_R_operand"       "=R")
        (unspec_volatile:P16APSV
          [(match_operand:P16APSV 1 "pic30_mode2_operand" "rR<>")
           (reg:HI DSWPAG)]
          UNSPECV_PEDSWT))
  ]
  ""
  "mov %1,%0"
  [
    (set_attr "type" "use")
  ]
)

(define_insn "P32PEDSwrite_hi"
  [(set (match_operand:HI 0 "pic30_R_operand"       "=R")
        (unspec_volatile:HI
          [(match_operand:HI 1 "pic30_mode2_operand" "rR<>")
           (reg:HI DSWPAG)]
          UNSPECV_PEDSWT))
  ]
  ""
  "mov %1,%0"
  [
    (set_attr "type" "use")
  ]
)

(define_insn "P32PEDSuwrite_hi"
  [(set (match_operand:HI 0 "pic30_unified_mode2k_operand"  "=R<>, Q")
        (unspec_volatile:HI
          [(match_operand:HI 1 "pic30_mode2_operand"        " rR<>,r")
           (reg:HI DSWPAG)]
          UNSPECV_PEDSWT))
  ]
  ""
  "@
   mov %1,%0
   mov %1,%0"
  [
    (set_attr "type" "use")
  ]
)

; P32PEDS does not cross a page boundary

(define_insn "P32PEDSwrite_<mode>"
  [(set (match_operand:M32BIT 0 "pic30_R_operand"       "=R,R")
        (unspec_volatile:M32BIT
          [(match_operand:M32BIT 1 "pic30_mode2_operand" "r,R")
           (reg:HI DSWPAG)]
          UNSPECV_PEDSWT))
  ]
  ""
  "*
   {
     static char *patterns[] = {
       \"mov.d %1,%0\",
       \"mov %I1,%I0\;mov %D1,%D0\"
     };

     static char *psv_psv_patterns[] = {
       \"mov.d %1,%0\",
       \"mov %I1,%I0\;nop\;mov %D1,%D0\"
     };
 
     if (pic30_psrd_psrd_errata(operands[1],NULL)) {
       pic30_rtx_nops++;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     }
   }"
  [
    (set_attr "type" "use")
  ]
)

(define_insn "P32PEDSuwrite_<mode>"
  [(set (match_operand:M32BIT 0 "pic30_unified_mode2k_operand" "=R,R,Q")
        (unspec_volatile:M32BIT
          [(match_operand:M32BIT 1 "pic30_mode2_operand"        " r,R,r")
           (reg:HI DSWPAG)]
          UNSPECV_PEDSWT))
  ]
  ""
  "*
   {
     static char *patterns[] = {
       \"mov.d %1,%0\",
       \"mov %I1,%I0\;mov %D1,%D0\",
       \"mov %1,%0\;mov %d1,%Q0\"
     };

     static char *psv_psv_patterns[] = {
       \"mov.d %1,%0\",
       \"mov %I1,%I0\;nop\;mov %D1,%D0\",
       \"mov %1,%0\;mov %d1,%Q0\"
     };

     if (pic30_psrd_psrd_errata(operands[1],NULL)) {
       pic30_rtx_nops++;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     }
   }"
  [
    (set_attr "type" "use")
  ]
)

(define_insn "P32PEDSwrite_<mode>"
  [(set (match_operand:M64BIT 0 "pic30_R_operand"       "=R,R")
        (unspec_volatile:M64BIT
          [(match_operand:M64BIT 1 "pic30_mode2_operand" "r,R")
           (reg:HI DSWPAG)]
          UNSPECV_PEDSWT))
   (clobber (reg:HI DSWPAG))
   (clobber (match_dup 1))
  ]
  ""
  "*
   {
     static char *patterns[] = {
       \"mov.d %1,%I0\;mov.d %t1,%D0\",
       \"mov %I1,%I0\;mov %I1,%I0\;mov %I1,%I0\;mov %1,%0\" 
     };

     static char *psv_psv_patterns[] = {
       \"mov.d %1,%I0\;mov.d %t1,%D0\",
       \"mov %I1,%I0\;nop\;mov %I1,%I0\;nop\;mov %I1,%I0\;nop\;mov %1,%0\" 
     };

     if (pic30_psrd_psrd_errata(operands[1],NULL)) {
       pic30_rtx_nops+=3;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     }
   }"
  [
    (set_attr "type" "use")
  ]
)

;
; funky addition
;   shift up low words first so that we don't have to worry about PSV enable bit
;   add
;   check for upper word being zero
;   zero -> 0 in upper bit 1 otherwise ... set carry 
;   shift it in

(define_insn "addp32eds3_lit"
  [(set (match_operand: P32EDS  0 "pic30_register_operand" "=r,r")
        (plus: P32EDS
          (match_operand:P32EDS 1 "pic30_register_operand" " 0,0")
          (match_operand:P32EDS 2 "pic30_OJM_operand"      " PJ,M")))
   (clobber (match_scratch:HI   3                          "=&r,&r"))
  ]
  ""
  "@
   mov %1,%3\;add #%2,%0\;xor %3,%0,%3\;btsc _SR,#3\;bset %0,#15\;rlc %3,%3\;addc #0,%d0
   mov %1,%3\;sub #%J2,%0\;xor %3,%0,%3\;lsr %3,#15,%3\;sub %d0,%3,%d0\;btss _SR,#1\;bset %0,#15"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def")
  ]
)

(define_insn "addp32eds3_r"
  [(set (match_operand: P32EDS   0 "pic30_register_operand" "=r,&r")
        (plus: P32EDS
          (match_operand:P32EDS  1 "pic30_register_operand" "%r,0")
          (match_operand:P32EDS  2 "pic30_mode2_operand"    "r,R")))
   (clobber (match_scratch:HI 3                             "=&r,&r"))
   (clobber (match_scratch:HI 4                             "=&r,&r"))
  ]
  ""
  "@
   sl %1,%3\;sl %2,%4\;add %3,%4,%0\;bset _SR,#1\;addc %d1,%d2,%d0\;bclr _SR,#0\;btss _SR,#1\;bset _SR,#0\;rrc %0,%0
   sl %1,%3\;sl %I2,%4\;add %3,%4,%0\;bset _SR,#1\;addc %d1,%D2,%d0\;bclr _SR,#0\;btss _SR,#1\;bset _SR,#0\;rrc %0,%0"
  [
    (set_attr "type" "def")
  ]
)

(define_expand "addp32eds3"
  [(set (match_operand:P32EDS 0 "pic30_register_operand" "")
        (plus: P32EDS (match_operand:P32EDS 1 "pic30_register_operand" "")
                      (match_operand:P32EDS 2 "pic30_mode1i_operand" "")))]
  ""
  "
{  rtx (*gen)(rtx,rtx,rtx) = gen_addp32eds3_r;

   if (GET_CODE(operands[2]) == CONST_INT) {
#if 0
     int val = INTVAL(operands[2]);
     rtx new_val = GEN_INT(val << 1);
#endif
     rtx new_val = operands[2];
     if (pic30_OJM_operand(new_val, HImode)) {
       emit_insn(gen_addp32eds3_lit(operand0,operand1,operand2));
       DONE;
     } else {
       /* load the immediate separately */
       rtx result = gen_reg_rtx(P32EDSmode);

       emit_insn(gen_movp32eds_lit(result, new_val));
       emit_insn(gen(operand0, operand1, result));
       DONE;
     }
   }
   emit_insn(gen(operand0,operand1,operand2));
   DONE;
}")

;
;  Paged arithmetic doesn't cross a page boundary, add low part only
;

(define_insn "addp32peds3"
  [(set (match_operand: P32PEDS  0 "pic30_register_operand"   "=r,r,r,r,r,r,r, r,r")
        (plus: P32PEDS
          (match_operand:P32PEDS 1 "pic30_register_operand"   "%0,r,0,0,r,0,0, r,r")
          (match_operand:P32PEDS 2 "pic30_rR_or_JMNP_operand" " P,P,J,N,N,M,Rr,r,R")
        )
   )]
  ""
  "*
   {
     static char *patterns[] = {
       \"add %1,#%2,%0\",
       \"add %1,#%2,%0\;mov %d1,%d0\",
       \"add #%2,%0\",
       \"sub %1,#%J2,%0\",
       \"sub %1,#%J2,%0\;mov %d1,%d0\",
       \"sub #%J2,%0\",
       \"add %1,%2,%0\",
       \"add %1,%2,%0\;mov %d1,%d0\",
       \"add %1,%I2,%0\;mov %D2,%d0\"
     };

     static char *psv_psv_patterns[] = {
       \"add %1,#%2,%0\",
       \"add %1,#%2,%0\;mov %d1,%d0\",
       \"add #%2,%0\",
       \"sub %1,#%J2,%0\",
       \"sub %1,#%J2,%0\;mov %d1,%d0\",
       \"sub #%J2,%0\",
       \"add %1,%2,%0\",
       \"add %1,%2,%0\;mov %d1,%d0\",
       \"add %1,%I2,%0\;nop\;mov %D2,%d0\"
     };

     if (pic30_psrd_psrd_errata(operands[2],NULL)) {
       pic30_rtx_nops++;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     }
   }"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "etc,etc,etc,etc,etc,etc,use,etc,use")
  ]
)

(define_insn "addp24prog3_DATA"
  [(set (match_operand:P24PROG    0 
             "pic30_mode2_operand"    "=r,r,r,r,r,<>,<>,<>,<>,<>,R,R,R,R,R")
        (plus:P24PROG 
           (match_operand:P24PROG 1 
             "pic30_register_operand" "%r,r,r,r,r,r,r,r,r,r,r,r,r,r,r")
           (match_operand:P24PROG 2 
             "pic30_math_operand"     " r,<>,R,N,P,r,<>,R,N,P,r,<>,R,N,P")))]
  ""
  "*
   {
     static char *patterns[] = {
       \"add %1,%2,%0\;addc %d1,%d2,%d0\",
       \"add %1,%2,%0\;addc %d1,%2,%d0\",
       \"add %1,%I2,%0\;addc %d1,%D2,%d0\",
       \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
       \"add %1,#%2,%0\;addc %d1,#0,%d0\",
       \"add %1,%2,%0\;addc %d1,%d2,%0\",
       \"add %1,%2,%0\;addc %d1,%2,%0\",
       \"add %1,%I2,%0\;addc %d1,%D2,%0\",
       \"sub %1,#%J2,%0\;subb %d1,#0,%0\",
       \"add %1,#%2,%0\;addc %d1,#0,%0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%2,%I0\;addc %d1,%2,%D0\",
       \"add %1,%I2,%I0\;addc %d1,%D2,%D0\",
       \"sub %1,#%J2,%I0\;subb %d1,#0,%D0\",
       \"add %1,#%2,%I0\;addc %d1,#0,%D0\"
     };

     static char *psv_psv_patterns[] = {
       \"add %1,%2,%0\;addc %d1,%d2,%d0\",
       \"add %1,%2,%0\;nop\;addc %d1,%2,%d0\",
       \"add %1,%I2,%0\;nop\;addc %d1,%D2,%d0\",
       \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
       \"add %1,#%2,%0\;addc %d1,#0,%d0\",
       \"add %1,%2,%0\;addc %d1,%d2,%0\",
       \"add %1,%2,%0\;nop\;addc %d1,%2,%0\",
       \"add %1,%I2,%0\;nop\;addc %d1,%D2,%0\",
       \"sub %1,#%J2,%0\;subb %d1,#0,%0\",
       \"add %1,#%2,%0\;addc %d1,#0,%0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%2,%I0\;nop\;addc %d1,%2,%D0\",
       \"add %1,%I2,%I0\;nop\;addc %d1,%D2,%D0\",
       \"sub %1,#%J2,%I0\;subb %d1,#0,%D0\",
       \"add %1,#%2,%I0\;addc %d1,#0,%D0\"
     };

     if (pic30_psrd_psrd_errata(operands[2],NULL)) {
       pic30_rtx_nops++;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     }
   }"
  [
    (set_attr "cc" "math")
    (set_attr "type" "def,defuse,defuse,def,def,use,use,use,use,use,use,use,use,use,use")
  ]
)

(define_insn "addp24prog3_APSV"
  [(set (match_operand:P24PROG    0 
             "pic30_mode2_operand"    "=r,r,r,r,r,<>,<>,<>,<>,<>,R,R,R,R,R")
        (plus:P24PROG 
           (match_operand:P24PROG 1 
             "pic30_register_operand" "%r,r,r,r,r,r,r,r,r,r,r,r,r,r,r")
           (match_operand:P24PROG 2 
             "pic30_math_APSV_operand" " r,<>,R,N,P,r,<>,R,N,P,r,<>,R,N,P")))]
  ""
  "*
   {
     static char *patterns[] = {
       \"add %1,%2,%0\;addc %d1,%d2,%d0\",
       \"add %1,%2,%0\;addc %d1,%2,%d0\",
       \"add %1,%I2,%0\;addc %d1,%D2,%d0\",
       \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
       \"add %1,#%2,%0\;addc %d1,#0,%d0\",
       \"add %1,%2,%0\;addc %d1,%d2,%0\",
       \"add %1,%2,%0\;addc %d1,%2,%0\",
       \"add %1,%I2,%0\;addc %d1,%D2,%0\",
       \"sub %1,#%J2,%0\;subb %d1,#0,%0\",
       \"add %1,#%2,%0\;addc %d1,#0,%0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%2,%I0\;addc %d1,%2,%D0\",
       \"add %1,%I2,%I0\;addc %d1,%D2,%D0\",
       \"sub %1,#%J2,%I0\;subb %d1,#0,%D0\",
       \"add %1,#%2,%I0\;addc %d1,#0,%D0\"
     };

     static char *psv_psv_patterns[] = {
       \"add %1,%2,%0\;addc %d1,%d2,%d0\",
       \"add %1,%2,%0\;nop\;addc %d1,%2,%d0\",
       \"add %1,%I2,%0\;nop\;addc %d1,%D2,%d0\",
       \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
       \"add %1,#%2,%0\;addc %d1,#0,%d0\",
       \"add %1,%2,%0\;addc %d1,%d2,%0\",
       \"add %1,%2,%0\;nop\;addc %d1,%2,%0\",
       \"add %1,%I2,%0\;nop\;addc %d1,%D2,%0\",
       \"sub %1,#%J2,%0\;subb %d1,#0,%0\",
       \"add %1,#%2,%0\;addc %d1,#0,%0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%2,%I0\;nop\;addc %d1,%2,%D0\",
       \"add %1,%I2,%I0\;nop\;addc %d1,%D2,%D0\",
       \"sub %1,#%J2,%I0\;subb %d1,#0,%D0\",
       \"add %1,#%2,%I0\;addc %d1,#0,%D0\"
     };
   
     if (pic30_psrd_psrd_errata(operands[2],NULL)) {
       pic30_rtx_nops++;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     }
   }"
  [
    (set_attr "cc" "math")
    (set_attr "type" "def,defuse,defuse,def,def,use,use,use,use,use,use,use,use,use,use")
  ]
)

(define_expand "addp24prog3"
  [(set (match_operand:P24PROG    0
             "pic30_mode2_operand"    "=r,r,r,r,r,<>,<>,<>,<>,<>,R,R,R,R,R")
        (plus:P24PROG
           (match_operand:P24PROG 1
             "pic30_register_operand" "%r,r,r,r,r,r,r,r,r,r,r,r,r,r,r")
           (match_operand:P24PROG 2
             "pic30_math_APSV_operand" " r,<>,R,N,P,r,<>,R,N,P,r,<>,R,N,P")))]
  ""
  "
{
  if (pic30_math_operand(operands[2],GET_MODE(operands[2])))
    emit(gen_addp24prog3_DATA(operands[0],operands[1],operands[2]));
  else
    emit(gen_addp24prog3_APSV(operands[0],operands[1],operands[2]));
  DONE;
}")

(define_insn "add2P24PSV3_lit"
  [(set (match_operand:P24PSV   0 "pic30_reg_or_R_operand" "=r,r,R,r,r,R,r")
        (plus:P24PSV
          (match_operand:P24PSV 1 "pic30_register_operand" "%0,r,r,0,r,r,0")
          (match_operand:P24PSV 2 "pic30_JN_operand"       " P,P,P,N,N,N,J")))]
  ""
  "*
   {
     static char *patterns[] = {
        \"add %1,#%2,%0\;addc %d1,#0,%d0\",
        \"add %1,#%2,%0\;addc %d1,#0,%d0\",
        \"add %1,#%2,%I0\;addc %d1,#0,%D0\",
        \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
        \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
        \"sub %1,#%J2,%I0\;subb %d1,#0,%D0\",
        \"add #%2,%0\;addc #0,%d0\",
        \"sub #%J2,%0\;subb #0,%d0\",
        \"add %1,#%2,%0\;addc %d1,#0,%d0\",
        \"sub %1,#%2,%0\;subb %d1,#0,%d0\",
        0};

    if ((which_alternative == 0) && (INTVAL(operands[2]) > 15)) {
      if (REGNO(operands[0]) == REGNO(operands[1]))
        which_alternative = 6;
      else which_alternative = 8;
    } else if ((which_alternative == 1) && (INTVAL(operands[2]) < -15)) {
      if (REGNO(operands[0]) == REGNO(operands[1]))
        which_alternative = 7;
      else which_alternative = 8;
    }
    return patterns[which_alternative];
   }"
  [
    (set_attr "cc" "math")
    (set_attr "type" "def,def,use,def,def,use,def")
  ]
)

(define_insn "addp24psv3_DATA_e"
  [(set (match_operand:P24PSV    0 
             "pic30_mode2_operand"   "=r,r, r,<>,<>,<>,R,R, R")
        (plus:P24PSV
           (match_operand:P24PSV 1 
             "pic30_register_operand" "r,r, r,r, r, r, r,r, r")
           (match_operand:P24PSV 2
             "pic30_mode2_operand"    "r,<>,R,r, <>,R, r,<>,R")))
  ]
  ""
  "*
   {
     static char *patterns[] = {
       \"add %1,%2,%0\;addc %d1,%d2,%d0\",
       \"add %1,%2,%0\;addc %d1,%2,%d0\",
       \"add %1,%I2,%0\;addc %d1,%D2,%d0\",
       \"add %1,%2,%0\;addc %d1,%d2,%0\",
       \"add %1,%2,%0\;addc %d1,%2,%0\",
       \"add %1,%I2,%0\;addc %d1,%D2,%0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%2,%I0\;addc %d1,%2,%D0\",
       \"add %1,%I2,%I0\;addc %d1,%D2,%D0\"
     };

     static char *psv_psv_patterns[] = {
       \"add %1,%2,%0\;addc %d1,%d2,%d0\",
       \"add %1,%2,%0\;nop\;addc %d1,%2,%d0\",
       \"add %1,%I2,%0\;nop\;addc %d1,%D2,%d0\",
       \"add %1,%2,%0\;addc %d1,%d2,%0\",
       \"add %1,%2,%0\;nop\;addc %d1,%2,%0\",
       \"add %1,%I2,%0\;nop\;addc %d1,%D2,%0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%2,%I0\;nop\;addc %d1,%2,%D0\",
       \"add %1,%I2,%I0\;nop\;addc %d1,%D2,%D0\"
     };

     if (pic30_psrd_psrd_errata(operands[2],NULL)) {
       pic30_rtx_nops++;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     }
   }"
  [
    (set_attr "cc" "math")
    (set_attr "type" "def,defuse,defuse,use,use,use,use,use,use")
  ]
)

(define_insn "addp24psv3_APSV_e"
  [(set (match_operand:P24PSV    0 
             "pic30_mode2_operand"     "=r,r, r,<>,<>,<>,R,R, R")
        (plus:P24PSV
           (match_operand:P24PSV 1 
             "pic30_register_operand"   "r,r, r,r, r, r, r,r, r")
           (match_operand:P24PSV 2
             "pic30_mode2_APSV_operand" "r,<>,R,r, <>,R, r,<>,R")))]
  ""
  "*
   {
     static char *patterns[] = {
       \"add %1,%2,%0\;addc %d1,%d2,%d0\",
       \"add %1,%2,%0\;addc %d1,%2,%d0\",
       \"add %1,%I2,%0\;addc %d1,%D2,%d0\",
       \"add %1,%2,%0\;addc %d1,%d2,%0\",
       \"add %1,%2,%0\;addc %d1,%2,%0\",
       \"add %1,%I2,%0\;addc %d1,%D2,%0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%2,%I0\;addc %d1,%2,%D0\",
       \"add %1,%I2,%I0\;addc %d1,%D2,%D0\"
     };

     static char *psv_psv_patterns[] = {
       \"add %1,%2,%0\;addc %d1,%d2,%d0\",
       \"add %1,%2,%0\;nop\;addc %d1,%2,%d0\",
       \"add %1,%I2,%0\;nop\;addc %d1,%D2,%d0\",
       \"add %1,%2,%0\;addc %d1,%d2,%0\",
       \"add %1,%2,%0\;nop\;addc %d1,%2,%0\",
       \"add %1,%I2,%0\;nop\;addc %d1,%D2,%0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%2,%I0\;nop\;addc %d1,%2,%D0\",
       \"add %1,%I2,%I0\;nop\;addc %d1,%D2,%D0\"
     };
   
     if (pic30_psrd_psrd_errata(operands[2],NULL)) {
       pic30_rtx_nops++;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     }
   }"
  [
    (set_attr "cc" "math")
    (set_attr "type" "def,defuse,defuse,use,use,use,use,use,use")
  ]
)

(define_expand "addp24psv3"
  [(set (match_operand:P24PSV 0 "pic30_mode2_operand" "")
        (plus: P24PSV (match_operand:P24PSV 1 "pic30_register_operand" "")
                      (match_operand:P24PSV 2 "pic30_mode1i_operand" "")))]
  ""
  "
{  rtx (*gen)(rtx,rtx,rtx) = gen_addp24psv3_APSV_e;

   if (pic30_mode2_operand(operands[2],GET_MODE(operands[2])))
     gen = gen_addp24psv3_DATA_e;
   if (GET_CODE(operands[2]) == CONST_INT) {
     rtx new_val = operands[2];
     if (pic30_JN_operand(new_val, HImode)) {
       emit_insn(gen_add2P24PSV3_lit(operand0,operand1,operand2));  
       DONE;
     } else {
       /* load the immediate separately */
       rtx result = gen_reg_rtx(P24PSVmode);

       emit_insn(gen_movp24psv_lit(result, new_val));
       emit_insn(gen(operand0, operand1, result));
       DONE;
     }
   }
   emit_insn(gen(operand0,operand1,operand2));
   DONE;
}")

;
; APSVrd
;
; target_flags & TARGET_TRACK_PSVPAG => we want to make sure PSVPAG is set right
;

(define_expand "P16APSVrd_qi"
  [(set (match_operand:QI 0 "pic30_move_operand"
                "=r<>,R,r<>, R,   r<>,RS,r<>,RS, Q,r,U,U")
        (match_operand:QI 1 "pic30_move2_APSV_operand"
                 "r,  r,<>RS,<>RS,r,  r, R<>,R<>,r,Q,a,r"))
  ]
  ""
  "
{ rtx sfr;
  rtx psv_page;
  rtx from = operands[1];
  rtx to = operands[0];

  if (TARGET_TRACK_PSVPAG) {
    sfr = gen_rtx_SYMBOL_REF(HImode,\"_const_psvpage\");
    psv_page = gen_reg_rtx(HImode);
    emit_insn(
      gen_save_const_psv(psv_page, sfr)           /* hopefully optimized away */
    );
    emit(
      gen_set_nvpsv(psv_page)                     /* hopefully optimized away */
    );
  }
  if (can_create_pseudo_p()) {
    if (GET_CODE(operands[1]) == MEM) {
      rtx inner = XEXP(operands[1],0);
      switch (GET_CODE(inner)) {
        case CONST:
        case LABEL_REF:
        case SYMBOL_REF:
          from = gen_reg_rtx(GET_MODE(inner));
          emit_move_insn(from, inner);
          from = gen_rtx_MEM(GET_MODE(operands[1]), from);
          break;
        default: break;
      }
    }
    if ((GET_CODE(operands[0]) == MEM) && 
        (!pic30_data_operand(operands[0],GET_MODE(operands[0])))) {
      rtx inner = XEXP(operands[0],0);
      switch (GET_CODE(inner)) {
        case CONST:
        case LABEL_REF:
        case SYMBOL_REF:
          to = gen_reg_rtx(GET_MODE(inner));
          emit_move_insn(to, inner);
          to = gen_rtx_MEM(GET_MODE(operands[0]), to);
          break;
        default: break;
      }
    }
  }
  emit_insn(
    gen_movqi_gen_APSV(to,from)
  );
  DONE;
}")

(define_expand "P16APSVrd_hi"
  [(set (match_operand:HI 0 "pic30_move_operand"
                "=r<>,R,r<>, R,   r<>,RS,r<>,RS, Q,r,U,U")
        (match_operand:HI 1 "pic30_move2_APSV_operand"
                 "r,  r,<>RS,<>RS,r,  r, R<>,R<>,r,Q,a,r"))
  ]
  ""
  "
{ rtx sfr;
  rtx psv_page;

  if (TARGET_TRACK_PSVPAG) {
    sfr = gen_rtx_SYMBOL_REF(HImode,\"_const_psvpage\");
    psv_page = gen_reg_rtx(HImode);
    emit_insn(
      gen_save_const_psv(psv_page, sfr)           /* hopefully optimized away */
    );
    emit(
      gen_set_nvpsv(psv_page)                     /* hopefully optimized away */
    );
  }
  emit_insn(
    gen_movhi_gen_APSV(operands[0],operands[1])
  );
  DONE;
}")

(define_expand "P16APSVrd_p16apsv"
  [(set (match_operand:P16APSV 0 "pic30_move_operand"
                "=r<>,R,r<>, R,   r<>,RS,r<>,RS, Q,r,U,U")
        (match_operand:P16APSV 1 "pic30_move2_APSV_operand"
                 "r,  r,<>RS,<>RS,r,  r, R<>,R<>,r,Q,a,r"))
  ]
  ""
  "
{ rtx sfr;
  rtx psv_page;

  if (TARGET_TRACK_PSVPAG) {
    sfr = gen_rtx_SYMBOL_REF(HImode,\"_const_psvpage\");
    psv_page = gen_reg_rtx(HImode);
    emit_insn(
      gen_save_const_psv(psv_page, sfr)           /* hopefully optimized away */
    );
    emit(
      gen_set_nvpsv(psv_page)                     /* hopefully optimized away */
    );
  }
  emit_insn(
    gen_movp16apsv_gen_APSV(operands[0],operands[1])
  );
  DONE;
}")

(define_expand "P16APSVrd_p16pmp"
  [(set (match_operand:P16PMP 0 "pic30_move_operand"
                "=r<>,R,r<>, R,   r<>,RS,r<>,RS, Q,r,U,U")
        (match_operand:P16PMP 1 "pic30_move2_APSV_operand"
                 "r,  r,<>RS,<>RS,r,  r, R<>,R<>,r,Q,a,r"))
  ]
  ""
  "
{ rtx sfr;
  rtx psv_page;

  if (TARGET_TRACK_PSVPAG) {
    sfr = gen_rtx_SYMBOL_REF(HImode,\"_const_psvpage\");
    psv_page = gen_reg_rtx(HImode);
    emit_insn(
      gen_save_const_psv(psv_page, sfr)           /* hopefully optimized away */
    );
    emit(
      gen_set_nvpsv(psv_page)                     /* hopefully optimized away */
    );
  }
  emit_insn(
    gen_movP16PMP_gen_APSV(operands[0],operands[1])
  );
  DONE;
}")


(define_expand "P16APSVrd_<mode>"
  [(set (match_operand:M32BIT 0 "pic30_move_operand"
                "=r<>,R,r<>, R,   r<>,RS,r<>,RS, Q,r,U,U")
        (match_operand:M32BIT 1 "pic30_move2_APSV_operand"
                 "r,  r,<>RS,<>RS,r,  r, R<>,R<>,r,Q,a,r"))
  ]
  ""
  "
{ rtx sfr;
  rtx psv_page;

  if (TARGET_TRACK_PSVPAG) {
    sfr = gen_rtx_SYMBOL_REF(HImode,\"_const_psvpage\");
    psv_page = gen_reg_rtx(HImode);
    emit_insn(
      gen_save_const_psv(psv_page, sfr)           /* hopefully optimized away */
    );
    emit(
      gen_set_nvpsv(psv_page)                     /* hopefully optimized away */
    );
  }
  emit_insn(
    gen_mov<mode>_gen_APSV(operands[0],operands[1])
  );
  DONE;
}")

(define_expand "P16APSVrd_<mode>"
  [(set (match_operand:M64BIT 0 "pic30_move_operand"
                "=r<>,R,r<>, R,   r<>,RS,r<>,RS, Q,r,U,U")
        (match_operand:M64BIT 1 "pic30_move2_APSV_operand"
                 "r,  r,<>RS,<>RS,r,  r, R<>,R<>,r,Q,a,r"))
  ]
  ""
  "
{ rtx sfr;
  rtx psv_page;

  if (TARGET_TRACK_PSVPAG) {
    sfr = gen_rtx_SYMBOL_REF(HImode,\"_const_psvpage\");
    psv_page = gen_reg_rtx(HImode);
    emit_insn(
      gen_save_const_psv(psv_page, sfr)           /* hopefully optimized away */
    );
    emit(
      gen_set_nvpsv(psv_page)                     /* hopefully optimized away */
    );
  }
  emit_insn(
    gen_mov<mode>_gen_APSV(operands[0],operands[1])
  );
  DONE;
}")

;
;  These insns and splits define how to read via a P24PROG or P24PSV, decomposed
;    into smaller operations if the optimizer is turned on.

(define_expand "P24PROGrd_qi"
   [(set (match_operand:QI 0 "pic30_move_operand"       "=r,R,rR,r,R")
         (mem:QI 
           (match_operand:P24PROG 1 "pic30_psv_operand" "r,r,RQ,ST,ST")))]
   ""
   "
{  rtx op2 = gen_reg_rtx(P24PROGmode);
   rtx op3 = gen_reg_rtx(HImode);
   rtx op1_ = gen_reg_rtx(SImode);
   rtx op0 = operand0;
   
   if (!pic30_mode2_operand(op0, QImode)) {
     op0 = gen_reg_rtx(QImode);
   }
   pic30_managed_psv = 1;
   emit_insn(
     gen_movp24prog_gen(op2, operand1)                   /* copy pointer */
   );
   emit_insn(
     gen_copy_psv(op3)                                   /* preserve PSVPAG */
   );
   emit_insn(
     gen_unpack_MPROG(op1_,op2)                          /* unpack PSV ptr */
   );
   emit_insn(
     gen_set_psv(gen_rtx_SUBREG(HImode, op1_, 2))        /* set PSVPAG */
   );
   emit_insn(
     gen_P24PROGread_qi(op0, 
                        gen_rtx_SUBREG(HImode, op1_, 0)) /* read value */
   );
   if (op0 != operand0) {
     emit_insn(
       gen_movqi(operand0, op0)
     );
   }
   emit_insn(
     gen_set_psv(op3)                                    /* restore PSVPAG */
   );
   DONE;
}")
 
(define_expand "P24PSVrd_qi"
   [(set (match_operand:QI 0 "pic30_move_operand" "=r,R,rR,r,R")
         (mem:QI (match_operand:P24PSV 1 "pic30_psv_operand" "r,r,RQ,ST,ST")))
   ]
   ""
   "
{  rtx op2 = gen_reg_rtx(P24PSVmode);
   rtx op3 = gen_reg_rtx(HImode);
   rtx op1_ = gen_reg_rtx(SImode);
   rtx op0;
  
   op0 = gen_reg_rtx(QImode);
   pic30_managed_psv = 1;
   emit_insn(
     gen_movp24psv_gen(op2, operand1)                   /* copy pointer */
   );
   emit_insn(
     gen_copy_psv(op3)                                   /* preserve PSVPAG */
   );
   emit_insn(
     gen_unpack_MPSV(op1_,op2)                           /* unpack PSV ptr */
   );
   emit_insn(
     gen_set_psv(gen_rtx_SUBREG(HImode, op1_, 2))        /* set PSVPAG */
   );
   emit_insn(
     gen_P24PROGread_qi(op0,
                        gen_rtx_SUBREG(HImode, op1_, 0)) /* read value */
   );
   emit_insn(
     gen_set_psv(op3)                                    /* restore PSVPAG */
   );
   if (op0 != operand0) {
     emit_insn(
       gen_movqi(operand0, op0)
     );
   }
   DONE;
}")

(define_expand "P24PROGrd_hi"
   [(set (match_operand:HI 0 "pic30_move_operand" "=r,R,rR,r,R")
         (mem:HI (match_operand:P24PROG 1 "pic30_psv_operand" "r,r,RQ,ST,ST")))
   ]
   ""
   "
{  rtx op2 = gen_reg_rtx(P24PROGmode);
   rtx op3 = gen_reg_rtx(HImode);
   rtx op1_ = gen_reg_rtx(SImode);
   rtx op0;
  
   op0 = gen_reg_rtx(HImode);
   pic30_managed_psv = 1;
   emit_insn(
     gen_movp24prog_gen(op2, operand1)                   /* copy pointer */
   );
   emit_insn(
     gen_copy_psv(op3)                                   /* preserve PSVPAG */
   );
   emit_insn(
     gen_unpack_MPROG(op1_,op2)                          /* unpack PSV ptr */
   );
   emit_insn(
     gen_set_psv(gen_rtx_SUBREG(HImode, op1_, 2))        /* set PSVPAG */
   );
   emit_insn(
     gen_P24PROGread_hi(op0, 
                        gen_rtx_SUBREG(HImode, op1_, 0)) /* read value */
   );
   emit_insn(
     gen_set_psv(op3)                                    /* restore PSVPAG */
   );
   if (op0 != operand0) {
     emit_insn(
       gen_movhi(operand0, op0)
     );
   }
   DONE;
}")

(define_expand "P24PROGrd_p16apsv"
   [(set (match_operand:P16APSV 0 "pic30_move_operand" "=r,R,rR,r,R")
         (mem:P16APSV (match_operand:P24PROG 1 "pic30_psv_operand" "r,r,RQ,ST,ST")))
   ]
   ""
   "
{  rtx op2 = gen_reg_rtx(P24PROGmode);
   rtx op3 = gen_reg_rtx(HImode);
   rtx op1_ = gen_reg_rtx(SImode);
   rtx op0;
  
   op0 = gen_reg_rtx(GET_MODE(operand0));
   pic30_managed_psv = 1;
   emit_insn(
     gen_movp24prog_gen(op2, operand1)                   /* copy pointer */
   );
   emit_insn(
     gen_copy_psv(op3)                                   /* preserve PSVPAG */
   );
   emit_insn(
     gen_unpack_MPROG(op1_,op2)                          /* unpack PSV ptr */
   );
   emit_insn(
     gen_set_psv(gen_rtx_SUBREG(HImode, op1_, 2))        /* set PSVPAG */
   );
   emit_insn(
     gen_P24PROGread_p16apsv(op0, 
                        gen_rtx_SUBREG(HImode, op1_, 0)) /* read value */
   );
   emit_insn(
     gen_set_psv(op3)                                    /* restore PSVPAG */
   );
   if (op0 != operand0) {
     emit_move_insn(operand0, op0);
   }
   DONE;
}")

(define_expand "P24PSVrd_hi"
   [(set (match_operand:HI 0 "pic30_move_operand" "=r,R,rR,r,R")
         (mem:HI (match_operand:P24PSV 1 "pic30_psv_operand" "r,r,RQ,ST,ST")))
   ]
   ""
   "
{  rtx op2 = gen_reg_rtx(P24PSVmode);
   rtx op3 = gen_reg_rtx(HImode);
   rtx op1_ = gen_reg_rtx(SImode);
   rtx op0;
  
   op0 = gen_reg_rtx(HImode);
   pic30_managed_psv = 1;
   emit_insn(
     gen_movp24psv_gen(op2, operand1)                   /* copy pointer */
   );
   emit_insn(
     gen_copy_psv(op3)                                   /* preserve PSVPAG */
   );
   emit_insn(
     gen_unpack_MPSV(op1_,op2)                           /* unpack PSV ptr */
   );
   emit_insn(
     gen_set_psv(gen_rtx_SUBREG(HImode, op1_, 2))        /* set PSVPAG */
   );
   emit_insn(
     gen_P24PROGread_hi(op0, 
                        gen_rtx_SUBREG(HImode, op1_, 0)) /* read value */
   );
   emit_insn(
     gen_set_psv(op3)                                    /* restore PSVPAG */
   );
   if (op0 != operand0) {
     emit_insn(
       gen_movhi(operand0, op0)
     );
   }
   DONE;
}")

(define_expand "P24PSVrd_p16apsv"
   [(set (match_operand:P16APSV 0 "pic30_move_operand" "=r,R,rR,r,R")
         (mem:HI (match_operand:P24PSV 1 "pic30_psv_operand" "r,r,RQ,ST,ST")))
   ]
   ""
   "
{  rtx op2 = gen_reg_rtx(P24PSVmode);
   rtx op3 = gen_reg_rtx(HImode);
   rtx op1_ = gen_reg_rtx(SImode);
   rtx op0;
  
   op0 = gen_reg_rtx(GET_MODE(operand0));
   pic30_managed_psv = 1;
   emit_insn(
     gen_movp24psv_gen(op2, operand1)                   /* copy pointer */
   );
   emit_insn(
     gen_copy_psv(op3)                                   /* preserve PSVPAG */
   );
   emit_insn(
     gen_unpack_MPSV(op1_,op2)                           /* unpack PSV ptr */
   );
   emit_insn(
     gen_set_psv(gen_rtx_SUBREG(HImode, op1_, 2))        /* set PSVPAG */
   );
   emit_insn(
     gen_P24PROGread_p16apsv(op0, 
                        gen_rtx_SUBREG(HImode, op1_, 0)) /* read value */
   );
   emit_insn(
     gen_set_psv(op3)                                    /* restore PSVPAG */
   );
   if (op0 != operand0) {
     emit_move_insn(operand0, op0);
   }
   DONE;
}")


(define_expand "P24PROGrd_p16pmp"
   [(set (match_operand:P16PMP 0 "pic30_move_operand" "=r,R,rR,r,R")
         (mem:P16PMP 
           (match_operand:P24PROG 1 "pic30_psv_operand" "r,r,RQ,ST,ST")))
   ]
   ""
   "
{  rtx op2 = gen_reg_rtx(P24PROGmode);
   rtx op3 = gen_reg_rtx(HImode);
   rtx op1_ = gen_reg_rtx(SImode);
   rtx op0;

   op0 = gen_reg_rtx(P16PMPmode);
   pic30_managed_psv = 1;
   emit_insn(
     gen_movp24prog_gen(op2, operand1)                   /* copy pointer */
   );
   emit_insn(
     gen_copy_psv(op3)                                   /* preserve PSVPAG */
   );
   emit_insn(
     gen_unpack_MPROG(op1_,op2)                          /* unpack PSV ptr */
   );
   emit_insn(
     gen_set_psv(gen_rtx_SUBREG(HImode, op1_, 2))        /* set PSVPAG */
   );
   emit_insn(
     gen_P24PROGread_p16pmp(op0,
                        gen_rtx_SUBREG(HImode, op1_, 0)) /* read value */
   );
   emit_insn(
     gen_set_psv(op3)                                    /* restore PSVPAG */
   );
   if (op0 != operand0) {
     emit_insn(
       gen_movp16pmp(operand0, op0)
     );
   }
   DONE;
}")

(define_expand "P24PSVrd_p16pmp"
   [(set (match_operand:P16PMP 0 "pic30_move_operand" "=r,R,rR,r,R")
         (mem:P16PMP
           (match_operand:P24PSV 1 "pic30_psv_operand" "r,r,RQ,ST,ST")))
   ]
   ""
   "
{  rtx op2 = gen_reg_rtx(P24PSVmode);
   rtx op3 = gen_reg_rtx(HImode);
   rtx op1_ = gen_reg_rtx(SImode);
   rtx op0;

   op0 = gen_reg_rtx(P16PMPmode);
   pic30_managed_psv = 1;
   emit_insn(
     gen_movp24psv_gen(op2, operand1)                   /* copy pointer */
   );
   emit_insn(
     gen_copy_psv(op3)                                   /* preserve PSVPAG */
   );
   emit_insn(
     gen_unpack_MPSV(op1_,op2)                          /* unpack PSV ptr */
   );
   emit_insn(
     gen_set_psv(gen_rtx_SUBREG(HImode, op1_, 2))        /* set PSVPAG */
   );
   emit_insn(
     gen_P24PROGread_p16pmp(op0,
                        gen_rtx_SUBREG(HImode, op1_, 0)) /* read value */
   );
   emit_insn(
     gen_set_psv(op3)                                    /* restore PSVPAG */
   );
   if (op0 != operand0) {
     emit_insn(
       gen_movp16pmp(operand0, op0)
     );
   }
   DONE;
}")

(define_expand "P24PROGrd_<mode>"
   [(set (match_operand:M32BIT 0 "pic30_move_operand" "=r,R,r,R")
         (mem:M32BIT (match_operand:P24PROG 1 "pic30_psv_operand" "r,r,R,R")))
   ]
   ""
   "
{  rtx op2 = gen_reg_rtx(P24PROGmode);
   rtx op3 = gen_reg_rtx(HImode);
   rtx op1_ = gen_reg_rtx(SImode);
   rtx op0;
  
   op0 = gen_reg_rtx(GET_MODE(operand0));
   pic30_managed_psv = 1;
   emit_insn(
     gen_movp24prog_gen(op2, operand1)                   /* copy pointer */
   );
   emit_insn(
     gen_copy_psv(op3)                                   /* preserve PSVPAG */
   );
   emit_insn(
     gen_unpack_MPROG(op1_,op2)                           /* unpack PSV ptr */
   );
   emit_insn(
     gen_set_psv(gen_rtx_SUBREG(HImode, op1_, 2))        /* set PSVPAG */
   );
   emit_insn(
     gen_P24PROGread_<mode>(op0, 
                        gen_rtx_SUBREG(HImode, op1_, 0)) /* read value */
   );
   emit_insn(
     gen_set_psv(op3)                                    /* restore PSVPAG */
   );
   if (op0 != operand0) {
     emit_insn(
       gen_mov<mode>(operand0, op0)
     );
   }
   DONE;
}")

(define_expand "P24PSVrd_<mode>"
   [(set (match_operand:M32BIT 0 "pic30_move_operand" "=r,R,r,R")
         (mem:M32BIT (match_operand:P24PSV 1 "pic30_psv_operand" "r,r,R,R")))
   ]
   ""
   "
{  rtx op2 = gen_reg_rtx(P24PSVmode);
   rtx op3 = gen_reg_rtx(HImode);
   rtx op1_ = gen_reg_rtx(SImode);
   rtx op0;
  
   op0 = gen_reg_rtx(GET_MODE(operand0));
   pic30_managed_psv = 1;
   emit_insn(
     gen_movp24prog_gen(op2, operand1)                   /* copy pointer */
   );
   emit_insn(
     gen_copy_psv(op3)                                   /* preserve PSVPAG */
   );
   emit_insn(
     gen_unpack_MPSV(op1_,op2)                           /* unpack PSV ptr */
   );
   emit_insn(
     gen_set_psv(gen_rtx_SUBREG(HImode, op1_, 2))        /* set PSVPAG */
   );
   emit_insn(
     gen_P24PSVread_<mode>(op0,
                        gen_rtx_SUBREG(HImode, op1_, 0)) /* read value */
   );
   emit_insn(
     gen_set_psv(op3)                                    /* restore PSVPAG */
   );
   if (op0 != operand0) {
     emit_insn(
       gen_mov<mode>(operand0, op0)
     );
   }
   DONE;
}")

(define_expand "P24PROGrd_<mode>"
   [(set (match_operand:M64BIT 0 "pic30_move_operand" "=r,R,r,R")
         (mem:M64BIT (match_operand:P24PROG 1 "pic30_psv_operand" "r,r,R,R")))
   ]
   ""
   "
{  rtx op2 = gen_reg_rtx(P24PROGmode);
   rtx op3 = gen_reg_rtx(HImode);
   rtx op1_ = gen_reg_rtx(SImode);
   rtx op0;
  
   op0 = gen_reg_rtx(DImode);
   pic30_managed_psv = 1;
   emit_insn(
     gen_movp24prog_gen(op2, operand1)                   /* copy pointer */
   );
   emit_insn(
     gen_copy_psv(op3)                                   /* preserve PSVPAG */
   );
   emit_insn(
     gen_unpack_MPROG(op1_,op2)                           /* unpack PSV ptr */
   );
   emit_insn(
     gen_set_psv(gen_rtx_SUBREG(HImode, op1_, 2))        /* set PSVPAG */
   );
   emit_insn(
     gen_P24PROGread_<mode>(op0, 
                        gen_rtx_SUBREG(HImode, op1_, 0)) /* read value */
   );
   emit_insn(
     gen_set_psv(op3)                                    /* restore PSVPAG */
   );
   if (op0 != operand0) {
     emit_insn(
       gen_mov<mode>(operand0, op0)
     );
   }
   DONE;
}")

(define_expand "P24PSVrd_<mode>"
   [(set (match_operand:M64BIT 0 "pic30_move_operand" "=r,R,r,R")
         (mem:M64BIT (match_operand:P24PSV 1 "pic30_psv_operand" "r,r,R,R")))
    (clobber (match_scratch:P24PSV 2 "=r,r,r,r"))
    (clobber (match_scratch:QI 3 "=r,r,r,r"))
   ]
   ""
   "
{  rtx op2 = gen_reg_rtx(P24PSVmode);
   rtx op3 = gen_reg_rtx(HImode);
   rtx op1_ = gen_reg_rtx(SImode);
   rtx op0;
  
   op0 = gen_reg_rtx(GET_MODE(operand0));
   pic30_managed_psv = 1;
   emit_insn(
     gen_movp24psv_gen(op2, operand1)                   /* copy pointer */
   );
   emit_insn(
     gen_copy_psv(op3)                                   /* preserve PSVPAG */
   );
   emit_insn(
     gen_unpack_MPSV(op1_,op2)                           /* unpack PSV ptr */
   );
   emit_insn(
     gen_set_psv(gen_rtx_SUBREG(HImode, op1_, 2))        /* set PSVPAG */
   );
   emit_insn(
     gen_P24PSVread_<mode>(op0, 
                        gen_rtx_SUBREG(HImode, op1_, 0)) /* read value */
   );
   emit_insn(
     gen_set_psv(op3)                                    /* restore PSVPAG */
   );
   if (op0 != operand0) {
     emit_insn(
       gen_mov<mode>(operand0, op0)
     );
   }
   DONE;
}")

;;;;;;;;;;;;;;;;;;;;;;; PMP

(define_expand "P16PMPrd_qi"
   [(set (match_operand:QI 0 "pic30_move_operand"       "=rR")
         (mem:QI
           (match_operand:P16PMP 1 "pic30_pmp_operand" "r")))]
   ""
   "
{  rtx result = gen_reg_rtx(GET_MODE(operands[0])); 
   rtx addr;

   addr = gen_reg_rtx(P16PMPmode);
   if (GET_CODE(operands[1]) == SYMBOL_REF) {
     emit_insn(
       gen_movp16pmp_address(addr,operands[1])
     );
   } else {
     emit_move_insn(addr,operands[1]);
   }

   emit_insn(
     gen_set_PMADDR(addr)                               /* set up address */
   );
   emit_insn(
     gen_while_PMMODE_busy()
   );
   emit_insn(
     gen_get_PMDIN1qi(result)                           /* dummy read */
   );
   emit_insn(
     gen_while_PMMODE_busy()
   );
   emit_insn(
     gen_get_PMDIN1qi(result)                           /* real read */
   );
   emit_move_insn(operands[0],result);
   DONE;
}")

(define_expand "P16PMPwt_qi"
   [(set (mem:QI (match_operand:P16PMP 0 "pic30_pmp_operand" "r"))
         (match_operand:QI 1 "pic30_move_operand"       "rR"))]
   ""
   "
{  rtx result = gen_reg_rtx(GET_MODE(operands[1]));
   rtx addr;

   addr = gen_reg_rtx(P16PMPmode);
   if (GET_CODE(operands[0]) == SYMBOL_REF) {
     emit_insn(
       gen_movp16pmp_address(addr,operands[0])
     );
   } else {
     emit_move_insn(addr,operands[0]);
   }

   emit_insn(
     gen_set_PMADDR(addr)                               /* set up address */
   );
   emit_insn(
     gen_while_PMMODE_busy()
   );
   emit_move_insn(result,operands[1]);
   emit_insn(
     gen_set_PMDIN1qi(result)                           /* write */
   );
   DONE;
}")

(define_expand "P16PMPrd_hi"
   [(set (match_operand:HI 0 "pic30_move_operand"       "=rR")
         (mem:HI
           (match_operand:P16PMP 1 "pic30_pmp_operand" "r")))]
   ""
   "
{  rtx result = gen_reg_rtx(GET_MODE(operands[0]));
   rtx addr;

   addr = gen_reg_rtx(P16PMPmode);
   if (GET_CODE(operands[1]) == SYMBOL_REF) {
     emit_insn(
       gen_movp16pmp_address(addr,operands[1])
     );
   } else {
     emit_move_insn(addr,operands[1]);
   }

   emit_insn(
     gen_set_PMADDR(addr)                               /* set up address */
   );
   emit_insn(
     gen_while_PMMODE_busy()
   );
   emit_insn(
     gen_get_PMDIN1hi(result)                           /* dummy read */
   );
   emit_insn(
     gen_while_PMMODE_busy()
   );
   emit_insn(
     gen_get_PMDIN1hi(result)                          /* real read */
   );
   emit_move_insn(operands[0],result);
   DONE;
}")

(define_expand "P16PMPrd_p16apsv"
   [(set (match_operand:P16APSV 0 "pic30_move_operand"       "=rR")
         (mem:P16APSV
           (match_operand:P16PMP 1 "pic30_pmp_operand" "r")))]
   ""
   "
{  rtx result = gen_reg_rtx(GET_MODE(operands[0]));
   rtx addr;

   addr = gen_reg_rtx(P16PMPmode);
   if (GET_CODE(operands[1]) == SYMBOL_REF) {
     emit_insn(
       gen_movp16pmp_address(addr,operands[1])
     );
   } else {
     emit_move_insn(addr,operands[1]);
   }

   emit_insn(
     gen_set_PMADDR(addr)                               /* set up address */
   );
   emit_insn(
     gen_while_PMMODE_busy()
   );
   emit_insn(
     gen_get_PMDIN1hi(gen_rtx_SUBREG(HImode,result,0)) /* dummy read */
   );
   emit_insn(
     gen_while_PMMODE_busy()
   );
   emit_insn(
     gen_get_PMDIN1hi(result)                          /* real read */
   );
   emit_move_insn(operands[0],result);
   DONE;
}")


(define_expand "P16PMPwt_hi"
   [(set (mem:HI (match_operand:P16PMP 0 "pic30_pmp_operand" "r"))
         (match_operand:HI 1 "pic30_move_operand"       "rR"))]
   ""
   "
{  rtx result = gen_reg_rtx(GET_MODE(operands[1]));
   rtx addr;

   addr = gen_reg_rtx(P16PMPmode);
   if (GET_CODE(operands[0]) == SYMBOL_REF) {
     emit_insn(
       gen_movp16pmp_address(addr,operands[0])
     );
   } else {
     emit_move_insn(addr,operands[0]);
   }

   emit_insn(
     gen_set_PMADDR(addr)                              /* set up address */
   );
   emit_insn(
     gen_while_PMMODE_busy()
   );
   emit_move_insn(result,operands[1]);
   emit_insn(
     gen_set_PMDIN1hi(result)                          /* write */
   );
   DONE;
}")

(define_expand "P16PMPwt_p16apsv"
   [(set (mem:P16APSV (match_operand:P16PMP 0 "pic30_pmp_operand" "r"))
         (match_operand:P16APSV 1 "pic30_move_operand"       "rR"))]
   ""
   "
{  rtx result = gen_reg_rtx(GET_MODE(operands[1]));
   rtx addr;

   addr = gen_reg_rtx(P16PMPmode);
   if (GET_CODE(operands[0]) == SYMBOL_REF) {
     emit_insn(
       gen_movp16pmp_address(addr,operands[0])
     );
   } else {
     emit_move_insn(addr,operands[0]);
   }

   emit_insn(
     gen_set_PMADDR(addr)                              /* set up address */
   );
   emit_insn(
     gen_while_PMMODE_busy()
   );
   emit_move_insn(result,operands[1]);
   emit_insn(
     gen_set_PMDIN1hi(gen_rtx_SUBREG(HImode,result,0)) /* write */
   );
   DONE;
}")

(define_expand "P16PMPrd_p16pmp"
   [(set (match_operand:P16PMP 0 "pic30_move_operand"       "=r,R,rR,r,R")
         (mem:P16PMP
           (match_operand:P16PMP 1 "pic30_pmp_operand" "r,r,RQ,ST,ST")))]
   ""
   "
{  rtx result = gen_reg_rtx(GET_MODE(operands[0]));
   rtx addr;

   addr = gen_reg_rtx(P16PMPmode);
   if (GET_CODE(operands[1]) == SYMBOL_REF) {
     emit_insn(
       gen_movp16pmp_address(addr,operands[1])
     );
   } else {
     emit_move_insn(addr,operands[1]);
   }

   emit_insn(
     gen_set_PMADDR(addr)                               /* set up address */
   );
   emit_insn(
     gen_while_PMMODE_busy()
   );
   emit_insn(
     gen_get_PMDIN1hi(gen_rtx_SUBREG(HImode,result,0)) /* dummy read */
   );
   emit_insn(
     gen_while_PMMODE_busy()
   );
   emit_insn(
     gen_get_PMDIN1hi(gen_rtx_SUBREG(HImode,result,0)) /* real read */
   );
   emit_move_insn(operands[0],result);
   DONE;
}")

(define_expand "P16PMPwt_p16pmp"
   [(set (mem:P16PMP 
           (match_operand:P16PMP 0 "pic30_pmp_operand" "r,r,RQ,ST,ST"))
         (match_operand:P16PMP 1 "pic30_move_operand"       "=r,R,rR,r,R"))]
   ""
   "
{  rtx result = gen_reg_rtx(GET_MODE(operands[1]));
   rtx addr;

   addr = gen_reg_rtx(P16PMPmode);
   if (GET_CODE(operands[0]) == SYMBOL_REF) {
     emit_insn(
       gen_movp16pmp_address(addr,operands[0])
     );
   } else {
     emit_move_insn(addr,operands[0]);
   }

   emit_insn(
     gen_set_PMADDR(addr)                               /* set up address */
   );
   emit_insn(
     gen_while_PMMODE_busy()
   );
   emit_move_insn(result,operands[1]);
   emit_insn(
     gen_set_PMDIN1hi(gen_rtx_SUBREG(HImode,result,0)) /* write */
   );
   DONE;
}")


(define_expand "P16PMPrd_<mode>"
   [(set (match_operand:M32BIT 0 "pic30_move_operand"       "=r,R,rR,r,R")
         (mem:M32BIT
           (match_operand:P16PMP 1 "pic30_pmp_operand" "r,r,RQ,ST,ST")))]
   ""
   "
{  rtx result = gen_reg_rtx(GET_MODE(operands[0]));
   rtx addr;

   addr = gen_reg_rtx(P16PMPmode);
   if (GET_CODE(operands[1]) == SYMBOL_REF) {
     emit_insn(
       gen_movp16pmp_address(addr,operands[1])
     );
   } else {
     emit_move_insn(addr,operands[1]);
   }

   emit_insn(
     gen_bitset_PMMODE(GEN_INT(11))                    /* set auto inc mode */
   );
   emit_insn(
     gen_set_PMADDR(addr)                               /* set up address */
   );
   emit_insn(
     gen_while_PMMODE_busy()
   );
   emit_insn(
     gen_get_PMDIN1hi(gen_rtx_SUBREG(HImode,result,0)) /* dummy read */
   );
   emit_insn(
     gen_while_PMMODE_busy()
   );
   emit_insn(
     gen_get_PMDIN1hi(gen_rtx_SUBREG(HImode,result,0)) /* real read, pt1 */
   );
   emit_insn(
     gen_while_PMMODE_busy()
   );
   emit_insn(
     gen_get_PMDIN1hi(gen_rtx_SUBREG(HImode,result,2)) /* real read, pt2 */
   );
   emit_insn(
     gen_bitclr_PMMODE(GEN_INT(11))                    /* clr auto inc mode */
   );
   emit_move_insn(operands[0],result);
   DONE;
}")

(define_expand "P16PMPwt_<mode>"
   [(set (mem:M32BIT 
           (match_operand:P16PMP 0 "pic30_pmp_operand" "r,r,RQ,ST,ST"))
         (match_operand:M32BIT 1 "pic30_move_operand"       "=r,R,rR,r,R"))]
   ""
   "
{  rtx result = gen_reg_rtx(GET_MODE(operands[1]));
   rtx addr;

   addr = gen_reg_rtx(P16PMPmode);
   if (GET_CODE(operands[0]) == SYMBOL_REF) {
     emit_insn(
       gen_movp16pmp_address(addr,operands[0])
     );
   } else {
     emit_move_insn(addr,operands[0]);
   }

   emit_insn(
     gen_set_PMADDR(addr)                               /* set up address */
   );
   emit_insn(
     gen_bitset_PMMODE(GEN_INT(11))                   /* set auto inc  mode */
   );
   emit_insn(
     gen_while_PMMODE_busy()
   );
   emit_move_insn(result,operands[1]);
   emit_insn(
     gen_set_PMDIN1hi(gen_rtx_SUBREG(HImode,result,0)) /* write        */
   );
   emit_insn(
     gen_while_PMMODE_busy()
   );
   emit_insn(
     gen_set_PMDIN1hi(gen_rtx_SUBREG(HImode,result,2)) /* write        */
   );
   emit_insn(
     gen_bitclr_PMMODE(GEN_INT(11))                    /* clr auto inc  mode */
   );
   DONE;
}")

(define_expand "P16PMPrd_<mode>"
   [(set (match_operand:M64BIT 0 "pic30_move_operand"       "=r,R,rR,r,R")
         (mem:M64BIT
           (match_operand:P16PMP 1 "pic30_pmp_operand" "r,r,RQ,ST,ST")))]
   ""
   "
{  rtx result = gen_reg_rtx(GET_MODE(operands[0]));
   rtx addr;

   addr = gen_reg_rtx(P16PMPmode);
   if (GET_CODE(operands[1]) == SYMBOL_REF) {
     emit_insn(
       gen_movp16pmp_address(addr,operands[1])
     );
   } else {
     emit_move_insn(addr,operands[1]);
   }

   emit_insn(
     gen_bitset_PMMODE(GEN_INT(11))                    /* set auto inc mode */
   );
   emit_insn(
     gen_set_PMADDR(addr)                               /* set up address */
   );
   emit_insn(
     gen_while_PMMODE_busy()
   );
   emit_insn(
     gen_get_PMDIN1hi(gen_rtx_SUBREG(HImode,result,0)) /* dummy read */
   );
   emit_insn(
     gen_while_PMMODE_busy()
   );
   emit_insn(
     gen_get_PMDIN1hi(gen_rtx_SUBREG(HImode,result,0)) /* real read, pt1 */
   );
   emit_insn(
     gen_while_PMMODE_busy()
   );
   emit_insn(
     gen_get_PMDIN1hi(gen_rtx_SUBREG(HImode,result,2)) /* real read, pt2 */
   );
   emit_insn(
     gen_while_PMMODE_busy()
   );
   emit_insn(
     gen_get_PMDIN1hi(gen_rtx_SUBREG(HImode,result,4)) /* real read, pt3 */
   );
   emit_insn(
     gen_while_PMMODE_busy()
   );
   emit_insn(
     gen_get_PMDIN1hi(gen_rtx_SUBREG(HImode,result,6)) /* real read, pt4 */
   );
   emit_insn(
     gen_bitclr_PMMODE(GEN_INT(11))                    /* clr auto inc mode */
   );
   emit_move_insn(operands[0],result);
   DONE;
}")


(define_expand "P16PMPwt_<mode>"
   [(set (mem:M64BIT
           (match_operand:P16PMP 0 "pic30_pmp_operand" "r,r,RQ,ST,ST"))
         (match_operand:M64BIT 1 "pic30_move_operand"       "=r,R,rR,r,R"))]
   ""
   "
{  rtx result = gen_reg_rtx(GET_MODE(operands[1]));
   rtx addr;

   addr = gen_reg_rtx(P16PMPmode);
   if (GET_CODE(operands[0]) == SYMBOL_REF) {
     emit_insn(
       gen_movp16pmp_address(addr,operands[0])
     );
   } else {
     emit_move_insn(addr,operands[0]);
   }

   emit_insn(
     gen_set_PMADDR(addr)                               /* set up address */
   );
   emit_insn(
     gen_bitset_PMMODE(GEN_INT(11))                    /* set auto inc mode */
   );
   emit_insn(
     gen_while_PMMODE_busy()
   );
   emit_move_insn(result,operands[1]);
   emit_insn(
     gen_set_PMDIN1hi(gen_rtx_SUBREG(HImode,result,0)) /* write */
   );
   emit_insn(
     gen_while_PMMODE_busy()
   );
   emit_insn(
     gen_set_PMDIN1hi(gen_rtx_SUBREG(HImode,result,2)) /* write */
   );
   emit_insn(
     gen_while_PMMODE_busy()
   );
   emit_insn(
     gen_set_PMDIN1hi(gen_rtx_SUBREG(HImode,result,4)) /* write */
   );
   emit_insn(
     gen_while_PMMODE_busy()
   );
   emit_insn(
     gen_set_PMDIN1hi(gen_rtx_SUBREG(HImode,result,6)) /* write */
   );
   emit_insn(
     gen_bitclr_PMMODE(GEN_INT(11))       /* clr auto increment mode */
   );
   DONE;
}")

;;;;;;;;;;;;;;;;;;;;;;; EXT

;;

(define_expand "P32EXTrd_qi"
   [(set (match_operand:QI 0 "pic30_move_operand"       "=r,R,rR,r,R")
         (mem:QI
           (match_operand:P32EXT 1 "pic30_ext_operand" "r,r,RQ,ST,ST")))]
   ""
   "{
      if (pic30_read_externals(pst_8)) {
        rtx input = gen_reg_rtx(P32EXTmode);

        emit_move_insn(input, operands[1]);
        emit_library_call_value(XEXP(DECL_RTL(pic30_read_externals(pst_8)),0),
                          operands[0], LCT_NORMAL, GET_MODE(operands[0]), 1, 
                          input, P32EXTmode);
        DONE;
      } else if (pic30_read_externals(pst_any)) {
        rtx input = gen_reg_rtx(P32EXTmode);
        rtx temp = assign_stack_temp(GET_MODE(operands[0]),
                                     GET_MODE_SIZE(GET_MODE(operands[0])), 0);
        rtx param2,param3;
  
        emit_move_insn(input, operands[1]);
        param3 = gen_reg_rtx(HImode);
        param2 = gen_reg_rtx(Pmode);
        emit_move_insn(param3, GEN_INT(1));
        emit_move_insn(param2, XEXP(temp,0));
        emit_library_call(XEXP(DECL_RTL(pic30_read_externals(pst_any)),0),
                          LCT_NORMAL, GET_MODE(operands[0]), 3,
                          input, P32EXTmode,
                          param2, Pmode,
                          param3, HImode);
        emit_move_insn(operands[0], temp);
        DONE;
      } else {
        error(\"Cannot access external memory space;\n\"
              \"\tdeclare __read_external or __read_external8\");
        DONE;
      }
    }"
)

(define_expand "P32EXTwt_qi"
   [(set (mem:QI (match_operand:P32EXT 0 "pic30_ext_operand" "r,r,RQ,ST,ST"))
         (match_operand:QI 1 "pic30_move_operand"            "r,R,rR,r,R"))]
   ""
   "{
      if (pic30_write_externals(pst_8)) {
        rtx input = gen_reg_rtx(P32EXTmode);
        rtx input1 = gen_reg_rtx(GET_MODE(operands[1]));

        emit_move_insn(input, operands[0]);
        emit_move_insn(input1, operands[1]);
        emit_library_call(XEXP(DECL_RTL(pic30_write_externals(pst_8)),0),
                          LCT_NORMAL, VOIDmode, 2, 
                          input, P32EXTmode,
                          input1, GET_MODE(operands[1]));
        DONE;
      } else if (pic30_write_externals(pst_any)) {
        rtx input = gen_reg_rtx(P32EXTmode);
        rtx temp = assign_stack_temp(GET_MODE(operands[1]),
                                     GET_MODE_SIZE(GET_MODE(operands[1])), 0);
        rtx param2,param3;
  
        emit_move_insn(input, operands[0]);
        emit_move_insn(temp, operands[1]);
        param3 = gen_reg_rtx(HImode);
        param2 = gen_reg_rtx(Pmode);
        emit_move_insn(param3, GEN_INT(1));
        emit_move_insn(param2, XEXP(temp,0));
        emit_library_call(XEXP(DECL_RTL(pic30_write_externals(pst_any)),0),
                          LCT_NORMAL, GET_MODE(operands[0]), 3,
                          input, P32EXTmode,
                          param2, Pmode,
                          param3, HImode);
        DONE;
      } else {
        error(\"Cannot access external memory space;\n\"
              \"\tdeclare __write_external or __write_external8\");
        DONE;
      }
    }"
)

(define_mode_iterator EXT16BITRD [HI P16APSV P16PMP])
(define_mode_iterator EXT16BITWT [HI P16APSV P16PMP])

(define_expand "P32EXTrd_<mode>"
   [(set (match_operand:EXT16BITRD 0 "pic30_move_operand"       "=r,R,rR,r,R")
         (mem:EXT16BITRD
           (match_operand:P32EXT 1 "pic30_ext_operand" "r,r,RQ,ST,ST")))]
   ""
   "{
      if (pic30_read_externals(pst_16)) {
        rtx input = gen_reg_rtx(P32EXTmode);

        emit_move_insn(input, operands[1]);
        emit_library_call_value(XEXP(DECL_RTL(pic30_read_externals(pst_16)),0),
                          operands[0], LCT_NORMAL, GET_MODE(operands[0]), 1, 
                          input, P32EXTmode);
        DONE;
      } else if (pic30_read_externals(pst_any)) {
        rtx input = gen_reg_rtx(P32EXTmode);
        rtx temp = assign_stack_temp(GET_MODE(operands[0]),
                                     GET_MODE_SIZE(GET_MODE(operands[0])), 0);
        rtx param2,param3;
  
        emit_move_insn(input, operands[1]);
        param3 = gen_reg_rtx(HImode);
        param2 = gen_reg_rtx(Pmode);
        emit_move_insn(param3, GEN_INT(2));
        emit_move_insn(param2, XEXP(temp,0));
        emit_library_call(XEXP(DECL_RTL(pic30_read_externals(pst_any)),0),
                          LCT_NORMAL, GET_MODE(operands[0]), 3,
                          input, P32EXTmode,
                          param2, Pmode,
                          param3, HImode);
        emit_move_insn(operands[0], temp);
        DONE;
      } else if (pic30_read_externals(pst_8)) {
        rtx input = gen_reg_rtx(P32EXTmode);

        emit_move_insn(input, operands[1]);
        emit_library_call_value(XEXP(DECL_RTL(pic30_read_externals(pst_8)),0),
          simplify_gen_subreg(QImode, operands[0], GET_MODE(operands[0]), 0), 
          LCT_NORMAL, QImode, 1, input, P32EXTmode);
        emit_insn(
          gen_addp32ext3_imm(input, input, GEN_INT(1))
        );
        emit_library_call_value(XEXP(DECL_RTL(pic30_read_externals(pst_8)),0),
          simplify_gen_subreg(QImode, operands[0], GET_MODE(operands[0]), 1), 
          LCT_NORMAL, QImode, 1, input, P32EXTmode);
        DONE;
      } else {
        error(\"Cannot access external memory space;\n\"
              \"\tdeclare __read_external or __read_external16\");
      }
    }"
)

(define_expand "P32EXTwt_<mode>"
   [(set (mem:EXT16BITWT
           (match_operand:P32EXT 0 "pic30_ext_operand"          "r,r,RQ,ST,ST"))
         (match_operand:EXT16BITWT 1 "pic30_move_operand"       "r,R,rR,r,R"))]
   ""
   "{
      if (pic30_write_externals(pst_16)) {
        rtx input = gen_reg_rtx(P32EXTmode);
        rtx input1 = gen_reg_rtx(GET_MODE(operands[1]));

        emit_move_insn(input, operands[0]);
        emit_move_insn(input1, operands[1]);
        emit_library_call(XEXP(DECL_RTL(pic30_write_externals(pst_16)),0),
                          LCT_NORMAL, VOIDmode, 2,
                          input, P32EXTmode,
                          input1, GET_MODE(operands[1]));
        DONE;
      } else if (pic30_write_externals(pst_any)) {
        rtx input = gen_reg_rtx(P32EXTmode);
        rtx temp = assign_stack_temp(GET_MODE(operands[1]),
                                     GET_MODE_SIZE(GET_MODE(operands[1])), 0);
        rtx param2,param3;
 
        emit_move_insn(input, operands[0]);
        emit_move_insn(temp, operands[1]);
        param3 = gen_reg_rtx(HImode);
        param2 = gen_reg_rtx(Pmode);
        emit_move_insn(param3, GEN_INT(2));
        emit_move_insn(param2, XEXP(temp,0));
        emit_library_call(XEXP(DECL_RTL(pic30_write_externals(pst_any)),0),
                          LCT_NORMAL, GET_MODE(operands[0]), 3,
                          input, P32EXTmode,
                          param2, Pmode,
                          param3, HImode);
        DONE;
      } else if (pic30_write_externals(pst_8)) {
        rtx input = gen_reg_rtx(P32EXTmode);
        rtx input1 = gen_reg_rtx(QImode);

        emit_move_insn(input, operands[0]);
        emit_move_insn(input1, 
          simplify_gen_subreg(QImode, operands[1], GET_MODE(operands[1]),0));
        emit_library_call(XEXP(DECL_RTL(pic30_write_externals(pst_8)),0),
                          LCT_NORMAL, VOIDmode, 2,
                          input, P32EXTmode,
                          input1, QImode);
        emit_insn(
          gen_addp32ext3_imm(input, input, GEN_INT(1))
        );
        emit_insn(
          gen_addqi3(input1, input1, GEN_INT(1))
        );
        emit_library_call(XEXP(DECL_RTL(pic30_write_externals(pst_8)),0),
                          LCT_NORMAL, VOIDmode, 2,
                          input, P32EXTmode,
                          input1, QImode);
        DONE;
      } else {
        error(\"Cannot access external memory space;\n\"
              \"\tdeclare __write_external or __write_external16\");
      }
    }"
)

(define_expand "P32EXTrd_p24psv"
   [(set (match_operand:P24PSV 0 "pic30_move_operand"       "=r,R,rR,r,R")
         (mem:P24PSV
           (match_operand:P32EXT 1 "pic30_ext_operand" "r,r,RQ,ST,ST")))]
   ""
   "{
      if (pic30_read_externals(pst_32)) {
        rtx input = gen_reg_rtx(P32EXTmode);

        emit_move_insn(input, operands[1]);
        emit_library_call_value(XEXP(DECL_RTL(pic30_read_externals(pst_32)),0),
                          operands[0], LCT_NORMAL, GET_MODE(operands[0]), 1,
                          input, P32EXTmode);
        DONE;
      } else if (pic30_read_externals(pst_any)) {
        rtx input = gen_reg_rtx(P32EXTmode);
        rtx temp = assign_stack_temp(GET_MODE(operands[0]),
                                     GET_MODE_SIZE(GET_MODE(operands[0])), 0);
        rtx param2,param3;

        emit_move_insn(input, operands[1]);
        param3 = gen_reg_rtx(HImode);
        param2 = gen_reg_rtx(Pmode);
        emit_move_insn(param3, GEN_INT(4));
        emit_move_insn(param2, XEXP(temp,0));
        emit_library_call(XEXP(DECL_RTL(pic30_read_externals(pst_any)),0),
                          LCT_NORMAL, GET_MODE(operands[0]), 3,
                          input, P32EXTmode,
                          param2, Pmode,
                          param3, HImode);
        emit_move_insn(operands[0], temp);
        DONE;
      } else {
        error(\"Cannot access external memory space;\n\"
              \"\tdeclare __write_external or __write_external32\");
      }
    }"
)

(define_expand "P32EXTwt_p24psv"
   [(set (mem:P24PSV 
           (match_operand:P32EXT 0 "pic30_ext_operand" "r,r,RQ,ST,ST"))
         (match_operand:P24PSV 1 "pic30_move_operand"  "r,R,rR,r,R"))]
   ""
   "{
      if (pic30_write_externals(pst_32)) {
        rtx input = gen_reg_rtx(P32EXTmode);
        rtx input1 = gen_reg_rtx(GET_MODE(operands[1]));

        emit_move_insn(input, operands[0]);
        emit_move_insn(input1, operands[1]);
        emit_library_call(XEXP(DECL_RTL(pic30_write_externals(pst_32)),0),
                          LCT_NORMAL, VOIDmode, 2,
                          input, P32EXTmode,
                          input1, GET_MODE(operands[1]));
        DONE;
      } else if (pic30_write_externals(pst_any)) {
        rtx input = gen_reg_rtx(P32EXTmode);
        rtx temp = assign_stack_temp(GET_MODE(operands[1]),
                                     GET_MODE_SIZE(GET_MODE(operands[1])), 0);
        rtx param2,param3;
 
        emit_move_insn(input, operands[0]);
        emit_move_insn(temp, operands[1]);
        param3 = gen_reg_rtx(HImode);
        param2 = gen_reg_rtx(Pmode);
        emit_move_insn(param3, GEN_INT(4));
        emit_move_insn(param2, XEXP(temp,0));
        emit_library_call(XEXP(DECL_RTL(pic30_write_externals(pst_any)),0),
                          LCT_NORMAL, GET_MODE(operands[0]), 3,
                          input, P32EXTmode,
                          param2, Pmode,
                          param3, HImode);
        DONE;
      } else {
        error(\"Cannot access external memory space;\n\"
              \"\tdeclare __write_external or __write_external32\");
      }
    }"
)

(define_expand "P32EXTrd_p24prog"
   [(set (match_operand:P24PROG 0 "pic30_move_operand"       "=r,R,rR,r,R")
         (mem:P24PROG
           (match_operand:P32EXT 1 "pic30_ext_operand" "r,r,RQ,ST,ST")))]
   ""
   "{
      if (pic30_read_externals(pst_32)) {
        rtx input = gen_reg_rtx(P32EXTmode);

        emit_move_insn(input, operands[1]);
        emit_library_call_value(XEXP(DECL_RTL(pic30_read_externals(pst_32)),0),
                          operands[0], LCT_NORMAL, GET_MODE(operands[0]), 1,
                          input, P32EXTmode);
        DONE;
      } else if (pic30_read_externals(pst_any)) {
        rtx input = gen_reg_rtx(P32EXTmode);
        rtx temp = assign_stack_temp(GET_MODE(operands[0]),
                                     GET_MODE_SIZE(GET_MODE(operands[0])), 0);
        rtx param2,param3;

        emit_move_insn(input, operands[1]);
        param3 = gen_reg_rtx(HImode);
        param2 = gen_reg_rtx(Pmode);
        emit_move_insn(param3, GEN_INT(4));
        emit_move_insn(param2, XEXP(temp,0));
        emit_library_call(XEXP(DECL_RTL(pic30_read_externals(pst_any)),0),
                          LCT_NORMAL, GET_MODE(operands[0]), 3,
                          input, P32EXTmode,
                          param2, Pmode,
                          param3, HImode);
        emit_move_insn(operands[0], temp);
        DONE;
      } else {
        error(\"Cannot access external memory space;\n\"
              \"\tdeclare __write_external or __write_external32\");
      }
    }"
)

(define_expand "P32EXTwt_p24prog"
   [(set (mem:P24PROG 
           (match_operand:P32EXT 0 "pic30_ext_operand" "r,r,RQ,ST,ST"))
         (match_operand:P24PROG 1 "pic30_move_operand" "r,R,rR,r,R"))]
   ""
   "{
      if (pic30_write_externals(pst_32)) {
        rtx input = gen_reg_rtx(P32EXTmode);
        rtx input1 = gen_reg_rtx(GET_MODE(operands[1]));

        emit_move_insn(input, operands[0]);
        emit_move_insn(input1, operands[1]);
        emit_library_call(XEXP(DECL_RTL(pic30_write_externals(pst_32)),0),
                          LCT_NORMAL, VOIDmode, 2,
                          input, P32EXTmode,
                          input1, GET_MODE(operands[1]));
        DONE;
      } else if (pic30_write_externals(pst_any)) {
        rtx input = gen_reg_rtx(P32EXTmode);
        rtx temp = assign_stack_temp(GET_MODE(operands[1]),
                                     GET_MODE_SIZE(GET_MODE(operands[1])), 0);
        rtx param2,param3;
 
        emit_move_insn(input, operands[0]);
        emit_move_insn(temp, operands[1]);
        param3 = gen_reg_rtx(HImode);
        param2 = gen_reg_rtx(Pmode);
        emit_move_insn(param3, GEN_INT(4));
        emit_move_insn(param2, XEXP(temp,0));
        emit_library_call(XEXP(DECL_RTL(pic30_write_externals(pst_any)),0),
                          LCT_NORMAL, GET_MODE(operands[0]), 3,
                          input, P32EXTmode,
                          param2, Pmode,
                          param3, HImode);
        DONE;
      } else {
        error(\"Cannot access external memory space;\n\"
              \"\tdeclare __write_external or __write_external32\");
      }
    }"
)

(define_expand "P32EXTrd_si"
   [(set (match_operand:SI 0 "pic30_move_operand"       "=r,R,rR,r,R")
         (mem:SI
           (match_operand:P32EXT 1 "pic30_ext_operand" "r,r,RQ,ST,ST")))]
   ""
   "{
      if (pic30_read_externals(pst_32)) {
        rtx input = gen_reg_rtx(P32EXTmode);

        emit_move_insn(input, operands[1]);
        emit_library_call_value(XEXP(DECL_RTL(pic30_read_externals(pst_32)),0),
                          operands[0], LCT_NORMAL, GET_MODE(operands[0]), 1,
                          input, P32EXTmode);
        DONE;
      } else if (pic30_read_externals(pst_any)) {
        rtx input = gen_reg_rtx(P32EXTmode);
        rtx temp = assign_stack_temp(GET_MODE(operands[0]),
                                     GET_MODE_SIZE(GET_MODE(operands[0])), 0);
        rtx param2,param3;

        emit_move_insn(input, operands[1]);
        param3 = gen_reg_rtx(HImode);
        param2 = gen_reg_rtx(Pmode);
        emit_move_insn(param3, GEN_INT(4));
        emit_move_insn(param2, XEXP(temp,0));
        emit_library_call(XEXP(DECL_RTL(pic30_read_externals(pst_any)),0),
                          LCT_NORMAL, GET_MODE(operands[0]), 3,
                          input, P32EXTmode,
                          param2, Pmode,
                          param3, HImode);
        emit_move_insn(operands[0], temp);
        DONE;
      } else {
        error(\"Cannot access external memory space;\n\"
              \"\tdeclare __read_external or __read_external32\");
      }
    }"
)

(define_expand "P32EXTwt_si"
   [(set (mem:SI (match_operand:P32EXT 0 "pic30_ext_operand" "r,r,RQ,ST,ST"))
         (match_operand:SI 1 "pic30_move_operand"       "r,R,rR,r,R"))]
   ""
   "{
      if (pic30_write_externals(pst_32)) {
        rtx input = gen_reg_rtx(P32EXTmode);
        rtx input1 = gen_reg_rtx(GET_MODE(operands[1]));

        emit_move_insn(input, operands[0]);
        emit_move_insn(input1, operands[1]);
        emit_library_call(XEXP(DECL_RTL(pic30_write_externals(pst_32)),0),
                          LCT_NORMAL, VOIDmode, 2,
                          input, P32EXTmode,
                          input1, GET_MODE(operands[1]));
        DONE;
      } else if (pic30_write_externals(pst_any)) {
        rtx input = gen_reg_rtx(P32EXTmode);
        rtx temp = assign_stack_temp(GET_MODE(operands[1]),
                                     GET_MODE_SIZE(GET_MODE(operands[1])), 0);
        rtx param2,param3;
 
        emit_move_insn(input, operands[0]);
        emit_move_insn(temp, operands[1]);
        param3 = gen_reg_rtx(HImode);
        param2 = gen_reg_rtx(Pmode);
        emit_move_insn(param3, GEN_INT(4));
        emit_move_insn(param2, XEXP(temp,0));
        emit_library_call(XEXP(DECL_RTL(pic30_write_externals(pst_any)),0),
                          LCT_NORMAL, GET_MODE(operands[0]), 3,
                          input, P32EXTmode,
                          param2, Pmode,
                          param3, HImode);
        DONE;
      } else {
        error(\"Cannot access external memory space;\n\"
              \"\tdeclare __write_external or __write_external32\");
      }
    }"
)

(define_expand "P32EXTrd_p32eds"
   [(set (match_operand:P32EDS 0 "pic30_move_operand"       "=r,R,rR,r,R")
         (mem:P32EDS
           (match_operand:P32EDS 1 "pic30_ext_operand" "r,r,RQ,ST,ST")))]
   ""
   "{
      if (pic30_read_externals(pst_32)) {
        rtx input = gen_reg_rtx(P32EDSmode);

        emit_move_insn(input, operands[1]);
        emit_library_call_value(XEXP(DECL_RTL(pic30_read_externals(pst_32)),0),
                          operands[0], LCT_NORMAL, GET_MODE(operands[0]), 1,
                          input, P32EDSmode);
        DONE;
      } else if (pic30_read_externals(pst_any)) {
        rtx input = gen_reg_rtx(P32EDSmode);
        rtx temp = assign_stack_temp(GET_MODE(operands[0]),
                                     GET_MODE_SIZE(GET_MODE(operands[0])), 0);
        rtx param2,param3;

        emit_move_insn(input, operands[1]);
        param3 = gen_reg_rtx(HImode);
        param2 = gen_reg_rtx(Pmode);
        emit_move_insn(param3, GEN_INT(4));
        emit_move_insn(param2, XEXP(temp,0));
        emit_library_call(XEXP(DECL_RTL(pic30_read_externals(pst_any)),0),
                          LCT_NORMAL, GET_MODE(operands[0]), 3,
                          input, P32EDSmode,
                          param2, Pmode,
                          param3, HImode);
        emit_move_insn(operands[0], temp);
        DONE;
      } else {
        error(\"Cannot access external memory space;\n\"
              \"\tdeclare __read_external or __read_external32\");
      }
    }"
)

(define_expand "P32EXTrd_p32peds"
   [(set (match_operand:P32PEDS 0 "pic30_move_operand"       "=r,R,rR,r,R")
         (mem:P32PEDS
           (match_operand:P32PEDS 1 "pic30_ext_operand" "r,r,RQ,ST,ST")))]
   ""
   "{
      if (pic30_read_externals(pst_32)) {
        rtx input = gen_reg_rtx(P32PEDSmode);

        emit_move_insn(input, operands[1]);
        emit_library_call_value(XEXP(DECL_RTL(pic30_read_externals(pst_32)),0),
                          operands[0], LCT_NORMAL, GET_MODE(operands[0]), 1,
                          input, P32EDSmode);
        DONE;
      } else if (pic30_read_externals(pst_any)) {
        rtx input = gen_reg_rtx(P32PEDSmode);
        rtx temp = assign_stack_temp(GET_MODE(operands[0]),
                                     GET_MODE_SIZE(GET_MODE(operands[0])), 0);
        rtx param2,param3;

        emit_move_insn(input, operands[1]);
        param3 = gen_reg_rtx(HImode);
        param2 = gen_reg_rtx(Pmode);
        emit_move_insn(param3, GEN_INT(4));
        emit_move_insn(param2, XEXP(temp,0));
        emit_library_call(XEXP(DECL_RTL(pic30_read_externals(pst_any)),0),
                          LCT_NORMAL, GET_MODE(operands[0]), 3,
                          input, P32PEDSmode,
                          param2, Pmode,
                          param3, HImode);
        emit_move_insn(operands[0], temp);
        DONE;
      } else {
        error(\"Cannot access external memory space;\n\"
              \"\tdeclare __read_external or __read_external32\");
      }
    }"
)

(define_expand "P32EXTrd_p32ext"
   [(set (match_operand:P32EXT 0 "pic30_move_operand"       "=r,R,rR,r,R")
         (mem:P32EXT
           (match_operand:P32EXT 1 "pic30_ext_operand" "r,r,RQ,ST,ST")))]
   ""
   "{
      if (pic30_read_externals(pst_32)) {
        rtx input = gen_reg_rtx(P32EXTmode);

        emit_move_insn(input, operands[1]);
        emit_library_call_value(XEXP(DECL_RTL(pic30_read_externals(pst_32)),0),
                          operands[0], LCT_NORMAL, GET_MODE(operands[0]), 1,
                          input, P32EXTmode);
        DONE;
      } else if (pic30_read_externals(pst_any)) {
        rtx input = gen_reg_rtx(P32EXTmode);
        rtx temp = assign_stack_temp(GET_MODE(operands[0]),
                                     GET_MODE_SIZE(GET_MODE(operands[0])), 0);
        rtx param2,param3;

        emit_move_insn(input, operands[1]);
        param3 = gen_reg_rtx(HImode);
        param2 = gen_reg_rtx(Pmode);
        emit_move_insn(param3, GEN_INT(4));
        emit_move_insn(param2, XEXP(temp,0));
        emit_library_call(XEXP(DECL_RTL(pic30_read_externals(pst_any)),0),
                          LCT_NORMAL, GET_MODE(operands[0]), 3,
                          input, P32EXTmode,
                          param2, Pmode,
                          param3, HImode);
        emit_move_insn(operands[0], temp);
        DONE;
      } else {
        error(\"Cannot access external memory space;\n\"
              \"\tdeclare __read_external or __read_external32\");
      }
    }"
)

(define_expand "P32EXTwt_p32eds"
   [(set (mem:P32EDS 
           (match_operand:P32EDS 0 "pic30_ext_operand" "r,r,RQ,ST,ST"))
         (match_operand:P32EDS 1 "pic30_move_operand"  "r,R,rR,r,R"))]
   ""
   "{
      if (pic30_write_externals(pst_32)) {
        rtx input = gen_reg_rtx(P32EDSmode);
        rtx input1 = gen_reg_rtx(GET_MODE(operands[1]));

        emit_move_insn(input, operands[0]);
        emit_move_insn(input1, operands[1]);
        emit_library_call(XEXP(DECL_RTL(pic30_write_externals(pst_32)),0),
                          LCT_NORMAL, VOIDmode, 2,
                          input, P32EDSmode,
                          input1, GET_MODE(operands[1]));
        DONE;
      } else if (pic30_write_externals(pst_any)) {
        rtx input = gen_reg_rtx(P32EDSmode);
        rtx temp = assign_stack_temp(GET_MODE(operands[1]),
                                     GET_MODE_SIZE(GET_MODE(operands[1])), 0);
        rtx param2,param3;
 
        emit_move_insn(input, operands[0]);
        emit_move_insn(temp, operands[1]);
        param3 = gen_reg_rtx(HImode);
        param2 = gen_reg_rtx(Pmode);
        emit_move_insn(param3, GEN_INT(4));
        emit_move_insn(param2, XEXP(temp,0));
        emit_library_call(XEXP(DECL_RTL(pic30_write_externals(pst_any)),0),
                          LCT_NORMAL, GET_MODE(operands[0]), 3,
                          input, P32EDSmode,
                          param2, Pmode,
                          param3, HImode);
        DONE;
      } else {
        error(\"Cannot access external memory space;\n\"
              \"\tdeclare __write_external or __write_external32\");
      }
    }"
)

(define_expand "P32EXTwt_p32peds"
   [(set (mem:P32PEDS 
           (match_operand:P32PEDS 0 "pic30_ext_operand" "r,r,RQ,ST,ST"))
         (match_operand:P32PEDS 1 "pic30_move_operand"  "r,R,rR,r,R"))]
   ""
   "{
      if (pic30_write_externals(pst_32)) {
        rtx input = gen_reg_rtx(P32PEDSmode);
        rtx input1 = gen_reg_rtx(GET_MODE(operands[1]));

        emit_move_insn(input, operands[0]);
        emit_move_insn(input1, operands[1]);
        emit_library_call(XEXP(DECL_RTL(pic30_write_externals(pst_32)),0),
                          LCT_NORMAL, VOIDmode, 2,
                          input, P32PEDSmode,
                          input1, GET_MODE(operands[1]));
        DONE;
      } else if (pic30_write_externals(pst_any)) {
        rtx input = gen_reg_rtx(P32PEDSmode);
        rtx temp = assign_stack_temp(GET_MODE(operands[1]),
                                     GET_MODE_SIZE(GET_MODE(operands[1])), 0);
        rtx param2,param3;
 
        emit_move_insn(input, operands[0]);
        emit_move_insn(temp, operands[1]);
        param3 = gen_reg_rtx(HImode);
        param2 = gen_reg_rtx(Pmode);
        emit_move_insn(param3, GEN_INT(4));
        emit_move_insn(param2, XEXP(temp,0));
        emit_library_call(XEXP(DECL_RTL(pic30_write_externals(pst_any)),0),
                          LCT_NORMAL, GET_MODE(operands[0]), 3,
                          input, P32PEDSmode,
                          param2, Pmode,
                          param3, HImode);
        DONE;
      } else {
        error(\"Cannot access external memory space;\n\"
              \"\tdeclare __write_external or __write_external32\");
      }
    }"
)

(define_expand "P32EXTwt_p32ext"
   [(set (mem:P32EXT 
           (match_operand:P32EXT 0 "pic30_ext_operand" "r,r,RQ,ST,ST"))
         (match_operand:P32EXT 1 "pic30_move_operand"  "r,R,rR,r,R"))]
   ""
   "{
      if (pic30_write_externals(pst_32)) {
        rtx input = gen_reg_rtx(P32EXTmode);
        rtx input1 = gen_reg_rtx(GET_MODE(operands[1]));

        emit_move_insn(input, operands[0]);
        emit_move_insn(input1, operands[1]);
        emit_library_call(XEXP(DECL_RTL(pic30_write_externals(pst_32)),0),
                          LCT_NORMAL, VOIDmode, 2,
                          input, P32EXTmode,
                          input1, GET_MODE(operands[1]));
        DONE;
      } else if (pic30_write_externals(pst_any)) {
        rtx input = gen_reg_rtx(P32EXTmode);
        rtx temp = assign_stack_temp(GET_MODE(operands[1]),
                                     GET_MODE_SIZE(GET_MODE(operands[1])), 0);
        rtx param2,param3;
 
        emit_move_insn(input, operands[0]);
        emit_move_insn(temp, operands[1]);
        param3 = gen_reg_rtx(HImode);
        param2 = gen_reg_rtx(Pmode);
        emit_move_insn(param3, GEN_INT(4));
        emit_move_insn(param2, XEXP(temp,0));
        emit_library_call(XEXP(DECL_RTL(pic30_write_externals(pst_any)),0),
                          LCT_NORMAL, GET_MODE(operands[0]), 3,
                          input, P32EXTmode,
                          param2, Pmode,
                          param3, HImode);
        DONE;
      } else {
        error(\"Cannot access external memory space;\n\"
              \"\tdeclare __write_external or __write_external32\");
      }
    }"
)

(define_expand "P32EXTrd_sf"
   [(set (match_operand:SF 0 "pic30_move_operand"       "=r,R,rR,r,R")
         (mem:SF
           (match_operand:P32EXT 1 "pic30_ext_operand" "r,r,RQ,ST,ST")))]
   ""
   "{
      if (pic30_read_externals(pst_32)) {
        rtx input = gen_reg_rtx(P32EXTmode);

        emit_move_insn(input, operands[1]);
        emit_library_call_value(XEXP(DECL_RTL(pic30_read_externals(pst_32)),0),
                          operands[0], LCT_NORMAL, GET_MODE(operands[0]), 1,
                          input, P32EXTmode);
        DONE;
      } else if (pic30_read_externals(pst_any)) {
        rtx input = gen_reg_rtx(P32EXTmode);
        rtx temp = assign_stack_temp(GET_MODE(operands[0]),
                                     GET_MODE_SIZE(GET_MODE(operands[0])), 0);
        rtx param2,param3;

        emit_move_insn(input, operands[1]);
        param3 = gen_reg_rtx(HImode);
        param2 = gen_reg_rtx(Pmode);
        emit_move_insn(param3, GEN_INT(4));
        emit_move_insn(param2, XEXP(temp,0));
        emit_library_call(XEXP(DECL_RTL(pic30_read_externals(pst_any)),0),
                          LCT_NORMAL, GET_MODE(operands[0]), 3,
                          input, P32EXTmode,
                          param2, Pmode,
                          param3, HImode);
        emit_move_insn(operands[0], temp);
        DONE;
      } else {
        error(\"Cannot access external memory space;\n\"
              \"\tdeclare __read_external or __read_external32\");
      }
    }"
)

(define_expand "P32EXTwt_sf"
   [(set (mem:SF (match_operand:P32EXT 0 "pic30_ext_operand" "r,r,RQ,ST,ST"))
         (match_operand:SF 1 "pic30_move_operand"            "r,R,rR,r,R"))]
   ""
   "{
      if (pic30_write_externals(pst_32)) {
        rtx input = gen_reg_rtx(P32EXTmode);
        rtx input1 = gen_reg_rtx(GET_MODE(operands[1]));

        emit_move_insn(input, operands[0]);
        emit_move_insn(input1, operands[1]);
        emit_library_call(XEXP(DECL_RTL(pic30_write_externals(pst_32)),0),
                          LCT_NORMAL, VOIDmode, 2,
                          input, P32EXTmode,
                          input1, GET_MODE(operands[1]));
        DONE;
      } else if (pic30_write_externals(pst_any)) {
        rtx input = gen_reg_rtx(P32EXTmode);
        rtx temp = assign_stack_temp(GET_MODE(operands[1]),
                                     GET_MODE_SIZE(GET_MODE(operands[1])), 0);
        rtx param2,param3;
 
        emit_move_insn(input, operands[0]);
        emit_move_insn(temp, operands[1]);
        param3 = gen_reg_rtx(HImode);
        param2 = gen_reg_rtx(Pmode);
        emit_move_insn(param3, GEN_INT(4));
        emit_move_insn(param2, XEXP(temp,0));
        emit_library_call(XEXP(DECL_RTL(pic30_write_externals(pst_any)),0),
                          LCT_NORMAL, GET_MODE(operands[0]), 3,
                          input, P32EXTmode,
                          param2, Pmode,
                          param3, HImode);
        DONE;
      } else {
        error(\"Cannot access external memory space;\n\"
              \"\tdeclare __write_external or __write_external32\");
      }
    }"
)

(define_expand "P32EXTrd_di"
   [(set (match_operand:DI 0 "pic30_move_operand"       "=r,R,rR,r,R")
         (mem:DI
           (match_operand:P32EXT 1 "pic30_ext_operand" "r,r,RQ,ST,ST")))]
   ""
   "{
      if (pic30_read_externals(pst_64)) {
        rtx input = gen_reg_rtx(P32EXTmode);

        emit_move_insn(input, operands[1]);
        emit_library_call_value(XEXP(DECL_RTL(pic30_read_externals(pst_64)),0),
                          operands[0], LCT_NORMAL, GET_MODE(operands[0]), 1,
                          input, P32EXTmode);
        DONE;
      } else if (pic30_read_externals(pst_any)) {
        rtx input = gen_reg_rtx(P32EXTmode);
        rtx temp = assign_stack_temp(GET_MODE(operands[0]),
                                     GET_MODE_SIZE(GET_MODE(operands[0])), 0);
        rtx param2,param3;

        emit_move_insn(input, operands[1]);
        param3 = gen_reg_rtx(HImode);
        param2 = gen_reg_rtx(Pmode);
        emit_move_insn(param3, GEN_INT(8));
        emit_move_insn(param2, XEXP(temp,0));
        emit_library_call(XEXP(DECL_RTL(pic30_read_externals(pst_any)),0),
                          LCT_NORMAL, GET_MODE(operands[0]), 3,
                          input, P32EXTmode,
                          param2, Pmode,
                          param3, HImode);
        emit_move_insn(operands[0], temp);
        DONE;
      } else {
        error(\"Cannot access external memory space;\n\"
              \"\tdeclare __read_external or __read_external64\");
      }
    }"
)

(define_expand "P32EXTwt_di"
   [(set (mem:DI (match_operand:P32EXT 0 "pic30_ext_operand" "r,r,RQ,ST,ST"))
         (match_operand:DI 1 "pic30_move_operand"            "r,R,rR,r,R"))]
   ""
   "{
      if (pic30_write_externals(pst_64)) {
        rtx input = gen_reg_rtx(P32EXTmode);
        rtx input1 = gen_reg_rtx(GET_MODE(operands[1]));

        emit_move_insn(input, operands[0]);
        emit_move_insn(input1, operands[1]);
        emit_library_call(XEXP(DECL_RTL(pic30_write_externals(pst_64)),0),
                          LCT_NORMAL, VOIDmode, 2,
                          input, P32EXTmode,
                          input1, GET_MODE(operands[1]));
        DONE;
      } else if (pic30_write_externals(pst_any)) {
        rtx input = gen_reg_rtx(P32EXTmode);
        rtx temp = assign_stack_temp(GET_MODE(operands[1]),
                                     GET_MODE_SIZE(GET_MODE(operands[1])), 0);
        rtx param2,param3;
 
        emit_move_insn(input, operands[0]);
        emit_move_insn(temp, operands[1]);
        param3 = gen_reg_rtx(HImode);
        param2 = gen_reg_rtx(Pmode);
        emit_move_insn(param3, GEN_INT(8));
        emit_move_insn(param2, XEXP(temp,0));
        emit_library_call(XEXP(DECL_RTL(pic30_write_externals(pst_any)),0),
                          LCT_NORMAL, GET_MODE(operands[0]), 3,
                          input, P32EXTmode,
                          param2, Pmode,
                          param3, HImode);
        DONE;
      } else {
        error(\"Cannot access external memory space;\n\"
              \"\tdeclare __write_external or __write_external64\");
      }
    }"
)

(define_expand "P32EXTrd_df"
   [(set (match_operand:DF 0 "pic30_move_operand"       "=r,R,rR,r,R")
         (mem:DF
           (match_operand:P32EXT 1 "pic30_ext_operand" "r,r,RQ,ST,ST")))]
   ""
   "{
      if (pic30_read_externals(pst_64)) {
        rtx input = gen_reg_rtx(P32EXTmode);

        emit_move_insn(input, operands[1]);
        emit_library_call_value(XEXP(DECL_RTL(pic30_read_externals(pst_64)),0),
                          operands[0], LCT_NORMAL, GET_MODE(operands[0]), 1,
                          input, P32EXTmode);
        DONE;
      } else if (pic30_read_externals(pst_any)) {
        rtx input = gen_reg_rtx(P32EXTmode);
        rtx temp = assign_stack_temp(GET_MODE(operands[0]),
                                     GET_MODE_SIZE(GET_MODE(operands[0])), 0);
        rtx param2,param3;

        emit_move_insn(input, operands[1]);
        param3 = gen_reg_rtx(HImode);
        param2 = gen_reg_rtx(Pmode);
        emit_move_insn(param3, GEN_INT(4));
        emit_move_insn(param2, XEXP(temp,0));
        emit_library_call(XEXP(DECL_RTL(pic30_read_externals(pst_any)),0),
                          LCT_NORMAL, GET_MODE(operands[0]), 3,
                          input, P32EXTmode,
                          param2, Pmode,
                          param3, HImode);
        emit_move_insn(operands[0], temp);
        DONE;
      } else {
        error(\"Cannot access external memory space;\n\"
              \"\tdeclare __read_external or __read_external64\");
      }
    }"
)

(define_expand "P32EXTwt_df"
   [(set (mem:DF (match_operand:P32EXT 0 "pic30_ext_operand" "r,r,RQ,ST,ST"))
         (match_operand:DF 1 "pic30_move_operand"            "r,R,rR,r,R"))]
   ""
   "{
      if (pic30_write_externals(pst_64)) {
        rtx input = gen_reg_rtx(P32EXTmode);
        rtx input1 = gen_reg_rtx(GET_MODE(operands[1]));

        emit_move_insn(input, operands[0]);
        emit_move_insn(input1, operands[1]);
        emit_library_call(XEXP(DECL_RTL(pic30_write_externals(pst_64)),0),
                          LCT_NORMAL, VOIDmode, 2,
                          input, P32EXTmode,
                          input1, GET_MODE(operands[1]));
        DONE;
      } else if (pic30_write_externals(pst_any)) {
        rtx input = gen_reg_rtx(P32EXTmode);
        rtx temp = assign_stack_temp(GET_MODE(operands[1]),
                                     GET_MODE_SIZE(GET_MODE(operands[1])), 0);
        rtx param2,param3;
 
        emit_move_insn(input, operands[0]);
        emit_move_insn(temp, operands[1]);
        param3 = gen_reg_rtx(HImode);
        param2 = gen_reg_rtx(Pmode);
        emit_move_insn(param3, GEN_INT(8));
        emit_move_insn(param2, XEXP(temp,0));
        emit_library_call(XEXP(DECL_RTL(pic30_write_externals(pst_any)),0),
                          LCT_NORMAL, GET_MODE(operands[0]), 3,
                          input, P32EXTmode,
                          param2, Pmode,
                          param3, HImode);
        DONE;
      } else {
        error(\"Cannot access external memory space;\n\"
              \"\tdeclare __write_external or __write_external64\");
      }
    }"
)

;;;;;;;;;;;;;;;;;;; DF

(define_expand "P32DFrd"
  [(set (match_operand 0 "pic30_register_operand"    "=a")
        (match_operand 1 "pic30_mem_df_operand" " RQST"))]
  ""
  { rtx op0 = operand0;
     emit_library_call_value(
       gen_rtx_SYMBOL_REF(HImode, \"|Nf|__P32DFrd\"),
       op0,
       LCT_NORMAL,
       GET_MODE(op0),
       2,               /* args */
       XEXP(operands[1], 0), P32DFmode,
       GEN_INT(GET_MODE_SIZE(GET_MODE(op0))), HImode
     );
     DONE;
  }
)

;;;;;;;;;;;;;;;;;;; EDS

(define_expand "P32EDSrd"
   [(set (match_operand 0 "pic30_reg_or_R_operand"       "=rR")
         (match_operand 1 "pic30_mem_eds_operand"    " RQST"))]
   ""
   "{
   rtx op2 = gen_reg_rtx(P32EDSmode);
   rtx op3 = gen_reg_rtx(HImode);
   rtx op0 = operand0;
   rtx op1 = operand1;
   rtx page = gen_reg_rtx(HImode);
   rtx offset = gen_reg_rtx(HImode);
   rtx (*fn)(rtx, rtx);
   int indirect_allowed=1;
   int psv_set=0;
   int unpack=0;

   if (GET_MODE(op0) != GET_MODE(op1)) FAIL;
   switch (GET_MODE(op0)) {
     default:
                  fprintf(stderr, \"Unknown mode: %s\n\",
                          mode_name[GET_MODE(op0)]);
                  FAIL;
     case QImode: fn = gen_P32EDSread_qi;
                  break;
     case HImode: fn = gen_P32EDSread_hi;
                  break;
     case SImode: fn = gen_P32EDSread_si;
                  unpack=1;
                  break;
     case DImode: fn = gen_P32EDSread_di;
                  indirect_allowed=0;
                  unpack=1;
                  break;
     case SFmode: fn = gen_P32EDSread_sf;
                  unpack=1;
                  break;
     case DFmode: fn = gen_P32EDSread_df;
                  indirect_allowed=0;
                  unpack=1;
                  break;
     case P16APSVmode: fn = gen_P32EDSread_p16apsv;
                  break;
     case P24PSVmode: fn = gen_P32EDSread_p24psv;
                  unpack=1;
                  break;
     case P24PROGmode: fn = gen_P32EDSread_p24prog;
                  unpack=1;
                  break;
     case P16PMPmode: fn = gen_P32EDSread_p16pmp;
                  unpack=1;
                  break;
     case P32EXTmode: fn = gen_P32EDSread_p32ext;
                  unpack=1;
                  break;
     case P32EDSmode: fn = gen_P32EDSread_p32eds;
                  unpack=1;
                  break;
     case P32PEDSmode: fn = gen_P32EDSread_p32peds;
                  unpack=1;
                  break;
   }
   if ((indirect_allowed == 0) && (pic30_R_operand(op0, GET_MODE(op0)))) {
     op0 = gen_reg_rtx(GET_MODE(op0));
   } else if (!pic30_reg_or_R_operand(op0, GET_MODE(op0))) {
     op0 = gen_reg_rtx(GET_MODE(op0));
   }
   pic30_managed_psv = 1;
   if (!TARGET_EDS) {
     emit_insn(
       gen_copy_psv(op3)                                /* preserve PSVPAG */
     );
   }
   if (pic30_R_constraint_strict(op1,0) || pic30_Q_constraint(op1) ||
       pic30_S_constraint_ecore(op1,1)) {
     if (GET_CODE(XEXP(op1,0)) == PLUS) {
       expand_binop(P32EDSmode, add_optab, XEXP(XEXP(op1,0),0),
                    XEXP(XEXP(op1,0),1), op2, 1, OPTAB_DIRECT);
     } else {
       emit_insn(
         gen_movp32eds_gen(op2, XEXP(op1,0)) /* copy pointer */
       );
     }
   } else {
     if (pic30_ecore_target()) {
       psv_set = 1;
       /* create pointer */
       if (pic30_symbolic_address_operand(XEXP(op1,0),VOIDmode) &&
           pic30_symbolic_address_operand_offset(XEXP(op1,0)) < 1023) {
         char *t = pic30_section_base(XEXP(op1,0),0,0);
         
         emit_insn(
           gen_movpag(XEXP(op1,0), GEN_INT(0))
         );
         emit_insn(
           gen_movEDS_address_offset(offset, GEN_INT((HOST_WIDE_INT)t))   
         );
       } else {
         rtx reg = force_reg(P32EDSmode, XEXP(op1,0));

         emit_insn(
           gen_movpag(simplify_gen_subreg(HImode, reg, GET_MODE(reg), 2), GEN_INT(0))
         );
         emit_move_insn(offset,
                        simplify_gen_subreg(HImode, reg, GET_MODE(reg), 0));
       }
     } else {
       emit_insn(
         gen_movp32eds_address(op2, XEXP(op1,0))        /* create pointer */
       );
     }
   }
   if (unpack) {
     rtx op2a = gen_reg_rtx(P32EDSmode);
     emit_insn(
       gen_unpack_EDS(op2a,op2)
     );
     op2 = op2a;
   }
   if (!psv_set) {
     emit_move_insn(page, gen_rtx_SUBREG(HImode,op2,2));
     emit_insn(
       gen_set_psv(page)                                  /* set PSVPAG */
     );
     emit_move_insn(offset, gen_rtx_SUBREG(HImode,op2,0));
   }
   emit_insn(
     fn(op0, gen_rtx_MEM(GET_MODE(op1),offset))         /* read value */
   );
   if (op0 != operand0) {
     emit_move_insn(operand0, op0);
   }
   if (!TARGET_EDS) {
     emit_insn(
       gen_set_vpsv(op3)                                /* restore PSVPAG */
     );
   }
   DONE;
}")

(define_insn "P32PEDSumovoffset"
  [(set (match_operand:HI         0 "pic30_register_operand" "=r")
        (subreg:HI
           (match_operand:P32PEDS 1 "pic30_register_operand" " r") 0))]
  ""
  "*
   if (REGNO(operands[1]) != REGNO(operands[0])) return \"mov %1,%0\";
   else return \"; nop\";
  "
)

(define_insn "P32PEDSumovoffset2"
  [(set (match_operand:HI           0 "pic30_register_operand"   "=r,&r")
        (subreg:HI
           (plus:P32PEDS
             (match_operand:P32PEDS 1 "pic30_register_operand"   " 0,r")
             (match_operand         2 "immediate_operand"  " J,i")) 0))]
  ""
  "@
   add #%2,%0
   mov #%2,%0\;add %0,%1,%0"
)


(define_insn "P32PEDSumovpage"
  [(set (match_operand:HI         0 "pic30_register_operand" "=r")
	(subreg:HI
           (match_operand:P32PEDS 1 "pic30_register_operand" " r") 2))]
  ""
  "mov %d1,%0"
)

(define_insn "P32PEDSumovpage2"
  [(set (match_operand:HI           0 "pic30_register_operand"   "=r")
        (subreg:HI
           (plus:P32PEDS
             (match_operand:P32PEDS 1 "pic30_register_operand"   " r")
             (match_operand         2 "immediate_operand"  " i")) 2))]
  ""
  "mov %d1,%0"
)


(define_expand "P32PEDSrd"
   [(set (match_operand 0 "pic30_move_operand"       "=rR")
         (match_operand 1 "pic30_mem_peds_operand"   " RQST"))]
   ""
   "{
   rtx op2 = gen_reg_rtx(P32PEDSmode);
   rtx op3 = gen_reg_rtx(HImode);
   rtx op0 = operand0;
   rtx op1 = operand1;
   rtx page = gen_reg_rtx(HImode);
   rtx offset = gen_reg_rtx(HImode);
   rtx (*fn)(rtx, rtx);
   int psv_set=0;
   int no_copy = 0;

   if (GET_MODE(op0) != GET_MODE(op1)) FAIL;
   switch (GET_MODE(op0)) {
     default:
                  fprintf(stderr, \"Unknown mode: %s\n\",
                          mode_name[GET_MODE(op0)]);
                  FAIL;
     case QImode: fn = gen_P32PEDSread_qi;
                  break;
     case HImode: fn = gen_P32PEDSread_hi;
                  break;
     case SImode: fn = gen_P32PEDSread_si;
                  break;
     case DImode: fn = gen_P32PEDSread_di;
                  break;
     case SFmode: fn = gen_P32PEDSread_sf;
                  break;
     case DFmode: fn = gen_P32PEDSread_df;
                  break;
     case P16APSVmode: fn = gen_P32PEDSread_p16apsv;
                  break;
     case P24PSVmode: fn = gen_P32PEDSread_p24psv;
                  break;
     case P24PROGmode: fn = gen_P32PEDSread_p24prog;
                  break;
     case P16PMPmode: fn = gen_P32PEDSread_p16pmp;
                  break;
     case P32EXTmode: fn = gen_P32PEDSread_p32ext;
                  break;
     case P32EDSmode: fn = gen_P32PEDSread_p32eds;
                  break;
     case P32PEDSmode: fn = gen_P32PEDSread_p32peds;
                  break;
   }
   if (!pic30_mode2_operand(op0, GET_MODE(op0))) {
     op0 = gen_reg_rtx(GET_MODE(op0));
   }
   pic30_managed_psv = 1;
   if (!TARGET_EDS) {
     emit_insn(
       gen_copy_psv(op3)                                /* preserve PSVPAG */
     );
   }
   if (pic30_R_constraint_strict(op1,0)) {
     switch (GET_MODE(op0)) {
       case HImode:
         no_copy = 1;
         op2 = XEXP(op1,0);
         fn = gen_P32PEDSuread_hi;
         break;
       case P32PEDSmode:
         no_copy = 1;
         op2 = XEXP(op1,0);
         fn = gen_P32PEDSuread_p32peds;
         break;
       default:
         emit_insn(
           gen_movp32peds_gen(op2, XEXP(op1,0))              /* copy pointer */
         );
         break;
     }
   } else if (pic30_Q_constraint(op1) || pic30_S_constraint(op1)) {
     rtx inner = XEXP(operands[1],0);

     if (pic30_Q_constraint(op1)) { 
       switch (GET_MODE(op0)) {
         case HImode:
           no_copy = 1;
           op2 = XEXP(op1,0);
           fn = gen_P32PEDSuread_hi;
           break;
         case P32PEDSmode:
           no_copy = 1;
           op2 = XEXP(op1,0);
           fn = gen_P32PEDSuread_p32peds;
           break;
         default:
           emit_insn(
             gen_addp32peds3(op2, XEXP(inner,0), XEXP(inner,1))
           );
       }
     } else {
       emit_insn(
         gen_addp32peds3(op2, XEXP(inner,0), XEXP(inner,1))
       );
     }
   } else {
     if (pic30_ecore_target()) {
       char *t = pic30_section_base(XEXP(op1,0),0,0);
       psv_set=1;
       emit_insn(
         gen_movEDS_address_offset(offset, GEN_INT((HOST_WIDE_INT)t))   /* create pointer */
       );
       emit_insn(
         gen_movpag(XEXP(op1,0), GEN_INT(0))
       );
     } else {
       emit_insn(
         gen_movp32peds_address(op2, XEXP(op1,0))        /* create pointer */
       );
     }
   }
   if (!psv_set) {
     if (!TARGET_EDS) {
       emit_move_insn(page, gen_rtx_SUBREG(HImode,op2,2));
       emit_insn(
         gen_set_psv(page)                                  /* set PSVPAG */
       );
       emit_move_insn(offset, gen_rtx_SUBREG(HImode,op2,0));
       offset = gen_rtx_MEM(GET_MODE(op1),offset);
     } else {
       if (no_copy) {
         if (GET_CODE(op2) == PLUS) {
           emit_insn(
             gen_set_unpsv(XEXP(op2,0))                       /* set PSVPAG */
           );
         } else {
           emit_insn(
             gen_set_unpsv(op2)                               /* set PSVPAG */
           );
         }
         offset = operands[1];
       } else {
         emit_insn(
           gen_P32PEDSumovpage(page,op2)
         );
         emit_insn(
           gen_set_psv(page)                                  /* set PSVPAG */
         );
         emit_insn(
           gen_P32PEDSumovoffset(offset,op2)
         );
         offset = gen_rtx_MEM(GET_MODE(op1),offset);
       }
     }
   }
   emit_insn(
     fn(op0, offset)                                         /* read value */
   );
   if (op0 != operand0) {
     emit_move_insn(operand0, op0);
   }
   if (!TARGET_EDS) {
     emit_insn(
       gen_set_psv(op3)                                 /* restore PSVPAG */
     );
   }
   DONE;
}")

(define_expand "P32EDSwt"
   [(set (match_operand 0 "pic30_mem_eds_operand"   "=RQ,ST")
         (match_operand 1 "pic30_move_operand"       " rR,rR"))]
   ""
   "{
   rtx op2 = gen_reg_rtx(P32EDSmode);
   rtx op3 = gen_reg_rtx(HImode);
   rtx op1 = operand1;
   rtx op0 = operand0;
   rtx page = gen_reg_rtx(HImode);
   rtx offset = gen_reg_rtx(HImode);
   rtx (*fn)(rtx, rtx);
   int eds_target = pic30_eds_target();
   int unpack=0;

   if ((GET_CODE(XEXP(op0,0)) == POST_INC) &&
       (REGNO(XEXP(XEXP(op0,0),0)) == SP_REGNO)) {
     /* this is a stack write that can only be generated with -munified
        (which changes the Pmode to P32EDSmode) - change it back to a normal
        write */
     switch (GET_MODE(op0)) {
       default:
                    fprintf(stderr, \"Unknown mode: %s\n\",
                            mode_name[GET_MODE(op0)]);
                    FAIL;
       case QImode: fn = gen_movqi;
                    break;
       case HImode: fn = gen_movhi;
                    break;
       case SImode: fn = gen_movsi;
                    break;
       case DImode: fn = gen_movdi;
                    break;
       case SFmode: fn = gen_movsf;
                    break;
       case DFmode: fn = gen_movdf;
                    break;
       case P16APSVmode: fn = gen_movp16apsv;
                    break;
       case P24PSVmode: fn = gen_movp24psv;
                    break;
       case P24PROGmode: fn = gen_movp24prog;
                    break;
       case P16PMPmode: fn = gen_movp16pmp;
                    break;
       case P32EXTmode: fn = gen_movp32ext;
                    break;
       case P32EDSmode: fn = gen_movp32eds;
                    break;
       case P32PEDSmode: fn = gen_movp32peds;
                    break;
     }

     if (fn(gen_rtx_MEM(GET_MODE(op0),
                        gen_rtx_POST_INC(HImode,gen_rtx_REG(HImode, SP_REGNO))),
            op1))
       DONE;
     FAIL;
   }
   if (GET_MODE(op0) != GET_MODE(op1)) FAIL;
   switch (GET_MODE(op0)) {
     default:
                  fprintf(stderr, \"Unknown mode: %s\n\",
                          mode_name[GET_MODE(op0)]);
                  FAIL;
     case QImode: fn = gen_P32EDSwrite_qi;
                  break;
     case HImode: fn = gen_P32EDSwrite_hi;
                  break;
     case SImode: fn = gen_P32EDSwrite_si;
                  unpack=1;
                  break;
     case DImode: fn = gen_P32EDSwrite_di;
                  unpack=1;
                  break;
     case SFmode: fn = gen_P32EDSwrite_sf;
                  unpack=1;
                  break;
     case DFmode: fn = gen_P32EDSwrite_df;
                  unpack=1;
                  break;
     case P16APSVmode: fn = gen_P32EDSwrite_p16apsv;
                  unpack=1;
                  break;
     case P24PSVmode: fn = gen_P32EDSwrite_p24psv;
                  unpack=1;
                  break;
     case P24PROGmode: fn = gen_P32EDSwrite_p24prog;
                  unpack=1;
                  break;
     case P16PMPmode: fn = gen_P32EDSwrite_p16pmp;
                  break;
     case P32EXTmode: fn = gen_P32EDSwrite_p32ext;
                  unpack=1;
                  break;
     case P32EDSmode: fn = gen_P32EDSwrite_p32eds;
                  unpack=1;
                  break;
     case P32PEDSmode: fn = gen_P32EDSwrite_p32peds;
                  unpack=1;
                  break;
   }
   if (!pic30_mode2_operand(op1, GET_MODE(op1))) {
     op1 = gen_reg_rtx(GET_MODE(op1));
     emit_move_insn(op1, operand1);
   }
   if (eds_target) {
     pic30_managed_psv = 1;
   }
   if (pic30_R_constraint_strict(op0,0) || pic30_Q_constraint(op0) ||
       pic30_S_constraint_ecore(op0,1)) {
     if (GET_CODE(XEXP(op0,0)) == PLUS) {
       expand_binop(P32EDSmode, add_optab, XEXP(XEXP(op0,0),0),
                    XEXP(XEXP(op0,0),1), op2, 1, OPTAB_DIRECT);
     } else {
       emit_insn(
         gen_movp32eds_gen(op2, XEXP(op0,0)) /* copy pointer */
       );
     }
   } else {
     emit_insn(
       gen_movp32eds_address(op2, XEXP(op0,0))          /* create pointer */
     );
   }
   if (unpack) {
     rtx op2a = gen_reg_rtx(P32EDSmode);
     emit_insn(
       gen_unpack_EDS(op2a,op2)
     );
     op2 = op2a;
   }
   if (eds_target) {
     if (!TARGET_EDS) {
       emit_insn(
         gen_copy_dsw(op3)                              /* preserve PSVPAG */
       );
     }
     if (!TARGET_EDS) {
       emit_move_insn(page, gen_rtx_SUBREG(HImode,op2,2));
     } else {
       emit(
         gen_P32PEDSumovpage(page, op2)
       );
     }
   }
   if (!TARGET_EDS) {
     emit_move_insn(offset, gen_rtx_SUBREG(HImode,op2,0));
   } else {
     emit(
       gen_P32PEDSumovoffset(offset,op2)
     );
   }
   if (eds_target) {
     emit_insn(
       gen_set_dsw(page)                                /* set PSVPAG */
     );
   }
   emit_insn(
     fn(gen_rtx_MEM(GET_MODE(op0),offset), op1)         /* write value */
   );
   if (eds_target) {
     if (!TARGET_EDS) {
       emit_insn(
         gen_set_dsw(op3)                               /* restore PSVPAG */
       );
     }
   }
   DONE;
}")

(define_expand "P32PEDSwt"
   [(set (match_operand 0 "pic30_mem_peds_operand"   "=RQ,ST")
         (match_operand 1 "pic30_move_operand"       " rR,rR"))]
   ""
   "{  
   rtx op2 = gen_reg_rtx(P32PEDSmode);
   rtx op3 = gen_reg_rtx(HImode);
   rtx op1 = operand1;
   rtx op0 = operand0;
   rtx page = gen_reg_rtx(HImode);
   rtx offset = gen_reg_rtx(HImode);
   rtx (*fn)(rtx, rtx);
   int eds_target = pic30_eds_target();
   int copy = 1;

   if (GET_MODE(op0) != GET_MODE(op1)) FAIL;
   switch (GET_MODE(op0)) {
     default:
                  fprintf(stderr, \"Unknown mode: %s\n\", 
                          mode_name[GET_MODE(op0)]);
                  FAIL;
     case QImode: fn = gen_P32PEDSwrite_qi;
                  break;
     case HImode: fn = gen_P32PEDSwrite_hi;
                  break;
     case SImode: fn = gen_P32PEDSwrite_si;
                  break;
     case DImode: fn = gen_P32PEDSwrite_di;
                  break;
     case SFmode: fn = gen_P32PEDSwrite_sf;
                  break;
     case DFmode: fn = gen_P32PEDSwrite_df;
                  break;
     case P16APSVmode: fn = gen_P32PEDSwrite_p16apsv;
                  break;
     case P24PSVmode: fn = gen_P32PEDSwrite_p24psv;
                  break;
     case P24PROGmode: fn = gen_P32PEDSwrite_p24prog;
                  break;
     case P16PMPmode: fn = gen_P32PEDSwrite_p16pmp;
                  break;
     case P32EXTmode: fn = gen_P32PEDSwrite_p32ext;
                  break;
     case P32EDSmode: fn = gen_P32PEDSwrite_p32eds;
                  break;
     case P32PEDSmode: fn = gen_P32PEDSwrite_p32peds;
                  break;
   }
   if (!pic30_mode2_operand(op1, GET_MODE(op1))) {
     op1 = gen_reg_rtx(GET_MODE(op1));
     emit_move_insn(op1, operand1);
   }
   if (eds_target) {
     pic30_managed_psv = 1;
   }
   if (pic30_R_constraint_strict(op0,0)) {
     emit_insn(
       gen_movp32peds_gen(op2, XEXP(op0,0))              /* copy pointer */
     );
   } else if (pic30_Q_constraint(op0) || pic30_S_constraint(op0)) {
     rtx inner = XEXP(operands[0],0);

     if (pic30_Q_constraint(op0)) {
       switch (GET_MODE(op1)) {
         case HImode:
           op2 = XEXP(op0,0);
           fn = gen_P32PEDSuwrite_hi;
           break;
         case P32EDSmode:
           op2 = XEXP(op0,0);
           fn = gen_P32PEDSuwrite_p32eds;
           break;
         case P32PEDSmode:
           op2 = XEXP(op0,0);
           fn = gen_P32PEDSuwrite_p32peds;
           break;
         default:
           emit_insn(
             gen_addp32peds3(op2, XEXP(inner,0), XEXP(inner,1))
           );
       }
     } else {
       emit_insn(
         gen_addp32peds3(op2, XEXP(inner,0), XEXP(inner,1))
       );
     }
   } else {
#if 0
     emit_insn(
       gen_movp32peds_address(op2, XEXP(op0,0))         /* create pointer */
     );
#endif
     copy = 0;
     char *t = pic30_section_base(XEXP(op0,0),0,0);
     emit_insn(
       gen_movEDS_address_offset(
         offset, 
         GEN_INT((HOST_WIDE_INT)t))
     );
     t = pic30_section_base(XEXP(op0,0),1,0);
     emit_insn(
       gen_movEDS_address_page(
         page,
         GEN_INT((HOST_WIDE_INT)t), GEN_INT(0))
     );
   }
   if (eds_target) {
     if (!TARGET_EDS) {
       emit_insn(
         gen_copy_dsw(op3)                              /* preserve PSVPAG */
       );
     }
     if (copy) {
       if (!TARGET_EDS) {
         emit_move_insn(page, gen_rtx_SUBREG(HImode,op2,2));
       } else {
         emit(
           gen_P32PEDSumovpage(page, op2)
         );
       }
     }
   }
   if (eds_target) {
     emit_insn(
       gen_set_dsw(page)                                /* set PSVPAG */
     );
   }
   if (copy) {
     if (!TARGET_EDS) {
       emit_move_insn(offset, gen_rtx_SUBREG(HImode,op2,0));
     } else {
       emit(
         gen_P32PEDSumovoffset(offset,op2)
       );
     }
   }
   emit_insn(
     fn(gen_rtx_MEM(GET_MODE(op0),offset), op1)         /* write value */
   );
   if (eds_target) {
     if (!TARGET_EDS) {
       emit_insn(
         gen_set_dsw(op3)                               /* restore PSVPAG */
       );
     }
   }
   DONE;
}")

;; unified 

;; will probably want to convert this to an expand...
;(define_insn "umovpagr"
;  [(set (reg:HI PSVPAG)
;        (uoffset_hi: HI
;           (match_operand:SI 0 "pic30_reg_or_symbolic_address_or_immediate"  "r,q,i")))]
;  ""
;  "*
;   {
;      if (which_alternative == 1) {
;        char *t = pic30_section_base(operands[0],1,0);
;        static char result[80];
;
;        sprintf(result,\"movpag #unified_hi(%s),DSRPAG\", t);
;        return result;
;      } else if (which_alternative == 2) {
;        return \"movpag #%0,DSRPAG\";
;      } else {
;        return \"movpag %d0,DSRPAG\";
;      }
;   }"
;  [
;    (set_attr "cc" "change0")
;    (set_attr "type" "etc")
;  ]
;)

(define_insn "umovpagr"
  [(set (reg:HI PSVPAG)
        (uoffset_hi: HI
           (match_operand 0 "pic30_RTU_operand"  "R,Q,TU")))]
  ""
  "*
   {  rtx inner = XEXP(operands[0],0);
      static char result[256];
      char *f = result;

      if (which_alternative == 2) {
        char *t = pic30_section_base(inner,1,0);

        sprintf(result,\"movpag #unified_hi(%s),DSRPAG\", t);
      } else {
        if (which_alternative == 1) {
          gcc_assert(GET_CODE(inner) == PLUS);
          inner = XEXP(inner,0);
        }
        if (((REGNO(inner) == FP_REGNO) &&
              pic30_frame_pointer_required()) ||
            (REGNO(inner) == SP_REGNO)) {
          /* OFFSET doesn't need unpacking, but we need to set page to 1
              on some devices -
              ecore devices allow the stack to be in page 1, others do not */
          if (pic30_ecore_target()) {
            f += sprintf(f, \"movpag #1,DSRPAG\");
          }
        } if (which_alternative == 1) {
          /* if these aren't paged then we need to add the offset into
             register value to check for a page overflow  - though
             I hope we only generate this kind of pattern for stack offsets */
          f += sprintf(f, \"movpag %s,DSRPAG\", reg_names[REGNO(inner)+1]);
        } else {
          /* a real register pair */
          f += sprintf(f, \"movpag %s,DSRPAG\", reg_names[REGNO(inner)+1]);
        }
      }
      return result;
   }"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "etc")
  ]
)

(define_insn "umovpagw"
  [(set (reg:HI DSWPAG)
        (uoffset_hi: HI
           (match_operand 0 "pic30_RTU_operand"  "R,Q,TU")))]
  ""
  "*
   {  rtx inner = XEXP(operands[0],0);
      static char result[256];
      char *f = result;

      /* non eds/ecore devices don't support this */
      gcc_assert(pic30_eds_target() || (!pic30_ecore_target()));
 
      if (which_alternative == 2) {
        char *t = pic30_section_base(inner,1,0);

        sprintf(result,\"movpag #unified_hi(%s),DSWPAG\", t);
      } else {
        if (which_alternative == 1) {
          gcc_assert(GET_CODE(inner) == PLUS);
          inner = XEXP(inner,0);
        }
        if (((REGNO(inner) == FP_REGNO) &&
              pic30_frame_pointer_required()) ||
            (REGNO(inner) == SP_REGNO)) {
          /* OFFSET doesn't need unpacking, but we need to set page to 1
              on some devices -
              ecore devices allow the stack to be in page 1, others do not */
          if (pic30_ecore_target()) {
            f += sprintf(f, \"movpag #1,DSWPAG\");
          }
        } if (which_alternative == 1) {
          /* if these aren't paged then we need to add the offset into
             register value to check for a page overflow  - though
             I hope we only generate this kind of pattern for stack offsets */
          f += sprintf(f, \"movpag %s,DSWPAG\", reg_names[REGNO(inner)+1]);
        } else { 
          /* a real register pair */
          f += sprintf(f, \"movpag %s,DSRWAG\", reg_names[REGNO(inner)+1]);
        }
      }
      return result;
   }"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "etc")
  ]
)

;(define_insn "umovpagw"
;  [(set (reg:HI DSWPAG)
;        (uoffset_hi: HI
;           (match_operand:SI 0 "pic30_reg_or_symbolic_address_or_immediate"  "r,q,i")))]
;  ""
;  "*
;   {
;      if (which_alternative == 1) {
;        char *t = pic30_section_base(operands[0],1,0);
;        static char result[80];
;
;        sprintf(result,\"movpag #unified_hi(%s),DSWPAG\", t);
;        return result;
;      } else if (which_alternative == 2) {
;        return \"movpag #%0,DSWPAG\";
;      } else {
;        return \"movpag %d0,DSWPAG\";
;      }
;   }"
;  [
;    (set_attr "cc" "change0")
;    (set_attr "type" "etc")
;  ]
;)

(define_insn "usetpagr"
  [(set (reg:HI PSVPAG)
        (uoffset_hi: HI
           (match_operand 0 "pic30_RTU_operand"  "R,Q,TU")))
   (clobber (match_scratch:HI 1                 "=X,r,r"))
  ]
  ""
  "*
   {  char *page;
      static char result[80];
      rtx inner = XEXP(operands[0],0);
      char *f = result;

      result[0] = 0;
      if (pic30_eds_target()) 
        page = \"_DSRPAG\";
      else page = \"_PSVPAG\";
      if (which_alternative == 2) {
        char *t = pic30_section_base(inner,1,0);

        sprintf(result,\"mov #unified_hi(%s),%%1\;mov %%1,%s\", t, page);
      } else {
        if (which_alternative == 1) {
          gcc_assert(GET_CODE(inner) == PLUS);
          inner = XEXP(inner,0);
        }
        if (((REGNO(inner) == FP_REGNO) &&
              pic30_frame_pointer_needed_p(get_frame_size())) ||
            (REGNO(inner) == SP_REGNO)) {
          /* OFFSET doesn't need unpacking, but we need to set page to 1
              on some devices -
              ecore devices allow the stack to be in page 1, others do not */
          if (pic30_ecore_target()) {
            f += sprintf(f, \"movpag #1,DSRPAG\;\");
          }
        } if (which_alternative == 1) {
          /* if these aren't paged then we need to add the offset into
             register value to check for a page overflow  - though
             I hope we only generate this kind of pattern for stack offsets */
          f += sprintf(f, \"mov %s,%s\", reg_names[REGNO(inner)],page);
        } else {
          /* a real register pair */
          f += sprintf(f, \"mov %s,%s\", reg_names[REGNO(inner)+1],page);
        }
      }
      return result;
   }"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "etc")
  ]
)

(define_insn "usetpagw"
  [(set (reg:HI DSWPAG)
        (uoffset_hi: HI
           (match_operand 0 "pic30_RTU_operand"  "R,Q,TU")))
   (clobber (match_scratch:HI 1                 "=X,r,r"))
  ]
  ""
  "*
   {  static char result[80];
      rtx inner = XEXP(operands[0],0);
      char *f = result;

      if (!pic30_eds_target()) return \"; DSWPAG register not rqd\";
      if (which_alternative == 2) {
        char *t = pic30_section_base(inner,1,0);

        sprintf(result,\"mov #unified_hi(%s),%%1\;mov %%1,_DSWPAG\", t);
      } else {
        if (which_alternative == 1) {
          gcc_assert(GET_CODE(inner) == PLUS);
          inner = XEXP(inner,0);
        }
        if (((REGNO(inner) == FP_REGNO) &&
              pic30_frame_pointer_required()) ||
            (REGNO(inner) == SP_REGNO)) {
          /* OFFSET doesn't need unpacking, but we need to set page to 1
              on some devices -
              ecore devices allow the stack to be in page 1, others do not */
          if (pic30_ecore_target()) {
            f += sprintf(f, \"movpag #1,DSWPAG\");
          }
        } if (which_alternative == 1) {
          /* if these aren't paged then we need to add the offset into
             register value to check for a page overflow  - though
             I hope we only generate this kind of pattern for stack offsets */
          f += sprintf(f, \"mov %s,_DSWPAG\", reg_names[REGNO(inner)]);
        } else {
          /* a real register pair */
          f += sprintf(f, \"mov %s,_DSWPAG\", reg_names[REGNO(inner)+1]);
        }
      }
      return result;
   }"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "etc")
  ]
)

(define_insn "umovoffset"
  [(set (match_operand:HI 0    "pic30_register_operand"         "=r,r,r")
        (uoffset_lo: HI
           (match_operand 1 "pic30_RTU_operand"                  "R,Q,TU")))]
  ""
  "*
   {  rtx inner = XEXP(operands[1],0);
      static char result[80];
     
      switch (which_alternative) {
        default: gcc_assert(0);

        case 2: {
          char *t = pic30_section_base(inner,0,0);

          sprintf(result,\"movpag #unified_lo(%s),%%0\", t);
          return result;
        } 

        case 1: {
          rtx base = XEXP(inner,0);
          rtx offset = XEXP(inner,1);
          int i;
         
          i = INTVAL(offset);
          if ((i >= 0) && (i < 32)) {
            sprintf(result,\"add %s,#%d,%%0\", reg_names[REGNO(base)], i);
          } else if ((i < 0) && (i > -32)) {
            sprintf(result,\"sub %s,#%d,%%0\", reg_names[REGNO(base)], -i);
          } else if ((i >= 0) && (i < 512)) {
            sprintf(result,\"mov %s,%%0\;add #%d,%%0\", 
                    reg_names[REGNO(base)], i);
          } else if ((i < 0) && (i > -512)) {
            sprintf(result,\"mov %s,%%0\;sub #%d,%%0\", 
                    reg_names[REGNO(base)], -i);
          } else gcc_assert(0);
          return result;
        }

        case 0: return \"mov %r1,%0\";
      }
   }"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "etc")
  ]
)

(define_insn "uunpack"
  [(parallel 
    [(set (match_operand:HI 0 "pic30_register_operand" "+r")
          (uunpack:HI (match_dup 0)))
     (set (match_operand:HI 1 "register_operand" "+r")
          (uunpack:HI (match_dup 1)))
     (use (match_operand:HI 2 "pic30_register_operand" "r"))]
  )]
  ""
  "*
   {  
     char *page = 0;
     static char result[256];
     char *f = result;

     if ((pic30_ecore_target()) || (pic30_eds_target())) {
       if (REGNO(operands[1]) == PSVPAG) page = \"_DSRPAG\";
       else if (REGNO(operands[1]) == DSWPAG) page = \"_DSWPAG\";
     } else {
       if (REGNO(operands[1]) == PSVPAG) page = \"_PSVPAG\";
     }
     f += sprintf(f, \"sl %%0,[w15]\;\");  /* shift up bit 15 */
     f += sprintf(f, \"rlc %s\;\",page);   /* shift into page */
     f += sprintf(f, \"bsw.z %%0,%%2\"); /* set bit 15 based on !z */
     return result;
   }
  "
)

(define_expand "set_offset_and_page_SI"
  [(set (match_operand:HI 0 "pic30_register_operand"           "=r,r")
        (uoffset_lo: HI
           (match_operand 1 "pic30_RTU_operand"                 "R,TU")))
   (set (match_operand:HI 2 "register_operand"                 "=r,r")
        (uoffset_hi: HI
           (match_dup 1)))
  ]
  "((REGNO(operands[2]) == PSVPAG) || (REGNO(operands[2]) == DSWPAG))"
  "
   { /* set the offset and page for the SI address */
     static char result[256];
     char *f = result;
     char *page = 0;
     rtx fifteen = gen_reg_rtx(HImode);
     int unpack = 1;

     {
       if (REGNO(operands[2]) == PSVPAG) {
         if (pic30_ecore_target()) {
           emit(
             gen_umovpagr(operands[1])
           );
         } else {
           emit(
             gen_usetpagr(operands[1])
           );
         }
       } else if (REGNO(operands[2]) == DSWPAG) {
         if (pic30_ecore_target()) {
           emit(
             gen_umovpagw(operands[1])
           );
         } else if (pic30_eds_target()) {
           emit(
             gen_usetpagw(operands[1])
           );
         } else unpack=0;
       }
       emit(
         gen_umovoffset(operands[0], operands[1])
       );
  
       if (unpack) {
         emit(
            gen_movhi_imm(fifteen, GEN_INT(15))
         );
         emit(
            gen_uunpack(operands[0], operands[2], fifteen)
         );
       }
       DONE;
     }
   }"
)

(define_expand "P32rd"
   [(set (match_operand 0 "pic30_reg_or_R_operand"       "=rR")
         (match_operand 1 "pic30_mem_eds_operand"    " RQST"))]
   ""
   "{
   rtx op2 = gen_reg_rtx(SImode);
   rtx op3 = gen_reg_rtx(HImode);
   rtx op0 = operand0;
   rtx op1 = operand1;
   rtx page = gen_reg_rtx(HImode);
   rtx offset = gen_reg_rtx(HImode);
   rtx (*fn)(rtx, rtx);
   int indirect_allowed=1;

   if (GET_MODE(op0) != GET_MODE(op1)) FAIL;
   switch (GET_MODE(op0)) {
     default:
                  fprintf(stderr, \"Unknown mode: %s\n\",
                          mode_name[GET_MODE(op0)]);
                  FAIL;
     case QImode: fn = gen_P32PEDSread_qi;
                  break;
     case HImode: fn = gen_P32PEDSread_hi;
                  break;
     case SImode: fn = gen_P32PEDSread_si;
                  break;
     case DImode: fn = gen_P32PEDSread_di;
                  indirect_allowed=0;
                  break;
     case SFmode: fn = gen_P32PEDSread_sf;
                  break;
     case DFmode: fn = gen_P32PEDSread_df;
                  indirect_allowed=0;
                  break;
     case P16APSVmode: fn = gen_P32PEDSread_p16apsv;
                  break;
     case P24PSVmode: fn = gen_P32PEDSread_p24psv;
                  break;
     case P24PROGmode: fn = gen_P32PEDSread_p24prog;
                  break;
     case P16PMPmode: fn = gen_P32PEDSread_p16pmp;
                  break;
     case P32EXTmode: fn = gen_P32PEDSread_p32ext;
                  break;
     case P32EDSmode: fn = gen_P32PEDSread_p32eds;
                  break;
     case P32PEDSmode: fn = gen_P32PEDSread_p32peds;
                  break;
   }
   if ((indirect_allowed == 0) && (pic30_R_operand(op0, GET_MODE(op0)))) {
     op0 = gen_reg_rtx(GET_MODE(op0));
   } else if (!pic30_reg_or_R_operand(op0, GET_MODE(op0))) {
     op0 = gen_reg_rtx(GET_MODE(op0));
   }
   pic30_managed_psv = 1;
   if (pic30_R_constraint_strict(op1,0) || pic30_Q_constraint(op1) ||
       pic30_S_constraint_ecore(op1,1)) {
     if (GET_CODE(XEXP(op1,0)) == PLUS) {
       op2 = expand_binop(SImode, add_optab, XEXP(XEXP(op1,0),0),
                    XEXP(XEXP(op1,0),1), op2, 1, OPTAB_DIRECT);
       op2 = gen_rtx_MEM(GET_MODE(op1),op2);
     } else {
#if 0
       emit_insn(
           gen_movp32eds_gen(op2, XEXP(op1,0)) /* copy pointer */
       );
#else
       // op2 = XEXP(op1,0);  // we may not need to create a copy
       op2 = op1;
#endif
     }
     emit_insn(
        gen_set_offset_and_page_SI(offset, op2, gen_rtx_REG(HImode, PSVPAG))
    );
   } else {
     /* create pointer */
     if (pic30_symbolic_address_operand(XEXP(op1,0),VOIDmode) &&
         pic30_symbolic_address_operand_offset(XEXP(op1,0)) < 1023) {
       emit_insn(
         gen_set_offset_and_page_SI(offset, op1, 
                                    gen_rtx_REG(HImode, PSVPAG))
       );
     } else {
#if 0 
       rtx reg = XEXP(op1,0);

       if (!REG_P(reg)) {
         reg = force_reg(SImode, XEXP(op1,0));
       } 
#endif
       emit_insn(
         gen_set_offset_and_page_SI(offset, op1, gen_rtx_REG(HImode, PSVPAG))
       );
     }
   }
   emit_insn(
     fn(op0, gen_rtx_MEM(GET_MODE(op1),offset))         /* read value */
   );
   if (op0 != operand0) {
     emit_move_insn(operand0, op0);
   }
   DONE;
}")

(define_expand "P32wt"
   [(set (match_operand 0 "pic30_mem_eds_operand"   "=RQ,ST")
         (match_operand 1 "pic30_move_operand"       " rR,rR"))]
   ""
   "{
   rtx op2 = gen_reg_rtx(SImode);
   rtx op3 = gen_reg_rtx(HImode);
   rtx op1 = operand1;
   rtx op0 = operand0;
   rtx page = gen_reg_rtx(HImode);
   rtx offset = gen_reg_rtx(HImode);
   rtx (*fn)(rtx, rtx);
   int eds_target = pic30_eds_target();

   if ((GET_CODE(XEXP(op0,0)) == POST_INC) &&
       (REGNO(XEXP(XEXP(op0,0),0)) == SP_REGNO)) {
     /* this is a stack write that can only be generated with -munified
        (which changes the Pmode to P32EDSmode) - change it back to a normal
        write */
     switch (GET_MODE(op0)) {
       default:
                    fprintf(stderr, \"Unknown mode: %s\n\",
                            mode_name[GET_MODE(op0)]);
                    FAIL;
       case QImode: fn = gen_movqi;
                    break;
       case HImode: fn = gen_movhi;
                    break;
       case SImode: fn = gen_movsi;
                    break;
       case DImode: fn = gen_movdi;
                    break;
       case SFmode: fn = gen_movsf;
                    break;
       case DFmode: fn = gen_movdf;
                    break;
       case P16APSVmode: fn = gen_movp16apsv;
                    break;
       case P24PSVmode: fn = gen_movp24psv;
                    break;
       case P24PROGmode: fn = gen_movp24prog;
                    break;
       case P16PMPmode: fn = gen_movp16pmp;
                    break;
       case P32EXTmode: fn = gen_movp32ext;
                    break;
       case P32EDSmode: fn = gen_movp32eds;
                    break;
       case P32PEDSmode: fn = gen_movp32peds;
                    break;
     }

     if (fn(gen_rtx_MEM(GET_MODE(op0),
                        gen_rtx_POST_INC(HImode,gen_rtx_REG(HImode, SP_REGNO))),
            op1))
       DONE;
     FAIL;
   }
   if (GET_MODE(op0) != GET_MODE(op1)) FAIL;
   switch (GET_MODE(op0)) {
     default:
                  fprintf(stderr, \"Unknown mode: %s\n\",
                          mode_name[GET_MODE(op0)]);
                  FAIL;
     case QImode: fn = gen_P32PEDSwrite_qi;
                  break;
     case HImode: fn = gen_P32PEDSwrite_hi;
                  break;
     case SImode: fn = gen_P32PEDSwrite_si;
                  break;
     case DImode: fn = gen_P32PEDSwrite_di;
                  break;
     case SFmode: fn = gen_P32PEDSwrite_sf;
                  break;
     case DFmode: fn = gen_P32PEDSwrite_df;
                  break;
     case P16APSVmode: fn = gen_P32PEDSwrite_p16apsv;
                  break;
     case P24PSVmode: fn = gen_P32PEDSwrite_p24psv;
                  break;
     case P24PROGmode: fn = gen_P32PEDSwrite_p24prog;
                  break;
     case P16PMPmode: fn = gen_P32PEDSwrite_p16pmp;
                  break;
     case P32EXTmode: fn = gen_P32PEDSwrite_p32ext;
                  break;
     case P32EDSmode: fn = gen_P32PEDSwrite_p32eds;
                  break;
     case P32PEDSmode: fn = gen_P32PEDSwrite_p32peds;
                  break;
   }
   if (!pic30_mode2_operand(op1, GET_MODE(op1))) {
     op1 = gen_reg_rtx(GET_MODE(op1));
     emit_move_insn(op1, operand1);
   }
   if (eds_target) {
     pic30_managed_psv = 1;
   }
   if (pic30_R_constraint_strict(op0,0) || pic30_Q_constraint(op0) ||
       pic30_S_constraint_ecore(op0,1)) {
     if (GET_CODE(XEXP(op0,0)) == PLUS) {
       op2 = expand_binop(SImode, add_optab, XEXP(XEXP(op0,0),0),
                    XEXP(XEXP(op0,0),1), op2, 1, OPTAB_DIRECT);
       op2 = gen_rtx_MEM(GET_MODE(op0),op2);
     } else {
#if 0
       emit_insn(
         gen_movp32eds_gen(op2, XEXP(op0,0)) /* copy pointer */
       );
#else
       // op2 = XEXP(op0,0);
       op2 = op0;
#endif
     }
     emit_insn(
       gen_set_offset_and_page_SI(offset,op2,gen_rtx_REG(HImode, DSWPAG))
     );
   } else {
     /* create pointer */
     if (pic30_symbolic_address_operand(XEXP(op0,0),VOIDmode) &&
         pic30_symbolic_address_operand_offset(XEXP(op0,0)) < 1023) {
       emit_insn(
         gen_set_offset_and_page_SI(offset, op0,
                                    gen_rtx_REG(HImode, DSWPAG))
       );
     } else {
#if 0
       rtx reg = XEXP(op0,0);

       if (!REG_P(reg)) {
         reg = force_reg(SImode, XEXP(op0,0));
       } 
#endif
       emit_insn(
         gen_set_offset_and_page_SI(offset, op0,gen_rtx_REG(HImode, DSWPAG))
       );
     }
   }
   emit_insn(
     fn(gen_rtx_MEM(GET_MODE(op0),offset), op1)         /* write value */
   );
   DONE;
}")

(define_insn "copyfpsi"
  [(set (match_operand:SI  0 "pic30_register_operand" "=r")
        (uextend:SI
          (match_operand:HI 1 "register_operand" "r")))]
  "(TARGET_EDS && (((pic30_frame_pointer_required() && REGNO(operands[1]) == FP_REGNO)) || (REGNO(operands[1]) == SP_REGNO)))"
  "mov %1,%0\;mov #1,%d0"
)
  
(define_insn "fpcopysi"
  [(set (match_operand:HI   0 "register_operand"      "=r")
        (utrunc:HI
          (match_operand:SI 1 "pic30_register_operand" "r")))]
  "(TARGET_EDS && (((pic30_frame_pointer_required() && REGNO(operands[0]) == FP_REGNO)) || (REGNO(operands[0]) == SP_REGNO)))"
  "mov %1,%0"
)

;; if unified is SImode
  
(define_insn "movqisi"
  [(set (match_operand:QI 0 "pic30_unified_move2_operand" "=r,RSQ")
        (match_operand:QI 1 "pic30_register_operand"       "r,r"))]
  "TARGET_EDS"
  "*
   if (which_alternative == 0) {
     return \"mov.b %1,%0\";
   }
   if (pic30_ecore_target()) {
     return \"movpag #1,DSWPAG\;mov.b %1,%0\";
   } else {
     return \"mov.b %1,%0\";
   }
  "
)

(define_insn "movqisi2"
  [(set (match_operand:QI 0 "pic30_register_operand"      "=r,r")
        (match_operand:QI 1 "pic30_unified_move2_operand"  "r,RSQ")
  )]
  "TARGET_EDS"
  "*
   if (which_alternative == 0) {
     return \"mov.b %1,%0\";
   }
   if (pic30_ecore_target()) {
     return \"movpag #1,DSRPAG\;mov.b %1,%0\";
   } else {
     return \"mov.b %1,%0\";
   }
  "
)

(define_insn "movhisi"
  [(set (match_operand:HI 0 "pic30_unified_move2_operand" "=r,R<>SQ")
        (match_operand:HI 1 "pic30_register_operand"       "r,r"))]
  "TARGET_EDS"
  "*
   if (which_alternative == 0) {
     return \"mov %1,%0\";
   }
   if (pic30_ecore_target()) {
     return \"movpag #1,DSWPAG\;mov %1,%0\";
   } else {
     return \"mov %1,%0\";
   }
  "
)

(define_insn "movhisi2"
  [(set (match_operand:HI 0 "pic30_register_operand"      "=r,r")
        (match_operand:HI 1 "pic30_unified_move2_operand"  "r,RSQ")
  )]
  "TARGET_EDS"
  "*
   if (which_alternative == 0) {
     return \"mov %1,%0\";
   }
   if (pic30_ecore_target()) {
     return \"movpag #1,DSRPAG\;mov %1,%0\";
   } else {
     return \"mov %1,%0\";
   }
  "
)

(define_insn "movsisi"
  [(set (match_operand:SI 0 "pic30_unified_move2_operand" "=r,R,Q")
        (match_operand:SI 1 "pic30_register_operand"       "r,r,r"))]
  "TARGET_EDS"
  "*
   if (which_alternative == 0) {
     return \"mov.d %1,%0\";
   }
   if (pic30_ecore_target()) {
     switch (which_alternative) {
       default: gcc_assert(0);
       case 2: return \"movpag #1,DSWPAG\;mov.d %1,%0\";
       case 3: return \"movpag #1,DSWPAG\;mov %1,%0\;mov %d1,%Q0\";
     }
   } else {
     switch (which_alternative) {
       default: gcc_assert(0);
       case 1: return \"mov.d %1,%0\";
       case 2: return \"mov %1,%0\;mov %d1,%Q0\";
     }
   }
  "
)

(define_insn "mov<mode>si2"
  [(set (match_operand:M32BIT 0 "pic30_register_operand"      "=r,r,r")
        (match_operand:M32BIT 1 "pic30_unified_move2_operand"  "r,R,Q")
  )]
  "TARGET_EDS"
  "*
   if (which_alternative == 0) {
     return \"mov.d %1,%0\";
   }
   if (pic30_ecore_target()) {
     switch (which_alternative) {
       default: gcc_assert(0);
       case 1: 
         if (pic30_psrd_psrd_errata_movd(NULL,operands[1])) {
           if (REGNO(XEXP(operands[1],0) == REGNO(operands[0]))) {
             return \"movpag #1,DSWPAG\;mov %Q1,%d0\;mov %1,%0\";
           } else {
             return \"movpag #1,DSWPAG\;mov %1,%0\;mov %Q1,%d0\";
           }
         } else {
           return \"movpag #1,DSWPAG\;mov.d %1,%0\";
         }
       case 2: {
         /* MEM ( PLUS ( reg, */
         rtx inner = XEXP(operands[1],0);
         if (REGNO(XEXP(inner,0)) == REGNO(operands[0])) {
           return \"movpag #1,DSWPAG\;mov %Q1,%d0\;mov %1,%0\";
         } else {
           return \"movpag #1,DSWPAG\;mov %1,%0\;mov %Q1,%d0\";
         }
       }
     }
   } else {
     switch (which_alternative) {
       default: gcc_assert(0);
       case 1: 
         if (pic30_psrd_psrd_errata_movd(NULL,operands[1])) {
           if (REGNO(XEXP(operands[1],0) == REGNO(operands[0]))) {
             return \"mov %Q1,%d0\;mov %1,%0\";
           } else {
             return \"mov %1,%0\;mov %Q1,%d0\";
           }
         } else {
           return \"mov.d %1,%0\";
         }
       case 2:  {
         /* MEM ( PLUS ( reg, */
         rtx inner = XEXP(operands[1],0);
         if (REGNO(XEXP(inner,0)) == REGNO(operands[0])) {
           return \"mov %Q1,%d0\;mov %1,%0\";
         } else {
           return \"mov %1,%0\;mov %Q1,%d0\";
         }
       }
     }
   }
  "
)

;; if unified is P32PEDS

(define_insn "copyfpP32PEDS"
  [(set (match_operand:P32PEDS  0 "pic30_register_operand" "=r")
        (uextend:P32PEDS
          (match_operand:HI 1 "register_operand" "r")))]
  "(TARGET_EDS && (((pic30_frame_pointer_required() && REGNO(operands[1]) == FP_REGNO)) || (REGNO(operands[1]) == SP_REGNO)))"
  "mov %1,%0\;mov #1,%d0"
)
  
(define_insn "fpcopyP32PEDS"
  [(set (match_operand:HI   0 "register_operand"      "=r")
        (utrunc:HI
          (match_operand:P32PEDS 1 "pic30_register_operand" "r")))]
  "(TARGET_EDS && (((pic30_frame_pointer_required() && REGNO(operands[0]) == FP_REGNO)) || (REGNO(operands[0]) == SP_REGNO)))"
  "mov %1,%0"
)

(define_insn "movqiP32PEDS"
  [(set (match_operand:QI 0 "pic30_unified_move2_operand" "=r,RSQ")
        (match_operand:QI 1 "pic30_register_operand"       "r,r"))]
  "TARGET_EDS"
  "*
   if (which_alternative == 0) {
     return \"mov.b %1,%0\";
   }
   if (pic30_ecore_target()) {
     return \"movpag #1,DSWPAG\;mov.b %1,%0\";
   } else {
     return \"mov.b %1,%0\";
   }
  "
)

(define_insn "movqiP32PEDS2"
  [(set (match_operand:QI 0 "pic30_register_operand"      "=r,r")
        (match_operand:QI 1 "pic30_unified_move2_operand"  "r,RSQ")
  )]
  "TARGET_EDS"
  "*
   if (which_alternative == 0) {
     return \"mov.b %1,%0\";
   }
   if (pic30_ecore_target()) {
     return \"movpag #1,DSRPAG\;mov.b %1,%0\";
   } else {
     return \"mov.b %1,%0\";
   }
  "
)

(define_insn "movhiP32PEDS"
  [(set (match_operand:HI 0 "pic30_unified_move2_operand" "=r,RSQ")
        (match_operand:HI 1 "pic30_register_operand"       "r,r"))]
  "TARGET_EDS"
  "*
   if (which_alternative == 0) {
     return \"mov %1,%0\";
   }
   if (pic30_ecore_target()) {
     return \"movpag #1,DSWPAG\;mov %1,%0\";
   } else {
     return \"mov %1,%0\";
   }
  "
)

(define_insn "movhiP32PEDS2"
  [(set (match_operand:HI 0 "pic30_register_operand"      "=r,r")
        (match_operand:HI 1 "pic30_unified_move2_operand"  "r,RSQ")
  )]
  "TARGET_EDS"
  "*
   if (which_alternative == 0) {
     return \"mov %1,%0\";
   }
   if (pic30_ecore_target()) {
     return \"movpag #1,DSRPAG\;mov %1,%0\";
   } else {
     return \"mov %1,%0\";
   }
  "
)

(define_insn "mov<mode>P32PEDS"
  [(set (match_operand:M32BIT 0 "pic30_unified_move2_operand" "=r,R,Q")
        (match_operand:M32BIT 1 "pic30_register_operand"       "r,r,r"))]
  "TARGET_EDS"
  "*
   if (which_alternative == 0) {
     return \"mov.d %1,%0\";
   }
   if (pic30_ecore_target()) {
     switch (which_alternative) {
       default: gcc_assert(0);
       case 2: return \"movpag #1,DSWPAG\;mov.d %1,%0\";
       case 3: return \"movpag #1,DSWPAG\;mov %1,%0\;mov %d1,%Q0\";
     }
   } else {
     switch (which_alternative) {
       default: gcc_assert(0);
       case 1: return \"mov.d %1,%0\";
       case 2: return \"mov %1,%0\;mov %d1,%Q0\";
     }
   }
  "
)

(define_insn "mov<mode>P32PEDS2"
  [(set (match_operand:M32BIT 0 "pic30_register_operand"      "=r,r,r")
        (match_operand:M32BIT 1 "pic30_unified_move2_operand"  "r,R,Q")
  )]
  "TARGET_EDS"
  "*
   if (which_alternative == 0) {
     return \"mov.d %1,%0\";
   }
   if (pic30_ecore_target()) {
     switch (which_alternative) {
       default: gcc_assert(0);
       case 1:
         if (pic30_psrd_psrd_errata_movd(NULL,operands[1])) {
           if (REGNO(XEXP(operands[1],0) == REGNO(operands[0]))) {
             return \"movpag #1,DSWPAG\;mov %Q1,%d0\;mov %1,%0\";
           } else {
             return \"movpag #1,DSWPAG\;mov %1,%0\;mov %Q1,%d0\";
           }
         } else {
           return \"movpag #1,DSWPAG\;mov.d %1,%0\";
         }
       case 2: {
         /* MEM ( PLUS ( reg, */
         rtx inner = XEXP(operands[1],0);
         if (REGNO(XEXP(inner,0)) == REGNO(operands[0])) {
           return \"movpag #1,DSWPAG\;mov %Q1,%d0\;mov %1,%0\";
         } else {
           return \"movpag #1,DSWPAG\;mov %1,%0\;mov %Q1,%d0\";
         }
       }
     }
   } else {
     switch (which_alternative) {
       default: gcc_assert(0);
       case 1: 
         if (pic30_psrd_psrd_errata_movd(NULL,operands[1])) {
           if (REGNO(XEXP(operands[1],0) == REGNO(operands[0]))) {
             return \"mov %Q1,%d0\;mov %1,%0\";
           } else {
             return \"mov %1,%0\;mov %Q1,%d0\";
           }
         } else {
           return \"mov.d %1,%0\";
         }     
       case 2:  {
         /* MEM ( PLUS ( reg, */ 
         rtx inner = XEXP(operands[1],0);
         if (REGNO(XEXP(inner,0)) == REGNO(operands[0])) {
           return \"mov %Q1,%d0\;mov %1,%0\";
         } else {
           return \"mov %1,%0\;mov %Q1,%d0\";
         }
       }  
     }
   }
  "
)

;(define_insn "movP32PEDSP32PEDS"
;  [(set (match_operand:P32PEDS 0 "pic30_unified_move2_operand" "=r,R,Q")
;        (match_operand:P32PEDS 1 "pic30_register_operand"       "r,r,r"))]
;  "TARGET_EDS"
;  "*
;   if (which_alternative == 0) {
;     return \"mov.d %1,%0\";
;   }
;   if (pic30_ecore_target()) {
;     switch (which_alternative) {
;       default: gcc_assert(0);
;       case 2: return \"movpag #1,DSWPAG\;mov.d %1,%0\";
;       case 3: return \"movpag #1,DSWPAG\;mov %1,%0\;mov %d1,%Q0\";
;     }
;   } else {
;     switch (which_alternative) {
;       default: gcc_assert(0);
;       case 1: return \"mov.d %1,%0\";
;       case 2: return \"mov %1,%0\;mov %d1,%Q0\";
;     }
;   }
;  "
;)
;
;/*VRT: Need optimized fix for psrd psrd*/
;(define_insn "movsiP32PEDSP32PEDS2"
;  [(set (match_operand:P32PEDS 0 "pic30_register_operand"      "=r,&r,&r")
;        (match_operand:P32PEDS 1 "pic30_unified_move2_operand"  "r, R, Q")
;  )]
;  "TARGET_EDS"
;  "*
;   if (which_alternative == 0) {
;     return \"mov.d %1,%0\";
;   }
;   if (pic30_ecore_target()) {
;     switch (which_alternative) {
;       default: gcc_assert(0);
;       case 1: if (pic30_psrd_psrd_errata_movd(NULL,operands[1])) {
;                 return \"movpag #1,DSWPAG\;mov %I1,%0\;mov %D1,%d0\";
;               } else {
;                 return \"movpag #1,DSWPAG\;mov.d %1,%0\";
;               }
;       case 2: return \"movpag #1,DSWPAG\;mov %1,%0\;mov %Q1,%d0\";
;     }
;   } else {
;     switch (which_alternative) {
;       default: gcc_assert(0);
;       case 1: if (pic30_psrd_psrd_errata_movd(NULL,operands[1])) {
;                 return \"mov %I1,%0\;mov %D1,%d0\";
;               } else {
;                 return \"mov.d %1,%0\";
;               }
;       case 2: return \"mov %1,%0\;mov %Q1,%d0\";
;     }
;   }
;  "
;)
;
;(define_insn "movP32EDSP32PEDS"
;  [(set (match_operand:P32EDS 0 "pic30_unified_move2_operand" "=r,R,Q")
;        (match_operand:P32EDS 1 "pic30_register_operand"       "r,r,r"))]
;  "TARGET_EDS"
;  "*
;   if (which_alternative == 0) {
;     return \"mov.d %1,%0\";
;   }
;   if (pic30_ecore_target()) {
;     switch (which_alternative) {
;       default: gcc_assert(0);
;       case 2: return \"movpag #1,DSWPAG\;mov.d %1,%0\";
;       case 3: return \"movpag #1,DSWPAG\;mov %1,%0\;mov %d1,%Q0\";
;     }
;   } else {
;     switch (which_alternative) {
;       default: gcc_assert(0);
;       case 1: return \"mov.d %1,%0\";
;       case 2: return \"mov %1,%0\;mov %d1,%Q0\";
;     }
;   }
;  "
;)
;
;/*VRT: Need optimized fix for psrd psrd*/
;(define_insn "movsiP32EDSP32PEDS2"
;  [(set (match_operand:P32EDS 0 "pic30_register_operand"      "=r,&r,&r")
;        (match_operand:P32EDS 1 "pic30_unified_move2_operand"  "r, R, Q")
;  )]
;  "TARGET_EDS"
;  "*
;   if (which_alternative == 0) {
;     return \"mov.d %1,%0\";
;   }
;   if (pic30_ecore_target()) {
;     switch (which_alternative) {
;       default: gcc_assert(0);
;       case 1: if (pic30_psrd_psrd_errata_movd(NULL,operands[1])) {
;                 return \"movpag #1,DSWPAG\;mov %I1,%0\;mov %D1,%d0\";
;               } else {
;                 return \"movpag #1,DSWPAG\;mov.d %1,%0\";
;               }
;       case 2: return \"movpag #1,DSWPAG\;mov %1,%0\;mov %Q1,%d0\";
;     }
;   } else {
;     switch (which_alternative) {
;       default: gcc_assert(0);
;       case 1: if (pic30_psrd_psrd_errata_movd(NULL,operands[1])) {
;                 return \"movpag #1,DSWPAG\;mov %I1,%0\;mov %D1,%d0\";
;               } else {
;                 return \"mov.d %1,%0\";
;               }
;       case 2: return \"mov %1,%0\;mov %Q1,%d0\";
;     }
;   }
;  "
;)

(define_insn "movhi_P24PROGaddress_low"
  [(set (match_operand:HI 0 "pic30_register_operand"               "=r")
        (subreg:HI
          (match_operand:P24PROG 1 "pic30_symbolic_address_operand" "q") 0))]
  ""
  "mov #tbloffset(%1),%0"
 [
  (set_attr "cc" "change0")
  (set_attr "type" "def")
 ]
)

(define_insn "movP16PMP_lit"
  [(set (match_operand:P16PMP 0 "pic30_register_operand"          "=r")
        (match_operand:P16PMP 1 "immediate_operand"               "i"))]
  ""
  "mov #%1,%0"
  [(set_attr "type" "def")]
)

(define_insn "movP32DF_lit"
  [(set (match_operand:P32DF 0 "pic30_register_operand"           "=r")
        (match_operand:P32DF 1 "immediate_operand"                "i"))]
  ""
  "*
   { static char buffer[80];
     long i = INTVAL(operands[1]);

     if (pic30_symbolic_address_operand(operands[1],P32DFmode)) {
       sprintf(buffer,\"mov #packed_lo(%%1),%%0\;mov #packed_hi(%%1),%%d0\");
     } else {
       sprintf(buffer,\"mov #%ld,%%0\;mov #%ld,%%d0\",(i & 0xFFFF),
                      (i & 0xFFFF0000) >> 15);
     }
     return buffer;
   }"
  [(set_attr "type" "def")]
)


(define_insn "movp32eds_lit"
  [(set (match_operand:P32EDS 0 "pic30_register_operand"          "=r")
        (match_operand:P32EDS 1 "immediate_operand"               "i"))]
  ""
  "*
   { static char buffer[80];
     long i = INTVAL(operands[1]);
   
     if (pic30_symbolic_address_operand(operands[1],P32EDSmode)) {
       sprintf(buffer,\"mov #edsoffset(%%1),%%0\;mov #edspage(%%1),%%d0\");
     } else {
       sprintf(buffer,\"mov #%ld,%%0\;mov #%ld,%%d0\",(i & 0x7FFF),
                      (i & 0xFF8000) >> 15);
     }
     return buffer;
   }"
  [(set_attr "type" "def")]
)

(define_insn "movp32peds_lit"
  [(set (match_operand:P32PEDS 0 "pic30_register_operand"          "=r")
        (match_operand:P32PEDS 1 "immediate_operand"               "i"))]
  ""
  "*
   { static char buffer[80];
     long i = INTVAL(operands[1]);

     if (pic30_symbolic_address_operand(operands[1],P32PEDSmode)) {
       sprintf(buffer,\"mov #edsoffset(%%1),%%0\;mov #edspage(%%1),%%d0\");
     } else {
       if (INTVAL(operands[1]) == 0) {
         sprintf(buffer,\"mul.uu %%0,#0,%%0\");
       } else {
         sprintf(buffer,\"mov #%ld,%%0\;mov #%ld,%%d0\",(i & 0x7FFF),
                         (i & 0xFF8000) >> 15);
       }
     }
     return buffer;
   }"
  [(set_attr "type" "def")]
)

(define_insn "movp24psv_lit"
  [(set (match_operand:P24PSV 0 "pic30_register_operand"          "=r")
        (match_operand:P24PSV 1 "immediate_operand"               "i"))]
  ""
  "* 
   { static char buffer[80];
     long i = INTVAL(operands[1]);

     if (pic30_symbolic_address_operand(operands[1],P24PSVmode)) {
       sprintf(buffer,\"mov #tbloffset(%%1),%%0\;mov #tblpage(%%1),%%d0\");
     } else {
       sprintf(buffer,\"mov #%ld,%%0\;mov #%ld,%%d0\",(i & 0xFFFF), 
                      (i & 0xFF0000) >> 16);
     }
     return buffer;
   }"
  [(set_attr "type" "def")]
)

(define_insn "movP24PROG_lit"
  [(set (match_operand:P24PROG 0 "pic30_register_operand"          "=r")
        (match_operand:P24PROG 1 "immediate_operand"               "i"))]
  ""
  "*
   { static char buffer[80];
     long i = INTVAL(operands[1]);

     if (pic30_symbolic_address_operand(operands[1],P24PROGmode)) {
       sprintf(buffer,\"mov #tbloffset(%%1),%%0\;mov #tblpage(%%1),%%d0\");
     } else {
       sprintf(buffer,\"mov #%ld,%%0\;mov #%ld,%%d0\",(i & 0xFFFF),
                      (i & 0xFF0000) >> 16);
     }
     return buffer;
   }"
  [(set_attr "type" "def")]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 32-bit integer moves
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Invalid move

(define_insn "*movsi_invalid_1"
  [(set (match_operand:SI 0 "pic30_register_operand"  "=r")
        (match_operand:SI 1 "pic30_code_operand" "g"))]
  ""
  "*
{
        error(\"invalid address space for operand\");
        return \"cannot generate instructions\";
}

")
(define_insn "*movsi_invalid_2"
  [(set (match_operand:SI 0 "pic30_code_operand" "=g")
        (match_operand:SI 1 "pic30_register_operand"    "r"))]
  ""
  "*
{
        error(\"invalid address space for operand\");
        return \"cannot generate instructions\";
}
")

(define_insn "mov<mode>_const0"
  [(set (match_operand:M32BIT 0 "pic30_move_operand" "=r,R,<>,U")
        (const_int 0))]
  ""
  "*
   static char *normal_patterns[] = {
     \"mul.uu %0,#0,%0\",
     \"clr %0\;mov %I0,%D0\",
     \"clr %0\;clr %0\",
     \"clr %0\;clr %0+2\"
   };

   static char *psv_psv_patterns[] = {
     \"mul.uu %0,#0,%0\",
     \"clr %0\;nop\;mov %I0,%D0\",
     \"clr %0\;nop\;clr %0\"
     \"clr %0\;clr %0+2\"
   };

   if (pic30_psrd_psrd_errata(operands[0],NULL)) {
     pic30_rtx_nops++;
     if (pic30_pre_modify(operands[0])) {
       return \"add %r0,#4,%r0\;clr %I0\;nop\;clr %D0\";
     } else return psv_psv_patterns[which_alternative];
   } else {
     if (pic30_pre_modify(operands[0])) {
       return \"add %r0,#4,%r0\;clr %I0\;clr %D0\";
     } else return normal_patterns[which_alternative];
   }
  "
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,use,defuse,etc")
  ]
)

(define_insn "*movsi_const1"
  [(set (match_operand:SI 0 "pic30_mode2res_operand" "=r,R,<>")
	(const_int -1))]
  ""
  "*
   
   static char *normal_patterns[] = {
     \"setm %0\;setm %d0\",
     \"setm %I0\;setm %D0\",
     \"setm %0\;setm %0\"
   };

   static char *psv_psv_patterns[] = {
     \"setm %0\;setm %d0\",
     \"setm %I0\;nop\;setm %D0\",
     \"setm %0\;nop\;setm %0\"
   };

   if (pic30_psrd_psrd_errata(operands[0],NULL)) {
     pic30_rtx_nops++;
   if (pic30_pre_modify(operands[0])) {
       return \"add %r0,#4,%r0\;setm %I0\;nop\;setm %D0\";
     } else return psv_psv_patterns[which_alternative];
   } else {
     if (pic30_pre_modify(operands[0])) {
     return \"add %r0,#4,%r0\;setm %I0\;setm %D0\";
   } else return normal_patterns[which_alternative];
   }

  "
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,use,use")
  ]
)

(define_insn "*movsi_const0sfr"
  [(set (match_operand:SI 0 "pic30_near_operand" "=U")
	(const_int 0))]
  ""
  "clr %0\;clr %0+2"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "etc")
  ]
)

(define_insn "*movsi_const1sfr"
  [(set (match_operand:SI 0 "pic30_near_operand" "=U")
	(const_int -1))]
  ""
  "setm %0\;setm %0+2"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "etc")
  ]
)

(define_insn "movsi_address"
  [(set (match_operand:SI 0 "pic30_register_operand"        "=r")
        (match_operand:SI 1 "pic30_symbolic_address_operand" "q"))]
  ""
  "*
   if (TARGET_EDS) {
     return \"mov #unified_lo(%1),%0\;mov #unified_hi(%1),%d0\";
   } else {
     return \"mov #%z1,%0\;mov #%y1,%d0\";
   }
  "
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "movsi_rimm"
  [(set (match_operand:SI 0 "pic30_register_operand" "=r,r")
        (match_operand:SI 1 "immediate_operand" "O,i"))]
  ""
  "@
   mul.uu %0,#0,%0
   mov #%z1,%0\;mov #%y1,%d0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "movaccsi"
  [(set (match_operand:SI 0 "pic30_register_operand"    "=r")
        (match_operand:SI 1 "pic30_accumulator_operand" " w"))]
  "pic30_integer_mac_support"
  "mov %m1L,%0\;mov %m1H,%d0"
)

(define_insn "movsiacc"
  [(set (match_operand:SI 0 "pic30_accumulator_operand" "=w")
        (match_operand:SI 1 "pic30_register_operand"    " r"))]
  "pic30_integer_mac_support"
  "mov %1,%m0L\;mov %d1,%m0H"
)

/*VRT: Need optimized fix for psrd psrd*/
(define_insn "mov<mode>_gen"
  [(set 
    (match_operand:M32BIT 0 "pic30_move_operand" "=r,r,&r,r,R,R,R,>,>,Q,&r,<,r,T")
    (match_operand:M32BIT 1 "pic30_move_operand"  "r,R, >,Q,r,0,R,r,>,r, <,r,T,r")
   )]
  ""
  "*
   {
        int idDst, idSrc, pre;

	switch (which_alternative)
	{
        default: gcc_assert(0);
	case 0: /* r = r */
		return \"mov.d %1,%0\";
	case 1: /* r = R */
		if (pic30_psrd_psrd_errata_movd(NULL,operands[1])) {
                  int src = REGNO(XEXP(operands[1],0));
                  int dst = REGNO(operands[0]);
                  if (src == dst) {
                    return \"mov %Q1,%d0\;mov %1,%0\";
                  } else {
                    return \"mov %1,%0\;mov %Q1,%d0\";
                  }
                } else {
		return \"mov.d %1,%0\";
                }
	case 2: /* r = > */
#if 0
		/* a quick note on pic30_pp_modify_valid(); 
                   this function does nothing in the current product as it
                   was there to detect an errata situation which has been
                   resolved and deprecated */
		if ((pre = pic30_pp_modify_valid(operands[1])) == 0) 
			return \"mov.d %1,%0\";
 		else if (pre == -1) /* pre increment */
			return \"add %r1,#4,%r1\;mov.d %s1,%0\";
		else if (pre == 1)  /* post increment */
			return \"mov.d %s1,%0\;add %r1,#4,%r1\";
#endif
                if (pic30_psrd_psrd_errata_movd(NULL,operands[1])) {
                  if (pic30_pre_modify(operands[1])) {
                    return \"add %r1,#4,%r1\;mov [%r1],%0\;mov [%r1+2],%d0\";
                  } else {
                    return \"mov %1,%0\;mov %1,%d0\";
                  }
                } else { 
                return \"mov.d %1,%0\";
                }
	case 3: /* r = Q */
		idDst = REGNO(operands[0]);
		idSrc = REGNO(XEXP(XEXP(operands[1],0),0));
                if (pic30_psrd_psrd_errata(NULL,operands[1])) {
                  pic30_rtx_nops++;
		  if (idDst == idSrc)
                  {
                     return \"mov %Q1,%d0\;nop\;mov %1,%0\";
                  } else {
                     return \"mov %1,%0\;nop\;mov %Q1,%d0\";
                  }
                } else {
		  if (idDst == idSrc)
                  {
                     return \"mov %Q1,%d0\;mov %1,%0\";
                  } else {
                     return \"mov %1,%0\;mov %Q1,%d0\";
                  }
                }
	case 4: /* R = r */
		return \"mov.d %1,%0\";
        case 5: /* R = 0 */
                return \"mov %1,%I0\;mov %1,%D0\";
        case 6: /* R = R */
                if (pic30_psrd_psrd_errata(operands[1],NULL)) {
                  pic30_rtx_nops++;
                  return \"mov %I1,%I0\;nop\;mov %D1,%D0\";
                } else {
                  return \"mov %I1,%I0\;mov %D1,%D0\";
                }
	case 7: /* > = r */
                return \"mov.d %1,%0\";
	case 8: /* > = > */
                /* any pre-decrement cannot be done in 'pieces' */
                { int op0_pre,op1_pre;

                  op0_pre = pic30_pre_modify(operands[0]);
                  op1_pre = pic30_pre_modify(operands[1]);
                  if (pic30_psrd_psrd_errata(operands[1],NULL)) {
                    pic30_rtx_nops++;
                    if (op0_pre && op1_pre) {
		      return \"add #4,%r1\;add #4,%r0\;\"
                             \"mov %I1,%I0\;nop\;mov %D1,%D0\";
                    } else if (op0_pre) {
                      return \"add #4,%r0\;mov %1,%I0\;nop\;mov %1,%D0\";
                    } else if (op1_pre) {
                      return \"add #4,%r1\;mov %I1,%0\;nop\;mov %D1,%0\";
                    } else return \"mov %1,%0\;nop\;mov %1,%0\";
                  } else {
                    if (op0_pre && op1_pre) {
		      return \"add #4,%r1\;add #4,%r0\;\"
                             \"mov %I1,%I0\;mov %D1,%D0\";
                    } else if (op0_pre) {
                      return \"add #4,%r0\;mov %1,%I0\;mov %1,%D0\";
                    } else if (op1_pre) {
                      return \"add #4,%r1\;mov %I1,%0\;mov %D1,%0\";
                    } else return \"mov %1,%0\;mov %1,%0\";
                  }
                }
	case 9: /* Q = r */
		return \"mov %1,%0\;mov %d1,%Q0\";
	case 10: /* r = < */
                if (pic30_psrd_psrd_errata_movd(NULL,operands[1])) {
                  if (pic30_pre_modify(operands[1])) {
                    return \"sub %r1,#4,%r1\;mov [%r1],%0\;mov [%r1+2],%d0\";
                  } else {
                    return \"mov %1,%d0\;mov %1,%0\";
                  }
                } else {
                return \"mov.d %1,%0\";
                }
	case 11: /* < = r */
                return \"mov.d %1,%0\";
	case 12: /* r = T */
               if (pic30_psrd_psrd_errata(operands[1],NULL)) {
                  pic30_rtx_nops++;
		  return \"mov %1,%0\;nop\;mov %Q1,%d0\";
               } else return \"mov %1,%0\;mov %Q1,%d0\";
	case 13: /* T = r */
		return \"mov %1,%0\;mov %d1,%Q0\";
	}
   }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type"
             "def,defuse,defuse,use,use,use,use,use,use,use,use,defuse,def,etc")
  ]
)

(define_insn "mov<mode>_gen_APSV"
  [(set 
    (match_operand:M32BIT 0 "pic30_move_operand" "=r,r,&r,r,R,R,R,>,>,Q,&r,<,r,T")
    (unspec:M32BIT [
      (match_operand:SI 1 "pic30_move_APSV_operand"  
                                                  "r,R, >,Q,r,0,R,r,>,r, <,r,T,r")
      (reg:HI PSVPAG)] UNSPECV_USEPSV))]
  ""
  "*
   {
        int idDst, idSrc, pre;

	switch (which_alternative)
	{
        default: gcc_assert(0);
	case 0: /* r = r */
		return \"mov.d %1,%0\";
	case 1: /* r = R */
                if (pic30_psrd_psrd_errata_movd(NULL,operands[1])) {
                  int src = REGNO(XEXP(operands[1],0));
                  int dst = REGNO(operands[0]);
                  if (src == dst) {
                    return \"mov %Q1,%d0\;mov %1,%0\";
                  } else {
                    return \"mov %1,%0\;mov %Q1,%d0\";
                  }
                } else {
		return \"mov.d %1,%0\";
                }
        case 2: /* r = > */
#if 0
                /* a quick note on pic30_pp_modify_valid();
                   this function does nothing in the current product as it
                   was there to detect an errata situation which has been
                   resolved and deprecated */
                if ((pre = pic30_pp_modify_valid(operands[1])) == 0)
                        return \"mov.d %1,%0\";
                else if (pre == -1) /* pre increment */
                        return \"add %r1,#4,%r1\;mov.d %s1,%0\";
                else if (pre == 1)  /* post increment */
                        return \"mov.d %s1,%0\;add %r1,#4,%r1\";
#endif
                if (pic30_psrd_psrd_errata_movd(NULL,operands[1])) {
                  if (pic30_pre_modify(operands[1])) {
                    return \"add %r1,#4,%r1\;mov [%r1],%0\;mov [%r1+2],%d0\";
                  } else {
                    return \"mov %1,%0\;mov %1,%d0\";
                  }
                } else {
                return \"mov.d %1,%0\";
                }
	case 3: /* r = Q */
		idDst = REGNO(operands[0]);
		idSrc = REGNO(XEXP(XEXP(operands[1],0),0));
		if (idDst == idSrc)
		{
			return \"mov %Q1,%d0\;mov %1,%0\";
		} else {
			return \"mov %1,%0\;mov %Q1,%d0\";
		}
	case 4: /* R = r */
		return \"mov.d %1,%0\";
        case 5: /* R = 0 */
                return \"mov %1,%I0\;mov %1,%D0\";
        case 6: /* R = R */
                if (pic30_psrd_psrd_errata(operands[1],NULL)) {
                  pic30_rtx_nops++;
                  return \"mov %I1,%I0\;nop\;mov %D1,%D0\";
                } else {
                  return \"mov %I1,%I0\;mov %D1,%D0\";
                }
	case 7: /* > = r */
                return \"mov.d %1,%0\";
	case 8: /* > = > */
                /* any pre-decrement cannot be done in 'pieces' */
                { int op0_pre,op1_pre;

                  op0_pre = pic30_pre_modify(operands[0]);
                  op1_pre = pic30_pre_modify(operands[1]);
                  if (pic30_psrd_psrd_errata(operands[1],NULL)) {
                    pic30_rtx_nops++;
                    if (op0_pre && op1_pre) {
                      return \"add #4,%r1\;add #4,%r0\;\"
                             \"mov %I1,%I0\;nop\;mov %D1,%D0\";
                    } else if (op0_pre) {
                      return \"add #4,%r0\;mov %1,%I0\;nop\;mov %1,%D0\";
                    } else if (op1_pre) {
                      return \"add #4,%r1\;mov %I1,%0\;nop\;mov %D1,%0\";
                    } else return \"mov %1,%0\;nop\;mov %1,%0\";
                  } else {
                    if (op0_pre && op1_pre) {
                      return \"add #4,%r1\;add #4,%r0\;\"
                             \"mov %I1,%I0\;mov %D1,%D0\";
                    } else if (op0_pre) {
                      return \"add #4,%r0\;mov %1,%I0\;mov %1,%D0\";
                    } else if (op1_pre) {
                      return \"add #4,%r1\;mov %I1,%0\;mov %D1,%0\";
                    } else return \"mov %1,%0\;mov %1,%0\";
                  }
                }
	case 9: /* Q = r */
		return \"mov %1,%0\;mov %d1,%Q0\";
	case 10: /* r = < */
                if (pic30_psrd_psrd_errata_movd(NULL,operands[1])) {
                  if (pic30_pre_modify(operands[1])) {
                    return \"sub %r1,#4,%r1\;mov [%r1],%0\;mov [%r1+2],%d0\";
                  } else {
                    return \"mov %1,%d0\;mov %1,%0\";
                  }
                } else {
                return \"mov.d %1,%0\";
                }
	case 11: /* < = r */
                return \"mov.d %1,%0\";
	case 12: /* r = T */
               if (pic30_psrd_psrd_errata(operands[1],NULL)) {
                  pic30_rtx_nops++;
		  return \"mov %1,%0\;nop\;mov %Q1,%d0\";
               } else return \"mov %1,%0\;mov %Q1,%d0\";
	case 13: /* T = r */
		return \"mov %1,%0\;mov %d1,%Q0\";
	}
   }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type"
             "def,defuse,defuse,def,use,use,use,use,use,use,defuse,use,def,etc")
  ]
)

;(define_insn "movp24psv_gen_APSV"
;  [(set (match_operand:P24PSV 0 "pic30_move_operand" "=r,r,r,r,R,R,R,>,>,Q,r,<,r,T")
;        (unspec:P24PSV [
;          (match_operand:P24PSV 1 "pic30_move_APSV_operand"  
;                                                      "r,R,>,Q,r,0,R,r,>,r,<,r,T,r")
;          (reg:HI PSVPAG)] UNSPECV_USEPSV))]
;  ""
;  "*
;{
;        int idDst, idSrc, pre;
;
;	switch (which_alternative)
;	{
;	case 0: /* r = r */
;		return \"mov.d %1,%0\";
;	case 1: /* r = R */
;		return \"mov.d %1,%0\";
;	case 2: /* r = > */
;#if 0
;                /* a quick note on pic30_pp_modify_valid();
;                   this function does nothing in the current product as it
;                   was there to detect an errata situation which has been
;                   resolved and deprecated */
;                if ((pre = pic30_pp_modify_valid(operands[1])) == 0)
;                        return \"mov.d %1,%0\";
;                else if (pre == -1) /* pre increment */
;                        return \"add %r1,#4,%r1\;mov.d %s1,%0\";
;                else if (pre == 1)  /* post increment */
;                        return \"mov.d %s1,%0\;add %r1,#4,%r1\";
;#endif
;                return \"mov.d %1,%0\";
;	case 3: /* r = Q */
;		idDst = REGNO(operands[0]);
;		idSrc = REGNO(XEXP(XEXP(operands[1],0),0));
;		if (idDst == idSrc)
;		{
;			return \"mov %Q1,%d0\;mov %1,%0\";
;		} else {
;			return \"mov %1,%0\;mov %Q1,%d0\";
;		}
;	case 4: /* R = r */
;		return \"mov.d %1,%0\";
;        case 5: /* R = 0 */
;                return \"mov %1,%I0\;mov %1,%D0\";
;        case 6: /* R = R */
;                return \"mov %I1,%I0\;mov %D1,%D0\";
;	case 7: /* > = r */
;                return \"mov.d %1,%0\";
;	case 8: /* > = > */
;                /* any pre-decrement cannot be done in 'pieces' */
;                { int op0_pre,op1_pre;
;
;                  op0_pre = pic30_pre_modify(operands[0]);
;                  op1_pre = pic30_pre_modify(operands[1]);
;                  if (op0_pre && op1_pre) {
;                    return \"add #4,%r1\;add #4,%r0\;mov %I1,%I0\;mov %D1,%D0\";
;                  } else if (op0_pre) {
;                    return \"add #4,%r0\;mov %1,%I0\;mov %1,%D0\";
;                  } else if (op1_pre) {
;                    return \"add #4,%r1\;mov %I1,%0\;mov %D1,%0\";
;                  } else return \"mov %1,%0\;mov %1,%0\";
;                }
;	case 9: /* Q = r */
;		return \"mov %1,%0\;mov %d1,%Q0\";
;	case 10: /* r = < */
;                return \"mov.d %1,%0\";
;        case 11: /* < = r */
;                return \"mov.d %1,%0\";
;	case 12: /* r = T */
;		return \"mov %1,%0\;mov %Q1,%d0\";
;	case 13: /* T = r */
;		return \"mov %1,%0\;mov %d1,%Q0\";
;        default: gcc_assert(0);
;	}
;}"
;  [
;   (set_attr "cc" "clobber")
;   (set_attr "type"
;             "def,defuse,defuse,def,use,use,use,use,use,use,defuse,use,def,etc")
;  ]
;)
;
;(define_insn "movp24prog_gen_APSV"
;  [(set (match_operand:P24PROG 0 "pic30_move_operand" "=r,r,r,r,R,R,R,>,>,Q,r,<,r,T")
;        (unspec:P24PROG [
;          (match_operand:P24PROG 1 "pic30_move_APSV_operand"  
;                                                       "r,R,>,Q,r,0,R,r,>,r,<,r,T,r")
;          (reg:HI PSVPAG)] UNSPECV_USEPSV))]
;  ""
;  "*
;{
;        int idDst, idSrc, pre;
;
;	switch (which_alternative)
;	{
;	case 0: /* r = r */
;		return \"mov.d %1,%0\";
;	case 1: /* r = R */
;		return \"mov.d %1,%0\";
;	case 2: /* r = > */
;#if 0
;                /* a quick note on pic30_pp_modify_valid();
;                   this function does nothing in the current product as it
;                   was there to detect an errata situation which has been
;                   resolved and deprecated */
;                if ((pre = pic30_pp_modify_valid(operands[1])) == 0)
;                        return \"mov.d %1,%0\";
;                else if (pre == -1) /* pre increment */
;                        return \"add %r1,#4,%r1\;mov.d %s1,%0\";
;                else if (pre == 1)  /* post increment */
;                        return \"mov.d %s1,%0\;add %r1,#4,%r1\";
;#endif
;                return \"mov.d %1,%0\";
;	case 3: /* r = Q */
;		idDst = REGNO(operands[0]);
;		idSrc = REGNO(XEXP(XEXP(operands[1],0),0));
;		if (idDst == idSrc)
;		{
;			return \"mov %Q1,%d0\;mov %1,%0\";
;		} else {
;			return \"mov %1,%0\;mov %Q1,%d0\";
;		}
;	case 4: /* R = r */
;		return \"mov.d %1,%0\";
;        case 5: /* R = 0 */
;                return \"mov %1,%I0\;mov %1,%D0\";
;        case 6: /* R = R */
;                return \"mov %I1,%I0\;mov %D1,%D0\";
;	case 7: /* > = r */
;                return \"mov.d %1,%0\";
;	case 8: /* > = > */
;                /* any pre-decrement cannot be done in 'pieces' */
;                { int op0_pre,op1_pre;
;
;                  op0_pre = pic30_pre_modify(operands[0]);
;                  op1_pre = pic30_pre_modify(operands[1]);
;                  if (op0_pre && op1_pre) {
;                    return \"add #4,%r1\;add #4,%r0\;mov %I1,%I0\;mov %D1,%D0\";
;                  } else if (op0_pre) {
;                    return \"add #4,%r0\;mov %1,%I0\;mov %1,%D0\";
;                  } else if (op1_pre) {
;                    return \"add #4,%r1\;mov %I1,%0\;mov %D1,%0\";
;                  } else return \"mov %1,%0\;mov %1,%0\";
;                }
;	case 9: /* Q = r */
;		return \"mov %1,%0\;mov %d1,%Q0\";
;        case 10: /* r = < */
;                return \"mov.d %1,%0\";
;        case 11: /* < = r */
;                return \"mov.d %1,%0\";
;	case 12: /* r = T */
;		return \"mov %1,%0\;mov %Q1,%d0\";
;	case 13: /* T = r */
;		return \"mov %1,%0\;mov %d1,%Q0\";
;        default: gcc_assert(0);
;	}
;}"
;  [
;   (set_attr "cc" "clobber")
;   (set_attr "type"
;             "def,defuse,defuse,def,use,use,use,use,use,use,defuse,use,def,etc")
;  ]
;)
;
;(define_insn "movp32ext_gen_APSV"
;  [(set (match_operand:P32EXT 0 "pic30_move_operand" "=r,r,r,r,R,R,R,>,>,Q,r,<,r,T")
;        (unspec:P32EXT [
;          (match_operand:P32EXT 1 "pic30_move_APSV_operand"  
;                                                      "r,R,>,Q,r,0,R,r,>,r,<,r,T,r")
;          (reg:HI PSVPAG)] UNSPECV_USEPSV))]
;  ""
;  "*
;{
;        int idDst, idSrc, pre;
;
;	switch (which_alternative)
;	{
;	case 0: /* r = r */
;		return \"mov.d %1,%0\";
;	case 1: /* r = R */
;		return \"mov.d %1,%0\";
;	case 2: /* r = > */
;#if 0
;                /* a quick note on pic30_pp_modify_valid();
;                   this function does nothing in the current product as it
;                   was there to detect an errata situation which has been
;                   resolved and deprecated */
;                if ((pre = pic30_pp_modify_valid(operands[1])) == 0)
;                        return \"mov.d %1,%0\";
;                else if (pre == -1) /* pre increment */
;                        return \"add %r1,#4,%r1\;mov.d %s1,%0\";
;                else if (pre == 1)  /* post increment */
;                        return \"mov.d %s1,%0\;add %r1,#4,%r1\";
;#endif
;                return \"mov.d %1,%0\";
;	case 3: /* r = Q */
;		idDst = REGNO(operands[0]);
;		idSrc = REGNO(XEXP(XEXP(operands[1],0),0));
;		if (idDst == idSrc)
;		{
;			return \"mov %Q1,%d0\;mov %1,%0\";
;		} else {
;			return \"mov %1,%0\;mov %Q1,%d0\";
;		}
;	case 4: /* R = r */
;		return \"mov.d %1,%0\";
;        case 5: /* R = 0 */
;                return \"mov %1,%I0\;mov %1,%D0\";
;        case 6: /* R = R */
;                return \"mov %I1,%I0\;mov %D1,%D0\";
;	case 7: /* > = r */
;                return \"mov.d %1,%0\";
;	case 8: /* > = > */
;                /* any pre-decrement cannot be done in 'pieces' */
;                { int op0_pre,op1_pre;
;
;                  op0_pre = pic30_pre_modify(operands[0]);
;                  op1_pre = pic30_pre_modify(operands[1]);
;                  if (op0_pre && op1_pre) {
;                    return \"add #4,%r1\;add #4,%r0\;mov %I1,%I0\;mov %D1,%D0\";
;                  } else if (op0_pre) {
;                    return \"add #4,%r0\;mov %1,%I0\;mov %1,%D0\";
;                  } else if (op1_pre) {
;                    return \"add #4,%r1\;mov %I1,%0\;mov %D1,%0\";
;                  } else return \"mov %1,%0\;mov %1,%0\";
;                }
;	case 9: /* Q = r */
;		return \"mov %1,%0\;mov %d1,%Q0\";
;	case 10: /* r = < */
;                return \"mov.d %1,%0\";
;        case 11: /* < = r */
;                return \"mov.d %1,%0\";
;	case 12: /* r = T */
;		return \"mov %1,%0\;mov %Q1,%d0\";
;	case 13: /* T = r */
;		return \"mov %1,%0\;mov %d1,%Q0\";
;        default: gcc_assert(0);
;	}
;}"
;  [
;   (set_attr "cc" "clobber")
;   (set_attr "type"
;             "def,defuse,defuse,def,use,use,use,use,use,use,defuse,use,def,etc")
;  ]
;)
;
;(define_insn "movp32eds_gen_APSV"
;  [(set (match_operand:P32EDS 0 "pic30_move_operand" "=r,r,r,r,R,R,R,>,>,Q,r,<,r,T")
;        (unspec:P32EDS [
;          (match_operand:P32EDS 1 "pic30_move_APSV_operand"  
;                                                      "r,R,>,Q,r,0,R,r,>,r,<,r,T,r")
;          (reg:HI PSVPAG)] UNSPECV_USEPSV))]
;  ""
;  "*
;{
;        int idDst, idSrc, pre;
;
;	switch (which_alternative)
;	{
;	case 0: /* r = r */
;		return \"mov.d %1,%0\";
;	case 1: /* r = R */
;		return \"mov.d %1,%0\";
;	case 2: /* r = > */
;#if 0
;                /* a quick note on pic30_pp_modify_valid();
;                   this function does nothing in the current product as it
;                   was there to detect an errata situation which has been
;                   resolved and deprecated */
;                if ((pre = pic30_pp_modify_valid(operands[1])) == 0)
;                        return \"mov.d %1,%0\";
;                else if (pre == -1) /* pre increment */
;                        return \"add %r1,#4,%r1\;mov.d %s1,%0\";
;                else if (pre == 1)  /* post increment */
;                        return \"mov.d %s1,%0\;add %r1,#4,%r1\";
;#endif
;                return \"mov.d %1,%0\";
;	case 3: /* r = Q */
;		idDst = REGNO(operands[0]);
;		idSrc = REGNO(XEXP(XEXP(operands[1],0),0));
;		if (idDst == idSrc)
;		{
;			return \"mov %Q1,%d0\;mov %1,%0\";
;		} else {
;			return \"mov %1,%0\;mov %Q1,%d0\";
;		}
;	case 4: /* R = r */
;		return \"mov.d %1,%0\";
;        case 5: /* R = 0 */
;                return \"mov %1,%I0\;mov %1,%D0\";
;        case 6: /* R = R */
;                return \"mov %I1,%I0\;mov %D1,%D0\";
;        case 7: /* > = r */
;                return \"add %r0,#4,%r0\;mov.d %1,%s1\";
;        case 8: /* > = > */
;                /* any pre-decrement cannot be done in 'pieces' */
;                { int op0_pre,op1_pre;
;
;                  op0_pre = pic30_pre_modify(operands[0]);
;                  op1_pre = pic30_pre_modify(operands[1]);
;                  if (op0_pre && op1_pre) {
;                    return \"add #4,%r1\;add #4,%r0\;mov %I1,%I0\;mov %D1,%D0\";
;                  } else if (op0_pre) {
;                    return \"add #4,%r0\;mov %1,%I0\;mov %1,%D0\";
;                  } else if (op1_pre) {
;                    return \"add #4,%r1\;mov %I1,%0\;mov %D1,%0\";
;                  } else return \"mov %1,%0\;mov %1,%0\";
;                }
;	case 9: /* Q = r */
;		return \"mov %1,%0\;mov %d1,%Q0\";
;	case 10: /* r = < */
;                return \"mov.d %1,%0\";
;        case 11: /* < = r */
;                return \"mov.d %1,%0\";
;	case 12: /* r = T */
;		return \"mov %1,%0\;mov %Q1,%d0\";
;	case 13: /* T = r */
;		return \"mov %1,%0\;mov %d1,%Q0\";
;        default: gcc_assert(0);
;	}
;}"
;  [
;   (set_attr "cc" "clobber")
;   (set_attr "type"
;             "def,defuse,defuse,def,use,use,use,use,use,use,defuse,use,def,etc")
;  ]
;)
;
;(define_insn "movp32peds_gen_APSV"
;  [(set (match_operand:P32PEDS 0 "pic30_move_operand" "=r,r,r,r,R,R,R,>,>,Q,r,<,r,T")
;        (unspec:P32PEDS [
;          (match_operand:P32PEDS 1 "pic30_move_APSV_operand"  
;                                                       "r,R,>,Q,r,0,R,r,>,r,<,r,T,r")
;          (reg:HI PSVPAG)] UNSPECV_USEPSV))]
;  ""
;  "*
;{
;        int idDst, idSrc, pre;
;
;        switch (which_alternative)
;	{
;	case 0: /* r = r */
;		return \"mov.d %1,%0\";
;	case 1: /* r = R */
;		return \"mov.d %1,%0\";
;	case 2: /* r = > */
;#if 0
;                /* a quick note on pic30_pp_modify_valid();
;                   this function does nothing in the current product as it
;                   was there to detect an errata situation which has been
;                   resolved and deprecated */
;                if ((pre = pic30_pp_modify_valid(operands[1])) == 0)
;                        return \"mov.d %1,%0\";
;                else if (pre == -1) /* pre increment */
;                        return \"add %r1,#4,%r1\;mov.d %s1,%0\";
;                else if (pre == 1)  /* post increment */
;                        return \"mov.d %s1,%0\;add %r1,#4,%r1\";
;#endif
;                return \"mov.d %1,%0\";
;	case 3: /* r = Q */
;		idDst = REGNO(operands[0]);
;		idSrc = REGNO(XEXP(XEXP(operands[1],0),0));
;		if (idDst == idSrc)
;		{
;			return \"mov %Q1,%d0\;mov %1,%0\";
;		} else {
;			return \"mov %1,%0\;mov %Q1,%d0\";
;		}
;	case 4: /* R = r */
;		return \"mov.d %1,%0\";
;        case 5: /* R = 0 */
;                return \"mov %1,%I0\;mov %1,%D0\";
;        case 6: /* R = R */
;                return \"mov %I1,%I0\;mov %D1,%D0\";
;	case 7: /* > = r */
;                return \"mov.d %1,%0\";
;        case 8: /* > = > */
;                /* any pre-decrement cannot be done in 'pieces' */
;                { int op0_pre,op1_pre;
;
;                  op0_pre = pic30_pre_modify(operands[0]);
;                  op1_pre = pic30_pre_modify(operands[1]);
;                  if (op0_pre && op1_pre) {
;                    return \"add #4,%r1\;add #4,%r0\;mov %I1,%I0\;mov %D1,%D0\";
;                  } else if (op0_pre) {
;                    return \"add #4,%r0\;mov %1,%I0\;mov %1,%D0\";
;                  } else if (op1_pre) {
;                    return \"add #4,%r1\;mov %I1,%0\;mov %D1,%0\";
;                  } else return \"mov %1,%0\;mov %1,%0\";
;                }
;	case 9: /* Q = r */
;		return \"mov %1,%0\;mov %d1,%Q0\";
;	case 10: /* r = < */
;                return \"mov.d %1,%0\";
;        case 11: /* < = r */
;                return \"mov.d %1,%0\";
;	case 12: /* r = T */
;		return \"mov %1,%0\;mov %Q1,%d0\";
;	case 13: /* T = r */
;		return \"mov %1,%0\;mov %d1,%Q0\";
;        default: gcc_assert(0);
;	}
;}"
;  [
;   (set_attr "cc" "clobber")
;   (set_attr "type"
;             "def,defuse,defuse,def,use,use,use,use,use,use,defuse,use,def,etc")
;  ]
;)

(define_insn "movp32ext_rimm"
  [(set (match_operand:P32EXT 0 "pic30_register_operand" "=r,r")
        (match_operand:P32EXT 1 "immediate_operand" "O,i"))]
  ""
  "@
   mul.uu %0,#0,%0
   mov #%z1,%0\;mov #%y1,%d0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "*movsi_constnsfr"
  [(set (match_operand:SI 0 "pic30_near_operand" "=U")
        (match_operand:SI 1 "immediate_operand"   "i"))
	(clobber (match_scratch:HI 2             "=r"))]
  ""
  "*
{
	int imm = INTVAL(operands[1]);
	unsigned short msw, lsw;
	msw = (imm >> 16) & 0xffff;
	lsw = (imm) & 0xffff;
	if (msw == 0)
	{
		if (lsw == 0xffff)
		{
			return \"setm %0\;clr %0+2\";
		}
		else
		{
			return \"mov #%1,%2\;mov %2,%0\;clr %0+2\";
		}
	}
	else if (lsw == 0)
	{
		if (msw == 0xffff)
		{
			return \"setm %0+2\;clr %0\";
		}
		else
		{
			return \"mov #%y1,%2\;mov %2,%0+2\;clr %0\";
		}
	}
	else if (lsw == msw)
	{
		return \"mov #%z1,%2\;mov %2,%0\;mov %2,%0+2\";
	}
	else
	{
		return \"mov #%z1,%2\;mov %2,%0\;mov #%y1,%2\;mov %2,%0+2\";
	}

}"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "etc")
  ]
)

(define_expand "movsi"
  [(set (match_operand:SI 0 "pic30_general_operand" "")
        (match_operand:SI 1 "pic30_general_operand" ""))]
  ""
  "
{
        if (pic30_emit_move_sequence(operands, SImode)) DONE;
}")


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 64-bit integer moves
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Invalid move

(define_insn "*movdi_invalid_1"
  [(set (match_operand:DI 0 "pic30_register_operand"  "=r")
        (match_operand:DI 1 "pic30_code_operand" "g"))]
  ""
  "*
{
        error(\"invalid address space for operand\");
        return \"cannot generate instructions\";
}

")
(define_insn "*movdi_invalid_2"
  [(set (match_operand:DI 0 "pic30_code_operand" "=g")
        (match_operand:DI 1 "pic30_register_operand"    "r"))]
  ""
  "*
{
        error(\"invalid address space for operand\");
        return \"cannot generate instructions\";
}
")
(define_insn "*movdi_rimm"
  [(set (match_operand:DI 0 "pic30_register_operand" "=r,r")
        (match_operand:DI 1 "immediate_operand" "O,i"))]
  ""
  "*
{
	REAL_VALUE_TYPE r;
	long l[4] = { 0 };

	switch (which_alternative)
	{
        case 0:
          return \"mul.uu %0,#0,%0\;\"
                 \"mul.uu %t0,#0,%t0\";
        default:
          if (GET_CODE(operands[1]) == CONST_DOUBLE)
          {
            REAL_VALUE_FROM_CONST_DOUBLE(r, operands[1]);
            switch (GET_MODE(operands[1]))
            {
              case VOIDmode:
                /*
                ** Integer
                */
                if (sizeof(HOST_WIDE_INT) == 4) {
                  l[0] = CONST_DOUBLE_LOW(operands[1]);
                  l[1] = CONST_DOUBLE_HIGH(operands[1]);
                } else if (sizeof(HOST_WIDE_INT) == 8) {
                  l[0] = CONST_DOUBLE_LOW(operands[1]) & 0xFFFFFFFF;
                  l[1] = CONST_DOUBLE_LOW(operands[1]) >> 32;
                } else {
                  gcc_unreachable();
                }
 
                break;
              default:
                REAL_VALUE_TO_TARGET_LONG_DOUBLE(r, l);
                break;
            }
          }
          else
          {
            if (sizeof(HOST_WIDE_INT) == 4) {
              l[0] = INTVAL(operands[1]);
              l[1] = l[0] < 0 ? -1 : 0;
            } else if (sizeof(HOST_WIDE_INT) == 8) {
              l[0] = CONST_DOUBLE_LOW(operands[1]) & 0xFFFFFFFF;
              l[1] = CONST_DOUBLE_LOW(operands[1]) >> 32;
            } else {
              gcc_unreachable();
            }
          }
          if (l[0] == 0)
          {
            return \"mul.uu %0,#0,%0\;\"
                   \"mov #%x1,%t0\;\"
                   \"mov #%w1,%q0\";
          }
          else if (l[1] == 0)
          {
            return \"mov #%z1,%0\;\"
                   \"mov #%y1,%d0\;\"
                   \"mul.uu %t0,#0,%t0\";
          }
          else if (l[0] == l[1])
          {
            return \"mov #%z1,%0\;\"
                   \"mov #%y1,%d0\;\"
                   \"mov.d %0,%t0\";
          }
          return \"mov #%z1,%0\;\"
                 \"mov #%y1,%d0\;\"
                 \"mov #%x1,%t0\;\"
                 \"mov #%w1,%q0\";
	}
}"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

;(define_insn "*movdi_gen"
;  [(set (match_operand:DI 0 "pic30_move_operand"
;					"=r,r,r,r,R,>,>,Q,r,<,T,r")
;        (match_operand:DI 1 "pic30_move_operand" 
;					 "r,R,>,Q,r,r,>,r,<,r,r,T"))]
;  ""
;  "*
;{
;  int idSrc, idDst;
;  char temp[64];
;  char save[64];
;  static char szInsn[64];
;
;  szInsn[0] = 0;
;  temp[0] = 0;
;  save[0] = 0;
;
;  switch (which_alternative) {
;    case 0: /* r = r */
;      idDst = REGNO(operands[0]);
;      idSrc = REGNO(operands[1]);
;      if (idDst <= idSrc) {
;        return \"mov.d %1,%0\;mov.d %t1,%t0\";
;      } else {
;        return \"mov.d %t1,%t0\;mov.d %1,%0\";
;      }
;    case 1: /* r = R */
;      idDst = REGNO(operands[0]);
;      idSrc = REGNO(XEXP(operands[1],0));
;      if (pic30_pp_modify_valid(0) == 0) {
;        if ((idDst > idSrc) || ((idDst+4) <= idSrc)) {
;          /*
;           ** source & dest don't overlap
;           */
;          if (pic30_psrd_psrd_errata_movd(NULL,operands[1])) {
;            return \"mov %1,%0\;\" 
;                   \"mov %Q1,%d0\;\"
;                   \"mov %R1,%t0\;\"
;                   \"mov %S1,%q0\";
;          } else if (pic30_psrd_psrd_errata(operands[1],NULL)) {
;            pic30_rtx_nops++;
;            return \"mov.d %I1,%0\;\" 
;                   \"nop\;\"
;                   \"mov.d %D1,%t0\";
;          } else {
;            return \"mov.d %I1,%0\;\" 
;                   \"mov.d %D1,%t0\";
;          }
;        }
;        if ((idDst+2) > idSrc) {
;          /*
;           ** [wn] -> wn+2:wn+3:wn:wn+1
;           */
;         if (pic30_psrd_psrd_errata_movd(NULL,operands[1])) {
;            return \"mov %R1,%t0\;\"
;                   \"mov %S1,%q0\;\"
;                   \"mov %1,%0\;\"   
;                   \"mov %Q1,%d0\";
;          } else if (pic30_psrd_psrd_errata(operands[1],NULL)) {
;            pic30_rtx_nops++;
;            return \"mov.d %P1,%t0\;nop\;mov.d %p1,%0\";
;          } else {
;            return \"mov.d %P1,%t0\;mov.d %p1,%0\";
;          }
;        } else {
;          /*
;           ** [wn] -> wn-2:wn-1:wn:wn+1
;           */
;         if (pic30_psrd_psrd_errata_movd(NULL,operands[1])) {
;            return \"mov %1,%0\;\"   
;                   \"mov %Q1,%d0\;\"
;                   \"mov %R1,%t0\;\"
;                   \"mov %S1,%q0\";
;          } else if (pic30_psrd_psrd_errata(operands[1],NULL)) {
;            pic30_rtx_nops++;
;            return \"mov.d %I1,%0\;nop\;mov.d %1,%t0\";
;          } else {
;            return \"mov.d %I1,%0\;mov.d %1,%t0\";
;          }
;        } 
;      } else { 
;        if ((idDst > idSrc) || ((idDst + 3) <= idSrc)) {
;          /*  don't significantly overlap */ 
;         if (pic30_psrd_psrd_errata_movd(NULL,operands[1])) {
;            return \"mov %1,%0\;\"   
;                   \"mov %Q1,%d0\;\"
;                   \"mov %R1,%t0\;\"
;                   \"mov %S1,%q0\";
;          } else if (pic30_psrd_psrd_errata(operands[1],NULL)) {
;            pic30_rtx_nops++;
;            return \"mov.d %1,%0\;nop\;mov [%r1+4],%t0\;nop\;mov [%r1+6],%q0\";
;          } else {
;            return \"mov.d %1,%0\;mov [%r1+4],%t0\;mov [%r1+6],%q0\";
;          }
;        }
;        /* idDst <= idSrc < idDst+3 */
;        switch (idDst + 4 - idSrc) {
;          case 4:  /* idSrc == idDst+0 */
;          case 3:  /* idSrc == idDst+1 */
;           if (pic30_psrd_psrd_errata_movd(NULL,operands[1])) {
;              return 
;                     \"mov %R1,%t0\;\"
;                     \"mov %S1,%q0\;\"
;                     \"mov %1,%0\;\"   
;                     \"mov %Q1,%d0\";
;            } else if (pic30_psrd_psrd_errata(operands[1],NULL)) {
;              pic30_rtx_nops+=2;
;              return \"mov [%r1+4],%t0\;\"
;                     \"nop\;\"
;                     \"mov [%r1+6],%q0\;\"
;                     \"nop\;\"
;                     \"mov.d %1,%0\";
;            } else {
;              return \"mov [%r1+4],%t0\;\"
;                     \"mov [%r1+6],%q0\;\"
;                     \"mov.d %1,%0\";
;            }
;          case 2:  /* idSrc == idDst+2 */
;           if (pic30_psrd_psrd_errata_movd(NULL,operands[1])) {
;              return \"mov %1,%0\;\"   
;                     \"mov %Q1,%d0\;\"
;                     \"mov %S1,%q0\;\"
;                     \"mov %R1,%t0\";
;            } else if (pic30_psrd_psrd_errata(operands[1],NULL)) {
;              pic30_rtx_nops+=2;
;              return \"mov.d %1,%0\;\"
;                     \"nop\;\"
;                     \"mov [%r1+6],%q0\;\"
;                     \"nop\;\"
;                     \"mov [%r1+4],%t0\";
;            } else {
;              return \"mov.d %1,%0\;mov [%r1+6],%q0\;mov [%r1+4],%t0\";
;            }
;          default: abort();
;        }
;      }
;    case 2: /* r = > */
;      if (pic30_psrd_psrd_errata_movd(operands[1],NULL)) {
;        if (pic30_pre_modify(operands[1])) {
;          return \"add %r1,#8,%r1\;\"
;                 \"mov %1,%0\;\"
;                 \"mov %Q1,%d0\;\"
;                 \"mov %R1,%t0\;\"
;                 \"mov %S1,%q0\";
;        } else {
;          return \"mov %1,%0\;\"
;                 \"mov %Q1,%d0\;\"
;                 \"mov %R1,%t0\;\"
;                 \"mov %S1,%q0\";
;        }
;      } else if (pic30_psrd_psrd_errata(operands[1],NULL)) {
;        pic30_rtx_nops+=1;
;        if (pic30_pre_modify(operands[1]))
;          return \"add %r1,#8,%r1\;mov.d %I1,%0\;nop\;mov.d %D1,%t0\";
;        else
;          return \"mov.d %1,%0\;nop\;mov.d %1,%t0\";
;      } else {
;        if (pic30_pre_modify(operands[1]))
;          return \"add %r1,#8,%r1\;mov.d %I1,%0\;mov.d %D1,%t0\";
;        else
;          return \"mov.d %1,%0\;mov.d %1,%t0\";
;      }
;    case 3: /* r = Q */
;      idDst = REGNO(operands[0]);
;      idSrc = REGNO(XEXP(XEXP(operands[1],0),0));
;      strcpy(temp, \"mov %1,%0\;\");
;      if (idDst != idSrc)
;        strcat(szInsn, temp);
;      else
;        strcat(save, temp);
;      idDst++;
;      strcpy(temp, \"mov %Q1,%d0\;\");
;      if (idDst != idSrc)
;        strcat(szInsn, temp);
;      else
;        strcat(save, temp);
;      idDst++;
;      strcpy(temp, \"mov %R1,%t0\;\");
;      if (idDst != idSrc)
;        strcat(szInsn, temp);
;      else
;        strcat(save, temp);
;      idDst++;
;      strcpy(temp, \"mov %S1,%q0\;\");
;      if (idDst != idSrc)
;        strcat(szInsn, temp);
;      else
;        strcat(save, temp);
;      idDst++;
;      if (save[0]) {
;        save[strlen(save)-2] = 0;
;        strcat(szInsn, save);
;      }
;      return szInsn;
;    case 4: /* R = r */
;      return \"mov.d %1,%I0\;mov.d %t1,%D0\";
;    case 5: /* > = r */
;      if (pic30_pre_modify(operands[0])) {
;        return \"add %r0,#8,%r0\;mov.d %1,%I0\;mov.d %t1,%D0\";
;      } else return \"mov.d %1,%0\;mov.d %t1,%0\";
;    case 6: /* > = > */
;      { int pre_op0, pre_op1;
;
;        pre_op0 = pic30_pre_modify(operands[0]);
;        pre_op1 = pic30_pre_modify(operands[1]);
;        if (pic30_psrd_psrd_errata_movd(operands[1],NULL)) {
;          if (pre_op0 && pre_op1) {
;            pic30_rtx_nops++;
;            return \"add %r0,#(8+4),%r0\;\"
;                   \"add %r1,#(8+4),%r1\;\"
;                   \"mov.d %s1,%D0\;\"
;                   \"nop\;\"
;                   \"mov.d %p1,%0\";
;          } else if (pre_op0) {
;            return \"add %r0,#8,%r0\;\"
;                   \"mov.d %s1,%I0\;\"
;                   \"add #4,%r1\;\"
;                   \"mov.d %s1,%D0\;\"
;                   \"add #4,%r1\";
;          } else if (pre_op1) {
;            return \"add %r1,#8,%r1\;\"
;                   \"mov.d %I1,%s0\;\"
;                   \"add #4,%r0\;\"
;                   \"mov.d %D1,%s0\;\"
;                   \"add #4,%r0\";
;          } else {
;            if (0 && optimize_size) {
;              // psv_psv repeat?
;              return \"repeat #(4-1)\;\"
;                     \"mov %1,%0\";
;            } else {
;              pic30_rtx_nops+=3;
;              return \"mov %1,%0\;\"
;                     \"nop\;\"
;                     \"mov %1,%0\;\"
;                     \"nop\;\"
;                     \"mov %1,%0\;\"
;                     \"nop\;\"
;                     \"mov %1,%0\";
;            }
;          }
;        } else 
;        if (pic30_psrd_psrd_errata(operands[1],NULL)) {
;          if (pre_op0 && pre_op1) {
;            pic30_rtx_nops++;
;            return \"add %r0,#(8+4),%r0\;\"
;                   \"add %r1,#(8+4),%r1\;\"
;                   \"mov.d %s1,%D0\;\"
;                   \"nop\;\"
;                   \"mov.d %p1,%0\";
;          } else if (pre_op0) {
;            return \"add %r0,#8,%r0\;\"
;                   \"mov.d %s1,%I0\;\"
;                   \"add #4,%r1\;\"
;                   \"mov.d %s1,%D0\;\"
;                   \"add #4,%r1\";
;          } else if (pre_op1) {
;            return \"add %r1,#8,%r1\;\"
;                   \"mov.d %I1,%s0\;\"
;                   \"add #4,%r0\;\"
;                   \"mov.d %D1,%s0\;\"
;                   \"add #4,%r0\";
;          } else {
;            if (0 && optimize_size) {
;              // psv_psv repeat?
;              return \"repeat #(4-1)\;\"
;                     \"mov %1,%0\";
;            } else {
;              pic30_rtx_nops+=3;
;              return \"mov %1,%0\;\"
;                     \"nop\;\"
;                     \"mov %1,%0\;\"
;                     \"nop\;\"
;                     \"mov %1,%0\;\"
;                     \"nop\;\"
;                     \"mov %1,%0\";
;            }
;          }
;       } else {
;          if (pre_op0 && pre_op1) {
;            return \"add %r0,#(8+4),%r0\;\"
;                   \"add %r1,#(8+4),%r1\;\"
;                   \"mov.d %s1,%D0\;\"
;                   \"mov.d %p1,%0\";
;          } else if (pre_op0) {
;            return \"add %r0,#8,%r0\;\"
;                   \"mov.d %s1,%I0\;\"
;                   \"add #4,%r1\;\"
;                   \"mov.d %s1,%D0\;\"
;                   \"add #4,%r1\";
;          } else if (pre_op1) {
;            return \"add %r1,#8,%r1\;\"
;                   \"mov.d %I1,%s0\;\"
;                   \"add #4,%r0\;\"
;                   \"mov.d %D1,%s0\;\"
;                   \"add #4,%r0\";
;          } else {
;            if (optimize_size) {
;              return \"repeat #(4-1)\;\"
;                     \"mov %1,%0\";
;            } else {
;              return \"mov %1,%0\;\"
;                     \"mov %1,%0\;\"
;                     \"mov %1,%0\;\"
;                     \"mov %1,%0\";
;            }
;          }
;        }
;      }
;    case 7: /* Q = r */
;      return \"mov %1,%0\;mov %d1,%Q0\;mov %t1,%R0\;mov %q1,%S0\";
;    case 8: /* r = < */
;      if (pic30_psrd_psrd_errata(operands[1],NULL)) {
;        pic30_rtx_nops++;
;        return \"mov.d %1,%t0\;nop\;mov.d %1,%0\";
;      } else {
;        return \"mov.d %1,%t0\;mov.d %1,%0\";
;      }
;    case 9: /* < = r */
;      return \"mov.d %t1,%0\;mov.d %1,%0\";
;    case 10: /* T = r */
;      return \"mov %1,%0\;\"
;             \"mov %d1,%Q0\;\"
;             \"mov %t1,%R0\;\"
;             \"mov %q1,%S0\";
;    case 11: /* r = T */
;            if (pic30_psrd_psrd_errata(operands[1],NULL)) {
;               pic30_rtx_nops++;
;               return \"mov %1,%0\;\"
;                      \"nop\;\"
;                      \"mov %Q1,%d0\;\"
;                      \"nop\;\"
;                      \"mov %R1,%t0\;\"
;                      \"nop\;\"
;                      \"mov %S1,%q0\";
;            } else {
;               return \"mov %1,%0\;\"
;                      \"mov %Q1,%d0\;\"
;                      \"mov %R1,%t0\;\"
;                      \"mov %S1,%q0\";
;            }
;    default: gcc_assert(0);
;  }
;}"
;  [
;   (set_attr "cc" "clobber")
;   (set_attr "type"
;             "def,defuse,defuse,defuse,use,use,use,use,defuse,use,etc,def")
;  ]
;)
;
;(define_insn "movdi_gen_APSV"
;  [(set (match_operand:DI 0 "pic30_move_operand"
;					"=r,r,r,r,R,>,>,Q,r,<,T,r")
;        (unspec:DI [
;          (match_operand:DI 1 "pic30_move_APSV_operand" 
;					"r,R,>,Q,r,r,>,r,<,r,r,T")
;          (reg:HI PSVPAG)] UNSPECV_USEPSV))]
;            
;  ""
;  "*
;{
;  int idSrc, idDst;
;  char temp[64];
;  char save[64];
;  static char szInsn[64];
;
;  szInsn[0] = 0;
;  temp[0] = 0;
;  save[0] = 0;
;
;  switch (which_alternative) {
;    case 0: /* r = r */
;      idDst = REGNO(operands[0]);
;      idSrc = REGNO(operands[1]);
;      if (idDst <= idSrc) {
;        return \"mov.d %1,%0\;mov.d %t1,%t0\";
;      } else {
;        return \"mov.d %t1,%t0\;mov.d %1,%0\";
;      }
;    case 1: /* r = R */
;      idDst = REGNO(operands[0]);
;      idSrc = REGNO(XEXP(operands[1],0));
;      if (pic30_pp_modify_valid(0) == 0) {
;        if ((idDst > idSrc) || ((idDst+4) <= idSrc)) {
;          /*
;           ** source & dest don't overlap
;           */
;          if (pic30_psrd_psrd_errata(operands[1],NULL)) {
;            pic30_rtx_nops++;
;            return \"mov.d %I1,%0\;\" 
;                   \"nop\;\"
;                   \"mov.d %D1,%t0\";
;          } else {
;            return \"mov.d %I1,%0\;\" 
;                   \"mov.d %D1,%t0\";
;          }
;        }
;        if ((idDst+2) > idSrc) {
;          /*
;           ** [wn] -> wn+2:wn+3:wn:wn+1
;           */
;          if (pic30_psrd_psrd_errata(operands[1],NULL)) {
;            pic30_rtx_nops++;
;            return \"mov.d %P1,%t0\;nop\;mov.d %p1,%0\";
;          } else {
;            return \"mov.d %P1,%t0\;mov.d %p1,%0\";
;          }
;        } else {
;          /*
;           ** [wn] -> wn-2:wn-1:wn:wn+1
;           */
;          if (pic30_psrd_psrd_errata(operands[1],NULL)) {
;            pic30_rtx_nops++;
;            return \"mov.d %I1,%0\;nop\;mov.d %1,%t0\";
;          } else {
;            return \"mov.d %I1,%0\;mov.d %1,%t0\";
;          }
;        } 
;      } else { 
;        if ((idDst > idSrc) || ((idDst + 3) <= idSrc)) {
;          /*  don't significantly overlap */ 
;          if (pic30_psrd_psrd_errata(operands[1],NULL)) {
;            pic30_rtx_nops+=2;
;            return \"mov.d %1,%0\;nop\;mov [%r1+4],%t0\;nop\;mov [%r1+6],%q0\";
;          } else {
;            return \"mov.d %1,%0\;mov [%r1+4],%t0\;mov [%r1+6],%q0\";
;          }
;        }
;        /* idDst <= idSrc < idDst+3 */
;        switch (idDst + 4 - idSrc) {
;          case 4:  /* idSrc == idDst+0 */
;          case 3:  /* idSrc == idDst+1 */
;            if (pic30_psrd_psrd_errata(operands[1],NULL)) {
;              pic30_rtx_nops+=2;
;              return \"mov [%r1+4],%t0\;\"
;                     \"nop\;\"
;                     \"mov [%r1+6],%q0\;\"
;                     \"nop\;\"
;                     \"mov.d %1,%0\";
;            } else {
;              return \"mov [%r1+4],%t0\;\"
;                     \"mov [%r1+6],%q0\;\"
;                     \"mov.d %1,%0\";
;            }
;          case 2:  /* idSrc == idDst+2 */
;            if (pic30_psrd_psrd_errata(operands[1],NULL)) {
;              pic30_rtx_nops+=2;
;              return \"mov.d %1,%0\;\"
;                     \"nop\;\"
;                     \"mov [%r1+6],%q0\;\"
;                     \"nop\;\"
;                     \"mov [%r1+4],%t0\";
;            } else {
;              return \"mov.d %1,%0\;mov [%r1+6],%q0\;mov [%r1+4],%t0\";
;            }
;          default: abort();
;        }
;      }
;    case 2: /* r = > */
;      if (pic30_psrd_psrd_errata(operands[1],NULL)) {
;        pic30_rtx_nops+=2;
;        if (pic30_pre_modify(operands[1]))
;          return \"add %r1,#8,%r1\;nop\;mov.d %I1,%0\;nop\;mov.d %D1,%t0\";
;        else
;          return \"mov.d %1,%0\;nop\;mov.d %1,%t0\";
;      } else {
;        if (pic30_pre_modify(operands[1]))
;          return \"add %r1,#8,%r1\;nop\;mov.d %I1,%0\;nop\;mov.d %D1,%t0\";
;        else
;          return \"mov.d %1,%0\;nop\;mov.d %1,%t0\";
;      }
;    case 3: /* r = Q */
;      idDst = REGNO(operands[0]);
;      idSrc = REGNO(XEXP(XEXP(operands[1],0),0));
;      strcpy(temp, \"mov %1,%0\;\");
;      if (idDst != idSrc)
;        strcat(szInsn, temp);
;      else
;        strcat(save, temp);
;      idDst++;
;      strcpy(temp, \"mov %Q1,%d0\;\");
;      if (idDst != idSrc)
;        strcat(szInsn, temp);
;      else
;        strcat(save, temp);
;      idDst++;
;      strcpy(temp, \"mov %R1,%t0\;\");
;      if (idDst != idSrc)
;        strcat(szInsn, temp);
;      else
;        strcat(save, temp);
;      idDst++;
;      strcpy(temp, \"mov %S1,%q0\;\");
;      if (idDst != idSrc)
;        strcat(szInsn, temp);
;      else
;        strcat(save, temp);
;      idDst++;
;      if (save[0]) {
;        save[strlen(save)-2] = 0;
;        strcat(szInsn, save);
;      }
;      return szInsn;
;    case 4: /* R = r */
;      return \"mov.d %1,%I0\;mov.d %t1,%D0\";
;    case 5: /* > = r */
;      if (pic30_pre_modify(operands[0])) {
;        return \"add %r0,#8,%r0\;mov.d %1,%I0\;mov.d %t1,%D0\";
;      } else return \"mov.d %1,%0\;mov.d %t1,%0\";
;    case 6: /* > = > */
;      { int pre_op0, pre_op1;
;
;        pre_op0 = pic30_pre_modify(operands[0]);
;        pre_op1 = pic30_pre_modify(operands[1]);
;        if (pic30_psrd_psrd_errata(operands[1],NULL)) {
;          if (pre_op0 && pre_op1) {
;            pic30_rtx_nops++;
;            return \"add %r0,#(8+4),%r0\;\"
;                   \"add %r1,#(8+4),%r1\;\"
;                   \"mov.d %s1,%D0\;\"
;                   \"nop\;\"
;                   \"mov.d %p1,%0\";
;          } else if (pre_op0) {
;            return \"add %r0,#8,%r0\;\"
;                   \"mov.d %s1,%I0\;\"
;                   \"add #4,%r1\;\"
;                   \"mov.d %s1,%D0\;\"
;                   \"add #4,%r1\";
;          } else if (pre_op1) {
;            return \"add %r1,#8,%r1\;\"
;                   \"mov.d %I1,%s0\;\"
;                   \"add #4,%r0\;\"
;                   \"mov.d %D1,%s0\;\"
;                   \"add #4,%r0\";
;          } else {
;            // psv_psv repeat
;            if (0 && optimize_size) {
;              return \"repeat #(4-1)\;\"
;                     \"mov %1,%0\";
;            } else {
;              pic30_rtx_nops+=3;
;              return \"mov %1,%0\;\"
;                     \"nop\;\"
;                     \"mov %1,%0\;\"
;                     \"nop\;\"
;                     \"mov %1,%0\;\"
;                     \"nop\;\"
;                     \"mov %1,%0\";
;            }
;          }
;       } else {
;          if (pre_op0 && pre_op1) {
;            return \"add %r0,#(8+4),%r0\;\"
;                   \"add %r1,#(8+4),%r1\;\"
;                   \"mov.d %s1,%D0\;\"
;                   \"mov.d %p1,%0\";
;          } else if (pre_op0) {
;            return \"add %r0,#8,%r0\;\"
;                   \"mov.d %s1,%I0\;\"
;                   \"add #4,%r1\;\"
;                   \"mov.d %s1,%D0\;\"
;                   \"add #4,%r1\";
;          } else if (pre_op1) {
;            return \"add %r1,#8,%r1\;\"
;                   \"mov.d %I1,%s0\;\"
;                   \"add #4,%r0\;\"
;                   \"mov.d %D1,%s0\;\"
;                   \"add #4,%r0\";
;          } else {
;            if (optimize_size) {
;              return \"repeat #(4-1)\;\"
;                     \"mov %1,%0\";
;            } else {
;              return \"mov %1,%0\;\"
;                     \"mov %1,%0\;\"
;                     \"mov %1,%0\;\"
;                     \"mov %1,%0\";
;            }
;          }
;        }
;      }
;    case 7: /* Q = r */
;      return \"mov %1,%0\;mov %d1,%Q0\;mov %t1,%R0\;mov %q1,%S0\";
;    case 8: /* r = < */
;      if (pic30_psrd_psrd_errata(operands[1],NULL)) {
;        pic30_rtx_nops++;
;        return \"mov.d %1,%t0\;nop\;mov.d %1,%0\";
;      } else {
;        return \"mov.d %1,%t0\;mov.d %1,%0\";
;      }
;    case 9: /* < = r */
;      return \"mov.d %t1,%0\;mov.d %1,%0\";
;    case 10: /* T = r */
;      return \"mov %1,%0\;\"
;             \"mov %d1,%Q0\;\"
;             \"mov %t1,%R0\;\"
;             \"mov %q1,%S0\";
;    case 11: /* r = T */
;      if (pic30_psrd_psrd_errata(operands[1],NULL)) {
;        pic30_rtx_nops++;
;        return \"mov %1,%0\;\"
;               \"nop\;\"
;               \"mov %Q1,%d0\;\"
;               \"nop\;\"
;               \"mov %R1,%t0\;\"
;               \"nop\;\"
;               \"mov %S1,%q0\";
;      } else {
;        return \"mov %1,%0\;\"
;               \"mov %Q1,%d0\;\"
;               \"mov %R1,%t0\;\"
;               \"mov %S1,%q0\";
;      }
;    default: gcc_assert(0);
;  }
;}"
;  [
;   (set_attr "cc" "clobber")
;   (set_attr "type"
;             "def,defuse,defuse,defuse,use,use,use,use,defuse,use,etc,def")
;  ]
;)
;

;
; simplify the options and make reload generate the complex ones we used to
;   support.  This should result in better code generation
;

(define_insn "*mov<mode>_gen"
  [(set (match_operand:M64BIT 0 "pic30_movedi_operand"
					"=r,r,&r,R,>,&r,<,TU,r,r,r,Q")
        (match_operand:M64BIT 1 "pic30_movedi_operand" 
					 "r,R, >,r,r, <,r,r, T,U,Q,r"))]
  ""
  "*
{
  int idSrc, idDst;
  char temp[64];
  char save[64];
  static char szInsn[64];

  szInsn[0] = 0;
  temp[0] = 0;
  save[0] = 0;

  switch (which_alternative) {
    case 0: /* r = r */
      idDst = REGNO(operands[0]);
      idSrc = REGNO(operands[1]);
      if (idDst <= idSrc) {
        return \"mov.d %1,%0\;mov.d %t1,%t0\";
      } else {
        return \"mov.d %t1,%t0\;mov.d %1,%0\";
      }
    case 1: /* r = R */
      idDst = REGNO(operands[0]);
      idSrc = REGNO(XEXP(operands[1],0));
      if (pic30_pp_modify_valid(0) == 0) {
        if ((idDst > idSrc) || ((idDst+4) <= idSrc)) {
          /*
           ** source & dest don't overlap
           */
          if (pic30_psrd_psrd_errata_movd(NULL,operands[1])) {
            return \"mov %1,%0\;\" 
                   \"mov %Q1,%d0\;\"
                   \"mov %R1,%t0\;\"
                   \"mov %S1,%q0\";
          } else if (pic30_psrd_psrd_errata(operands[1],NULL)) {
            pic30_rtx_nops++;
            return \"mov.d %I1,%0\;\" 
                   \"nop\;\"
                   \"mov.d %D1,%t0\";
          } else {
            return \"mov.d %I1,%0\;\" 
                   \"mov.d %D1,%t0\";
          }
        }
        if (pic30_psrd_psrd_errata_movd(NULL,operands[1])) {
          switch (idDst + 4 - idSrc) {
            case 4:  /* idSrc == idDst+0 */
              return \"mov %Q1,%d0\;\"
                     \"mov %R1,%t0\;\"
                     \"mov %S1,%q0\;\"
                     \"mov %1,%0\";
            case 3:  /* idSrc == idDst+1 */
              return \"mov %1,%0\;\" 
                     \"mov %R1,%t0\;\"
                     \"mov %S1,%q0\;\"
                     \"mov %Q1,%d0\";
            case 2:  /* idSrc == idDst+2 */
              return \"mov %1,%0\;\" 
                     \"mov %Q1,%d0\;\"
                     \"mov %S1,%q0\;\"
                     \"mov %R1,%t0\";
            default: /* idSrc == idDst+3 */
              return \"mov %1,%0\;\" 
                     \"mov %Q1,%d0\;\"
                     \"mov %R1,%t0\;\"
                     \"mov %S1,%q0\";
          }
        }
        if ((idDst+2) > idSrc) {
          /*
           ** [wn] -> wn+2:wn+3:wn:wn+1
           */
          if (pic30_psrd_psrd_errata(operands[1],NULL)) {
            pic30_rtx_nops++;
            return \"mov.d %P1,%t0\;nop\;mov.d %p1,%0\";
          } else {
            return \"mov.d %P1,%t0\;mov.d %p1,%0\";
          }
        } else {
          /*
           ** [wn] -> wn-2:wn-1:wn:wn+1
           */
          if (pic30_psrd_psrd_errata(operands[1],NULL)) {
            pic30_rtx_nops++;
            return \"mov.d %I1,%0\;nop\;mov.d %1,%t0\";
          } else {
            return \"mov.d %I1,%0\;mov.d %1,%t0\";
          }
        } 
      } else { 
        if ((idDst > idSrc) || ((idDst + 3) <= idSrc)) {
          /*  don't significantly overlap */ 
         if (pic30_psrd_psrd_errata_movd(NULL,operands[1])) {
            return \"mov %1,%0\;\"   
                   \"mov %Q1,%d0\;\"
                   \"mov %R1,%t0\;\"
                   \"mov %S1,%q0\";
          } else if (pic30_psrd_psrd_errata(operands[1],NULL)) {
            pic30_rtx_nops++;
            return \"mov.d %1,%0\;nop\;mov [%r1+4],%t0\;nop\;mov [%r1+6],%q0\";
          } else {
            return \"mov.d %1,%0\;mov [%r1+4],%t0\;mov [%r1+6],%q0\";
          }
        }
        /* idDst <= idSrc < idDst+3 */
        if (pic30_psrd_psrd_errata_movd(NULL,operands[1])) {
        switch (idDst + 4 - idSrc) {
          case 4:  /* idSrc == idDst+0 */
              return \"mov %Q1,%d0\;\"
                     \"mov %R1,%t0\;\"
                     \"mov %S1,%q0\;\"
                     \"mov %1,%0\";
          case 3:  /* idSrc == idDst+1 */
              return \"mov %1,%0\;\"
                     \"mov %R1,%t0\;\"
                     \"mov %S1,%q0\;\"
                     \"mov %Q1,%d0\";
            case 2:  /* idSrc == idDst+2 */
              return \"mov %1,%0\;\"
                     \"mov %Q1,%d0\;\"
                     \"mov %S1,%q0\;\"
                     \"mov %R1,%t0\";
            default: /* idSrc == idDst+3 */
              return \"mov %1,%0\;\"
                     \"mov %Q1,%d0\;\"
                     \"mov %R1,%t0\;\"
                     \"mov %S1,%q0\";
           }
        }
        switch (idDst + 4 - idSrc) {
          case 4:  /* idSrc == idDst+0 */
          case 3:  /* idSrc == idDst+1 */
            if (pic30_psrd_psrd_errata(operands[1],NULL)) {
              pic30_rtx_nops+=2;
              return \"mov [%r1+4],%t0\;\"
                     \"nop\;\"
                     \"mov [%r1+6],%q0\;\"
                     \"nop\;\"
                     \"mov.d %1,%0\";
            } else {
              return \"mov [%r1+4],%t0\;\"
                     \"mov [%r1+6],%q0\;\"
                     \"mov.d %1,%0\";
            }
          case 2:  /* idSrc == idDst+2 */
            if (pic30_psrd_psrd_errata(operands[1],NULL)) {
              pic30_rtx_nops+=2;
              return \"mov.d %1,%0\;\"
                     \"nop\;\"
                     \"mov [%r1+6],%q0\;\"
                     \"nop\;\"
                     \"mov [%r1+4],%t0\";
            } else {
              return \"mov.d %1,%0\;mov [%r1+6],%q0\;mov [%r1+4],%t0\";
            }
          default: abort();
        }
      }
    case 2: /* r = > */
      if (pic30_psrd_psrd_errata_movd(operands[1],NULL)) {
        if (pic30_pre_modify(operands[1])) {
          return \"add %r1,#8,%r1\;\"
                 \"mov [%r1],%0\;\"
                 \"mov [%r1+2],%d0\;\"
                 \"mov [%r1+4],%t0\;\"
                 \"mov [%r1+6],%q0\";
        } else {
          return \"mov %1,%0\;\"
                 \"mov %1,%d0\;\"
                 \"mov %1,%t0\;\"
                 \"mov %1,%q0\";
        }
      } else {
        if (pic30_pre_modify(operands[1]))
          return \"add %r1,#8,%r1\;mov.d [%r1++],%0\;mov.d [%r1--],%t0\";
        else
          return \"mov.d %1,%0\;mov.d %1,%t0\";
      }
    case 3: /* R = r */
      return \"mov.d %1,%I0\;mov.d %t1,%D0\";
    case 4: /* > = r */
      if (pic30_pre_modify(operands[0])) {
        return \"add %r0,#8,%r0\;mov.d %1,%I0\;mov.d %t1,%D0\";
      } else return \"mov.d %1,%0\;mov.d %t1,%0\";
    case 5: /* r = < */
      if (pic30_psrd_psrd_errata_movd(operands[1],NULL)) {
        if (pic30_pre_modify(operands[1])) {
          return \"sub %r1,#8,%r1\;\"
                 \"mov [%r1],%0\;\"
                 \"mov [%r1+2],%d0\;\"
                 \"mov [%r1+4],%t0\;\"
                 \"mov [%r1+6],%q0\";
        } else {
          return \"mov [%r1],%0\;\"
                 \"mov [%r1+2],%d0\;\"
                 \"mov [%r1+4],%t0\;\"
                 \"mov [%r1+6],%q0\;\"
                 \"sub %r1,#8,%r1\";
        }
      } else {
        if (pic30_pre_modify(operands[1])) {
          return \"sub %r1,#8,%r1\;mov.d [%r1++],%0\;mov.d [%r1--],%t0\";
        } else {
          return \"mov.d [%r1++],%0\;mov.d [%r1--],%t0\;sub %r1,#8,%r1\";
        }
      }
    case 6: /* < = r */
      return \"mov.d %t1,%0\;mov.d %1,%0\";
    case 7: /* TU = r */
      return \"mov %1,%0\;\"
             \"mov %d1,%Q0\;\"
             \"mov %t1,%R0\;\"
             \"mov %q1,%S0\";
    case 8: /* r = T */
      if (pic30_psrd_psrd_errata_movd(operands[1],NULL)) {
        /* nops not needed, we know that there is no precondition */
        return \"mov %1,%0\;\"
               \"mov %Q1,%d0\;\"
               \"mov %R1,%t0\;\"
               \"mov %S1,%q0\";
      } else if (pic30_psrd_psrd_errata(operands[1],NULL)) {
        pic30_rtx_nops++;
        return \"mov %1,%0\;\"
               \"nop\;\"
               \"mov %Q1,%d0\;\"
               \"nop\;\"
               \"mov %R1,%t0\;\"
               \"nop\;\"
               \"mov %S1,%q0\";
      } else {
        return \"mov %1,%0\;\"
               \"mov %Q1,%d0\;\"
               \"mov %R1,%t0\;\"
               \"mov %S1,%q0\";
      }
    case 9: /* r = U */
      return \"mov %1,%0\;\"
             \"mov %Q1,%d0\;\"
             \"mov %R1,%t0\;\"
             \"mov %S1,%q0\";
    case 10: /* r = Q */
      idDst = REGNO(operands[0]);
      idSrc = REGNO(XEXP(XEXP(operands[1],0),0));
      strcpy(temp, \"mov %1,%0\;\");
      if (idDst != idSrc)
        strcat(szInsn, temp);
      else
        strcat(save, temp);
      idDst++;
      strcpy(temp, \"mov %Q1,%d0\;\");
      if (idDst != idSrc)
        strcat(szInsn, temp);
      else
        strcat(save, temp);
      idDst++;
      strcpy(temp, \"mov %R1,%t0\;\");
      if (idDst != idSrc)
        strcat(szInsn, temp);
      else
        strcat(save, temp);
      idDst++;
      strcpy(temp, \"mov %S1,%q0\;\");
      if (idDst != idSrc)
        strcat(szInsn, temp);
      else
        strcat(save, temp);
      idDst++;
      if (save[0]) {
        save[strlen(save)-2] = 0;
        strcat(szInsn, save);
      }
      return szInsn;
    case 11: /* Q = r */
      return \"mov %1,%0\;mov %d1,%Q0\;mov %t1,%R0\;mov %q1,%S0\";


    default: gcc_assert(0);
  }
}"
  [
   (set_attr "cc" "clobber")
   (set_attr "type"
             "def,defuse,defuse,use,use,defuse,use,etc,def,def,defuse,use")
  ]
)

(define_insn "mov<mode>_gen_APSV"
  [(set (match_operand:M64BIT 0 "pic30_movedi_operand"
					"=r,r,&r,R,>,&r,<,TU,r,r,r,Q")
        (unspec:M64BIT [
          (match_operand:M64BIT 1 "pic30_movedi_operand" 
					 "r,R, >,r,r, <,r,r, T,U,Q,r")
          (reg:HI PSVPAG)] 
         UNSPECV_USEPSV))]
  ""
  "*
{
  int idSrc, idDst;
  char temp[64];
  char save[64];
  static char szInsn[64];

  szInsn[0] = 0;
  temp[0] = 0;
  save[0] = 0;

  switch (which_alternative) {
    case 0: /* r = r */
      idDst = REGNO(operands[0]);
      idSrc = REGNO(operands[1]);
      if (idDst <= idSrc) {
        return \"mov.d %1,%0\;mov.d %t1,%t0\";
      } else {
        return \"mov.d %t1,%t0\;mov.d %1,%0\";
      }
    case 1: /* r = R */
      idDst = REGNO(operands[0]);
      idSrc = REGNO(XEXP(operands[1],0));
      if (pic30_pp_modify_valid(0) == 0) {
        if ((idDst > idSrc) || ((idDst+4) <= idSrc)) {
          /*
           ** source & dest don't overlap
           */
          if (pic30_psrd_psrd_errata_movd(NULL,operands[1])) {
            return \"mov %1,%0\;\" 
                   \"mov %Q1,%d0\;\"
                   \"mov %R1,%t0\;\"
                   \"mov %S1,%q0\";
          } else if (pic30_psrd_psrd_errata(operands[1],NULL)) {
            pic30_rtx_nops++;
            return \"mov.d %I1,%0\;\" 
                   \"nop\;\"
                   \"mov.d %D1,%t0\";
          } else {
            return \"mov.d %I1,%0\;\" 
                   \"mov.d %D1,%t0\";
          }
        }
        if (pic30_psrd_psrd_errata_movd(NULL,operands[1])) {
          switch (idDst + 4 - idSrc) {
            case 4:  /* idSrc == idDst+0 */
              return \"mov %Q1,%d0\;\"
                     \"mov %R1,%t0\;\"
                     \"mov %S1,%q0\;\"
                     \"mov %1,%0\";
            case 3:  /* idSrc == idDst+1 */
              return \"mov %1,%0\;\" 
                     \"mov %R1,%t0\;\"
                     \"mov %S1,%q0\;\"
                     \"mov %Q1,%d0\";
            case 2:  /* idSrc == idDst+2 */
              return \"mov %1,%0\;\" 
                     \"mov %Q1,%d0\;\"
                     \"mov %S1,%q0\;\"
                     \"mov %R1,%t0\";
            default: /* idSrc == idDst+3 */
              return \"mov %1,%0\;\" 
                     \"mov %Q1,%d0\;\"
                     \"mov %R1,%t0\;\"
                     \"mov %S1,%q0\";
          }
        }
        if ((idDst+2) > idSrc) {
          /*
           ** [wn] -> wn+2:wn+3:wn:wn+1
           */
          if (pic30_psrd_psrd_errata(operands[1],NULL)) {
            pic30_rtx_nops++;
            return \"mov.d %P1,%t0\;nop\;mov.d %p1,%0\";
          } else {
            return \"mov.d %P1,%t0\;mov.d %p1,%0\";
          }
        } else {
          /*
           ** [wn] -> wn-2:wn-1:wn:wn+1
           */
          if (pic30_psrd_psrd_errata(operands[1],NULL)) {
            pic30_rtx_nops++;
            return \"mov.d %I1,%0\;nop\;mov.d %1,%t0\";
          } else {
            return \"mov.d %I1,%0\;mov.d %1,%t0\";
          }
        } 
      } else { 
        if ((idDst > idSrc) || ((idDst + 3) <= idSrc)) {
          /*  don't significantly overlap */ 
         if (pic30_psrd_psrd_errata_movd(NULL,operands[1])) {
            return \"mov %1,%0\;\"   
                   \"mov %Q1,%d0\;\"
                   \"mov %R1,%t0\;\"
                   \"mov %S1,%q0\";
          } else if (pic30_psrd_psrd_errata(operands[1],NULL)) {
            pic30_rtx_nops++;
            return \"mov.d %1,%0\;nop\;mov [%r1+4],%t0\;nop\;mov [%r1+6],%q0\";
          } else {
            return \"mov.d %1,%0\;mov [%r1+4],%t0\;mov [%r1+6],%q0\";
          }
        }
        /* idDst <= idSrc < idDst+3 */
        if (pic30_psrd_psrd_errata_movd(NULL,operands[1])) {
        switch (idDst + 4 - idSrc) {
          case 4:  /* idSrc == idDst+0 */
              return \"mov %Q1,%d0\;\"
                     \"mov %R1,%t0\;\"
                     \"mov %S1,%q0\;\"
                     \"mov %1,%0\";
          case 3:  /* idSrc == idDst+1 */
              return \"mov %1,%0\;\"
                     \"mov %R1,%t0\;\"
                     \"mov %S1,%q0\;\"
                     \"mov %Q1,%d0\";
            case 2:  /* idSrc == idDst+2 */
              return \"mov %1,%0\;\"
                     \"mov %Q1,%d0\;\"
                     \"mov %S1,%q0\;\"
                     \"mov %R1,%t0\";
            default: /* idSrc == idDst+3 */
              return \"mov %1,%0\;\"
                     \"mov %Q1,%d0\;\"
                     \"mov %R1,%t0\;\"
                     \"mov %S1,%q0\";
           }
        }
        switch (idDst + 4 - idSrc) {
          case 4:  /* idSrc == idDst+0 */
          case 3:  /* idSrc == idDst+1 */
            if (pic30_psrd_psrd_errata(operands[1],NULL)) {
              pic30_rtx_nops+=2;
              return \"mov [%r1+4],%t0\;\"
                     \"nop\;\"
                     \"mov [%r1+6],%q0\;\"
                     \"nop\;\"
                     \"mov.d %1,%0\";
            } else {
              return \"mov [%r1+4],%t0\;\"
                     \"mov [%r1+6],%q0\;\"
                     \"mov.d %1,%0\";
            }
          case 2:  /* idSrc == idDst+2 */
            if (pic30_psrd_psrd_errata(operands[1],NULL)) {
              pic30_rtx_nops+=2;
              return \"mov.d %1,%0\;\"
                     \"nop\;\"
                     \"mov [%r1+6],%q0\;\"
                     \"nop\;\"
                     \"mov [%r1+4],%t0\";
            } else {
              return \"mov.d %1,%0\;mov [%r1+6],%q0\;mov [%r1+4],%t0\";
            }
          default: abort();
        }
      }
    case 2: /* r = > */
      if (pic30_psrd_psrd_errata_movd(operands[1],NULL)) {
        if (pic30_pre_modify(operands[1])) {
          return \"add %r1,#8,%r1\;\"
                 \"mov %1,%0\;\"
                 \"mov %Q1,%d0\;\"
                 \"mov %R1,%t0\;\"
                 \"mov %S1,%q0\";
        } else {
          return \"mov %1,%0\;\"
                 \"mov %1,%d0\;\"
                 \"mov %1,%t0\;\"
                 \"mov %1,%q0\";
        }
      } else if (pic30_psrd_psrd_errata(operands[1],NULL)) {
        pic30_rtx_nops+=1;
        if (pic30_pre_modify(operands[1]))
          return \"add %r1,#8,%r1\;mov.d %I1,%0\;nop\;mov.d %D1,%t0\";
        else
          return \"mov.d %1,%0\;nop\;mov.d %1,%t0\";
      } else {
        if (pic30_pre_modify(operands[1]))
          return \"add %r1,#8,%r1\;mov.d %I1,%0\;mov.d %D1,%t0\";
        else
          return \"mov.d %1,%0\;mov.d %1,%t0\";
      }
    case 3: /* R = r */
      return \"mov.d %1,%I0\;mov.d %t1,%D0\";
    case 4: /* > = r */
      if (pic30_pre_modify(operands[0])) {
        return \"add %r0,#8,%r0\;mov.d %1,%I0\;mov.d %t1,%D0\";
      } else return \"mov.d %1,%0\;mov.d %t1,%0\";
    case 5: /* r = < */
      if (pic30_psrd_psrd_errata_movd(operands[1],NULL)) {
        if (pic30_pre_modify(operands[1])) {
          return \"sub %r1,#8,%r1\;\"
                 \"mov [%r1],%0\;\"
                 \"mov [%r1+2],%d0\;\"
                 \"mov [%r1+4],%t0\;\"
                 \"mov [%r1+6],%q0\";
        } else {
          return \"mov [%r1],%0\;\"
                 \"mov [%r1+2],%d0\;\"
                 \"mov [%r1+4],%t0\;\"
                 \"mov [%r1+6],%q0\;\"
                 \"sub %r1,#8,%r1\";
        }
      } else {
        if (pic30_pre_modify(operands[1])) {
          return \"sub %r1,#8,%r1\;mov.d [%r1++],%0\;mov.d [%r1--],%t0\";
        } else {
          return \"mov.d [%r1++],%0\;mov.d [%r1--],%t0\;sub %r1,#8,%r1\";
        }
      }
    case 6: /* < = r */
      return \"mov.d %t1,%0\;mov.d %1,%0\";
    case 7: /* TU = r */
      return \"mov %1,%0\;\"
             \"mov %d1,%Q0\;\"
             \"mov %t1,%R0\;\"
             \"mov %q1,%S0\";
    case 8: /* r = T */
      if (pic30_psrd_psrd_errata_movd(operands[1],NULL)) {
        /* nops not needed, we know that there is no precondition */
        return \"mov %1,%0\;\"
               \"mov %Q1,%d0\;\"
               \"mov %R1,%t0\;\"
               \"mov %S1,%q0\";
      } else if (pic30_psrd_psrd_errata(operands[1],NULL)) {
        pic30_rtx_nops++;
        return \"mov %1,%0\;\"
               \"nop\;\"
               \"mov %Q1,%d0\;\"
               \"nop\;\"
               \"mov %R1,%t0\;\"
               \"nop\;\"
               \"mov %S1,%q0\";
      } else {
        return \"mov %1,%0\;\"
               \"mov %Q1,%d0\;\"
               \"mov %R1,%t0\;\"
               \"mov %S1,%q0\";
      }
    case 9: /* r = U */
      return \"mov %1,%0\;\"
             \"mov %Q1,%d0\;\"
             \"mov %R1,%t0\;\"
             \"mov %S1,%q0\";
    case 10: /* r = Q */
      idDst = REGNO(operands[0]);
      idSrc = REGNO(XEXP(XEXP(operands[1],0),0));
      strcpy(temp, \"mov %1,%0\;\");
      if (idDst != idSrc)
        strcat(szInsn, temp);
      else
        strcat(save, temp);
      idDst++;
      strcpy(temp, \"mov %Q1,%d0\;\");
      if (idDst != idSrc)
        strcat(szInsn, temp);
      else
        strcat(save, temp);
      idDst++;
      strcpy(temp, \"mov %R1,%t0\;\");
      if (idDst != idSrc)
        strcat(szInsn, temp);
      else
        strcat(save, temp);
      idDst++;
      strcpy(temp, \"mov %S1,%q0\");
      if (idDst != idSrc)
        strcat(szInsn, temp);
      else
        strcat(save, temp);
      idDst++;
      if (save[0]) {
        save[strlen(save)-2] = 0;
        strcat(szInsn, save);
      }
      return szInsn;
    case 11: /* Q = r */
      return \"mov %1,%0\;mov %d1,%Q0\;mov %t1,%R0\;mov %q1,%S0\";
    default: gcc_assert(0);
  }
}"
  [
   (set_attr "cc" "clobber")
   (set_attr "type"
             "def,defuse,defuse,use,use,defuse,use,etc,def,def,defuse,use")
  ]
)

(define_expand "mov<mode>"
  [(set (match_operand:M64BIT 0 "pic30_general_operand" "")
        (match_operand:M64BIT 1 "pic30_general_operand" ""))]
  ""
  "
{
   if (pic30_emit_move_sequence(operands, GET_MODE(operands[0]))) DONE;
}")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Single Float (32 bit) moves
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Invalid move

(define_insn "*movsf_invalid_1"
  [(set (match_operand:SF 0 "pic30_register_operand"  "=r")
        (match_operand:SF 1 "pic30_code_operand" "g"))]
  ""
  "*
{
        error(\"invalid address space for operand\");
        return \"cannot generate instructions\";
}

")
(define_insn "*movsf_invalid_2"
  [(set (match_operand:SF 0 "pic30_code_operand" "=g")
        (match_operand:SF 1 "pic30_register_operand"    "r"))]
  ""
  "*
{
        error(\"invalid address space for operand\");
        return \"cannot generate instructions\";
}
")


(define_insn "*movsf_rimm"
  [(set (match_operand:SF 0 "pic30_register_operand" "=r,r")
        (match_operand:SF 1 "immediate_operand" "G,i"))]
  ""
  "*
{
	switch (which_alternative)
	{
	case 0:
		return \"mul.uu %0,#0,%0\;\";
	default:
		return \"mov #%x1,%0\;mov #%w1,%d0\";
	}
}"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "*movsf_constnsfr"
  [(set (match_operand:SF 0 "pic30_near_operand" "=U,U")
        (match_operand:SF 1 "immediate_operand"   "G,i"))
	(clobber (match_scratch:HI 2             "=X,r"))]
  ""
  "*
   {
     REAL_VALUE_TYPE r;
     long l = 0;

     switch (which_alternative) {
       case 0:
         return \"clr %0\;clr %0+2\";
       default:
         REAL_VALUE_FROM_CONST_DOUBLE(r, operands[1]);
         REAL_VALUE_TO_TARGET_SINGLE(r, l);
         if ((l & 0xFFFF) == 0) {
           return \"clr %0\;\"
                  \"mov #%w1,%2\;\"
                  \"mov %2,%0+2\";
         } else {
           return \"mov #%x1,%2\;\"
                  \"mov %2,%0\;\"
                  \"mov #%w1,%2\;\"
                  \"mov %2,%0+2\";
         }
     }
   }"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "etc")
  ]
)

(define_expand "movsf"
  [(set (match_operand:SF 0 "pic30_general_operand" "")
        (match_operand:SF 1 "pic30_general_operand" ""))]
  ""
  "
   {
     if (pic30_emit_move_sequence(operands, SFmode)) DONE;
   }"
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Double float (64 bit) moves
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Invalid move

(define_insn "*movdf_invalid_1"
  [(set (match_operand:DF 0 "pic30_register_operand"  "=r")
        (match_operand:DF 1 "pic30_code_operand" "g"))]
  ""
  "*
   {
        error(\"invalid address space for operand\");
        return \"cannot generate instructions\";
   }"
)

(define_insn "*movdf_invalid_2"
  [(set (match_operand:DF 0 "pic30_code_operand" "=g")
        (match_operand:DF 1 "pic30_register_operand"    "r"))]
  ""
  "*
   {
        error(\"invalid address space for operand\");
        return \"cannot generate instructions\";
   }"
)


(define_insn "*movdf_rimm"
  [(set (match_operand:DF 0 "pic30_register_operand" "=r,r")
        (match_operand:DF 1 "immediate_operand" "G,i"))]
  ""
  "*
   {
      REAL_VALUE_TYPE r;
      long l[4] = { 0 };

      switch (which_alternative) {
        case 0:
          return \"mul.uu %0,#0,%0\;\"
                 \"mul.uu %t0,#0,%t0\";
        default:
          REAL_VALUE_FROM_CONST_DOUBLE(r, operands[1]);
          REAL_VALUE_TO_TARGET_DOUBLE(r, l);
          if (l[0] == 0) {
            return \"mul.uu %0,#0,%0\;\"
                   \"mov #%x1,%t0\;\"
                   \"mov #%w1,%q0\";
          } else {
            return \"mov #%z1,%0\;\"
                   \"mov #%y1,%d0\;\"
                   \"mov #%x1,%t0\;\"
                   \"mov #%w1,%q0\";
          }
      }
   }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn_and_split "*movdf_rr"
  [(set (match_operand:DF 0 "pic30_register_operand" "=r")
        (match_operand:DF 1 "pic30_register_operand" " r"))]
  ""
  "mov.d %1,%0\;mov.d %t1,%t0"
  "reload_completed"
  [
   (set (subreg:SI (match_dup 0) 0) (subreg:SI (match_dup 1) 0))
   (set (subreg:SI (match_dup 0) 4) (subreg:SI (match_dup 1) 4))
  ]
  ""
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def")
  ]
)

;(define_insn "movdf_gen"
;  [(set (match_operand:DF 0 "pic30_move_operand"
;					"=r,r,r,r,R,>,>,Q,r,<,T,r")
;        (match_operand:DF 1 "pic30_move_operand" 
;					 "r,R,>,Q,r,r,>,r,<,r,r,T"))
;  ]
;  ""
;{
;  int idSrc, idDst;
;  char temp[64];
;  char save[64];
;  static char szInsn[64];
;
;  szInsn[0] = 0;
;  temp[0] = 0;
;  save[0] = 0;
;  switch (which_alternative) {
;    case 0: /* r = r */
;      idDst = REGNO(operands[0]);
;      idSrc = REGNO(operands[1]);
;      if (idDst <= idSrc) {
;        return \"mov.d %1,%0\;mov.d %t1,%t0\";
;      } else {
;        return \"mov.d %t1,%t0\;mov.d %1,%0\";
;      }
;    case 1: /* r = R */
;      idDst = REGNO(operands[0]);
;      idSrc = REGNO(XEXP(operands[1],0));
;      if (pic30_pp_modify_valid(0) == 0) {
;        if ((idDst > idSrc) || ((idDst+4) <= idSrc)) {
;          /*
;           ** source & dest don't overlap
;           */
;          if (pic30_psrd_psrd_errata(operands[1],NULL)) {
;            pic30_rtx_nops++;
;            return \"mov.d %I1,%0\;\" 
;                   \"nop\;\"
;                   \"mov.d %D1,%t0\";
;          } else {
;            return \"mov.d %I1,%0\;\" 
;                   \"mov.d %D1,%t0\";
;          }
;        }
;        if ((idDst+2) > idSrc) {
;          /*
;           ** [wn] -> wn+2:wn+3:wn:wn+1
;           */
;          if (pic30_psrd_psrd_errata(operands[1],NULL)) {
;            pic30_rtx_nops++;
;            return \"mov.d %P1,%t0\;nop\;mov.d %p1,%0\";
;          } else {
;            return \"mov.d %P1,%t0\;mov.d %p1,%0\";
;          }
;        } else {
;          /*
;           ** [wn] -> wn-2:wn-1:wn:wn+1
;           */
;          if (pic30_psrd_psrd_errata(operands[1],NULL)) {
;            pic30_rtx_nops++;
;            return \"mov.d %I1,%0\;nop\;mov.d %1,%t0\";
;          } else {
;            return \"mov.d %I1,%0\;mov.d %1,%t0\";
;          }
;        } 
;      } else { 
;        if ((idDst > idSrc) || ((idDst + 3) <= idSrc)) {
;          /*  don't significantly overlap */ 
;          if (pic30_psrd_psrd_errata(operands[1],NULL)) {
;            pic30_rtx_nops+=2;
;            return \"mov.d %1,%0\;nop\;mov [%r1+4],%t0\;nop\;mov [%r1+6],%q0\";
;          } else {
;            return \"mov.d %1,%0\;mov [%r1+4],%t0\;mov [%r1+6],%q0\";
;          }
;        }
;        /* idDst <= idSrc < idDst+3 */
;        switch (idDst + 4 - idSrc) {
;          case 4:  /* idSrc == idDst+0 */
;          case 3:  /* idSrc == idDst+1 */
;            if (pic30_psrd_psrd_errata(operands[1],NULL)) {
;              pic30_rtx_nops+=2;
;              return \"mov [%r1+4],%t0\;\"
;                     \"nop\;\"
;                     \"mov [%r1+6],%q0\;\"
;                     \"nop\;\"
;                     \"mov.d %1,%0\";
;            } else {
;              return \"mov [%r1+4],%t0\;\"
;                     \"mov [%r1+6],%q0\;\"
;                     \"mov.d %1,%0\";
;            }
;          case 2:  /* idSrc == idDst+2 */
;            if (pic30_psrd_psrd_errata(operands[1],NULL)) {
;              pic30_rtx_nops+=2;
;              return \"mov.d %1,%0\;\"
;                     \"nop\;\"
;                     \"mov [%r1+6],%q0\;\"
;                     \"nop\;\"
;                     \"mov [%r1+4],%t0\";
;            } else {
;              return \"mov.d %1,%0\;mov [%r1+6],%q0\;mov [%r1+4],%t0\";
;            }
;          default: abort();
;        }
;      }
;    case 2: /* r = > */
;      if (pic30_psrd_psrd_errata(operands[1],NULL)) {
;        pic30_rtx_nops++;
;        if (pic30_pre_modify(operands[1])) {
;          pic30_rtx_nops++;
;          return \"add %r1,#8,%r1\;nop\;mov.d %I1,%0\;nop\;mov.d %D1,%t0\";
;        } else {
;          return \"mov.d %1,%0\;nop\;mov.d %1,%t0\";
;        }
;      } else {
;        if (pic30_pre_modify(operands[1])) {
;          pic30_rtx_nops++;
;          return \"add %r1,#8,%r1\;nop\;mov.d %I1,%0\;nop\;mov.d %D1,%t0\";
;        } else {
;          return \"mov.d %1,%0\;nop\;mov.d %1,%t0\";
;        }
;      }
;    case 3: /* r = Q */
;      idDst = REGNO(operands[0]);
;      idSrc = REGNO(XEXP(XEXP(operands[1],0),0));
;      strcpy(temp, \"mov %1,%0\;\");
;      if (idDst != idSrc)
;        strcat(szInsn, temp);
;      else
;        strcat(save, temp);
;      idDst++;
;      strcpy(temp, \"mov %Q1,%d0\;\");
;      if (idDst != idSrc)
;        strcat(szInsn, temp);
;      else
;        strcat(save, temp);
;      idDst++;
;      strcpy(temp, \"mov %R1,%t0\;\");
;      if (idDst != idSrc)
;        strcat(szInsn, temp);
;      else
;        strcat(save, temp);
;      idDst++;
;      strcpy(temp, \"mov %S1,%q0\;\");
;      if (idDst != idSrc)
;        strcat(szInsn, temp);
;      else
;        strcat(save, temp);
;      idDst++;
;      if (save[0]) {
;        save[strlen(save)-2] = 0;
;        strcat(szInsn, save);
;      }
;      return szInsn;
;    case 4: /* R = r */
;      return \"mov.d %1,%I0\;mov.d %t1,%D0\";
;    case 5: /* > = r */
;      if (pic30_pre_modify(operands[0])) {
;        return \"add %r0,#8,%r0\;mov.d %1,%I0\;mov.d %t1,%D0\";
;      } else return \"mov.d %1,%0\;mov.d %t1,%0\";
;    case 6: /* > = > */
;      { int pre_op0, pre_op1;
;
;        pre_op0 = pic30_pre_modify(operands[0]);
;        pre_op1 = pic30_pre_modify(operands[1]);
;        if (pic30_psrd_psrd_errata(operands[1],NULL)) {
;          if (pre_op0 && pre_op1) {
;            pic30_rtx_nops++;
;            return \"add %r0,#(8+4),%r0\;\"
;                   \"add %r1,#(8+4),%r1\;\"
;                   \"mov.d %s1,%D0\;\"
;                   \"nop\;\"
;                   \"mov.d %p1,%0\";
;          } else if (pre_op0) {
;            return \"add %r0,#8,%r0\;\"
;                   \"mov.d %s1,%I0\;\"
;                   \"add #4,%r1\;\"
;                   \"mov.d %s1,%D0\;\"
;                   \"add #4,%r1\";
;          } else if (pre_op1) {
;            return \"add %r1,#8,%r1\;\"
;                   \"mov.d %I1,%s0\;\"
;                   \"add #4,%r0\;\"
;                   \"mov.d %D1,%s0\;\"
;                   \"add #4,%r0\";
;          } else {
;            // psv_psv repeat
;            if (0 && optimize_size) {
;              return \"repeat #(4-1)\;\"
;                     \"mov %1,%0\";
;            } else {
;              pic30_rtx_nops+=3;
;              return \"mov %1,%0\;\"
;                     \"nop\;\"
;                     \"mov %1,%0\;\"
;                     \"nop\;\"
;                     \"mov %1,%0\;\"
;                     \"nop\;\"
;                     \"mov %1,%0\";
;            }
;          }
;       } else {
;          if (pre_op0 && pre_op1) {
;            return \"add %r0,#(8+4),%r0\;\"
;                   \"add %r1,#(8+4),%r1\;\"
;                   \"mov.d %s1,%D0\;\"
;                   \"mov.d %p1,%0\";
;          } else if (pre_op0) {
;            return \"add %r0,#8,%r0\;\"
;                   \"mov.d %s1,%I0\;\"
;                   \"add #4,%r1\;\"
;                   \"mov.d %s1,%D0\;\"
;                   \"add #4,%r1\";
;          } else if (pre_op1) {
;            return \"add %r1,#8,%r1\;\"
;                   \"mov.d %I1,%s0\;\"
;                   \"add #4,%r0\;\"
;                   \"mov.d %D1,%s0\;\"
;                   \"add #4,%r0\";
;          } else {
;            if (optimize_size) {
;              return \"repeat #(4-1)\;\"
;                     \"mov %1,%0\";
;            } else {
;              return \"mov %1,%0\;\"
;                     \"mov %1,%0\;\"
;                     \"mov %1,%0\;\"
;                     \"mov %1,%0\";
;            }
;          }
;        }
;      }
;    case 7: /* Q = r */
;      return \"mov %1,%0\;mov %d1,%Q0\;mov %t1,%R0\;mov %q1,%S0\";
;    case 8: /* r = < */
;      if (pic30_psrd_psrd_errata(operands[1],NULL)) {
;        pic30_rtx_nops++;
;        return \"mov.d %1,%t0\;nop\;mov.d %1,%0\";
;      } else {
;        return \"mov.d %1,%t0\;mov.d %1,%0\";
;      }
;    case 9: /* < = r */
;      return \"mov.d %t1,%0\;mov.d %1,%0\";
;    case 10: /* T = r */
;      return \"mov %1,%0\;\"
;             \"mov %d1,%Q0\;\"
;             \"mov %t1,%R0\;\"
;             \"mov %q1,%S0\";
;    case 11: /* r = T */
;      if (pic30_psrd_psrd_errata(operands[1],NULL)) {
;        pic30_rtx_nops++;
;        return \"mov %1,%0\;\"
;               \"nop\;\"
;               \"mov %Q1,%d0\;\"
;               \"nop\;\"
;               \"mov %R1,%t0\;\"
;               \"nop\;\"
;               \"mov %S1,%q0\";
;      } else {
;        return \"mov %1,%0\;\"
;               \"mov %Q1,%d0\;\"
;               \"mov %R1,%t0\;\"
;               \"mov %S1,%q0\";
;      }
;    default: gcc_assert(0);
;  }
;  return "?mov? %1,%0";
;}
; [(set_attr "cc" "clobber")
;  (set_attr "type"
;            "def,defuse,defuse,defuse,use,use,use,use,defuse,use,etc,use")
; ]
;)
;
;(define_insn "movdf_gen_APSV"
;  [(set (match_operand:DF 0 "pic30_move_operand"
;					"=r,r,r,r,R,>,>,Q,r,<,T,r")
;        (unspec:DF [
;          (match_operand:DF 1 "pic30_move_APSV_operand" 
;					 "r,R,>,Q,r,r,>,r,<,r,r,T")
;          (reg:HI PSVPAG)] UNSPECV_USEPSV))]
;  ""
;{
;  int idSrc, idDst;
;  char temp[64];
;  char save[64];
;  static char szInsn[64];
;
;  szInsn[0] = 0;
;  temp[0] = 0;
;  save[0] = 0;
;  switch (which_alternative) {
;    case 0: /* r = r */
;      idDst = REGNO(operands[0]);
;      idSrc = REGNO(operands[1]);
;      if (idDst <= idSrc) {
;        return \"mov.d %1,%0\;mov.d %t1,%t0\";
;      } else {
;        return \"mov.d %t1,%t0\;mov.d %1,%0\";
;      }
;    case 1: /* r = R */
;      idDst = REGNO(operands[0]);
;      idSrc = REGNO(XEXP(operands[1],0));
;      if (pic30_pp_modify_valid(0) == 0) {
;        if ((idDst > idSrc) || ((idDst+4) <= idSrc)) {
;          /*
;           ** source & dest don't overlap
;           */
;          if (pic30_psrd_psrd_errata(operands[1],NULL)) {
;            pic30_rtx_nops++;
;            return \"mov.d %I1,%0\;\" 
;                   \"nop\;\"
;                   \"mov.d %D1,%t0\";
;          } else {
;            return \"mov.d %I1,%0\;\" 
;                   \"mov.d %D1,%t0\";
;          }
;        }
;        if ((idDst+2) > idSrc) {
;          /*
;           ** [wn] -> wn+2:wn+3:wn:wn+1
;           */
;          if (pic30_psrd_psrd_errata(operands[1],NULL)) {
;            pic30_rtx_nops++;
;            return \"mov.d %P1,%t0\;nop\;mov.d %p1,%0\";
;          } else {
;            return \"mov.d %P1,%t0\;mov.d %p1,%0\";
;          }
;        } else {
;          /*
;           ** [wn] -> wn-2:wn-1:wn:wn+1
;           */
;          if (pic30_psrd_psrd_errata(operands[1],NULL)) {
;            pic30_rtx_nops++;
;            return \"mov.d %I1,%0\;nop\;mov.d %1,%t0\";
;          } else {
;            return \"mov.d %I1,%0\;mov.d %1,%t0\";
;          }
;        } 
;      } else { 
;        if ((idDst > idSrc) || ((idDst + 3) <= idSrc)) {
;          /*  don't significantly overlap */ 
;          if (pic30_psrd_psrd_errata(operands[1],NULL)) {
;            pic30_rtx_nops+=2;
;            return \"mov.d %1,%0\;nop\;mov [%r1+4],%t0\;nop\;mov [%r1+6],%q0\";
;          } else {
;            return \"mov.d %1,%0\;mov [%r1+4],%t0\;mov [%r1+6],%q0\";
;          }
;        }
;        /* idDst <= idSrc < idDst+3 */
;        switch (idDst + 4 - idSrc) {
;          case 4:  /* idSrc == idDst+0 */
;          case 3:  /* idSrc == idDst+1 */
;            if (pic30_psrd_psrd_errata(operands[1],NULL)) {
;              pic30_rtx_nops+=2;
;              return \"mov [%r1+4],%t0\;\"
;                     \"nop\;\"
;                     \"mov [%r1+6],%q0\;\"
;                     \"nop\;\"
;                     \"mov.d %1,%0\";
;            } else {
;              return \"mov [%r1+4],%t0\;\"
;                     \"mov [%r1+6],%q0\;\"
;                     \"mov.d %1,%0\";
;            }
;          case 2:  /* idSrc == idDst+2 */
;            if (pic30_psrd_psrd_errata(operands[1],NULL)) {
;              pic30_rtx_nops+=2;
;              return \"mov.d %1,%0\;\"
;                     \"nop\;\"
;                     \"mov [%r1+6],%q0\;\"
;                     \"nop\;\"
;                     \"mov [%r1+4],%t0\";
;            } else {
;              return \"mov.d %1,%0\;mov [%r1+6],%q0\;mov [%r1+4],%t0\";
;            }
;          default: abort();
;        }
;      }
;    case 2: /* r = > */
;      if (pic30_psrd_psrd_errata(operands[1],NULL)) {
;        pic30_rtx_nops++;
;        if (pic30_pre_modify(operands[1])) {
;          pic30_rtx_nops++;
;          return \"add %r1,#8,%r1\;nop\;mov.d %I1,%0\;nop\;mov.d %D1,%t0\";
;        } else {
;          return \"mov.d %1,%0\;nop\;mov.d %1,%t0\";
;        }
;      } else {
;        if (pic30_pre_modify(operands[1])) {
;          pic30_rtx_nops++;
;          return \"add %r1,#8,%r1\;nop\;mov.d %I1,%0\;nop\;mov.d %D1,%t0\";
;        } else {
;          return \"mov.d %1,%0\;nop\;mov.d %1,%t0\";
;        }
;      }
;    case 3: /* r = Q */
;      idDst = REGNO(operands[0]);
;      idSrc = REGNO(XEXP(XEXP(operands[1],0),0));
;      strcpy(temp, \"mov %1,%0\;\");
;      if (idDst != idSrc)
;        strcat(szInsn, temp);
;      else
;        strcat(save, temp);
;      idDst++;
;      strcpy(temp, \"mov %Q1,%d0\;\");
;      if (idDst != idSrc)
;        strcat(szInsn, temp);
;      else
;        strcat(save, temp);
;      idDst++;
;      strcpy(temp, \"mov %R1,%t0\;\");
;      if (idDst != idSrc)
;        strcat(szInsn, temp);
;      else
;        strcat(save, temp);
;      idDst++;
;      strcpy(temp, \"mov %S1,%q0\;\");
;      if (idDst != idSrc)
;        strcat(szInsn, temp);
;      else
;        strcat(save, temp);
;      idDst++;
;      if (save[0]) {
;        save[strlen(save)-2] = 0;
;        strcat(szInsn, save);
;      }
;      return szInsn;
;    case 4: /* R = r */
;      return \"mov.d %1,%I0\;mov.d %t1,%D0\";
;    case 5: /* > = r */
;      if (pic30_pre_modify(operands[0])) {
;        return \"add %r0,#8,%r0\;mov.d %1,%I0\;mov.d %t1,%D0\";
;      } else return \"mov.d %1,%0\;mov.d %t1,%0\";
;    case 6: /* > = > */
;      { int pre_op0, pre_op1;
;
;        pre_op0 = pic30_pre_modify(operands[0]);
;        pre_op1 = pic30_pre_modify(operands[1]);
;        if (pic30_psrd_psrd_errata(operands[1],NULL)) {
;          if (pre_op0 && pre_op1) {
;            pic30_rtx_nops++;
;            return \"add %r0,#(8+4),%r0\;\"
;                   \"add %r1,#(8+4),%r1\;\"
;                   \"mov.d %s1,%D0\;\"
;                   \"nop\;\"
;                   \"mov.d %p1,%0\";
;          } else if (pre_op0) {
;            return \"add %r0,#8,%r0\;\"
;                   \"mov.d %s1,%I0\;\"
;                   \"add #4,%r1\;\"
;                   \"mov.d %s1,%D0\;\"
;                   \"add #4,%r1\";
;          } else if (pre_op1) {
;            return \"add %r1,#8,%r1\;\"
;                   \"mov.d %I1,%s0\;\"
;                   \"add #4,%r0\;\"
;                   \"mov.d %D1,%s0\;\"
;                   \"add #4,%r0\";
;          } else {
;            // psv_psv repeat
;            if (0 && optimize_size) {
;              return \"repeat #(4-1)\;\"
;                     \"mov %1,%0\";
;            } else {
;              pic30_rtx_nops+=3;
;              return \"mov %1,%0\;\"
;                     \"nop\;\"
;                     \"mov %1,%0\;\"
;                     \"nop\;\"
;                     \"mov %1,%0\;\"
;                     \"nop\;\"
;                     \"mov %1,%0\";
;            }
;          }
;       } else {
;          if (pre_op0 && pre_op1) {
;            return \"add %r0,#(8+4),%r0\;\"
;                   \"add %r1,#(8+4),%r1\;\"
;                   \"mov.d %s1,%D0\;\"
;                   \"mov.d %p1,%0\";
;          } else if (pre_op0) {
;            return \"add %r0,#8,%r0\;\"
;                   \"mov.d %s1,%I0\;\"
;                   \"add #4,%r1\;\"
;                   \"mov.d %s1,%D0\;\"
;                   \"add #4,%r1\";
;          } else if (pre_op1) {
;            return \"add %r1,#8,%r1\;\"
;                   \"mov.d %I1,%s0\;\"
;                   \"add #4,%r0\;\"
;                   \"mov.d %D1,%s0\;\"
;                   \"add #4,%r0\";
;          } else {
;            if (optimize_size) {
;              return \"repeat #(4-1)\;\"
;                     \"mov %1,%0\";
;            } else {
;              return \"mov %1,%0\;\"
;                     \"mov %1,%0\;\"
;                     \"mov %1,%0\;\"
;                     \"mov %1,%0\";
;            }
;          }
;        }
;      }
;    case 7: /* Q = r */
;      return \"mov %1,%0\;mov %d1,%Q0\;mov %t1,%R0\;mov %q1,%S0\";
;    case 8: /* r = < */
;      if (pic30_psrd_psrd_errata(operands[1],NULL)) {
;        pic30_rtx_nops++;
;        return \"mov.d %1,%t0\;nop\;mov.d %1,%0\";
;      } else {
;        return \"mov.d %1,%t0\;mov.d %1,%0\";
;      }
;    case 9: /* < = r */
;      return \"mov.d %t1,%0\;mov.d %1,%0\";
;    case 10: /* T = r */
;      return \"mov %1,%0\;\"
;             \"mov %d1,%Q0\;\"
;             \"mov %t1,%R0\;\"
;             \"mov %q1,%S0\";
;    case 11: /* r = T */
;      if (pic30_psrd_psrd_errata(operands[1],NULL)) {
;        pic30_rtx_nops++;
;        return \"mov %1,%0\;\"
;               \"nop\;\"
;               \"mov %Q1,%d0\;\"
;               \"nop\;\"
;               \"mov %R1,%t0\;\"
;               \"nop\;\"
;               \"mov %S1,%q0\";
;      } else {
;        return \"mov %1,%0\;\"
;               \"mov %Q1,%d0\;\"
;               \"mov %R1,%t0\;\"
;               \"mov %S1,%q0\";
;      }
;    default: gcc_assert(0);
;  }
;  return "?mov? %1,%0";
;}
; [(set_attr "cc" "clobber")
;  (set_attr "type"
;            "def,defuse,defuse,defuse,use,use,use,use,defuse,use,etc,use")
; ]
;)
;
;(define_expand "movdf"
;  [(set (match_operand:DI 0 "pic30_general_operand" "")
;        (match_operand:DI 1 "pic30_general_operand" ""))]
;  ""
;  "
;{
;	if (pic30_emit_move_sequence(operands, DFmode)) DONE;
;}")

;; pointer conversions
;;

(define_mode_iterator TBLMODE [P24PSV P24PROG])

(define_insn "mov<mode>p32eds"
  [
   (set (match_operand:P32EDS  0 "pic30_register_operand" "=r,r")
        (unspec: P32EDS
          [
            (match_operand:TBLMODE 1 "pic30_register_operand" " 0,r") 
          ] UNSPECV_PSVCONVERT))
  ]
  ""
  "@
   btsts.c %0,#15\;rlc %d0,%d0
   mov %1,%0\;btsts.c %1,#15\;rlc %d1,%d0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "mov<mode>p32peds"
  [
   (set (match_operand:P32PEDS 0 "pic30_register_operand" "=r,r")
        (unspec: P32PEDS
          [
            (match_operand:TBLMODE 1 "pic30_register_operand" " 0,r") 
          ] UNSPECV_PSVCONVERT))
  ]
  ""
  "@
   btsts.c %0,#15\;rlc %d0,%d0
   mov %1,%0\;btsts.c %1,#15\;rlc %d1,%d0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; add instructions 
;;
;; During the instruction canonicalization phase,
;; (minus x (const_int n)) is converted to (plus x (const_int -n)).
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;
;; quarter integer
;;;;;;;;;;;;;;;;;;

(define_insn "*addqi3_incdec_DATA"
  [(set (match_operand:QI 0 "pic30_mode2_operand" "=r<>,R,r<>,R")
        (plus:QI 
           (match_operand:QI 1 "pic30_math_operand" "r,  r,R<>,R<>")
           (match_operand:QI 2 "immediate_operand" "i,  i,i,  i")))]
 "(-2<=INTVAL(operands[2]))&&(INTVAL(operands[2])!=0)&&(INTVAL(operands[2])<=2)"
  "*
{
	switch (INTVAL(operands[2]))
	{
	case -2:
		return \"dec2.b %1,%0\";
	case -1:
		return \"dec.b %1,%0\";
	case 1:
		return \"inc.b %1,%0\";
	case 2:
		return \"inc2.b %1,%0\";
	default:
		gcc_assert(0);
		return \"nop\";
	}
}"
  [
   (set_attr "cc" "math")
   (set_attr "type" "defuse,use,defuse,use")
  ]
)

;; There is a potential register class issue here, if we cannot claim WREG
;;   then this pattern will fail.  But allowing a general reg seems to have
;;;  a slight negative impact on one particular applicaton - leaving the
;;   option open for now.  CAW

(define_insn "*addqi3_incdecsfr"
  [(set (match_operand:QI 0 "pic30_wreg_or_near_operand"   "=U,a")
        (plus:QI (match_operand:QI 1 "pic30_near_operand" "%0,U")
                 (match_operand:QI 2 "immediate_operand"   "i,i")))]
 "(-2<=INTVAL(operands[2]))&&(INTVAL(operands[2])!=0)&&(INTVAL(operands[2])<=2)"
  "*
{
  switch (INTVAL(operands[2])) {
    case -2: switch (which_alternative) {
               case 0: return \"dec2.b %0\";
               case 1: return \"dec2.b %1,WREG\";
               /* r,U,i */
               case 2: return \"mov #%1,%0\;dec2.b [%0],%0\";
             }
    case -1: switch (which_alternative) {
               case 0: return \"dec.b %0\";
               case 1: return \"dec.b %1,WREG\";
               case 2: return \"mov #%1,%0\;dec.b [%0],%0\";
             }
    case 1: switch (which_alternative) {
               case 0: return \"inc.b %0\";
               case 1: return \"inc.b %1,WREG\";
               case 2: return \"mov #%1,%0\;inc.b [%0],%0\";
             }
    case 2: switch (which_alternative) {
               case 0: return \"inc2.b %0\";
               case 1: return \"inc2.b %1,WREG\";
               case 2: return \"mov #%1,%0\;inc2.b [%0],%0\";
             }
    default: gcc_assert(0);
             return \"nop\";
  }
}"
  [
   (set_attr "cc" "math")
   (set_attr "type" "etc,def")
  ]
)

(define_insn "addqi3_DATA"
  [(set (match_operand:QI 0 "pic30_mode2_operand"
              "=r<>,r<>,R,R, r<>,R,r<>,R,r<>,R,  r<>,R,r<>,R,r,r")
        (plus:QI 
           (match_operand:QI 1 "pic30_math_operand"
              "%r,  r,  r,r, r,  r,r,  r,R<>,R<>,N,  N,P,  P,0,J")
           (match_operand:QI 2 "pic30_mode1JN_operand"
              "r,  R<>,r,R<>,N,  N,P,  P,r,  r,  r,  r,r,  r,J,0")))]
  ""
  "@
   add.b %1,%2,%0
   add.b %1,%2,%0
   add.b %1,%2,%0
   add.b %1,%2,%0
   sub.b %1,#%J2,%0
   sub.b %1,#%J2,%0
   add.b %1,#%2,%0
   add.b %1,#%2,%0
   add.b %2,%1,%0
   add.b %2,%1,%0
   sub.b %2,#%J1,%0
   sub.b %2,#%J1,%0
   add.b %2,#%1,%0
   add.b %2,#%1,%0
   add.b #%2,%0
   add.b #%1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "defuse,defuse,use,use,defuse,use,defuse,use,defuse,use,defuse,use,defuse,use,def,def")
  ]
)

(define_insn "addqi3_APSV"
  [(set (match_operand:QI 0 "pic30_mode2_operand"
               "=r<>,r<>,R,R,  r<>,R,r<>,R,r<>,R,  r<>,R,r<>,R,r,r")
        (plus:QI 
           (match_operand:QI 1 "pic30_math_APSV_operand"
               "%r,  r,  r,r,  r,  r,r,  r,R<>,R<>,N,  N,P,  P,0,J")
           (match_operand:QI 2 "pic30_mode1JN_APSV_operand"
               "r,   R<>,r,R<>,N,  N,P,  P,r,  r,  r,  r,r,  r,J,0")))]
  ""
  "@
   add.b %1,%2,%0
   add.b %1,%2,%0
   add.b %1,%2,%0
   add.b %1,%2,%0
   sub.b %1,#%J2,%0
   sub.b %1,#%J2,%0
   add.b %1,#%2,%0
   add.b %1,#%2,%0
   add.b %2,%1,%0
   add.b %2,%1,%0
   sub.b %2,#%J1,%0
   sub.b %2,#%J1,%0
   add.b %2,#%1,%0
   add.b %2,#%1,%0
   add.b #%2,%0
   add.b #%1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,defuse,use,use,def,use,def,use,defuse,use,def,use,def,use,def,def")
  ]
)

(define_expand "addqi3"
  [(set (match_operand:QI 0 "pic30_mode2_operand"
               "=r<>,r<>,R,R,  r<>,R,r<>,R,r<>,R,  r<>,R,r<>,R,r,r")
        (plus:QI
           (match_operand:QI 1 "pic30_math_APSV_operand"
               "%r,  r,  r,r,  r,  r,r,  r,R<>,R<>,N,  N,P,  P,0,J")
           (match_operand:QI 2 "pic30_mode1JN_APSV_operand"
               "r,  R<>,r,R<>,N,  N,P,  P,r,  r,  r,  r,r,  r,J,0")))]
  ""
  "
{
  if (pic30_math_operand(operands[1],GET_MODE(operands[1])) &&
      pic30_mode1JN_operand(operands[2],GET_MODE(operands[2])))
    emit(gen_addqi3_DATA(operands[0],operands[1],operands[2]));
  else
    emit(gen_addqi3_APSV(operands[0],operands[1],operands[2]));
  DONE;
}")

; leave this match_dup, operand 0 will not require a reload (CAW)
(define_insn "*addqi3_sfr0"
  [(set (match_operand:QI 0 "pic30_near_operand"         "=U")
        (plus:QI (match_dup 0)
                 (match_operand:QI 1 "pic30_wreg_operand" "a")))]
  ""
  "add.b %0"
  [
    (set_attr "cc" "math")
    (set_attr "type" "etc")
  ]
)

(define_insn "*addqi3_sfr1"
  [(set (match_operand:QI 0 "pic30_near_operand"         "=U")
        (plus:QI (match_operand:QI 1 "pic30_wreg_operand" "a")
                 (match_dup 0)))]
  ""
  "add.b %0"
  [
    (set_attr "cc" "math")
    (set_attr "type" "etc")
  ]
)

(define_insn_and_split "*addqi3_sfr2"
  [(set (match_operand:QI 0 "pic30_register_operand"            "=a ,a, d")
        (plus:QI (match_operand:QI 1 "pic30_near_operand" "%U ,U, U")
                 (match_operand:QI 2 "pic30_register_operand"   " a ,d, d")))
   (clobber (match_scratch:HI 3                           "=X ,X,&r"))]
  ""
  "@
   add.b %1,WREG
   mov.b %2,w0\;add.b %1,WREG
   mov #%1,%3\;add.b %2,[%3],%0"
  "reload_completed"
  [
   (const_int 0)
  ]
"
{
  if (!pic30_wreg_operand(operands[0], QImode) &&
      !pic30_wreg_operand(operands[2], QImode))
  {
  	rtx pop = gen_rtx_MEM(QImode, operands[3]);
	emit_insn(gen_movhi_address(operands[3], XEXP(operands[1],0)));
	emit_insn(gen_addqi3(operands[0], operands[2], pop));
  	DONE;
  }
  else
  {
  	FAIL;
  }
}
"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
  ]
)

;;;;;;;;;;;;;;;
;; half integer
;;;;;;;;;;;;;;;
(define_predicate "new_pic30_inc_imm_operand"
  (and (match_operand 0 "immediate_operand")
       (match_test "(-2<=INTVAL(op)) && (INTVAL(op)!=0) && (INTVAL(op)<=2)")))
  
(define_mode_iterator A16BITADD [HI P16APSV P16PMP])

(define_insn "add<mode>3"
  [(set (match_operand:A16BITADD 0 "pic30_mode2_operand"
              "=r<>,R,  r<>,R,r<>,r<>,R,R,  r<>,R,r<>,R,R,r<>,R,  r<>,r<>,R,r<>,R,r,r,r,  !?r,!?r")
        (plus:A16BITADD 
           (match_operand:A16BITADD 1 "pic30_JMmath_operand"
              "%r<>,r<>,R,  R,r,  r,  r,r,  r,  r,r,  r,r,r,  R<>,R<>,N,  N,P,  P,0,J,NPJ,JM, r")
           (match_operand:A16BITADD 2 "pic30_JMmath_operand"
              "L,   L,  L,  L,r,  R<>,r,R<>,N,  N,P,  P,r,r,  r,  r,  r,  r,r,  r,J,0,NPJ,r,  JM"))
  )]
  ""
  "*
{
   switch (which_alternative) {
     case  0:
     case  1:
     case  2:
     case  3:
       switch (INTVAL(operands[2])) {
         case -2:  return \"dec2 %1,%0\";
         case -1:  return \"dec %1,%0\";
         case 1:  return \"inc %1,%0\";
         case 2:  return \"inc2 %1,%0\";
         default: error(\"unknown L value: addhi3\");
                  return \"bad adhhi3\";
       }
       break;
     case  4: return \"add %1,%2,%0\";
     case  5: return \"add %1,%2,%0\";
     case  6: return \"add %1,%2,%0\";
     case  7: return \"add %1,%2,%0\";
     case  8: return \"sub %1,#%J2,%0\";
     case  9: return \"sub %1,#%J2,%0\";
     case 10: return \"add %1,#%2,%0\";
     case 11: return \"add %1,#%2,%0\";
     case 12: return \"add %2,%1,%0\";
     case 13: return \"add %2,%1,%0\";
     case 14: return \"add %2,%1,%0\";
     case 15: return \"add %2,%1,%0\";
     case 16: return \"sub %2,#%J1,%0\";
     case 17: return \"sub %2,#%J1,%0\";
     case 18: return \"add %2,#%1,%0\";
     case 19: return \"add %2,#%1,%0\";
     case 20: return \"add #%2,%0\";
     case 21: return \"add #%1,%0\";
     case 22: return \"mov #(%1+%2),%0\";
     case 23: if (REGNO(operands[0]) != REGNO(operands[2]))
                return \"mov #%1,%0\;add %0,%2,%0\";
              else {
                if (INTVAL(operands[1]) < 0)
                  return \"sub #%J1,%0\";
                else 
                  return \"add #%1,%0\";
              }
     case 24: if (REGNO(operands[0]) != REGNO(operands[1])) 
                return \"mov #%2,%0\;add %0,%1,%0\";
              else {
                if (INTVAL(operands[2]) < 0)
                  return \"sub #%J2,%0\";
                else 
                  return \"add #%2,%0\";
              }
     default: gcc_assert(0);
              return \"bad addhi3\";
   }
}"
  [
   (set_attr "cc" "math")
   (set_attr "type" 
              "def,use,defuse,use,def,defuse,use,use,def,use,def,use,use,def,use,defuse,def,use,def,use,def,def,def,def,def")
  ]
)

; this match_can cause issues iff operand 1 is dies in this instruction and
;   we decide to use it to reload operand 0 (CAW)
(define_insn "*addhi3_sfr0"
  [(set (match_operand:HI 0 "pic30_reg_or_near_operand"   "+U,r")
        (plus:HI (match_dup 0)
                 (match_operand:HI 1 "pic30_wreg_operand" "a,a")))]
  ""
  "@
   add %0
   add %0,%1,%0"
  [
    (set_attr "cc" "math")
    (set_attr "type" "etc,def")
  ]
)

; this match_can cause issues iff operand 1 is dies in this instruction and
;   we decide to use it to reload operand 0 (CAW)
(define_insn "*addhi3_sfr1"
  [(set (match_operand:HI 0 "pic30_reg_or_near_operand"   "+U,r")
        (plus:HI (match_operand:HI 1 "pic30_wreg_operand" "a,a")
                 (match_dup 0)))]
  ""
  "@
   add %0
   add %0,%1,%0"
  [
    (set_attr "cc" "math")
    (set_attr "type" "etc,def")
  ]
)

(define_insn "*addhi3_sfr2"
  [(set (match_operand:HI 0 "pic30_wreg_operand"          "=a")
        (plus:HI (match_operand:HI 1 "pic30_near_operand" "%U")
                 (match_operand:HI 2 "pic30_wreg_operand" " a")))]
  ""
  "*
{
   switch (0) {
     case 0: return \"add %1,WREG\";
     case 1: return \"mov %2,w0\;add %1,WREG\";
     case 2: if (REGNO(operands[0]) != REGNO(operands[2])) 
               return \"mov #%1,%0\;add %2,[%0],%0\";
             else {
               gcc_assert(0);
             }
   }
}"
;  "reload_completed"
;  [
;   (set (match_dup 3) (match_dup 1))
;   (set (match_dup 0) (plus:HI (match_dup 2) (match_dup 3)))
;  ]
;
;{
;  if (!pic30_wreg_operand(operands[0], HImode) &&
;      !pic30_wreg_operand(operands[2], HImode))
;  {
;  }
;  else
;  {
;  	FAIL;
;  }
;}
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
  ]
)

(define_insn "*addhi3_incdecsfr"
  [(set (match_operand:HI 0 "pic30_wreg_or_near_operand"  "=U,a,d")
        (plus:HI (match_operand:HI 1 "pic30_near_operand" "%0,U,U")
                 (match_operand:HI 2 "immediate_operand"  " i,i,i")))]
 "(-2<=INTVAL(operands[2]))&&(INTVAL(operands[2])!=0)&&(INTVAL(operands[2])<=2)"
  "*
{
  switch (INTVAL(operands[2])) {
    case -2: switch (which_alternative) {
               case 0: return \"dec2 %0\";
               case 1: return \"dec2 %1,WREG\";
               case 2: return \"mov %1,%0\;dec2 %0,%0\";
               default: abort();
             }
    case -1: switch (which_alternative) {
               case 0: return \"dec %0\";
               case 1: return \"dec %1,WREG\";
               case 2: return \"mov %1,%0\;dec %0,%0\";
               default: abort();
             }
    case 1: switch (which_alternative) {
               case 0: return \"inc %0\";
               case 1: return \"inc %1,WREG\";
               case 2: return \"mov %1,%0\;inc %0,%0\";
               default: abort();
             }
    case 2: switch (which_alternative) {
               case 0: return \"inc2 %0\";
               case 1: return \"inc2 %1,WREG\";
               case 2: return \"mov %1,%0\;inc2 %0,%0\";
               default: abort();
             }
    default: gcc_assert(0);
  }
}"
  [
   (set_attr "cc" "math")
   (set_attr "type" "etc,def,def")
  ]
)

;;;;;;;;;;;;;;;;;
;; single integer
;;;;;;;;;;;;;;;;;

(define_insn "*addsihi3"
  [(set (match_operand:SI 0 "pic30_register_operand"         "=r")
        (plus:SI 
           (match_operand:SI 1 "pic30_register_operand" "r")
           (zero_extend:SI 
              (match_operand:HI 2 "pic30_register_operand" "r"))))]
  ""
  "add %1,%2,%0\;addc %d1,#0,%d0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
  ]
)

(define_insn "*addhisi3_ze"
  [(set (match_operand:SI 0 "pic30_mode2_operand"         "=r,>,>,R,R")
        (plus:SI 
           (zero_extend:SI 
              (match_operand:HI 1 "pic30_register_operand" "r,r,r,r,r"))
           (match_operand:SI 2 "pic30_mode2_operand"       "r,0,>,0,R")))
   (clobber (match_scratch:HI 3                           "=X,&r,&r,&r,&r"))
  ]
  ""
  "@
   add %1,%2,%0\;addc %d2,#0,%d0
   add %1,%s2,%0\;clr %3\;addc %3,%s2,%0
   add %1,%2,%0\;clr %3\;addc %3,%2,%0
   add %1,%2,%I0\;clr %3\;addc %3,%2,%D0
   add %1,%I2,%I0\;clr %3\;addc %3,%D2,%D0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
  ]
)

(define_insn "*addhisi3_se"
  [(set (match_operand:SI 0 "pic30_mode2_operand"         "=r,>,>,R,R")
        (plus:SI
           (sign_extend:SI
              (match_operand:HI 1 "pic30_register_operand" "r,r,r,r,r"))
           (match_operand:SI 2 "pic30_mode2_operand"       "r,0,>,0,R")))
   (clobber (match_scratch:HI 3                           "=&r,&r,&r,&r,&r"))
  ]
  ""
  "*
   static char *patterns[] = {
     \"asr %1,#15,%3\;add %1,%2,%0\;addc %3,%d2,%d0\",
     \"asr %1,#15,%3\;add %1,%s2,%0\;addc %3,%s2,%0\",
     \"asr %1,#15,%3\;add %1,%2,%0\;addc %3,%2,%0\",
     \"asr %1,#15,%3\;add %1,%2,%I0\;addc %3,%2,%D0\",
     \"asr %1,#15,%3\;add %1,%I2,%I0\;addc %3,%D2,%D0\"
   };

   static char *psv_psv_patterns[] = {
     \"asr %1,#15,%3\;add %1,%2,%0\;addc %3,%d2,%d0\",
     \"asr %1,#15,%3\;add %1,%s2,%0\;addc %3,%s2,%0\",
     \"asr %1,#15,%3\;add %1,%2,%0\;nop\;addc %3,%2,%0\",
     \"asr %1,#15,%3\;add %1,%2,%I0\;addc %3,%2,%D0\",
     \"asr %1,#15,%3\;add %1,%I2,%I0\;nop\;addc %3,%D2,%D0\"
   };

   if (pic30_psrd_psrd_errata(NULL,operands[2])) {
     pic30_rtx_nops++;
    return psv_psv_patterns[which_alternative];
  } else {
    return patterns[which_alternative];
  }
 "
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
  ]
)


(define_insn "*addsi3_imm"
  [(set (match_operand:SI 0 "pic30_register_operand"          "=r,r,r,r")
        (plus:SI (match_operand:SI 1 "pic30_register_operand" "%r,r,0,0")
                 (match_operand:SI 2 "pic30_JM_operand"       " P,N,J,M")))]
  ""
  "@
   add %1,#%2,%0\;addc %d1,#0,%d0
   sub %1,#%J2,%0\;subb %d1,#0,%d0
   add #%2,%0\;addc #0,%d0
   sub %0,#%J2\;subb %d0,#0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
  ]
)

(define_insn "*addsi3_immmsw"
  [(set (match_operand:SI          0 "pic30_register_operand" "=r,r")
        (plus:SI (match_operand:SI 1 "pic30_register_operand" "%0,r")
                 (match_operand:SI 2 "immediate_operand"      " i,i")))]
  "((INTVAL(operands[2]) & 0x0000FFFF) == 0) && 
   (-31 < (INTVAL(operands[2]) >> 16)) && ((INTVAL(operands[2]) >> 16) < 31)"
  "*
{
  int i = INTVAL(operands[2]) >> 16;
  static char szInsn[48];
  switch (which_alternative)
  {
    default: gcc_assert(0);
    case 0:
      if (i < 0) sprintf(szInsn, \"sub %%d1,#%d,%%d0\", -i);
      else sprintf(szInsn, \"add %%d1,#%d,%%d0\", i);
      break;
    case 1:
      if (i < 0) sprintf(szInsn, \"sub %%1,#0,%%0\;subb %%d1,#%d,%%d0\",-i);
      else sprintf(szInsn, \"add %%1,#0,%%0\;addc %%d1,#%d,%%d0\", i);
      break;
  }
  return szInsn;
}"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "addsi3_errata_APSV"
 [(set (match_operand:SI 0 "pic30_rR_or_near_operand"        "=r,r,r,&r,r,r,r,r,R,R,R")
       (plus:SI 
         (match_operand:SI 1 "pic30_rR_or_near_APSV_operand" "%r,0,r, R,r,r,0,0,r,r,r")
         (match_operand:SI 2 "pic30_rR_or_JMNP_APSV_operand"  "r,r,0, r,P,N,J,M,r,0,R")
  ))
  (clobber (match_scratch:HI 3                               "=X,X,X,&r,X,X,X,X,X,X,&r")
  )
 ]
  "(pic30_errata_mask & psv_errata)"
  "*
{
  static char *patterns[] = {
    \"add %2,%1,%0\;addc %d2,%d1,%d0\",
    \"add %2,%1,%0\;addc %d2,%d1,%d0\",
    \"add %2,%1,%0\;addc %d2,%d1,%d0\",
    \"add %2,%I1,%0\;mov %D1,%3\;addc %d2,%3,%d0\",
    \"add %1,#%2,%0\;addc %d1,#0,%d0\",
    \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
    \"add #%2,%0\;addc #%y2,%d0\",
    \"sub #%J2,%0\;subb #0,%d0\",
    \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
    \"add %1,%2,%0\;addc %d1,%P2,%D0\",
    \"add %1,%I2,%I0\;mov %D2,%3\;addc %d1,%3,%D0\",
    0};

  static char *psv_psv_patterns[] = {
    \"add %2,%1,%0\;addc %d2,%d1,%d0\",
    \"add %2,%1,%0\;addc %d2,%d1,%d0\",
    \"add %2,%1,%0\;addc %d2,%d1,%d0\",
    \"add %2,%I1,%0\;nop\;mov %D1,%3\;addc %d2,%3,%d0\",
    \"add %1,#%2,%0\;addc %d1,#0,%d0\",
    \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
    \"add #%2,%0\;addc #%y2,%d0\",
    \"sub #%J2,%0\;subb #0,%d0\",
    \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
    \"add %1,%2,%0\;addc %d1,%P2,%D0\",
    \"add %1,%I2,%I0\;nop\;mov %D2,%3\;addc %d1,%3,%D0\",
    0};

  if (pic30_psrd_psrd_errata(operands[1],operands[2])) {
    pic30_rtx_nops++;
    return psv_psv_patterns[which_alternative];
  } else {
    return patterns[which_alternative];
  }
}"
  [
    (set_attr "cc" "math,math,math,math,math,math,math,math,math,math,math")
    (set_attr "type" "def,def,def,defuse,def,def,def,def,use,use,use")
  ]
)

(define_insn "addsi3_DATA"
 [(set (match_operand:SI   0 "pic30_rR_or_near_operand" "=r,r,r,&r,r,r,r,r,R,R,R")
       (plus:SI  
         (match_operand:SI 1 "pic30_rR_or_near_operand" "%r,0,r, R,r,r,0,0,r,r,r")
         (match_operand:SI 2 "pic30_rR_or_JMNP_operand"  "r,r,0, r,P,N,J,M,r,0,R")  ))
 ]
  ""
  "*
{
  static char *patterns[] = {
    \"add %2,%1,%0\;addc %d2,%d1,%d0\",
    \"add %2,%1,%0\;addc %d2,%d1,%d0\",
    \"add %2,%1,%0\;addc %d2,%d1,%d0\",
    \"add %2,%I1,%0\;addc %d2,%D1,%d0\",
    \"add %1,#%2,%0\;addc %d1,#0,%d0\",
    \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
    \"add #%2,%0\;addc #%y2,%d0\",
    \"sub #%J2,%0\;subb #0,%d0\",
    \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
    \"add %1,%2,%0\;addc %d1,%P2,%D0\",
    \"add %1,%I2,%I0\;addc %d1,%D2,%D0\",
    0};

  static char *psv_psv_patterns[] = {
    \"add %2,%1,%0\;addc %d2,%d1,%d0\",
    \"add %2,%1,%0\;addc %d2,%d1,%d0\",
    \"add %2,%1,%0\;addc %d2,%d1,%d0\",
    \"add %2,%I1,%0\;nop\;addc %d2,%D1,%d0\",
    \"add %1,#%2,%0\;addc %d1,#0,%d0\",
    \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
    \"add #%2,%0\;addc #%y2,%d0\",
    \"sub #%J2,%0\;subb #0,%d0\",
    \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
    \"add %1,%2,%0\;addc %d1,%P2,%D0\",
    \"add %1,%I2,%I0\;nop\;addc %d1,%D2,%D0\",
    0};

  if (pic30_psrd_psrd_errata(operands[1],operands[2])) {
    pic30_rtx_nops++;
    return psv_psv_patterns[which_alternative];
  } else {
    return patterns[which_alternative];
  }
}"
  [
    (set_attr "cc" "math,math,math,math,math,math,math,math,math,math,math")
    (set_attr "type" "def,def,def,defuse,def,def,def,def,use,use,use")
  ]
)

(define_insn "addsi3_noerrata_APSV"
 [(set (match_operand:SI   0 "pic30_rR_or_near_operand"      "=r,r,r,&r,r,r,r,r,R,R,R")
       (plus:SI  
         (match_operand:SI 1 "pic30_rR_or_near_APSV_operand" "%r,0,r, R,r,r,0,0,r,r,r")
         (match_operand:SI 2 "pic30_rR_or_JMNP_APSV_operand"  "r,r,0, r,P,N,J,M,r,0,R")  ))
 ]
  "(!(pic30_errata_mask & psv_errata))"
  "*
{
  static char *patterns[] = {
    \"add %2,%1,%0\;addc %d2,%d1,%d0\",
    \"add %2,%1,%0\;addc %d2,%d1,%d0\",
    \"add %2,%1,%0\;addc %d2,%d1,%d0\",
    \"add %2,%I1,%0\;addc %d2,%D1,%d0\",
    \"add %1,#%2,%0\;addc %d1,#0,%d0\",
    \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
    \"add #%2,%0\;addc #%y2,%d0\",
    \"sub #%J2,%0\;subb #%0,%d0\",
    \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
    \"add %1,%2,%0\;addc %d1,%P2,%D0\",
    \"add %1,%I2,%I0\;addc %d1,%D2,%D0\",
    0};

  static char *psv_psv_patterns[] = {
    \"add %2,%1,%0\;addc %d2,%d1,%d0\",
    \"add %2,%1,%0\;addc %d2,%d1,%d0\",
    \"add %2,%1,%0\;addc %d2,%d1,%d0\",
    \"add %2,%I1,%0\;nop\;addc %d2,%D1,%d0\",
    \"add %1,#%2,%0\;addc %d1,#0,%d0\",
    \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
    \"add #%2,%0\;addc #%y2,%d0\",
    \"sub #%J2,%0\;subb #%0,%d0\",
    \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
    \"add %1,%2,%0\;addc %d1,%P2,%D0\",
    \"add %1,%I2,%I0\;nop\;addc %d1,%D2,%D0\",
    0};

  if (pic30_psrd_psrd_errata(operands[1],operands[2])) {
    pic30_rtx_nops++;
    return psv_psv_patterns[which_alternative];
  } else {
    return patterns[which_alternative];
  }
}"
  [
    (set_attr "cc" "math,math,math,math,math,math,math,math,math,math,math")
    (set_attr "type" "def,def,def,defuse,def,def,def,def,use,use,use")
  ]
)

(define_expand "addsi3"
  [(set (match_operand:SI 0 "pic30_rR_or_near_operand" "")
        (plus:SI
          (match_operand:SI 1 "pic30_rR_or_near_APSV_operand" "")
          (match_operand:SI 2 "pic30_rR_or_JMNP_APSV_operand" "")))]
  ""
  "
{ 
  if (pic30_rR_or_near_operand(operands[1],GET_MODE(operands[1])) &&
      pic30_rR_or_JMNP_operand(operands[2],GET_MODE(operands[2]))) {
    emit_insn(gen_addsi3_DATA(operands[0], operands[1], operands[2]));
  } else if (pic30_rR_or_near_APSV_operand(operands[1],GET_MODE(operands[1])) &&
             pic30_rR_or_JMNP_APSV_operand(operands[2],GET_MODE(operands[2]))) {
    if (pic30_errata_mask & psv_errata) {
      emit_insn(gen_addsi3_errata_APSV(operands[0], operands[1], operands[2]));
    } else {
      emit_insn(gen_addsi3_noerrata_APSV(operands[0],operands[1], operands[2]));
    }
  } else {
    rtx reg1 = operands[1];
    rtx reg2 = operands[2];

    if (!pic30_register_operand(reg1,GET_MODE(reg1)))
      reg1 = force_reg(GET_MODE(reg1), reg1);
    if (!pic30_mode2mres_operand(reg2,GET_MODE(reg2)))
      reg2 = force_reg(GET_MODE(reg2), reg2);
    emit(gen_addsi3x_DATA(operands[0], reg1, reg2));
  }
  DONE;
}")

(define_insn "addsi3x_DATA"
  [(set (match_operand:SI   0 "pic30_mode2mres_operand" "=r,&r,&r,R,R,R,>,>,>")
        (plus:SI 
          (match_operand:SI 1 "pic30_register_operand"  "%r, r, r,r,r,r,r,r,r")
          (match_operand:SI 2 "pic30_mode2mres_operand" " r, R, >,r,R,>,r,R,>"))
   )
  ]
  ""
  "*
   {
     static char *patterns[] = {
        \"add %1,%2,%0\;addc %d1,%d2,%d0\",
        \"add %1,%I2,%0\;addc %d1,%D2,%d0\",
        \"add %1,%2,%0\;addc %d1,%2,%d0\",
        \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
        \"add %1,%I2,%I0\;addc %d1,%D2,%D0\",
        \"add %1,%2,%I0\;addc %d1,%2,%D0\",
        \"add %1,%2,%0\;addc %d1,%d2,%0\",
        \"add %1,%I2,%0\;addc %d1,%D2,%0\",
        \"add %1,%2,%0\;addc %d1,%2,%0\",
        0};

     static char *psv_psv_patterns[] = {
        \"add %1,%2,%0\;addc %d1,%d2,%d0\",
        \"add %1,%I2,%0\;nop\;addc %d1,%D2,%d0\",
        \"add %1,%2,%0\;nop\;addc %d1,%2,%d0\",
        \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
        \"add %1,%I2,%I0\;nop\;addc %d1,%D2,%D0\",
        \"add %1,%2,%I0\;nop\;addc %d1,%2,%D0\",
        \"add %1,%2,%0\;addc %d1,%d2,%0\",
        \"add %1,%I2,%0\;nop\;addc %d1,%D2,%0\",
        \"add %1,%2,%0\;nop\;addc %d1,%2,%0\",
        0};

     static char *pre_patterns[] = {
        \"add %1,%2,%0\;addc %d1,%d2,%d0\",
        \"add %1,%I2,%0\;addc %d1,%D2,%d0\",
        \"add %r2,#4,%r2\;add %1,%I2,%0\;addc %d1,%D2,%d0\",
        \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
        \"add %1,%I2,%I0\;addc %d1,%D2,%D0\",
        \"add %r2,#4,%r2\;add %1,%I2,%I0\;addc %d1,%D2,%D0\",
        \"add %r0,#4,%r0\;add %1,%2,%I0\;addc %d1,%d2,%D0\",
        \"add %r0,#4,%r0\;add %1,%I2,%I0\;addc %d1,%D2,%D0\",
        \"add %1,%2,%0\;addc %d1,%2,%0\",  // alternative 8 not possible to use
        0};

     static char *psv_psv_pre_patterns[] = {
        \"add %1,%2,%0\;addc %d1,%d2,%d0\",
        \"add %1,%I2,%0\;nop\;addc %d1,%D2,%d0\",
        \"add %r2,#4,%r2\;add %1,%I2,%0\;nop\;addc %d1,%D2,%d0\",
        \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
        \"add %1,%I2,%I0\;nop\;addc %d1,%D2,%D0\",
        \"add %r2,#4,%r2\;add %1,%I2,%I0\;nop\;addc %d1,%D2,%D0\",
        \"add %r0,#4,%r0\;add %1,%2,%I0\;addc %d1,%d2,%D0\",
        \"add %r0,#4,%r0\;add %1,%I2,%I0\;nop\;addc %d1,%D2,%D0\",
        \"add %1,%2,%0\;addc %d1,%2,%0\",  // alternative 8 not possible to use
        0};

    if (pic30_psrd_psrd_errata(operands[1],operands[2])) {
      pic30_rtx_nops++;
      if (pic30_pre_modify(operands[0]) && pic30_pre_modify(operands[2])) {
        return \"add %r0,#4,%r0\;\"
               \"add %r2,#4,%r2\;\"
               \"add %1,%I2,%I0\;\"
               \"nop\;\"
               \"addc %d1,%D2,%D0\";
      } else if (which_alternative == 8) {
        if (pic30_pre_modify(operands[0])) {
          return \"add %r0,#4,%r0\;\"
                 \"add %1,%2,%I0\;\"
                 \"nop\;\"
                 \"addc %d1,%2,%D0\";
        } if (pic30_pre_modify(operands[2])) {
          return \"add %r2,#4,%r2\;\"
                 \"add %1,%I2,%0\;\"
                 \"nop\;\"
                 \"addc %d1,%D2,%0\";
        }
      } else if (pic30_pre_modify(operands[0]) || 
                 pic30_pre_modify(operands[2])) {
        return psv_psv_pre_patterns[which_alternative];
      } 
      return psv_psv_patterns[which_alternative];
    } else {
      if (pic30_pre_modify(operands[0]) && pic30_pre_modify(operands[2])) {
        return \"add %r0,#4,%r0\;\"
               \"add %r2,#4,%r2\;\"
               \"add %1,%I2,%I0\;\"
               \"addc %d1,%D2,%D0\";
      } else if (which_alternative == 8) {
        if (pic30_pre_modify(operands[0])) {
          return \"add %r0,#4,%r0\;\"
                 \"add %1,%2,%I0\;\"
                 \"addc %d1,%2,%D0\";
        } if (pic30_pre_modify(operands[2])) {
          return \"add %r2,#4,%r2\;\"
                 \"add %1,%I2,%0\;\"
                 \"addc %d1,%D2,%0\";
        }
      } else if (pic30_pre_modify(operands[0]) || 
		 pic30_pre_modify(operands[2])) {
        return pre_patterns[which_alternative];
      } 
      return patterns[which_alternative];
    }
  }"
  [
    (set_attr "cc" "math")
    (set_attr "type" "def,defuse,defuse,use,use,use,use,use,use")
  ]
)

(define_insn "addsi3x_noerrata_APSV"
  [(set (match_operand:SI   0 "pic30_mode2mres_operand"     "=r,&r,&r,R,R,R,>,>,>")
        (plus:SI 
          (match_operand:SI 1 "pic30_register_operand"      "%r, r, r,r,r,r,r,r,r")
          (match_operand:SI 2 "pic30_mode2mres_APSV_operand" "r, R, >,r,R,>,r,R,>")))
  ]
  "(!(pic30_errata_mask & psv_errata))"
  "*
   {
     static char *patterns[] = {
        \"add %1,%2,%0\;addc %d1,%d2,%d0\",
        \"add %1,%I2,%0\;addc %d1,%D2,%d0\",
        \"add %1,%2,%0\;addc %d1,%2,%d0\",
        \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
        \"add %1,%I2,%I0\;addc %d1,%D2,%D0\",
        \"add %1,%2,%I0\;addc %d1,%2,%D0\",
        \"add %1,%2,%0\;addc %d1,%d2,%0\",
        \"add %1,%I2,%0\;addc %d1,%D2,%0\",
        \"add %1,%2,%0\;addc %d1,%2,%0\",
        0};

     static char *psv_psv_patterns[] = {
        \"add %1,%2,%0\;addc %d1,%d2,%d0\",
        \"add %1,%I2,%0\;nop\;addc %d1,%D2,%d0\",
        \"add %1,%2,%0\;nop\;addc %d1,%2,%d0\",
        \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
        \"add %1,%I2,%I0\;nop\;addc %d1,%D2,%D0\",
        \"add %1,%2,%I0\;nop\;addc %d1,%2,%D0\",
        \"add %1,%2,%0\;addc %d1,%d2,%0\",
        \"add %1,%I2,%0\;nop\;addc %d1,%D2,%0\",
        \"add %1,%2,%0\;nop\;addc %d1,%2,%0\",
        0};

     static char *pre_patterns[] = {
        \"add %1,%2,%0\;addc %d1,%d2,%d0\",
        \"add %1,%I2,%0\;addc %d1,%D2,%d0\",
        \"add %r2,#4,%r2\;add %1,%I2,%0\;addc %d1,%D2,%d0\",
        \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
        \"add %1,%I2,%I0\;addc %d1,%D2,%D0\",
        \"add %r2,#4,%r2\;add %1,%I2,%I0\;addc %d1,%D2,%D0\",
        \"add %r0,#4,%r0\;add %1,%2,%I0\;addc %d1,%d2,%D0\",
        \"add %r0,#4,%r0\;add %1,%I2,%I0\;addc %d1,%D2,%D0\",
        \"add %1,%2,%0\;addc %d1,%2,%0\",  // alternative 8 not possible to use
        0};

     static char *psv_psv_pre_patterns[] = {
        \"add %1,%2,%0\;addc %d1,%d2,%d0\",
        \"add %1,%I2,%0\;nop\;addc %d1,%D2,%d0\",
        \"add %r2,#4,%r2\;add %1,%I2,%0\;nop\;addc %d1,%D2,%d0\",
        \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
        \"add %1,%I2,%I0\;nop\;addc %d1,%D2,%D0\",
        \"add %r2,#4,%r2\;add %1,%I2,%I0\;nop\;addc %d1,%D2,%D0\",
        \"add %r0,#4,%r0\;add %1,%2,%I0\;addc %d1,%d2,%D0\",
        \"add %r0,#4,%r0\;add %1,%I2,%I0\;nop\;addc %d1,%D2,%D0\",
        \"add %1,%2,%0\;addc %d1,%2,%0\",  // alternative 8 not possible to use
        0};

    if (pic30_psrd_psrd_errata(operands[1],operands[2])) {
      pic30_rtx_nops++;
      if (pic30_pre_modify(operands[0]) && pic30_pre_modify(operands[2])) {
        return \"add %r0,#4,%r0\;\"
               \"add %r2,#4,%r2\;\"
               \"add %1,%I2,%I0\;\"
               \"nop\;\"
               \"addc %d1,%D2,%D0\";
      } else if (which_alternative == 8) {
        if (pic30_pre_modify(operands[0])) {
          return \"add %r0,#4,%r0\;\"
                 \"add %1,%2,%I0\;\"
                 \"nop\;\"
                 \"addc %d1,%2,%D0\";
        } if (pic30_pre_modify(operands[2])) {
          return \"add %r2,#4,%r2\;\"
                 \"add %1,%I2,%0\;\"
                 \"nop\;\"
                 \"addc %d1,%D2,%0\";
        }
      } else if (pic30_pre_modify(operands[0]) || 
                 pic30_pre_modify(operands[2])) {
        return psv_psv_pre_patterns[which_alternative];
      } 
      return psv_psv_patterns[which_alternative];
    } else {
      if (pic30_pre_modify(operands[0]) && pic30_pre_modify(operands[2])) {
        return \"add %r0,#4,%r0\;\"
               \"add %r2,#4,%r2\;\"
               \"add %1,%I2,%I0\;\"
               \"addc %d1,%D2,%D0\";
      } else if (which_alternative == 8) {
        if (pic30_pre_modify(operands[0])) {
          return \"add %r0,#4,%r0\;\"
                 \"add %1,%2,%I0\;\"
                 \"addc %d1,%2,%D0\";
        } if (pic30_pre_modify(operands[2])) {
          return \"add %r2,#4,%r2\;\"
                 \"add %1,%I2,%0\;\"
                 \"addc %d1,%D2,%0\";
        }
      } else if (pic30_pre_modify(operands[0]) || 
		 pic30_pre_modify(operands[2])) {
        return pre_patterns[which_alternative];
      } 
      return patterns[which_alternative];
    }
  }"
  [
    (set_attr "cc" "math")
    (set_attr "type" "def,defuse,defuse,use,use,use,use,use,use")
  ]
)

(define_insn "addsi3x_errata_APSV"
  [(set 
    (match_operand:SI   0 "pic30_mode2mres_operand"      "=r,&r,&r,R,R,R,>,>,>")
    (plus:SI 
      (match_operand:SI 1 "pic30_register_operand"       "%r, r, r,r,r,r,r,r,r")
      (match_operand:SI 2 "pic30_mode2mres_APSV_operand" " r, R, >,r,R,>,r,R,>")
    )
   )
   (clobber (match_scratch:HI 3                     "=X,&r,&r,X,&r,&r,X,&r,&r"))
  ]
  "(pic30_errata_mask & psv_errata)"
  "*
   {
     static char *patterns[] = {
        \"add %1,%2,%0\;addc %d1,%d2,%d0\",
        \"add %1,%I2,%0\;mov %D2,%3\;addc %d1,%3,%d0\",
        \"add %1,%2,%0\;mov %2,%3\;addc %d1,%3,%d0\",
        \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
        \"add %1,%I2,%I0\;mov %D2,%3\;addc %d1,%3,%D0\",
        \"add %1,%2,%I0\;mov %2,%3\;addc %d1,%3,%D0\",
        \"add %1,%2,%0\;addc %d1,%d2,%0\",
        \"add %1,%I2,%0\;mov %D2,%3\;addc %d1,%3,%0\",
        \"add %1,%2,%0\;mov %2,%3\;addc %d1,%3,%0\",
        0};

     static char *psv_psv_patterns[] = {
        \"add %1,%2,%0\;addc %d1,%d2,%d0\",
        \"add %1,%I2,%0\;nop\;mov %D2,%3\;addc %d1,%3,%d0\",
        \"add %1,%2,%0\;nop\;mov %2,%3\;addc %d1,%3,%d0\",
        \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
        \"add %1,%I2,%I0\;nop\;mov %D2,%3\;addc %d1,%3,%D0\",
        \"add %1,%2,%I0\;nop\;mov %2,%3\;addc %d1,%3,%D0\",
        \"add %1,%2,%0\;addc %d1,%d2,%0\",
        \"add %1,%I2,%0\;nop\;mov %D2,%3\;addc %d1,%3,%0\",
        \"add %1,%2,%0\;nop\;mov %2,%3\;addc %d1,%3,%0\",
        0};

     static char *pre_patterns[] = {
        \"add %1,%2,%0\;addc %d1,%d2,%d0\",
        \"add %1,%I2,%0\;mov %D2,%3\;addc %d1,%3,%d0\",
        \"add %r2,#4,%r2\;add %1,%I2,%0\;mov %D2,%3\;addc %d1,%3,%d0\",
        \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
        \"add %1,%I2,%I0\;mov %D2,%3\;addc %d1,%3,%D0\",
        \"add %r2,#4,%r2\;add %1,%I2,%I0\;mov %D2,%3\;addc %d1,%3,%D0\",
        \"add %r0,#4,%r0\;add %1,%2,%I0\;addc %d1,%d2,%D0\",
        \"add %r0,#4,%r0\;add %1,%I2,%I0\;mov %D2,%3\;addc %d1,%3,%D0\",
        \"add %1,%2,%0\;mov %2,%3\;addc %d1,%3,%0\", // alternative 8 not possible to use
        0};

     static char *psv_psv_pre_patterns[] = {
        \"add %1,%2,%0\;addc %d1,%d2,%d0\",
        \"add %1,%I2,%0\;nop\;mov %D2,%3\;addc %d1,%3,%d0\",
        \"add %r2,#4,%r2\;add %1,%I2,%0\;nop\;mov %D2,%3\;addc %d1,%3,%d0\",
        \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
        \"add %1,%I2,%I0\;nop\;mov %D2,%3\;addc %d1,%3,%D0\",
        \"add %r2,#4,%r2\;add %1,%I2,%I0\;nop\;mov %D2,%3\;addc %d1,%3,%D0\",
        \"add %r0,#4,%r0\;add %1,%2,%I0\;addc %d1,%d2,%D0\",
        \"add %r0,#4,%r0\;add %1,%I2,%I0\;nop\;mov %D2,%3\;addc %d1,%3,%D0\",
        \"add %1,%2,%0\;mov %2,%3\;addc %d1,%3,%0\", // alternative 8 not possible to use
        0};

     if (pic30_psrd_psrd_errata(operands[1],operands[2])) {
       pic30_rtx_nops++;
       if (pic30_pre_modify(operands[0]) && pic30_pre_modify(operands[2])) {
         return \"add %r0,#4,%r0\;\"
                \"add %r2,#4,%r2\;\"
                \"add %1,%I2,%I0\;\"
                \"nop\;\"
                \"mov %D2,%3\;\"
                \"addc %d1,%3,%D0\";
       } else if (which_alternative == 8) {
         if (pic30_pre_modify(operands[0])) {
           return \"add %r0,#4,%r0\;\"
                  \"add %1,%2,%I0\;\"
                  \"mov %2,%3\;\"
                  \"addc %d1,%3,%D0\";
         } else if (pic30_pre_modify(operands[2])) {
           return \"add %r2,#4,%r2\;\"
                  \"add %1,%I2,%0\;\"
                  \"mov %D2,%3\;\"
                  \"addc %d1,%3,%0\";
         }
       } else if (pic30_pre_modify(operands[0]) || 
                  pic30_pre_modify(operands[2])) {
         return pre_patterns[which_alternative];
       } 
       return psv_psv_patterns[which_alternative];
     } else {
       if (pic30_pre_modify(operands[0]) && pic30_pre_modify(operands[2])) {
         return \"add %r0,#4,%r0\;\"
                \"add %r2,#4,%r2\;\"
                \"add %1,%I2,%I0\;\"
                \"mov %D2,%3\;\"
                \"addc %d1,%3,%D0\";
       } else if (which_alternative == 8) {
         if (pic30_pre_modify(operands[0])) {
           return \"add %r0,#4,%r0\;\"
                  \"add %1,%2,%I0\;\"
                  \"mov %2,%3\;\"
                  \"addc %d1,%3,%D0\";
         } else if (pic30_pre_modify(operands[2])) {
           return \"add %r2,#4,%r2\;\"
                  \"add %1,%I2,%0\;\"
                  \"mov %D2,%3\;\"
                  \"addc %d1,%3,%0\";
         }
       } else if (pic30_pre_modify(operands[0]) || 
                  pic30_pre_modify(operands[2])) {
         return pre_patterns[which_alternative];
       } 
       return patterns[which_alternative];
     }
   }"
  [
    (set_attr "cc" "math")
    (set_attr "type" "def,defuse,defuse,use,use,use,use,use,use")
  ]
)

;;;;;;;;;;;;;;;;;
;; P32DF integer
;;;;;;;;;;;;;;;;;

(define_insn "*addp32dfhi3"
  [(set (match_operand:P32DF    0 "pic30_register_operand" "=r")
        (plus:P32DF 
           (match_operand:P32DF 1 "pic30_register_operand"  "r")
           (zero_extend:P32DF 
              (match_operand:HI 2 "pic30_register_operand"  "r"))))]
  ""
  "add %1,%2,%0\;addc %d1,#0,%d0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
  ]
)

(define_insn "*addhip32df3"
  [(set (match_operand:P32DF    0 "pic30_register_operand" "=r")
        (plus:P32DF 
           (zero_extend:P32DF 
              (match_operand:HI 1 "pic30_register_operand"  "r"))
           (match_operand:P32DF 2 "pic30_register_operand"  "r")))]
  ""
  "add %2,%1,%0\;addc %d2,#0,%d0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
  ]
)

(define_insn "*addp32df3_imm"
  [(set (match_operand:P32DF 0 "pic30_register_operand"          "=r,r,r,r")
        (plus:P32DF (match_operand:SI 1 "pic30_register_operand" "%r,r,0,0")
                 (match_operand:P32DF 2 "pic30_JM_operand"       " P,N,J,M")))]
  ""
  "@
   add %1,#%2,%0\;addc %d1,#0,%d0
   sub %1,#%J2,%0\;subb %d1,#0,%d0
   add #%2,%0\;addc #0,%d0
   sub %0,#%J2\;subb %d0,#0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
  ]
)

(define_insn "*addp32df3_immmsw"
  [(set (match_operand:P32DF          0 "pic30_register_operand" "=r,r")
        (plus:P32DF (match_operand:SI 1 "pic30_register_operand" "%0,r")
                 (match_operand:P32DF 2 "immediate_operand"      " i,i")))]
  "((INTVAL(operands[2]) & 0x0000FFFF) == 0) && 
   (-31 < (INTVAL(operands[2]) >> 16)) && ((INTVAL(operands[2]) >> 16) < 31)"
  "*
   {
     int i = INTVAL(operands[2]) >> 16;
     static char szInsn[48];
     switch (which_alternative)
     {
       default: gcc_assert(0);
       case 0:
         if (i < 0) sprintf(szInsn, \"sub %%d1,#%d,%%d0\", -i);
         else sprintf(szInsn, \"add %%d1,#%d,%%d0\", i);
         break;
       case 1:
         if (i < 0) sprintf(szInsn, \"sub %%1,#0,%%0\;subb %%d1,#%d,%%d0\",-i);
         else sprintf(szInsn, \"add %%1,#0,%%0\;addc %%d1,#%d,%%d0\", i);
         break;
     }
     return szInsn;
   }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "addp32df3_errata_APSV"
 [(set (match_operand:P32DF 0 "pic30_rR_or_near_operand"        "=r,r,r,&r,r,r,r,R,R,R")
       (plus:P32DF 
         (match_operand:P32DF 1 "pic30_rR_or_near_APSV_operand" "%r,0,r, R,r,r,0,r,r,r")
         (match_operand:P32DF 2 "pic30_rR_or_JN_APSV_operand"    "r,r,0, r,P,N,J,r,0,R")
  ))
  (clobber (match_scratch:HI 3                         "=X,X,X,&r,X,X,X,X,X,&r")
  )
 ]
  "(pic30_errata_mask & psv_errata)"
  "*
   {
     static char *patterns[] = {
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%I1,%0\;mov %D1,%3\;addc %d2,%3,%d0\",
       \"add %1,#%2,%0\;addc %d1,#0,%d0\",
       \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
       \"add #%2,%0\;addc #%y2,%d0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%2,%0\;addc %d1,%P2,%D0\",
       \"add %1,%I2,%I0\;mov %D2,%3\;addc %d1,%3,%D0\"
     };

     static char *psv_psv_patterns[] = {
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%I1,%0\;nop\;mov %D1,%3\;addc %d2,%3,%d0\",
       \"add %1,#%2,%0\;addc %d1,#0,%d0\",
       \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
       \"add #%2,%0\;addc #%y2,%d0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%2,%0\;addc %d1,%P2,%D0\",
       \"add %1,%I2,%I0\;nop\;mov %D2,%3\;addc %d1,%3,%D0\"
     };

     if (pic30_psrd_psrd_errata(operands[1],operands[2])) {
       pic30_rtx_nops++;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     }
  }"
  [
    (set_attr "cc" "math,math,math,math,math,math,math,math,math,math")
    (set_attr "type" "def,def,def,defuse,def,def,def,use,use,use")
  ]
)

(define_insn "addp32df3_DATA"
 [(set (match_operand:P32DF   0 "pic30_rR_or_near_operand" "=r,r,r,&r,r,r,r,R,R,R")
       (plus:P32DF  
         (match_operand:P32DF 1 "pic30_rR_or_near_operand" "%r,0,r, R,r,r,0,r,r,r")
         (match_operand:P32DF 2 "pic30_rR_or_JN_operand"    "r,r,0, r,P,N,J,r,0,R")  ))
 ]
  ""
  "*
   {
     static char *patterns[] = {
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%I1,%0\;addc %d2,%D1,%d0\",
       \"add %1,#%2,%0\;addc %d1,#0,%d0\",
       \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
       \"add #%2,%0\;addc #%y2,%d0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%2,%0\;addc %d1,%P2,%D0\",
       \"add %1,%I2,%I0\;addc %d1,%D2,%D0\"
     };

     static char *psv_psv_patterns[] = {
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%I1,%0\;nop\;addc %d2,%D1,%d0\",
       \"add %1,#%2,%0\;addc %d1,#0,%d0\",
       \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
       \"add #%2,%0\;addc #%y2,%d0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%2,%0\;addc %d1,%P2,%D0\",
       \"add %1,%I2,%I0\;nop\;addc %d1,%D2,%D0\"
     };

     if (pic30_psrd_psrd_errata(operands[1],operands[2])) {
       pic30_rtx_nops++;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     }
   }"
  [
    (set_attr "cc" "math,math,math,math,math,math,math,math,math,math")
    (set_attr "type" "def,def,def,defuse,def,def,def,use,use,use")
  ]
)

(define_insn "addp32df3_noerrata_APSV"
 [(set (match_operand:P32DF   0 "pic30_rR_or_near_operand"      "=r,r,r,&r,r,r,r,R,R,R")
       (plus:P32DF  
         (match_operand:P32DF 1 "pic30_rR_or_near_APSV_operand" "%r,0,r, R,r,r,0,r,r,r")
         (match_operand:P32DF 2 "pic30_rR_or_JN_APSV_operand"    "r,r,0, r,P,N,J,r,0,R")  ))
 ]
  "(!(pic30_errata_mask & psv_errata))"
  "*
   {
     static char *patterns[] = {
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%I1,%0\;addc %d2,%D1,%d0\",
       \"add %1,#%2,%0\;addc %d1,#0,%d0\",
       \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
       \"add #%2,%0\;addc #%y2,%d0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%2,%0\;addc %d1,%P2,%D0\",
       \"add %1,%I2,%I0\;addc %d1,%D2,%D0\"
     };

     static char *psv_psv_patterns[] = {
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%I1,%0\;nop\;addc %d2,%D1,%d0\",
       \"add %1,#%2,%0\;addc %d1,#0,%d0\",
       \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
       \"add #%2,%0\;addc #%y2,%d0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%2,%0\;addc %d1,%P2,%D0\",
       \"add %1,%I2,%I0\;nop\;addc %d1,%D2,%D0\"
     };

     if (pic30_psrd_psrd_errata(operands[1],operands[2])) {
       pic30_rtx_nops++;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     }
   }"
  [
    (set_attr "cc" "math,math,math,math,math,math,math,math,math,math")
    (set_attr "type" "def,def,def,defuse,def,def,def,use,use,use")
  ]
)

(define_expand "addp32df3"
  [(set (match_operand:P32DF 0 "pic30_rR_or_near_operand" "")
        (plus:P32DF
          (match_operand:P32DF 1 "pic30_rR_or_near_APSV_operand" "")
          (match_operand:P32DF 2 "pic30_rR_or_JN_APSV_operand" "")))]
  ""
  "
{ 
  if (pic30_rR_or_near_operand(operands[1],GET_MODE(operands[1])) &&
      pic30_rR_or_JN_APSV_operand(operands[2],GET_MODE(operands[2]))) {
    emit_insn(gen_addp32df3_DATA(operands[0], operands[1], operands[2]));
  } else if (pic30_errata_mask & psv_errata) {
    emit_insn(gen_addp32df3_errata_APSV(operands[0], operands[1], operands[2]));
  } else {
    emit_insn(gen_addp32df3_noerrata_APSV(operands[0], operands[1], operands[2]));
  }
  DONE;
}")

(define_insn "addp32df3x_DATA"
  [(set (match_operand:P32DF   0 "pic30_mode2mres_operand" "=r,&r,&r,R,R,R,>,>,>")
        (plus:P32DF 
          (match_operand:P32DF 1 "pic30_register_operand"  "%r, r, r,r,r,r,r,r,r")
          (match_operand:P32DF 2 "pic30_mode2mres_operand" " r, R, >,r,R,>,r,R,>")))
  ]
  ""
  "*
   {
     static char *patterns[] = {
       \"add %1,%2,%0\;addc %d1,%d2,%d0\",
       \"add %1,%I2,%0\;addc %d1,%D2,%d0\",
       \"add %1,%2,%0\;addc %d1,%d2,%d0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%I2,%I0\;addc %d1,%D2,%D0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%2,%0\;addc %d1,%d2,%d0\",
       \"add %1,%I2,%0\;addc %d1,%D2,%d0\",
       \"add %1,%2,%0\;addc %d1,%d2,%d0\"
     };

     static char *psv_psv_patterns[] = {
       \"add %1,%2,%0\;addc %d1,%d2,%d0\",
       \"add %1,%I2,%0\;nop\;addc %d1,%D2,%d0\",
       \"add %1,%2,%0\;nop\;addc %d1,%d2,%d0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%I2,%I0\;nop\;addc %d1,%D2,%D0\",
       \"add %1,%2,%I0\;nop\;addc %d1,%d2,%D0\",
       \"add %1,%2,%0\;addc %d1,%d2,%d0\",
       \"add %1,%I2,%0\;nop\;addc %d1,%D2,%d0\",
       \"add %1,%2,%0\;nop\;addc %d1,%d2,%d0\"
     };

     if (pic30_psrd_psrd_errata(operands[1],operands[2])) {
       pic30_rtx_nops++;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     }
   }"
  [
    (set_attr "cc" "math")
    (set_attr "type" "def,defuse,defuse,use,use,use,use,use,use")
  ]
)

(define_insn "addp32df3x_noerrata_APSV"
  [(set (match_operand:P32DF   0 "pic30_mode2mres_operand"     "=r,&r,&r,R,R,R,>,>,>")
        (plus:P32DF 
          (match_operand:P32DF 1 "pic30_register_operand"      "%r, r, r,r,r,r,r,r,r")
          (match_operand:P32DF 2 "pic30_mode2mres_APSV_operand" "r, R, >,r,R,>,r,R,>")))
  ]
  "(!(pic30_errata_mask & psv_errata))"
  "*
   {
     static char *patterns[] = {
       \"add %1,%2,%0\;addc %d1,%d2,%d0\",
       \"add %1,%I2,%0\;addc %d1,%D2,%d0\",
       \"add %1,%2,%0\;addc %d1,%d2,%d0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%I2,%I0\;addc %d1,%D2,%D0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%2,%0\;addc %d1,%d2,%d0\",
       \"add %1,%I2,%0\;addc %d1,%D2,%d0\",
       \"add %1,%2,%0\;addc %d1,%d2,%d0\"
     };

     static char *psv_psv_patterns[] = {
       \"add %1,%2,%0\;addc %d1,%d2,%d0\",
       \"add %1,%I2,%0\;nop\;addc %d1,%D2,%d0\",
       \"add %1,%2,%0\;nop\;addc %d1,%d2,%d0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%I2,%I0\;nop\;addc %d1,%D2,%D0\",
       \"add %1,%2,%I0\;nop\;addc %d1,%d2,%D0\",
       \"add %1,%2,%0\;addc %d1,%d2,%d0\",
       \"add %1,%I2,%0\;nop\;addc %d1,%D2,%d0\",
       \"add %1,%2,%0\;nop\;addc %d1,%d2,%d0\"
     };

     if (pic30_psrd_psrd_errata(operands[1],operands[2])) {
       pic30_rtx_nops++;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     }
   }"
  [
    (set_attr "cc" "math")
    (set_attr "type" "def,defuse,defuse,use,use,use,use,use,use")
  ]
)

(define_insn "addp32df3x_errata_APSV"
  [(set (match_operand:P32DF   0 "pic30_mode2mres_operand"      "=r,&r,&r,R,R,R,>,>,>")
        (plus:P32DF 
          (match_operand:P32DF 1 "pic30_register_operand"       "%r, r, r,r,r,r,r,r,r")
          (match_operand:P32DF 2 "pic30_mode2mres_APSV_operand" " r, R, >,r,R,>,r,R,>")
   ))
   (clobber (match_scratch:HI 3                                 "=X,&r,&r,X,&r,&r,X,&r,&r"))
  ]
  "(pic30_errata_mask & psv_errata)"
  "*
   {
     static char *patterns[] = {
       \"add %1,%2,%0\;addc %d1,%d2,%d0\",
       \"add %1,%I2,%0\;mov %D2,%3\;addc %d1,%3,%d0\",
       \"add %1,%2,%0\;mov %d2,%3\;addc %d1,%3,%d0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%I2,%I0\;mov %D2,%3\;addc %d1,%3,%D0\",
       \"add %1,%2,%I0\;mov %d2,%3\;addc %d1,%3,%D0\",
       \"add %1,%2,%0\;addc %d1,%d2,%d0\",
       \"add %1,%I2,%0\;mov %D2,%3\;addc %d1,%3,%d0\",
       \"add %1,%2,%0\;mov %d2,%3\;addc %d1,%3,%d0\"
     };

     static char *psv_psv_patterns[] = {
       \"add %1,%2,%0\;addc %d1,%d2,%d0\",
       \"add %1,%I2,%0\;nop\;mov %D2,%3\;addc %d1,%3,%d0\",
       \"add %1,%2,%0\;nop\;mov %d2,%3\;addc %d1,%3,%d0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%I2,%I0\;nop\;mov %D2,%3\;addc %d1,%3,%D0\",
       \"add %1,%2,%I0\;nop\;mov %d2,%3\;addc %d1,%3,%D0\",
       \"add %1,%2,%0\;addc %d1,%d2,%d0\",
       \"add %1,%I2,%0\;nop\;mov %D2,%3\;addc %d1,%3,%d0\",
       \"add %1,%2,%0\;nop\;mov %d2,%3\;addc %d1,%3,%d0\"
     };

     if (pic30_psrd_psrd_errata(operands[1],operands[2])) {
       pic30_rtx_nops++;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     }
   }"
  [
    (set_attr "cc" "math")
    (set_attr "type" "def,defuse,defuse,use,use,use,use,use,use")
  ]
)

;; P32EXT

(define_insn "addp32ext3_imm"
  [(set (match_operand:P32EXT 0 "pic30_register_operand"          "=r,r,r,r")
        (plus:P32EXT 
                 (match_operand:P32EXT 1 "pic30_register_operand" "%r,r,0,0")
                 (match_operand:P32EXT 2 "pic30_JM_operand"       " P,N,J,M")))]
  ""
  "@
   add %1,#%2,%0\;addc %d1,#0,%d0
   sub %1,#%J2,%0\;subb %d1,#0,%d0
   add #%2,%0\;addc #0,%d0
   sub %0,#%J2\;subb %d0,#0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
  ]
)

(define_insn "addp32ext3_errata_APSV"
 [(set (match_operand:P32EXT   0 "pic30_rR_or_near_operand"  "=r,r,r,&r,r,r,r,R,R,R")
   (plus:P32EXT
     (match_operand:P32EXT 1 "pic30_rR_or_near_APSV_operand" "%r,0,r, R,r,r,0,r,r,r")
     (match_operand:P32EXT 2 "pic30_rR_or_JN_APSV_operand"    "r,r,0, r,P,N,J,r,0,R")
  ))
  (clobber (match_scratch:HI 3                         "=X,X,X,&r,X,X,X,X,X,&r")
  )
 ]
  "(pic30_errata_mask & psv_errata)"
  "*
   {
     static char *patterns[] = {
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%I1,%0\;mov %D1,%3\;addc %d2,%3,%d0\",
       \"add %1,#%2,%0\;addc %d1,#0,%d0\",
       \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
       \"add #%2,%0\;addc #%y2,%d0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%2,%0\;addc %d1,%P2,%D0\",
       \"add %1,%I2,%I0\;mov %D2,%3\;addc %d1,%3,%D0\"
     };

     static char *psv_psv_patterns[] = {
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%I1,%0\;nop\;mov %D1,%3\;addc %d2,%3,%d0\",
       \"add %1,#%2,%0\;addc %d1,#0,%d0\",
       \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
       \"add #%2,%0\;addc #%y2,%d0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%2,%0\;addc %d1,%P2,%D0\",
       \"add %1,%I2,%I0\;nop\;mov %D2,%3\;addc %d1,%3,%D0\"
     };

     if (pic30_psrd_psrd_errata(operands[1],operands[2])) {
       pic30_rtx_nops++;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     }
   }"
  [
    (set_attr "cc" "math,math,math,math,math,math,math,math,math,math")
    (set_attr "type" "def,def,def,defuse,def,def,def,use,use,use")
  ]
)

(define_insn "addp32ext3_DATA"
 [(set (match_operand:P32EXT   0 "pic30_rR_or_near_operand" "=r,r,r,&r,r,r,r,R,R,R")
       (plus:P32EXT
         (match_operand:P32EXT 1 "pic30_rR_or_near_operand" "%r,0,r, R,r,r,0,r,r,r")
         (match_operand:P32EXT 2 "pic30_rR_or_JN_operand"    "r,r,0, r,P,N,J,r,0,R")  ))
 ]
  ""
  "*
   {
     static char *patterns[] = {
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%I1,%0\;addc %d2,%D1,%d0\",
       \"add %1,#%2,%0\;addc %d1,#0,%d0\",
       \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
       \"add #%2,%0\;addc #%y2,%d0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%2,%0\;addc %d1,%P2,%D0\",
       \"add %1,%I2,%I0\;addc %d1,%D2,%D0\"
     };

     static char *psv_psv_patterns[] = {
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%I1,%0\;nop\;addc %d2,%D1,%d0\",
       \"add %1,#%2,%0\;addc %d1,#0,%d0\",
       \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
       \"add #%2,%0\;addc #%y2,%d0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%2,%0\;addc %d1,%P2,%D0\",
       \"add %1,%I2,%I0\;nop\;addc %d1,%D2,%D0\"
     };

     if (pic30_psrd_psrd_errata(operands[1],operands[2])) {
       pic30_rtx_nops++;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     }
   }"
  [
    (set_attr "cc" "math,math,math,math,math,math,math,math,math,math")
    (set_attr "type" "def,def,def,defuse,def,def,def,use,use,use")
  ]
)

(define_insn "addp32ext3_noerrata_APSV"
 [(set (match_operand:P32EXT   0 "pic30_rR_or_near_operand"      "=r,r,r,&r,r,r,r,R,R,R")
       (plus:P32EXT
         (match_operand:P32EXT 1 "pic30_rR_or_near_APSV_operand" "%r,0,r, R,r,r,0,r,r,r")
         (match_operand:P32EXT 2 "pic30_rR_or_JN_APSV_operand"    "r,r,0, r,P,N,J,r,0,R")  ))
 ]
  "(!(pic30_errata_mask & psv_errata))"
  "*
   {
     static char *patterns[] = {
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%I1,%0\;addc %d2,%D1,%d0\",
       \"add %1,#%2,%0\;addc %d1,#0,%d0\",
       \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
       \"add #%2,%0\;addc #%y2,%d0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%2,%0\;addc %d1,%P2,%D0\",
       \"add %1,%I2,%I0\;addc %d1,%D2,%D0\"
     };

     static char *psv_psv_patterns[] = {
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%I1,%0\;nop\;addc %d2,%D1,%d0\",
       \"add %1,#%2,%0\;addc %d1,#0,%d0\",
       \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
       \"add #%2,%0\;addc #%y2,%d0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%2,%0\;addc %d1,%P2,%D0\",
       \"add %1,%I2,%I0\;nop\;addc %d1,%D2,%D0\"
     };

     if (pic30_psrd_psrd_errata(operands[1],operands[2])) {
       pic30_rtx_nops++;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     }
   }"
  [
    (set_attr "cc" "math,math,math,math,math,math,math,math,math,math")
    (set_attr "type" "def,def,def,defuse,def,def,def,use,use,use")
  ]
)

(define_expand "addp32ext3"
  [(set (match_operand:P32EXT 0 "pic30_rR_or_near_operand" "")
        (plus:P32EXT
          (match_operand:P32EXT 1 "pic30_rR_or_near_APSV_operand" "")
          (match_operand:P32EXT 2 "pic30_rR_or_JN_APSV_operand" "")))]
  ""
  "
{
  if (pic30_rR_or_near_operand(operands[1],GET_MODE(operands[1])) &&
      pic30_rR_or_JN_operand(operands[2],GET_MODE(operands[2]))) {
    emit_insn(gen_addp32ext3_DATA(operands[0], operands[1], operands[2]));
  } else if (pic30_errata_mask & psv_errata) {
    emit_insn(gen_addp32ext3_errata_APSV(operands[0], operands[1], operands[2]));
  } else {
    emit_insn(gen_addp32ext3_noerrata_APSV(operands[0], operands[1], operands[2]));
  }
  DONE;
}")

;; P32EDS

;;;;;;;;;;;;;;;;;
;; double integer
;;;;;;;;;;;;;;;;;

(define_insn "*adddi3_imm"
  [(set (match_operand:DI          0 "pic30_register_operand" "=r,r,r,r")
        (plus:DI (match_operand:DI 1 "pic30_register_operand" "%r,r,0,0")
                 (match_operand:DI 2 "pic30_JM_operand"       " P,N,J,M")))]
  ""
  "@
   add %1,#%2,%0\;addc %d1,#0,%d0\;addc %t1,#0,%t0\;addc %q1,#0,%q0
   sub %1,#%J2,%0\;subb %d1,#0,%d0\;subb %t1,#0,%t0\;subb %q1,#0,%q0
   add #%2,%0\;addc #%y2,%d0\;addc #%x2,%t0\;addc #%w2,%q0
   sub %0,#%J2\;subb %d0,#0\;subb %t0,#0\;subb %q0,#0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
  ]
)

(define_insn "*addhidi3_se"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (plus:DI
           (sign_extend:DI
              (match_operand:HI 1 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")))
  (clobber (match_scratch:HI 3                   "=&r,&r,&r,&r,&r,&r,&r,&r,&r"))
  ]
  ""
  "*
{
   char *noerrata_patterns[] = {
     /* r,r,r */          \"asr %1,#15,%3\;add %1,%2,%0\;addc %3,%d2,%d0\;\"
                              \"addc %3,%t2,%t0\;addc %3,%q2,%q0\",

     /* >,r,r */          \"asr %1,#15,%3\;add %1,%2,%0\;addc %3,%d2,%0\;\"
                              \"addc %3,%t2,%0\;addc %3,%q2,%0\",

     /* >,r,0 */          \"asr %1,#15,%3\;add %1,%s2,%0\;addc %3,%s2,%0\;\"
                              \"addc %3,%s2,%0\;addc %3,%s2,%0\",

     /* >,r,> */          \"asr %1,#15,%3\;add %1,%2,%0\;addc %3,%2,%0\;\"
                              \"addc %3,%2,%0\;addc %3,%2,%0\",

     /* r,r,> */          \"asr %1,#15,%3\;add %1,%2,%0\;addc %3,%2,%d0\;\"
                              \"addc %3,%2,%t0\;addc %3,%2,%q0\",

     /* R,r,r */          \"asr %1,#15,%3\;add %1,%2,%I0\;addc %3,%d2,%I0\;\"
                              \"addc %3,%t2,%I0\;addc %3,%q2,%s0\",

     /* R,r,0 */          \"asr %1,#15,%3\;add %1,%2,%I0\;addc %3,%2,%I0\;\"
                              \"addc %3,%2,%I0\;addc %3,%2,%s0\",

     /* R,r,R */          \"asr %1,#15,%3\;add %1,%I2,%I0\;addc %3,%I2,%I0\;\"
                              \"addc %3,%I2,%I0\;addc %3,%2,%0\",

     /* r,r,R */          \"asr %1,#15,%3\;add %1,%I2,%0\;addc %3,%I2,%d0\;\"
                              \"addc %3,%I2,%t0\;addc %3,%2,%q0\",
   };

   char *psv_psv_patterns[] = {
     /* r,r,r */          \"asr %1,#15,%3\;add %1,%2,%0\;addc %3,%d2,%d0\;\"
                              \"addc %3,%t2,%t0\;addc %3,%q2,%q0\",

     /* >,r,r */          \"asr %1,#15,%3\;add %1,%2,%0\;addc %3,%d2,%0\;\"
                              \"addc %3,%t2,%0\;addc %3,%q2,%0\",

     /* >,r,0 */          \"asr %1,#15,%3\;add %1,%s2,%0\;addc %3,%s2,%0\;\"
                              \"addc %3,%s2,%0\;addc %3,%s2,%0\",

     /* >,r,> */          \"asr %1,#15,%3\;\"
                          \"add %1,%2,%0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%0\",

     /* r,r,> */          \"asr %1,#15,%3\;\"
                          \"add %1,%2,%0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%d0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%t0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%q0\",

     /* R,r,r */          \"asr %1,#15,%3\;add %1,%2,%I0\;addc %3,%d2,%I0\;\"
                              \"addc %3,%t2,%I0\;addc %3,%q2,%s0\",

     /* R,r,0 */          \"asr %1,#15,%3\;add %1,%2,%I0\;addc %3,%2,%I0\;\"
                              \"addc %3,%2,%I0\;addc %3,%2,%s0\",

     /* R,r,R */          \"asr %1,#15,%3\;\"
                          \"add %1,%I2,%I0\;\"
                          \"\nop\;\"
                          \"addc %3,%I2,%I0\;\"
                          \"\nop\;\"
                          \"addc %3,%I2,%I0\;\"
                          \"\nop\;\"
                          \"addc %3,%2,%0\",

     /* r,r,R */          \"asr %1,#15,%3\;\"
                          \"add %1,%I2,%0\;\"
                          \"\nop\;\"
                          \"addc %3,%I2,%d0\;\"
                          \"\nop\;\"
                          \"addc %3,%I2,%t0\;\"
                          \"\nop\;\"
                          \"addc %3,%2,%q0\",
   };
 
  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  char **patterns;
  int regno;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
  ]
)

(define_insn "*addhidi3_ze"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (plus:DI
           (zero_extend:DI
              (match_operand:HI 1 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")))
  (clobber (match_scratch:HI 3                   "=X,X,&r,&r,&r,X,&r,&r,&r"))
  ]
  ""
  "*
{
  char *noerrata_patterns[] = {
     /* r,r,r */          \"add %1,%2,%0\;addc %d2,#0,%d0\;\"
                              \"addc %t2,#0,%t0\;addc %q2,#0,%q0\",

     /* >,r,r */          \"add %1,%2,%0\;addc %d2,#0,%0\;\"
                              \"addc %t2,#0,%0\;addc %q2,#0,%0\",

     /* >,r,0 */          \"clr %3\;add %1,%s2,%0\;addc %3,%s2,%0\;\"
                              \"addc %3,%s2,%0\;addc %3,%s2,%0\",

     /* >,r,> */          \"clr %3\;add %1,%2,%0\;addc %3,%2,%0\;\"
                              \"addc %3,%2,%0\;addc %3,%2,%0\",

     /* r,r,> */          \"clr %3\;add %1,%2,%0\;addc %3,%2,%d0\;\"
                              \"addc %3,%2,%t0\;addc %3,%2,%q0\",

     /* R,r,r */          \"add %1,%2,%I0\;addc %d2,#0,%I0\;\"
                              \"addc %t2,#0,%I0\;addc %q2,#0,%s0\",

     /* R,r,0 */          \"clr %3\;add %1,%2,%I0\;addc %3,%2,%I0\;\"
                              \"addc %3,%2,%I0\;addc %3,%2,%s0\",

     /* R,r,R */          \"clr %3\;add %1,%I2,%I0\;addc %3,%I2,%I0\;\"
                              \"addc %3,%I2,%I0\;addc %3,%2,%0\",

     /* r,r,R */          \"clr %3\;add %1,%I2,%0\;addc %3,%I2,%d0\;\"
                              \"addc %3,%I2,%t0\;addc %3,%2,%q0\",
  };

  char *psv_psv_patterns[] = {
     /* r,r,r */          \"add %1,%2,%0\;addc %d2,#0,%d0\;\"
                              \"addc %t2,#0,%t0\;addc %q2,#0,%q0\",

     /* >,r,r */          \"add %1,%2,%0\;addc %d2,#0,%0\;\"
                              \"addc %t2,#0,%0\;addc %q2,#0,%0\",

     /* >,r,0 */          \"clr %3\;add %1,%s2,%0\;addc %3,%s2,%0\;\"
                              \"addc %3,%s2,%0\;addc %3,%s2,%0\",

     /* >,r,> */          \"clr %3\;\"
                          \"add %1,%2,%0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%0\",

     /* r,r,> */          \"clr %3\;\"
                          \"add %1,%2,%0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%d0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%t0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%q0\",

     /* R,r,r */          \"add %1,%2,%I0\;addc %d2,#0,%I0\;\"
                              \"addc %t2,#0,%I0\;addc %q2,#0,%s0\",

     /* R,r,0 */          \"clr %3\;add %1,%2,%I0\;addc %3,%2,%I0\;\"
                              \"addc %3,%2,%I0\;addc %3,%2,%s0\",

     /* R,r,R */          \"clr %3\;\"
                          \"add %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"addc %3,%I2,%I0\;\"
                          \"nop\;\"
                          \"addc %3,%I2,%I0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%0\",

     /* r,r,R */          \"clr %3\;\"
                          \"add %1,%I2,%0\;\"
                          \"nop\;\"
                          \"addc %3,%I2,%d0\;\"
                          \"nop\;\"
                          \"addc %3,%I2,%t0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  char **patterns;
  int regno;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
  ]
)

(define_insn "*addsidi3_se"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (plus:DI
           (sign_extend:DI
              (match_operand:SI 1 "pic30_register_operand" "r,r,r,r,r,r,r,r,r"))
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>,>,r,0,R,R")))
  (clobber (match_scratch:HI 3                   "=&r,&r,&r,&r,&r,&r,&r,&r,&r"))
  ]
  ""
  "*
{
  char *noerrata_patterns[] = {
     /* r,r,r */          \"asr %d1,#15,%3\;add %1,%2,%0\;addc %d1,%d2,%d0\;\"
                              \"addc %3,%t2,%t0\;addc %3,%q2,%q0\",

     /* >,r,r */          \"asr %d1,#15,%3\;add %1,%2,%0\;addc %d1,%d2,%0\;\"
                              \"addc %3,%t2,%0\;addc %3,%q2,%0\",

     /* >,r,0 */          \"asr %d1,#15,%3\;add %1,%s2,%0\;addc %d1,%s2,%0\;\"
                              \"addc %3,%s2,%0\;addc %3,%s2,%0\",

     /* >,r,> */          \"asr %d1,#15,%3\;add %1,%2,%0\;addc %d1,%2,%0\;\"
                              \"addc %3,%2,%0\;addc %3,%2,%0\",

     /* r,r,> */          \"asr %d1,#15,%3\;add %1,%2,%0\;addc %d1,%2,%d0\;\"
                              \"addc %3,%2,%t0\;addc %3,%2,%q0\",

     /* R,r,r */          \"asr %d1,#15,%3\;add %1,%2,%I0\;addc %d1,%d2,%I0\;\"
                              \"addc %3,%t2,%I0\;addc %3,%q2,%s0\",

     /* R,r,0 */          \"asr %d1,#15,%3\;add %1,%2,%I0\;addc %d1,%2,%I0\;\"
                              \"addc %3,%2,%I0\;addc %3,%2,%s0\",

     /* R,r,R */          \"asr %d1,#15,%3\;add %1,%I2,%I0\;addc %d1,%I2,%I0\;\"
                              \"addc %3,%I2,%I0\;addc %3,%2,%0\",

     /* r,r,R */          \"asr %d1,#15,%3\;add %1,%I2,%0\;addc %d1,%I2,%d0\;\"
                              \"addc %3,%I2,%t0\;addc %3,%2,%q0\",
  };

  char *psv_psv_patterns[] = {
     /* r,r,r */          \"asr %d1,#15,%3\;add %1,%2,%0\;addc %d1,%d2,%d0\;\"
                              \"addc %3,%t2,%t0\;addc %3,%q2,%q0\",

     /* >,r,r */          \"asr %d1,#15,%3\;add %1,%2,%0\;addc %d1,%d2,%0\;\"
                              \"addc %3,%t2,%0\;addc %3,%q2,%0\",

     /* >,r,0 */          \"asr %d1,#15,%3\;add %1,%s2,%0\;addc %d1,%s2,%0\;\"
                              \"addc %3,%s2,%0\;addc %3,%s2,%0\",

     /* >,r,> */          \"asr %d1,#15,%3\;\"
                          \"add %1,%2,%0\;\"
                          \"nop\;\"
                          \"addc %d1,%2,%0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%0\",

     /* r,r,> */          \"asr %d1,#15,%3\;\"
                          \"add %1,%2,%0\;\"
                          \"nop\;\"
                          \"addc %d1,%2,%d0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%t0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%q0\",

     /* R,r,r */          \"asr %d1,#15,%3\;add %1,%2,%I0\;addc %d1,%d2,%I0\;\"
                              \"addc %3,%t2,%I0\;addc %3,%q2,%s0\",

     /* R,r,0 */          \"asr %d1,#15,%3\;add %1,%2,%I0\;addc %d1,%2,%I0\;\"
                              \"addc %3,%2,%I0\;addc %3,%2,%s0\",

     /* R,r,R */          \"asr %d1,#15,%3\;\"
                          \"add %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"addc %d1,%I2,%I0\;\"
                          \"nop\;\"
                          \"addc %3,%I2,%I0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%0\",

     /* r,r,R */          \"asr %d1,#15,%3\;\"
                          \"add %1,%I2,%0\;\"
                          \"nop\;\"
                          \"addc %d1,%I2,%d0\;\"
                          \"nop\;\"
                          \"addc %3,%I2,%t0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  char **patterns;
  int regno;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
  ]
)

(define_insn "*addsidi3_ze"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (plus:DI
           (zero_extend:DI
              (match_operand:SI 1 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")))
  (clobber (match_scratch:HI 3                   "=X,X,&r,&r,&r,X,&r,&r,&r"))
  ]
  ""
  "*
{
   char *noerrata_patterns[] = {
     /* r,r,r */          \"add %1,%2,%0\;addc %d1,%d2,%d0\;\"
                              \"addc %t2,#0,%t0\;addc %q2,#0,%q0\",

     /* >,r,r */          \"add %1,%2,%0\;addc %d1,%d2,%0\;\"
                              \"addc %t2,#0,%0\;addc %q2,#0,%0\",

     /* >,r,0 */          \"clr %3\;add %1,%s2,%0\;addc %d1,%s2,%0\;\"
                              \"addc %3,%s2,%0\;addc %3,%s2,%0\",

     /* >,r,> */          \"clr %3\;add %1,%2,%0\;addc %d1,%2,%0\;\"
                              \"addc %3,%2,%0\;addc %3,%2,%0\",

     /* r,r,> */          \"clr %3\;add %1,%2,%0\;addc %d1,%2,%d0\;\"
                              \"addc %3,%2,%t0\;addc %3,%2,%q0\",

     /* R,r,r */          \"add %1,%2,%I0\;addc %d1,%d2,%I0\;\"
                              \"addc %t2,#0,%I0\;addc %q2,#0,%s0\",

     /* R,r,0 */          \"clr %3\;add %1,%2,%I0\;addc %d1,%2,%I0\;\"
                              \"addc %3,%2,%I0\;addc %3,%2,%s0\",

     /* R,r,R */          \"clr %3\;add %1,%I2,%I0\;addc %d1,%I2,%I0\;\"
                              \"addc %3,%I2,%I0\;addc %3,%2,%0\",

     /* r,r,R */          \"clr %3\;add %1,%I2,%0\;addc %d1,%I2,%d0\;\"
                              \"addc %3,%I2,%t0\;addc %3,%2,%q0\",
  };

   char *psv_psv_patterns[] = {
     /* r,r,r */          \"add %1,%2,%0\;addc %d1,%d2,%d0\;\"
                              \"addc %t2,#0,%t0\;addc %q2,#0,%q0\",

     /* >,r,r */          \"add %1,%2,%0\;addc %d1,%d2,%0\;\"
                              \"addc %t2,#0,%0\;addc %q2,#0,%0\",

     /* >,r,0 */          \"clr %3\;add %1,%s2,%0\;addc %d1,%s2,%0\;\"
                              \"addc %3,%s2,%0\;addc %3,%s2,%0\",

     /* >,r,> */          \"clr %3\;\"
                          \"add %1,%2,%0\;\"
                          \"nop\;\"
                          \"addc %d1,%2,%0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%0\",

     /* r,r,> */          \"clr %3\;\"
                          \"add %1,%2,%0\;\"
                          \"nop\;\"
                          \"addc %d1,%2,%d0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%t0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%q0\",

     /* R,r,r */          \"add %1,%2,%I0\;addc %d1,%d2,%I0\;\"
                              \"addc %t2,#0,%I0\;addc %q2,#0,%s0\",

     /* R,r,0 */          \"clr %3\;add %1,%2,%I0\;addc %d1,%2,%I0\;\"
                              \"addc %3,%2,%I0\;addc %3,%2,%s0\",

     /* R,r,R */          \"clr %3\;\"
                          \"add %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"addc %d1,%I2,%I0\;\"
                          \"nop\;\"
                          \"addc %3,%I2,%I0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%0\",

     /* r,r,R */          \"clr %3\;\"
                          \"add %1,%I2,%0\;\"
                          \"nop\;\"
                          \"addc %d1,%I2,%d0\;\"
                          \"nop\;\"
                          \"addc %3,%I2,%t0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  char **patterns;
  int regno;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }
  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
  ]
)

(define_insn "*adddihi3_se"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (plus:DI
           (match_operand:DI 1 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")
           (sign_extend:DI
              (match_operand:HI 2 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
        )
   )
  (clobber (match_scratch:HI 3                   "=&r,&r,&r,&r,&r,&r,&r,&r,&r"))
  ]
  ""
  "*
{
   char *noerrata_patterns[] = {
     /* r,r,r */          \"asr %2,#15,%3\;add %1,%2,%0\;addc %d1,%3,%d0\;\"
                              \"addc %t1,%3,%t0\;addc %q1,%3,%q0\",

     /* >,r,r */          \"asr %2,#15,%3\;add %1,%2,%0\;addc %d1,%3,%0\;\"
                              \"addc %t1,%3,%0\;addc %q1,%3,%0\",

     /* >,0,r */          \"asr %2,#15,%3\;add %2,%s1,%0\;addc %3,%s1,%0\;\"
                              \"addc %3,%s1,%0\;addc %3,%s1,%0\",

     /* >,>,r */          \"asr %2,#15,%3\;add %2,%1,%0\;addc %3,%1,%0\;\"
                              \"addc %3,%1,%0\;addc %3,%2,%0\",

     /* r,>,r */          \"asr %2,#15,%3\;add %2,%1,%0\;addc %3,%1,%d0\;\"
                              \"addc %3,%1,%t0\;addc %3,%1,%q0\",

     /* R,r,r */          \"asr %2,#15,%3\;add %1,%2,%I0\;addc %d1,%3,%I0\;\"
                              \"addc %t1,%3,%I0\;addc %q1,%3,%s0\",

     /* R,0,r */          \"asr %2,#15,%3\;add %2,%1,%I0\;addc %3,%1,%I0\;\"
                              \"addc %3,%1,%I0\;addc %3,%1,%s0\",

     /* R,R,r */          \"asr %2,#15,%3\;add %2,%I1,%I0\;addc %3,%I1,%I0\;\"
                              \"addc %3,%I1,%I0\;addc %3,%1,%0\",

     /* r,R,r */          \"asr %2,#15,%3\;add %2,%I1,%0\;addc %3,%I1,%d0\;\"
                              \"addc %3,%I1,%t0\;addc %3,%1,%q0\",
  };

  char *psv_psv_patterns[] = {
     /* r,r,r */          \"asr %2,#15,%3\;add %1,%2,%0\;addc %d1,%3,%d0\;\"
                              \"addc %t1,%3,%t0\;addc %q1,%3,%q0\",

     /* >,r,r */          \"asr %2,#15,%3\;add %1,%2,%0\;addc %d1,%3,%0\;\"
                              \"addc %t1,%3,%0\;addc %q1,%3,%0\",

     /* >,0,r */          \"asr %2,#15,%3\;add %2,%s1,%0\;addc %3,%s1,%0\;\"
                              \"addc %3,%s1,%0\;addc %3,%s1,%0\",

     /* >,>,r */          \"asr %2,#15,%3\;\"
                          \"add %2,%1,%0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%0\",

     /* r,>,r */          \"asr %2,#15,%3\;\"
                          \"add %2,%1,%0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%d0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%t0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%q0\",

     /* R,r,r */          \"asr %2,#15,%3\;add %1,%2,%I0\;addc %d1,%3,%I0\;\"
                              \"addc %t1,%3,%I0\;addc %q1,%3,%s0\",

     /* R,0,r */          \"asr %2,#15,%3\;add %2,%1,%I0\;addc %3,%1,%I0\;\"
                              \"addc %3,%1,%I0\;addc %3,%1,%s0\",

     /* R,R,r */          \"asr %2,#15,%3\;\"
                          \"add %2,%I1,%I0\;\"
                          \"nop\;\"
                          \"addc %3,%I1,%I0\;\"
                          \"nop\;\"
                          \"addc %3,%I1,%I0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%0\",

     /* r,R,r */          \"asr %2,#15,%3\;\"
                          \"add %2,%I1,%0\;\"
                          \"nop\;\"
                          \"addc %3,%I1,%d0\;\"
                          \"nop\;\"
                          \"addc %3,%I1,%t0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  char **patterns;
  int regno;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,0,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,R,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[1],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;

     case 8:  /* r,R,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[1],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
  ]
)

(define_insn "*adddihi3_ze"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (plus:DI
           (match_operand:DI 1 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")
           (zero_extend:DI
              (match_operand:HI 2 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
        )
   )
  (clobber (match_scratch:HI 3                   "=X,X,&r,&r,&r,X,&r,&r,&r"))
  ]
  ""
  "*
{
   char *noerrata_patterns[] = {
     /* r,r,r */          \"add %1,%2,%0\;addc %d1,#0,%d0\;\"
                              \"addc %t1,#0,%t0\;addc q1,#0,%q0\",

     /* >,r,r */          \"add %1,%2,%0\;addc %d1,#0,%0\;\"
                              \"addc %t1,#0,%0\;addc %q1,#0,%0\",

     /* >,0,r */          \"clr %3\;add %s1,%2,%0\;addc %3,%s1,%0\;\"
                              \"addc %3,%s1,%0\;addc %3,%s1,%0\",

     /* >,>,r */          \"clr %3\;add %2,%1,%0\;addc %3,%1,%0\;\"
                              \"addc %3,%1,%0\;addc %3,%1,%0\",

     /* r,>,r */          \"clr %3\;add %2,%1,%0\;addc %3,%1,%d0\;\"
                              \"addc %3,%1,%t0\;addc %3,%1,%q0\",

     /* R,r,r */          \"add %1,%2,%I0\;addc %d1,#0,%I0\;\"
                              \"addc %t1,#0,%I0\;addc %q1,#0,%0\",

     /* R,0,r */          \"clr %3\;add %2,%1,%I0\;addc %3,%1,%I0\;\"
                              \"addc %3,%1,%I0\;addc %3,%1,%0\",

     /* R,R,r */          \"clr %3\;add %2,%I1,%I0\;addc %3,%I1,%I0\;\"
                              \"addc %3,%I1,%I0\;addc %3,%1,%0\",

     /* r,R,r */          \"clr %3\;add %2,%I1,%0\;addc %3,%I1,%d0\;\"
                              \"addc %3,%I1,%t0\;addc %3,%1,%q0\",
  };

  char *psv_psv_patterns[] = {
     /* r,r,r */          \"add %1,%2,%0\;addc %d1,#0,%d0\;\"
                              \"addc %t1,#0,%t0\;addc q1,#0,%q0\",

     /* >,r,r */          \"add %1,%2,%0\;addc %d1,#0,%0\;\"
                              \"addc %t1,#0,%0\;addc %q1,#0,%0\",

     /* >,0,r */          \"clr %3\;add %s1,%2,%0\;addc %3,%s1,%0\;\"
                              \"addc %3,%s1,%0\;addc %3,%s1,%0\",

     /* >,>,r */          \"clr %3\;\"
                          \"add %2,%1,%0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%0\",

     /* r,>,r */          \"clr %3\;\"
                          \"add %2,%1,%0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%d0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%t0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%q0\",

     /* R,r,r */          \"add %1,%2,%I0\;addc %d1,#0,%I0\;\"
                              \"addc %t1,#0,%I0\;addc %q1,#0,%0\",

     /* R,0,r */          \"clr %3\;add %2,%1,%I0\;addc %3,%1,%I0\;\"
                              \"addc %3,%1,%I0\;addc %3,%1,%0\",

     /* R,R,r */          \"clr %3\;\"
                          \"add %2,%I1,%I0\;\"
                          \"nop\;\"
                          \"addc %3,%I1,%I0\;\"
                          \"nop\;\"
                          \"addc %3,%I1,%I0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%0\",

     /* r,R,r */          \"clr %3\;\"
                          \"add %2,%I1,%0\;\"
                          \"nop\;\"
                          \"addc %3,%I1,%d0\;\"
                          \"nop\;\"
                          \"addc %3,%I1,%t0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  char **patterns;
  int regno;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,0,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,R,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[1],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;

     case 8:  /* r,R,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[1],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
  ]
)

(define_insn "*adddisi3_se"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (plus:DI
           (match_operand:SI 1 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")
           (sign_extend:DI
              (match_operand:SI 2 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
        )
   )
  (clobber (match_scratch:HI 3                   "=&r,&r,&r,&r,&r,&r,&r,&r,&r"))
  ]
  ""
  "*
{
   char *noerrata_patterns[] = {
     /* r,r,r */          \"asr %d2,#15,%3\;add %1,%2,%0\;addc %d1,%d2,%d0\;\"
                              \"addc %3,%t1,%t0\;addc %3,%q1,%q0\",

     /* >,r,r */          \"asr %d2,#15,%3\;add %1,%2,%0\;addc %d1,%d2,%0\;\"
                              \"addc %3,%t1,%0\;addc %3,%q1,%0\",

     /* >,0,r */          \"asr %d2,#15,%3\;add %2,%s1,%0\;addc %d2,%s1,%0\;\"
                              \"addc %3,%s1,%0\;addc %3,%s1,%0\",

     /* >,>,r */          \"asr %d2,#15,%3\;add %2,%1,%0\;addc %d2,%1,%0\;\"
                              \"addc %3,%1,%0\;addc %3,%1,%0\",

     /* r,>,r */          \"asr %d2,#15,%3\;add %2,%1,%0\;addc %d2,%1,%d0\;\"
                              \"addc %3,%1,%t0\;addc %3,%1,%q0\",

     /* R,r,r */          \"asr %d2,#15,%3\;add %2,%1,%I0\;addc %d2,%d1,%I0\;\"
                              \"addc %3,%t1,%I0\;addc %3,%q1,%s0\",

     /* R,0,r */          \"asr %d2,#15,%3\;add %2,%1,%I0\;addc %d2,%1,%I0\;\"
                              \"addc %3,%1,%I0\;addc %3,%1,%s0\",

     /* R,R,r */          \"asr %d2,#15,%3\;add %2,%I1,%I0\;addc %d2,%I1,%I0\;\"
                              \"addc %3,%I1,%I0\;addc %3,%1,%0\",

     /* r,R,r */          \"asr %d2,#15,%3\;add %2,%I1,%0\;addc %d2,%I1,%d0\;\"
                              \"addc %3,%I1,%t0\;addc %3,%1,%q0\",
  };

   char *psv_psv_patterns[] = {
     /* r,r,r */          \"asr %d2,#15,%3\;add %1,%2,%0\;addc %d1,%d2,%d0\;\"
                              \"addc %3,%t1,%t0\;addc %3,%q1,%q0\",

     /* >,r,r */          \"asr %d2,#15,%3\;add %1,%2,%0\;addc %d1,%d2,%0\;\"
                              \"addc %3,%t1,%0\;addc %3,%q1,%0\",

     /* >,0,r */          \"asr %d2,#15,%3\;add %2,%s1,%0\;addc %d2,%s1,%0\;\"
                              \"addc %3,%s1,%0\;addc %3,%s1,%0\",

     /* >,>,r */          \"asr %d2,#15,%3\;\"
                          \"add %2,%1,%0\;\"
                          \"nop\;\"
                          \"addc %d2,%1,%0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%0\",

     /* r,>,r */          \"asr %d2,#15,%3\;\"
                          \"add %2,%1,%0\;\"
                          \"nop\;\"
                          \"addc %d2,%1,%d0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%t0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%q0\",

     /* R,r,r */          \"asr %d2,#15,%3\;add %2,%1,%I0\;addc %d2,%d1,%I0\;\"
                              \"addc %3,%t1,%I0\;addc %3,%q1,%s0\",

     /* R,0,r */          \"asr %d2,#15,%3\;add %2,%1,%I0\;addc %d2,%1,%I0\;\"
                              \"addc %3,%1,%I0\;addc %3,%1,%s0\",

     /* R,R,r */          \"asr %d2,#15,%3\;\"
                          \"add %2,%I1,%I0\;\"
                          \"nop\;\"
                          \"addc %d2,%I1,%I0\;\"
                          \"nop\;\"
                          \"addc %3,%I1,%I0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%0\",

     /* r,R,r */          \"asr %d2,#15,%3\;\"
                          \"add %2,%I1,%0\;\"
                          \"nop\;\"
                          \"addc %d2,%I1,%d0\;\"
                          \"nop\;\"
                          \"addc %3,%I1,%t0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  char **patterns;
  int regno;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[1],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[1],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
  ]
)

(define_insn "*adddisi3_ze"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (plus:DI
           (match_operand:DI 1 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")
           (zero_extend:DI
              (match_operand:SI 2 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
        )
   )
  (clobber (match_scratch:HI 3                   "=X,X,&r,&r,&r,X,&r,&r,&r"))
  ]
  ""
  "*
{
   char *noerrata_patterns[] = {
     /* r,r,r */          \"add %1,%2,%0\;addc %d1,%d2,%d0\;\"
                              \"addc %t1,#0,%t0\;addc %q1,#0,%q0\",

     /* >,r,r */          \"add %1,%2,%0\;addc %d1,%d2,%0\;\"
                              \"addc %t1,#0,%0\;addc %q1,#0,%0\",

     /* >,0,r */          \"clr %3\;add %2,%s1,%0\;addc %d2,%s1,%0\;\"
                              \"addc %3,%s1,%0\;addc %3,%s1,%0\",

     /* >,>,r */          \"clr %3\;add %2,%1,%0\;addc %d2,%1,%0\;\"
                              \"addc %3,%1,%0\;addc %3,%1,%0\",

     /* r,>,r */          \"clr %3\;add %2,%1,%0\;addc %d2,%1,%d0\;\"
                              \"addc %3,%1,%t0\;addc %3,%1,%q0\",

     /* R,r,r */          \"add %1,%2,%I0\;addc %d1,%d2,%I0\;\"
                              \"addc %t1,#0,%I0\;addc %q1,#0,%s0\",

     /* R,0,r */          \"clr %3\;add %2,%1,%I0\;addc %d2,%1,%I0\;\"
                              \"addc %3,%1,%I0\;addc %3,%1,%s0\",

     /* R,R,r */          \"clr %3\;add %2,%I1,%I0\;addc %d2,%I1,%I0\;\"
                              \"addc %3,%I1,%I0\;addc %3,%1,%0\",

     /* r,R,r */          \"clr %3\;add %2,%I1,%0\;addc %d2,%I1,%d0\;\"
                              \"addc %3,%I1,%t0\;addc %3,%1,%q0\",
  };

  char *psv_psv_patterns[] = {
     /* r,r,r */          \"add %1,%2,%0\;addc %d1,%d2,%d0\;\"
                              \"addc %t1,#0,%t0\;addc %q1,#0,%q0\",

     /* >,r,r */          \"add %1,%2,%0\;addc %d1,%d2,%0\;\"
                              \"addc %t1,#0,%0\;addc %q1,#0,%0\",

     /* >,0,r */          \"clr %3\;add %2,%s1,%0\;addc %d2,%s1,%0\;\"
                              \"addc %3,%s1,%0\;addc %3,%s1,%0\",

     /* >,>,r */          \"clr %3\;\"
                          \"add %2,%1,%0\;\"
                          \"nop\;\"
                          \"addc %d2,%1,%0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%0\",

     /* r,>,r */          \"clr %3\;\"
                          \"add %2,%1,%0\;\"
                          \"nop\;\"
                          \"addc %d2,%1,%d0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%t0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%q0\",

     /* R,r,r */          \"add %1,%2,%I0\;addc %d1,%d2,%I0\;\"
                              \"addc %t1,#0,%I0\;addc %q1,#0,%s0\",

     /* R,0,r */          \"clr %3\;add %2,%1,%I0\;addc %d2,%1,%I0\;\"
                              \"addc %3,%1,%I0\;addc %3,%1,%s0\",

     /* R,R,r */          \"clr %3\;\"
                          \"add %2,%I1,%I0\;\"
                          \"nop\;\"
                          \"addc %d2,%I1,%I0\;\"
                          \"nop\;\"
                          \"addc %3,%I1,%I0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%0\",

     /* r,R,r */          \"clr %3\;\"
                          \"add %2,%I1,%0\;\"
                          \"nop\;\"
                          \"addc %d2,%I1,%d0\;\"
                          \"nop\;\"
                          \"addc %3,%I1,%t0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%q0\",
  };


  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  char **patterns;
  int regno;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[1],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[1],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
  ]
)

;(define_insn "adddi3"
;  [(set (match_operand:DI          0 "pic30_register_operand" "=r")
;        (plus:DI (match_operand:DI 1 "pic30_register_operand" "%r")
;                 (match_operand:DI 2 "pic30_register_operand" " r")))]
;  ""
;  "add %2,%1,%0\;addc %d2,%d1,%d0\;addc %t2,%t1,%t0\;addc %q2,%q1,%q0"
;  [
;   (set_attr "cc" "math")
;   (set_attr "type" "def")
;  ]
;)

(define_insn "adddi3"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (plus:DI
           (match_operand:DI 1 "pic30_register_operand"    "r,r,r,r, r,r,r,r, r")
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")))
  ]
  ""
  "*
{
   char *noerrata_patterns[] = {
     /* r,r,r */          \"add %1,%2,%0\;addc %d1,%d2,%d0\;\"
                              \"addc %t1,%t2,%t0\;addc %q1,%q2,%q0\",

     /* >,r,r */          \"add %1,%2,%0\;addc %d1,%d2,%0\;\"
                              \"addc %t1,%t2,%0\;addc %q1,%q2,%0\",

     /* >,r,0 */          \"add %1,%s2,%0\;addc %d1,%s2,%0\;\"
                              \"addc %t1,%s2,%0\;addc %q1,%s2,%0\",

     /* >,r,> */          \"add %1,%2,%0\;addc %d1,%2,%0\;\"
                              \"addc %t1,%2,%0\;addc %q1,%2,%0\",

     /* r,r,> */          \"add %1,%2,%0\;addc %d1,%2,%d0\;\"
                              \"addc %t1,%2,%t0\;addc %q1,%2,%q0\",

     /* R,r,r */          \"add %1,%2,%I0\;addc %d1,%d2,%I0\;\"
                              \"addc %t1,%t2,%I0\;addc %q1,%q2,%s0\",

     /* R,r,0 */          \"add %1,%2,%I0\;addc %d1,%2,%I0\;\"
                              \"addc %t1,%2,%I0\;addc %q1,%2,%s0\",

     /* R,r,R */          \"add %1,%I2,%I0\;addc %d1,%I2,%I0\;\"
                              \"addc %t1,%I2,%I0\;addc %q1,%2,%0\",

     /* r,r,R */          \"add %1,%I2,%0\;addc %d1,%I2,%d0\;\"
                              \"addc %t1,%I2,%t0\;addc %q1,%2,%q0\",
  };

   char *psv_psv_patterns[] = {
     /* r,r,r */          \"add %1,%2,%0\;addc %d1,%d2,%d0\;\"
                              \"addc %t1,%t2,%t0\;addc %q1,%q2,%q0\",

     /* >,r,r */          \"add %1,%2,%0\;addc %d1,%d2,%0\;\"
                              \"addc %t1,%t2,%0\;addc %q1,%q2,%0\",

     /* >,r,0 */          \"add %1,%s2,%0\;addc %d1,%s2,%0\;\"
                              \"addc %t1,%s2,%0\;addc %q1,%s2,%0\",

     /* >,r,> */          \"add %1,%2,%0\;\"
                          \"nop\;\"
                          \"addc %d1,%2,%0\;\"
                          \"nop\;\"
                          \"addc %t1,%2,%0\;\"
                          \"nop\;\"
                          \"addc %q1,%2,%0\",

     /* r,r,> */          \"add %1,%2,%0\;\"
                          \"nop\;\"
                          \"addc %d1,%2,%d0\;\"
                          \"nop\;\"
                          \"addc %t1,%2,%t0\;\"
                          \"nop\;\"
                          \"addc %q1,%2,%q0\",

     /* R,r,r */          \"add %1,%2,%I0\;\"
                          \"addc %d1,%d2,%I0\;\"
                          \"addc %t1,%t2,%I0\;\"
                          \"addc %q1,%q2,%s0\",

     /* R,r,0 */          \"add %1,%2,%I0\;\"
                          \"addc %d1,%2,%I0\;\"
                          \"addc %t1,%2,%I0\;\"
                          \"addc %q1,%2,%s0\",

     /* R,r,R */          \"add %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"addc %d1,%I2,%I0\;\"
                          \"nop\;\"
                          \"addc %t1,%I2,%I0\;\"
                          \"nop\;\"
                          \"addc %q1,%2,%0\",

     /* r,r,R */          \"add %1,%I2,%0\;\"
                          \"nop\;\"
                          \"addc %d1,%I2,%d0\;\"
                          \"nop\;\"
                          \"addc %t1,%I2,%t0\;\"
                          \"nop\;\"
                          \"addc %q1,%2,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  char **patterns;
  int regno;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
  ]
)
;;;;;;;;
;; float
;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; subtract instructions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;
;; quarter integer
;;;;;;;;;;;;;;;;;;

(define_insn "*subqi3_imm"
  [(set (match_operand:QI 0 "pic30_register_operand"          "=r,r")
        (minus:QI (match_operand:QI 1 "pic30_register_operand" "0,0")
                  (match_operand:QI 2 "pic30_JM_operand" "J,M")))]
  ""
  "@
   sub.b %0,#%2
   add.b #%J2,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
  ]
)

(define_insn "subqi3_DATA"
  [(set (match_operand:QI 0 "pic30_mode2_operand"     "=r<>,r<>,R,R,  r<>,R,r<>,R")
        (minus:QI 
          (match_operand:QI 1 "pic30_register_operand" "r,  r,  r,r,  r,  r,r,  r")
          (match_operand:QI 2 "pic30_mode1PN_operand"  "r,  R<>,r,R<>,N,  N,P,  P")))]
  ""
  "@
   sub.b %1,%2,%0
   sub.b %1,%2,%0
   sub.b %1,%2,%0
   sub.b %1,%2,%0
   add.b %1,#%J2,%0
   add.b %1,#%J2,%0
   sub.b %1,#%2,%0
   sub.b %1,#%2,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,defuse,use,use,def,use,def,use")
  ]
)

(define_insn "subqi3_APSV"
  [(set (match_operand:QI 0 "pic30_mode2_operand" "=r<>,r<>,R,R,  r<>,R,r<>,R")
        (minus:QI 
           (match_operand:QI 1 "pic30_register_operand" "r,r,r,r,r,r,r,r")
           (match_operand:QI 2 "pic30_mode1PN_APSV_operand" 
                               "r,R<>,r,R<>,N,N,P,P")))]
  ""
  "@
   sub.b %1,%2,%0
   sub.b %1,%2,%0
   sub.b %1,%2,%0
   sub.b %1,%2,%0
   add.b %1,#%J2,%0
   add.b %1,#%J2,%0
   sub.b %1,#%2,%0
   sub.b %1,#%2,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,defuse,use,use,def,use,def,use")
  ]
)

(define_expand "subqi3"
  [(set (match_operand:QI 0 "pic30_mode2_operand" "=r<>,r<>,R,R,  r<>,R,r<>,R")
        (minus:QI 
           (match_operand:QI 1 "pic30_register_operand" "r,r,r,r,r,r,r,r")
           (match_operand:QI 2 "pic30_mode1PN_APSV_operand" 
                               "r,R<>,r,R<>,N,N,P,P")))]
  ""
  "
{
  if (pic30_mode1PN_operand(operands[2],GET_MODE(operands[2])))
    emit(gen_subqi3_DATA(operands[0],operands[1],operands[2]));
  else
    emit(gen_subqi3_APSV(operands[0],operands[1],operands[2]));
  DONE;
}")

; leave this match_dup, operand 0 will not require a reload (CAW)
(define_insn "*subqi3_sfr0"
  [(set (match_operand:QI 0 "pic30_near_operand"          "=U")
        (minus:QI (match_dup 0)
                  (match_operand:QI 1 "pic30_wreg_operand" "a")))]
  ""
  "sub.b %0"
  [
    (set_attr "cc" "math")
    (set_attr "type" "etc")
  ]
)

;
; pattern 3 could cause a RAW stall, but not the TLCD ECC issue
;   since U won't match a FLASH page
;
(define_insn "*subqi3_sfr1"
  [(set (match_operand:QI 0 "pic30_register_operand"             "=a,a,d")
        (minus:QI (match_operand:QI 1 "pic30_near_operand"       " U,U,U")
                  (match_operand:QI 2 "pic30_register_operand"   " a,d,d")))
   (clobber (match_scratch:QI 3                            "=X,X,&r"))]
  ""
  "@
   sub.b %1,WREG
   mov.b %2,w0\;sub.b %1,WREG
   mov #%1,%3\;subr.b %2,[%3],%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
  ]
)

;;;;;;;;;;;;;;;
;; half integer
;;;;;;;;;;;;;;;

; leave this match_dup, operand 1 cannot interfere with reload (CAW)
(define_insn "*subhi3_imm"
  [(set (match_operand:HI 0 "pic30_register_operand"          "=r,r")
        (minus:HI (match_dup 0)
                  (match_operand:HI 1 "pic30_JM_operand" "J,M")))]
  ""
  "@
   sub %0,#%1
   add #%J1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
  ]
)

(define_insn "subhi3_DATA"
  [(set (match_operand:HI 0 "pic30_mode2_operand"
             "=r<>,R,r<>,R,  r<>,R,r<>,R,  r<>,R,r<>,R,r<>,R")
        (minus:HI 
           (match_operand:HI 1 "pic30_mode1P_operand"
              "r,  r,r,  r,  r,  r,R<>,R<>,r,  r,r,  r,P,  P")
           (match_operand:HI 2 "pic30_mode1PN_operand"
              "r,  r,R<>,R<>,r,  r,r,  r,  N,  N,P,  P,r,  r")))]
  ""
  "@
   sub %1,%2,%0
   sub %1,%2,%0
   sub %1,%2,%0
   sub %1,%2,%0
   subr %2,%1,%0
   subr %2,%1,%0
   subr %2,%1,%0
   subr %2,%1,%0
   add %1,#%J2,%0
   add %1,#%J2,%0
   sub %1,#%2,%0
   sub %1,#%2,%0
   subr %2,#%1,%0
   subr %2,#%1,%0"
  [
     (set_attr "cc" "math")
     (set_attr "type"
  	 "def,use,defuse,use,def,use,defuse,use,def,use,def,use,def,use")
  ])

(define_insn "subhi3_APSV"
  [(set (match_operand:HI 0 "pic30_mode2_operand"
             "=r<>,R,r<>,R,  r<>,R,r<>,R,  r<>,R,r<>,R,r<>,R")
        (minus:HI 
           (match_operand:HI 1 "pic30_mode1P_APSV_operand"
              "r,  r,r,  r,  r,  r,R<>,R<>,r,  r,r,  r,P,  P")
           (match_operand:HI 2 "pic30_mode1PN_APSV_operand"
              "r,  r,R<>,R<>,r,  r,r,  r,  N,  N,P,  P,r,  r")))]
  ""
  "@
   sub %1,%2,%0
   sub %1,%2,%0
   sub %1,%2,%0
   sub %1,%2,%0
   subr %2,%1,%0
   subr %2,%1,%0
   subr %2,%1,%0
   subr %2,%1,%0
   add %1,#%J2,%0
   add %1,#%J2,%0
   sub %1,#%2,%0
   sub %1,#%2,%0
   subr %2,#%1,%0
   subr %2,#%1,%0"
  [
    (set_attr "cc" "math")
    (set_attr "type"
  	 "def,use,defuse,use,def,use,defuse,use,def,use,def,use,def,use")
  ]
)

(define_insn "subp16apsv3"
  [(set (match_operand:P16APSV 0 "pic30_mode2_operand"
             "=r<>,R,r<>,R,  r<>,R,r<>,R,  r<>,R,r<>,R,r<>,R")
        (minus:P16APSV 
           (match_operand:P16APSV 1 "pic30_mode1P_operand"
              "r,  r,r,  r,  r,  r,R<>,R<>,r,  r,r,  r,P,  P")
           (match_operand:P16APSV 2 "pic30_mode1PN_operand"
              "r,  r,R<>,R<>,r,  r,r,  r,  N,  N,P,  P,r,  r")))]
  ""
  "@
   sub %1,%2,%0
   sub %1,%2,%0
   sub %1,%2,%0
   sub %1,%2,%0
   subr %2,%1,%0
   subr %2,%1,%0
   subr %2,%1,%0
   subr %2,%1,%0
   add %1,#%J2,%0
   add %1,#%J2,%0
   sub %1,#%2,%0
   sub %1,#%2,%0
   subr %2,#%1,%0
   subr %2,#%1,%0"
  [
    (set_attr "cc" "math")
    (set_attr "type"
  	 "def,use,defuse,use,def,use,defuse,use,def,use,def,use,def,use")
  ]
)

(define_expand "subhi3"
  [(set (match_operand:HI 0 "pic30_mode2_operand"
              "=r<>,R,r<>,R,  r<>,R,r<>,R,  r<>,R,r<>,R,r<>,R")
        (minus:HI
           (match_operand:HI 1 "pic30_mode1P_APSV_operand"
              "r,  r,r,  r,  r,  r,R<>,R<>,r,  r,r,  r,P,  P")
           (match_operand:HI 2 "pic30_mode1PN_APSV_operand"
              "r,  r,R<>,R<>,r,  r,r,  r,  N,  N,P,  P,r,  r")))]
  ""
  "
  {
    if (pic30_mode1P_operand(operands[1],GET_MODE(operands[1])) &&
      pic30_mode1PN_operand(operands[2],GET_MODE(operands[2])))
      emit(gen_subhi3_DATA(operands[0],operands[1],operands[2]));
    else
      emit(gen_subhi3_APSV(operands[0],operands[1],operands[2]));
    DONE;
  }"
)

; this match_can cause issues iff operand 1 is dies in this instruction and
;   we decide to use it to reload operand 0 (CAW)
(define_insn "subhi3_sfr0"
  [(set (match_operand:HI 0 "pic30_reg_or_near_operand"    "+U,r")
        (minus:HI (match_dup 0)
                  (match_operand:HI 1 "pic30_wreg_operand" "a,a")))]
  ""
  "@
   sub %0
   sub %0,%1,%0"
  [
    (set_attr "cc" "math")
    (set_attr "type" "etc,def")
  ]
)

(define_insn_and_split "*subhi3_sfr1"
  [(set (match_operand:HI 0 "pic30_register_operand"             "=a ,a, d")
        (minus:HI (match_operand:HI 1 "pic30_near_operand"       " U ,U, U")
                  (match_operand:HI 2 "pic30_register_operand"   " a ,d, d")))
   (clobber (match_scratch:HI 3                                  "=X ,X,&r"))]
  ""
  "@
   sub %1,WREG
   mov %2,w0\;sub %1,WREG
   mov #%1,%3\;subr %2,[%3],%0"
  "reload_completed"
  [
   (set (match_dup 3) (match_dup 1))
   (set (match_dup 0) (minus:HI (match_dup 3) (match_dup 2)))
  ]
"
{
  if (!pic30_wreg_operand(operands[0], HImode) &&
      !pic30_wreg_operand(operands[2], HImode))
  {
  }
  else
  {
  	FAIL;
  }
}
"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
  ]
)

;;;;;;;;;;;;;;;;;
;; single integer
;;;;;;;;;;;;;;;;;

(define_insn "*subsihi3"
  [(set (match_operand:SI 0 "pic30_register_operand"          "=r")
        (minus:SI (match_operand:SI 1 "pic30_register_operand" "r")
                  (zero_extend:SI (match_operand:HI 2 "pic30_register_operand" "r"))))
  ]
  ""
  "sub %1,%2,%0\;subb %d1,#0,%d0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
  ]
)

(define_insn "subp32eds3"
  [(set(match_operand:P32EDS   0 "pic30_register_operand" "=&r")
       (minus:P32EDS
         (match_operand:P32EDS 1 "pic30_register_operand" "r")
         (match_operand:P32EDS 2 "pic30_register_operand" "r")))
  ]
  ""
  "sl %1,%0\;sl %2,%d0\;sub %0,%d0,%0\;subb %d1,%d2,%d0\;asr %d0,%d0\;rrc %0,%0"
)

(define_insn "subsip32eds3"
  [(set(match_operand:SI         0 "pic30_register_operand" "=&r")
       (minus:SI
         (zero_extend:SI
           (match_operand:P32EDS 1 "pic30_register_operand" "r"))
         (zero_extend:SI
           (match_operand:P32EDS 2 "pic30_register_operand" "r"))))
  ]
  ""
  "sl %1,%0\;sl %2,%d0\;sub %0,%d0,%0\;subb %d1,%d2,%d0\;asr %d0,%d0\;rrc %0,%0"
)

(define_insn "subsi_p32eds"
  [(set(match_operand:SI                 0 "pic30_register_operand" "=&r")
       (minus:SI
         (subreg:SI(match_operand:P32EDS 1 "pic30_register_operand" "r") 0)
         (subreg:SI(match_operand:P32EDS 2 "pic30_register_operand" "r") 0)))
  ]
  ""
  "sl %1,%0\;sl %2,%d0\;sub %0,%d0,%0\;subb %d1,%d2,%d0\;asr %d0,%d0\;rrc %0,%0"
)

(define_insn "*subsi3_imm0"
  [(set (match_operand:SI 0 "pic30_register_operand"          "=r,r")
        (minus:SI (match_operand:SI 1 "pic30_register_operand" "r,r")
                  (match_operand:SI 2 "pic30_PN_operand"       "N,P")))]
  ""
  "@
   add %1,#%J2,%0\;addc %d1,#0,%d0
   sub %1,#%2,%0\;subb %d1,#0,%d0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
  ]
)

(define_insn "*subsi3_imm1"
  [(set (match_operand:SI 0 "pic30_register_operand"          "=r")
        (minus:SI (match_operand:SI 1 "pic30_P_operand"        "P")
                  (match_operand:SI 2 "pic30_register_operand" "r")))]
  ""
  "subr %2,#%1,%0\;subbr %d2,#0,%d0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
  ]
)

(define_insn "*subsi3_imm2"
  [(set (match_operand:SI 0 "pic30_register_operand"          "=r,r")
        (minus:SI (match_operand:SI 1 "pic30_register_operand" "0,0")
                  (match_operand:SI 2 "pic30_JM_operand"       "J,M")))]
  ""
  "@
   sub %0,#%2\;subb %d0,#0
   add #%J2,%0\;addc #0,%d0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
  ]
)

(define_insn "subsi3_errata"
  [(set (match_operand:SI   0 "pic30_reg_or_R_operand" "=r,r,r,&r,R,R,R,&r,R,R")
        (minus:SI 
          (match_operand:SI 1 "pic30_reg_or_R_operand" " r,0,r, r,r,r,r, R,0,R")
          (match_operand:SI 2 "pic30_reg_or_R_operand" " r,r,0, R,r,0,R, r,r,r")
   ))
   (clobber (match_scratch:HI 3                       "=X,X,X,&r,X,&r,&r,X,X,X")
   )
  ]
  "(pic30_errata_mask & psv_errata)"
  "*
   {
     static char *patterns[] = {
       \"sub %1,%2,%0\;subb %d1,%d2,%d0\",
       \"sub %1,%2,%0\;subb %d1,%d2,%d0\",
       \"sub %1,%2,%0\;subb %d1,%d2,%d0\",
       \"sub %1,%I2,%0\;mov %D2,%3\;subb %d1,%3,%d0\",
       \"sub %1,%2,%I0\;subb %d1,%d2,%D0\",
       \"sub %1,%2,%I0\;mov %2,%3\;subb %d1,%3,%D0\",
       \"sub %1,%I2,%I0\;mov %D2,%3\;subb %d1,%3,%D0\",
       \"subr %2,%I1,%0\;subbr %d2,%D1,%d0\",
       \"subr %2,%1,%I0\;subbr %d2,%1,%D0\",
       \"subr %2,%I1,%I0\;subbr %d2,%D1,%D0\"
     };

     static char *psv_psv_patterns[] = {
       \"sub %1,%2,%0\;subb %d1,%d2,%d0\",
       \"sub %1,%2,%0\;subb %d1,%d2,%d0\",
       \"sub %1,%2,%0\;subb %d1,%d2,%d0\",
       \"sub %1,%I2,%0\;nop\;mov %D2,%3\;subb %d1,%3,%d0\",
       \"sub %1,%2,%I0\;subb %d1,%d2,%D0\",
       \"sub %1,%2,%I0\;mov %2,%3\;subb %d1,%3,%D0\",
       \"sub %1,%I2,%I0\;nop\;mov %D2,%3\;subb %d1,%3,%D0\",
       \"subr %2,%I1,%0\;nop\;subbr %d2,%D1,%d0\",
       \"subr %2,%1,%I0\;subbr %d2,%1,%D0\",
       \"subr %2,%I1,%I0\;nop\;subbr %d2,%D1,%D0\"
     };

     if (pic30_psrd_psrd_errata(operands[1],operands[2])) {
       pic30_rtx_nops++;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     }
   }"
  [
    (set_attr "cc" "math")
    (set_attr "type" "def,def,def,defuse,use,use,use,defuse,use,use")
  ]
)

(define_insn "subsi3_noerrata"
  [(set (match_operand:SI   0 "pic30_reg_or_R_operand" "=r,r,r,&r,R,R,R,&r,R,R")
        (minus:SI 
          (match_operand:SI 1 "pic30_reg_or_R_operand" "r,0,r, r,r,r,r,  R,0,R")
          (match_operand:SI 2 "pic30_reg_or_R_operand" "r,r,0, R,r,0,R, r,r,r")
   ))
  ]
  ""
  "*
   {
     static char *patterns[] = {
       \"sub %1,%2,%0\;subb %d1,%d2,%d0\",
       \"sub %1,%2,%0\;subb %d1,%d2,%d0\",
       \"sub %1,%2,%0\;subb %d1,%d2,%d0\",
       \"sub %1,%I2,%0\;subb %d1,%D2,%d0\",
       \"sub %1,%2,%I0\;subb %d1,%d2,%D0\",
       \"sub %1,%2,%I0\;subb %d1,%2,%D0\",
       \"sub %1,%I2,%I0\;subb %d1,%D2,%D0\",
       \"subr %2,%I1,%0\;subbr %d2,%D1,%d0\",
       \"subr %2,%1,%I0\;subbr %d2,%1,%D0\",
       \"subr %2,%I1,%I0\;subbr %d2,%D1,%D0\"
     };

     static char *psv_psv_patterns[] = {
       \"sub %1,%2,%0\;subb %d1,%d2,%d0\",
       \"sub %1,%2,%0\;subb %d1,%d2,%d0\",
       \"sub %1,%2,%0\;subb %d1,%d2,%d0\",
       \"sub %1,%I2,%0\;nop\;subb %d1,%D2,%d0\",
       \"sub %1,%2,%I0\;subb %d1,%d2,%D0\",
       \"sub %1,%2,%I0\;subb %d1,%2,%D0\",
       \"sub %1,%I2,%I0\;nop\;subb %d1,%D2,%D0\",
       \"subr %2,%I1,%0\;nop\;subbr %d2,%D1,%d0\",
       \"subr %2,%1,%I0\;subbr %d2,%1,%D0\",
       \"subr %2,%I1,%I0\;nop\;subbr %d2,%D1,%D0\"
     };

     if (pic30_psrd_psrd_errata(operands[1],operands[2])) {
       pic30_rtx_nops++;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     }
   }"
  [
    (set_attr "cc" "math")
    (set_attr "type" "def,def,def,defuse,use,use,use,defuse,use,use")
  ]
)

(define_expand "subsi3"
  [(set (match_operand:SI   0 "pic30_reg_or_R_operand" "")
        (minus:SI 
          (match_operand:SI 1 "pic30_reg_or_R_operand" "")
          (match_operand:SI 2 "pic30_reg_or_R_operand" "")))
  ]
  ""
  "
{
  if (pic30_errata_mask & psv_errata) {
    emit(gen_subsi3_errata(operands[0],operands[1],operands[2]));
  } else {
    emit(gen_subsi3_noerrata(operands[0],operands[1],operands[2]));
  }
  DONE;
}")

;;;;;;;;;;;;;;;;;
;; double integer
;;;;;;;;;;;;;;;;;

(define_insn "*subdi3_imm"
  [(set (match_operand:DI 0 "pic30_register_operand"           "=r,r")
        (minus:DI (match_operand:DI 1 "pic30_register_operand" " 0,0")
                  (match_operand:DI 2 "pic30_JM_operand"       " J,M")))]
  ""
  "@
   sub %0,#%2\;subb %d0,#0\;subb %t0,#0\;subb %q0,#0
   add #%J2,%0\;addc #0,%d0\;addc #0,%t0\;addc #0,%q0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
  ]
)

(define_insn "*subhidi3_se"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (minus:DI
           (sign_extend:DI
              (match_operand:HI 1 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")))
  (clobber (match_scratch:HI 3                   "=&r,&r,&r,&r,&r,&r,&r,&r,&r"))
  ]
  ""
  "*
{
   char *noerrata_patterns[] = {
     /* r,r,r */          \"asr %1,#15,%3\;sub %1,%2,%0\;subb %3,%d2,%d0\;\"
                              \"subb %3,%t2,%t0\;subb %3,%q2,%q0\",

     /* >,r,r */          \"asr %1,#15,%3\;sub %1,%2,%0\;subb %3,%d2,%0\;\"
                              \"subb %3,%t2,%0\;subb %3,%q2,%0\",

     /* >,r,0 */          \"asr %1,#15,%3\;sub %1,%s2,%0\;subb %3,%s2,%0\;\"
                              \"subb %3,%s2,%0\;subb %3,%s2,%0\",

     /* >,r,> */          \"asr %1,#15,%3\;sub %1,%2,%0\;subb %3,%2,%0\;\"
                              \"subb %3,%2,%0\;subb %3,%2,%0\",

     /* r,r,> */          \"asr %1,#15,%3\;sub %1,%2,%0\;subb %3,%2,%d0\;\"
                              \"subb %3,%2,%t0\;subb %3,%2,%q0\",

     /* R,r,r */          \"asr %1,#15,%3\;sub %1,%2,%I0\;subb %3,%d2,%I0\;\"
                              \"subb %3,%t2,%I0\;subb %3,%q2,%0\",

     /* R,r,0 */          \"asr %1,#15,%3\;sub %1,%2,%I0\;subb %3,%2,%I0\;\"
                              \"subb %3,%2,%I0\;subb %3,%2,%0\",

     /* R,r,R */          \"asr %1,#15,%3\;sub %1,%I2,%I0\;subb %3,%I2,%I0\;\"
                              \"subb %3,%I2,%I0\;subb %3,%2,%0\",

     /* r,r,R */          \"asr %1,#15,%3\;sub %1,%I2,%0\;subb %3,%I2,%d0\;\"
                              \"subb %3,%I2,%t0\;subb %3,%2,%q0\",
  };

   char *psv_psv_patterns[] = {
     /* r,r,r */          \"asr %1,#15,%3\;sub %1,%2,%0\;subb %3,%d2,%d0\;\"
                              \"subb %3,%t2,%t0\;subb %3,%q2,%q0\",

     /* >,r,r */          \"asr %1,#15,%3\;sub %1,%2,%0\;subb %3,%d2,%0\;\"
                              \"subb %3,%t2,%0\;subb %3,%q2,%0\",

     /* >,r,0 */          \"asr %1,#15,%3\;sub %1,%s2,%0\;subb %3,%s2,%0\;\"
                              \"subb %3,%s2,%0\;subb %3,%s2,%0\",

     /* >,r,> */          \"asr %1,#15,%3\;\"
                          \"sub %1,%2,%0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%0\",

     /* r,r,> */          \"asr %1,#15,%3\;\"
                          \"sub %1,%2,%0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%d0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%t0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%q0\",

     /* R,r,r */          \"asr %1,#15,%3\;sub %1,%2,%I0\;subb %3,%d2,%I0\;\"
                              \"subb %3,%t2,%I0\;subb %3,%q2,%0\",

     /* R,r,0 */          \"asr %1,#15,%3\;sub %1,%2,%I0\;subb %3,%2,%I0\;\"
                              \"subb %3,%2,%I0\;subb %3,%2,%0\",

     /* R,r,R */          \"asr %1,#15,%3\;\"
                          \"sub %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"subb %3,%I2,%I0\;\"
                          \"nop\;\"
                          \"subb %3,%I2,%I0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%0\",

     /* r,r,R */          \"asr %1,#15,%3\;\"
                          \"sub %1,%I2,%0\;\"
                          \"nop\;\"
                          \"subb %3,%I2,%d0\;\"
                          \"nop\;\"
                          \"subb %3,%I2,%t0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  char **patterns;
  int regno;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
  ]
)

(define_insn "*subhidi3_ze"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (minus:DI
           (zero_extend:DI
              (match_operand:HI 1 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")))
  (clobber (match_scratch:HI 3                   "=X,X,&r,&r,&r,X,&r,&r,&r"))
  ]
  ""
  "*
{
   char *noerrata_patterns[] = {
     /* r,r,r */          \"sub %1,%2,%0\;subbr %d2,#0,%d0\;\"
                              \"subbr %t2,#0,%t0\;subbr %q2,#0,%q0\",

     /* >,r,r */          \"sub %1,%2,%0\;subbr %d2,#0,%0\;\"
                              \"subbr %t2,#0,%0\;subbr %q2,#0,%0\",

     /* >,r,0 */          \"clr %3\;sub %1,%s2,%0\;subb %3,%s2,%0\;\"
                              \"subb %3,%s2,%0\;subb %3,%s2,%0\",

     /* >,r,> */          \"clr %3\;sub %1,%2,%0\;subb %3,%2,%0\;\"
                              \"subb %3,%2,%0\;subb %3,%2,%0\",

     /* r,r,> */          \"clr %3\;sub %1,%2,%0\;subb %3,%2,%d0\;\"
                              \"subb %3,%2,%t0\;subb %3,%2,%q0\",

     /* R,r,r */          \"sub %1,%2,%I0\;subbr %d2,#0,%I0\;\"
                              \"subbr %t2,#0,%I0\;subbr %q2,#0,%0\",

     /* R,r,0 */          \"clr %3\;sub %1,%2,%I0\;subb %3,%2,%I0\;\"
                              \"subb %3,%2,%I0\;subb %3,%2,%0\",

     /* R,r,R */          \"clr %3\;sub %1,%I2,%I0\;subb %3,%I2,%I0\;\"
                              \"subb %3,%I2,%I0\;subb %3,%2,%0\",

     /* r,r,R */          \"clr %3\;sub %1,%I2,%0\;subb %3,%I2,%d0\;\"
                              \"subb %3,%I2,%t0\;subb %3,%2,%q0\",
  };

   char *psv_psv_patterns[] = {
     /* r,r,r */          \"sub %1,%2,%0\;subbr %d2,#0,%d0\;\"
                              \"subbr %t2,#0,%t0\;subbr %q2,#0,%q0\",

     /* >,r,r */          \"sub %1,%2,%0\;subbr %d2,#0,%0\;\"
                              \"subbr %t2,#0,%0\;subbr %q2,#0,%0\",

     /* >,r,0 */          \"clr %3\;sub %1,%s2,%0\;subb %3,%s2,%0\;\"
                              \"subb %3,%s2,%0\;subb %3,%s2,%0\",

     /* >,r,> */          \"clr %3\;\"
                          \"sub %1,%2,%0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%0\",

     /* r,r,> */          \"clr %3\;\"
                          \"sub %1,%2,%0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%d0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%t0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%q0\",

     /* R,r,r */          \"sub %1,%2,%I0\;subbr %d2,#0,%I0\;\"
                              \"subbr %t2,#0,%I0\;subbr %q2,#0,%0\",

     /* R,r,0 */          \"clr %3\;sub %1,%2,%I0\;subb %3,%2,%I0\;\"
                              \"subb %3,%2,%I0\;subb %3,%2,%0\",

     /* R,r,R */          \"clr %3\;\"
                          \"sub %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"subb %3,%I2,%I0\;\"
                          \"nop\;\"
                          \"subb %3,%I2,%I0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%0\",

     /* r,r,R */          \"clr %3\;\"
                          \"sub %1,%I2,%0\;\"
                          \"nop\;\"
                          \"subb %3,%I2,%d0\;\"
                          \"nop\;\"
                          \"subb %3,%I2,%t0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  char **patterns;
  int regno;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
  ]
)

(define_insn "*subsidi3_se"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (minus:DI
           (sign_extend:DI
              (match_operand:SI 1 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")))
  (clobber (match_scratch:HI 3                   "=&r,&r,&r,&r,&r,&r,&r,&r,&r"))
  ]
  ""
  "*
{
   char *noerrata_patterns[] = {
     /* r,r,r */          \"asr %d1,#15,%3\;sub %1,%2,%0\;subb %d1,%d2,%d0\;\"
                              \"subb %3,%t2,%t0\;subb %3,%q2,%q0\",

     /* >,r,r */          \"asr %d1,#15,%3\;sub %1,%2,%0\;subb %d1,%d2,%0\;\"
                              \"subb %3,%t2,%0\;subb %3,%q2,%0\",

     /* >,r,0 */          \"asr %d1,#15,%3\;sub %1,%s2,%0\;subb %d1,%s2,%0\;\"
                              \"subb %3,%s2,%0\;subb %3,%s2,%0\",

     /* >,r,> */          \"asr %d1,#15,%3\;sub %1,%2,%0\;subb %d1,%2,%0\;\"
                              \"subb %3,%2,%0\;subb %3,%2,%0\",

     /* r,r,> */          \"asr %d1,#15,%3\;sub %1,%2,%0\;subb %d1,%2,%d0\;\"
                              \"subb %3,%2,%t0\;subb %3,%2,%q0\",

     /* R,r,r */          \"asr %d1,#15,%3\;sub %1,%2,%I0\;subb %d1,%d2,%I0\;\"
                              \"subb %3,%t2,%I0\;subb %3,%q2,%s0\",

     /* R,r,0 */          \"asr %d1,#15,%3\;sub %1,%2,%I0\;subb %d1,%2,%I0\;\"
                              \"subb %3,%2,%I0\;subb %3,%2,%0\",

     /* R,r,R */          \"asr %d1,#15,%3\;sub %1,%I2,%I0\;subb %d1,%I2,%I0\;\"
                              \"subb %3,%I2,%I0\;subb %3,%2,%0\",

     /* r,r,R */          \"asr %d1,#15,%3\;sub %1,%I2,%0\;subb %d1,%I2,%d0\;\"
                              \"subb %3,%I2,%t0\;subb %3,%2,%q0\",
  };

  char *psv_psv_patterns[] = {
     /* r,r,r */          \"asr %d1,#15,%3\;sub %1,%2,%0\;subb %d1,%d2,%d0\;\"
                              \"subb %3,%t2,%t0\;subb %3,%q2,%q0\",

     /* >,r,r */          \"asr %d1,#15,%3\;sub %1,%2,%0\;subb %d1,%d2,%0\;\"
                              \"subb %3,%t2,%0\;subb %3,%q2,%0\",

     /* >,r,0 */          \"asr %d1,#15,%3\;sub %1,%s2,%0\;subb %d1,%s2,%0\;\"
                              \"subb %3,%s2,%0\;subb %3,%s2,%0\",

     /* >,r,> */          \"asr %d1,#15,%3\;\"
                          \"sub %1,%2,%0\;\"
                          \"nop\;\"
                          \"subb %d1,%2,%0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%0\",

     /* r,r,> */          \"asr %d1,#15,%3\;\"
                          \"sub %1,%2,%0\;\"
                          \"nop\;\"
                          \"subb %d1,%2,%d0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%t0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%q0\",

     /* R,r,r */          \"asr %d1,#15,%3\;sub %1,%2,%I0\;subb %d1,%d2,%I0\;\"
                              \"subb %3,%t2,%I0\;subb %3,%q2,%s0\",

     /* R,r,0 */          \"asr %d1,#15,%3\;sub %1,%2,%I0\;subb %d1,%2,%I0\;\"
                              \"subb %3,%2,%I0\;subb %3,%2,%0\",

     /* R,r,R */          \"asr %d1,#15,%3\;\"
                          \"sub %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"subb %d1,%I2,%I0\;\"
                          \"nop\;\"
                          \"subb %3,%I2,%I0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%0\",

     /* r,r,R */          \"asr %d1,#15,%3\;\"
                          \"sub %1,%I2,%0\;\"
                          \"nop\;\"
                          \"subb %d1,%I2,%d0\;\"
                          \"nop\;\"
                          \"subb %3,%I2,%t0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%q0\",
  };


  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  char **patterns;
  int regno;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }  

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
  ]
)

(define_insn "*subsidi3_ze"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (minus:DI
           (zero_extend:DI
              (match_operand:SI 1 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")))
  (clobber (match_scratch:HI 3                   "=X,X,&r,&r,&r,X,&r,&r,&r"))
  ]
  ""
  "*
{
   char *noerrata_patterns[] = {
     /* r,r,r */          \"sub %1,%2,%0\;subb %d1,%d2,%d0\;\"
                              \"subbr %t2,#0,%t0\;subbr %q2,#0,%q0\",

     /* >,r,r */          \"sub %1,%2,%0\;subb %d1,%d2,%0\;\"
                              \"subbr %t2,#0,%0\;subbr %q2,#0,%0\",

     /* >,r,0 */          \"clr %3\;sub %1,%s2,%0\;subb %d1,%s2,%0\;\"
                              \"subb %3,%s2,%0\;subb %3,%s2,%0\",

     /* >,r,> */          \"clr %3\;sub %1,%2,%0\;subb %d1,%2,%0\;\"
                              \"subb %3,%2,%0\;subb %3,%2,%0\",

     /* r,r,> */          \"clr %3\;sub %1,%2,%0\;subb %d1,%2,%d0\;\"
                              \"subb %3,%2,%t0\;subb %3,%2,%q0\",

     /* R,r,r */          \"sub %1,%2,%I0\;subb %d1,%d2,%I0\;\"
                              \"subbr %t2,#0,%I0\;subbr %q2,#0,%0\",

     /* R,r,0 */          \"clr %3\;sub %1,%2,%I0\;subb %d1,%2,%I0\;\"
                              \"subb %3,%2,%I0\;subb %3,%2,%0\",

     /* R,r,R */          \"clr %3\;sub %1,%I2,%I0\;subb %d1,%I2,%I0\;\"
                              \"subb %3,%I2,%I0\;subb %3,%2,%0\",

     /* r,r,R */          \"clr %3\;sub %1,%I2,%0\;subb %d1,%I2,%d0\;\"
                              \"subb %3,%I2,%t0\;subb %3,%2,%q0\",
  };

  char *psv_psv_patterns[] = {
     /* r,r,r */          \"sub %1,%2,%0\;subb %d1,%d2,%d0\;\"
                              \"subbr %t2,#0,%t0\;subbr %q2,#0,%q0\",

     /* >,r,r */          \"sub %1,%2,%0\;subb %d1,%d2,%0\;\"
                              \"subbr %t2,#0,%0\;subbr %q2,#0,%0\",

     /* >,r,0 */          \"clr %3\;sub %1,%s2,%0\;subb %d1,%s2,%0\;\"
                              \"subb %3,%s2,%0\;subb %3,%s2,%0\",

     /* >,r,> */          \"clr %3\;\"
                          \"sub %1,%2,%0\;\"
                          \"nop\;\"
                          \"subb %d1,%2,%0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%0\",

     /* r,r,> */          \"clr %3\;\"
                          \"sub %1,%2,%0\;\"
                          \"nop\;\"
                          \"subb %d1,%2,%d0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%t0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%q0\",

     /* R,r,r */          \"sub %1,%2,%I0\;subb %d1,%d2,%I0\;\"
                              \"subbr %t2,#0,%I0\;subbr %q2,#0,%0\",

     /* R,r,0 */          \"clr %3\;sub %1,%2,%I0\;subb %d1,%2,%I0\;\"
                              \"subb %3,%2,%I0\;subb %3,%2,%0\",

     /* R,r,R */          \"clr %3\;\"
                          \"sub %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"subb %d1,%I2,%I0\;\"
                          \"nop\;\"
                          \"subb %3,%I2,%I0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%0\",

     /* r,r,R */          \"clr %3\;\"
                          \"sub %1,%I2,%0\;\"
                          \"nop\;\"
                          \"subb %d1,%I2,%d0\;\"
                          \"nop\;\"
                          \"subb %3,%I2,%t0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  char **patterns;
  int regno;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
  ]
)


(define_insn "*subdihi3_se"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (minus:DI
           (match_operand:DI 1 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")
           (sign_extend:DI
              (match_operand:HI 2 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
))
  (clobber (match_scratch:HI 3                   "=&r,&r,&r,&r,&r,&r,&r,&r,&r"))
  ]
  ""
  "*
{
   char *noerrata_patterns[] = {
     /* r,r,r */          \"asr %2,#15,%3\;sub %1,%2,%0\;subb %d1,%3,%d0\;\"
                              \"subb %t1,%3,%t0\;subb %q1,%3,%q0\",

     /* >,r,r */          \"asr %2,#15,%3\;sub %1,%2,%0\;subb %d1,%3,%0\;\"
                              \"subb %t1,%3,%0\;subb %q1,%3,%0\",

     /* >,0,r */          \"asr %2,#15,%3\;subr %2,%s1,%0\;subbr %3,%s1,%0\;\"
                              \"subbr %3,%s1,%0\;subbr %3,%s1,%0\",

     /* >,>,r */          \"asr %2,#15,%3\;subr %2,%1,%0\;subbr %3,%1,%0\;\"
                              \"subbr %3,%1,%0\;subbr %3,%1,%0\",

     /* r,>,r */          \"asr %2,#15,%3\;subr %2,%1,%0\;subbr %3,%1,%d0\;\"
                              \"subbr %3,%1,%t0\;subbr %3,%1,%q0\",

     /* R,r,r */          \"asr %2,#15,%3\;sub %2,%1,%I0\;subbr %3,%d1,%I0\;\"
                              \"subbr %3,%t1,%I0\;subbr %3,%q1,%0\",

     /* R,0,r */          \"asr %2,#15,%3\;subr %2,%1,%I0\;subbr %3,%1,%I0\;\"
                              \"subbr %3,%1,%I0\;subbr %3,%1,%0\",

     /* R,R,r */          \"asr %2,#15,%3\;subr %2,%I1,%I0\;subbr %3,%I1,%I0\;\"
                              \"subbr %3,%I1,%I0\;subbr %3,%1,%0\",

     /* r,R,r */          \"asr %2,#15,%3\;subr %2,%I1,%0\;subbr %3,%I1,%d0\;\"
                              \"subbr %3,%I1,%t0\;subbr %3,%1,%q0\",
  };

  char *psv_psv_patterns[] = {
     /* r,r,r */          \"asr %2,#15,%3\;sub %1,%2,%0\;subb %d1,%3,%d0\;\"
                              \"subb %t1,%3,%t0\;subb %q1,%3,%q0\",

     /* >,r,r */          \"asr %2,#15,%3\;sub %1,%2,%0\;subb %d1,%3,%0\;\"
                              \"subb %t1,%3,%0\;subb %q1,%3,%0\",

     /* >,0,r */          \"asr %2,#15,%3\;subr %2,%s1,%0\;subbr %3,%s1,%0\;\"
                              \"subbr %3,%s1,%0\;subbr %3,%s1,%0\",

     /* >,>,r */          \"asr %2,#15,%3\;\"
                          \"subr %2,%1,%0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%0\",

     /* r,>,r */          \"asr %2,#15,%3\;\"
                          \"subr %2,%1,%0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%d0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%t0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%q0\",

     /* R,r,r */          \"asr %2,#15,%3\;sub %2,%1,%I0\;subbr %3,%d1,%I0\;\"
                              \"subbr %3,%t1,%I0\;subbr %3,%q1,%0\",

     /* R,0,r */          \"asr %2,#15,%3\;subr %2,%1,%I0\;subbr %3,%1,%I0\;\"
                              \"subbr %3,%1,%I0\;subbr %3,%1,%0\",

     /* R,R,r */          \"asr %2,#15,%3\;\"
                          \"subr %2,%I1,%I0\;\"
                          \"nop\;\"
                          \"subbr %3,%I1,%I0\;\"
                          \"nop\;\"
                          \"subbr %3,%I1,%I0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%0\",

     /* r,R,r */          \"asr %2,#15,%3\;\"
                          \"subr %2,%I1,%0\;\"
                          \"nop\;\"
                          \"subbr %3,%I1,%d0\;\"
                          \"nop\;\"
                          \"subbr %3,%I1,%t0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  int regno;
  char **patterns;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[1],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[1],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
  ]
)

(define_insn "*subdihi3_ze"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (minus:DI
           (match_operand:DI 1 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")
           (zero_extend:DI
              (match_operand:HI 2 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
))
  (clobber (match_scratch:HI 3                   "=X,X,&r,&r,&r,X,&r,&r,&r"))
  ]
  ""
  "*
{
   char *noerrata_patterns[] = {
     /* r,r,r */          \"sub %1,%2,%0\;subb %d1,#0,%d0\;\"
                            \"subb %t1,#0,%t0\;subb %q1,#0,%q0\",

     /* >,r,r */          \"sub %1,%2,%0\;subb %d1,#0,%0\;\"
                            \"subb %t1,#0,%0\;subb %q1,#0,%0\",

     /* >,0,r */          \"clr %3\;subr %2,%s1,%0\;subbr %3,%s1,%0\;\"
                            \"subbr %3,%s1,%0\;subbr %3,%s1,%0\",

     /* >,>,r */          \"clr %3\;subr %2,%1,%0\;subbr %3,%1,%0\;\"
                            \"subbr %3,%1,%0\;subbr %3,%1,%0\",

     /* r,>,r */          \"clr %3\;subr %2,%1,%0\;subbr %3,%1,%d0\;\"
                            \"subbr %3,%1,%t0\;subbr %3,%1,%q0\",

     /* R,r,r */          \"sub %1,%2,%I0\;subbr %d1,#0,%I0\;\"
                            \"subbr %t1,#0,%I0\;subbr %q1,#0,%0\",

     /* R,0,r */          \"clr %3\;subr %2,%1,%I0\;subbr %3,%1,%I0\;\"
                            \"subbr %3,%1,%I0\;subbr %3,%1,%0\",

     /* R,R,r */          \"clr %3\;subr %2,%I1,%I0\;subbr %3,%I1,%I0\;\"
                            \"subbr %3,%I1,%I0\;subbr %3,%1,%0\",

     /* r,R,r */          \"clr %3\;subr %2,%I1,%0\;subbr %3,%I1,%d0\;\"
                              \"subbr %3,%I1,%t0\;subbr %3,%1,%q0\",
  };

  char *psv_psv_patterns[] = {
     /* r,r,r */          \"sub %1,%2,%0\;subb %d1,#0,%d0\;\"
                            \"subb %t1,#0,%t0\;subb %q1,#0,%q0\",

     /* >,r,r */          \"sub %1,%2,%0\;subb %d1,#0,%0\;\"
                            \"subb %t1,#0,%0\;subb %q1,#0,%0\",

     /* >,0,r */          \"clr %3\;subr %2,%s1,%0\;subbr %3,%s1,%0\;\"
                            \"subbr %3,%s1,%0\;subbr %3,%s1,%0\",

     /* >,>,r */          \"clr %3\;\"
                          \"subr %2,%1,%0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%0\",

     /* r,>,r */          \"clr %3\;\"
                          \"subr %2,%1,%0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%d0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%t0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%q0\",

     /* R,r,r */          \"sub %1,%2,%I0\;subbr %d1,#0,%I0\;\"
                            \"subbr %t1,#0,%I0\;subbr %q1,#0,%0\",

     /* R,0,r */          \"clr %3\;subr %2,%1,%I0\;subbr %3,%1,%I0\;\"
                            \"subbr %3,%1,%I0\;subbr %3,%1,%0\",

     /* R,R,r */          \"clr %3\;\"
                          \"subr %2,%I1,%I0\;\"
                          \"nop\;\"
                          \"subbr %3,%I1,%I0\;\"
                          \"nop\;\"
                          \"subbr %3,%I1,%I0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%0\",

     /* r,R,r */          \"clr %3\;\"
                          \"subr %2,%I1,%0\;\"
                          \"nop\;\"
                          \"subbr %3,%I1,%d0\;\"
                          \"nop\;\"
                          \"subbr %3,%I1,%t0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%q0\",
  };


  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  char **patterns;
  int regno;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[1],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[1],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
  ]
)

(define_insn "*subdisi3_se"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (minus:DI
           (match_operand:DI 1 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")
           (sign_extend:DI
              (match_operand:SI 2 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
))
  (clobber (match_scratch:HI 3                   "=&r,&r,&r,&r,&r,&r,&r,&r,&r"))
  ]
  ""
  "*
{
   char *noerrata_patterns[] = {
     /* r,r,r */          \"asr %d2,#15,%3\;sub %1,%2,%0\;subb %d1,%d2,%d0\;\"
                             \"subb %t1,%3,%t0\;subb %q1,%3,%q0\",
             
     /* >,r,r */          \"asr %d2,#15,%3\;sub %1,%2,%0\;subb %d1,%d2,%0\;\"
                             \"subb %t1,%3,%0\;subb %q1,%3,%0\",
             
     /* >,0,r */          \"asr %d2,#15,%3\;subr %2,%s1,%0\;subbr %d2,%s1,%0\;\"
                             \"subbr %3,%s1,%0\;subbr %3,%s1,%0\",
             
     /* >,>,r */          \"asr %d2,#15,%3\;subr %2,%1,%0\;subbr %d2,%1,%0\;\"
                             \"subbr %3,%1,%0\;subbr %3,%1,%0\",
             
     /* r,>,r */          \"asr %d2,#15,%3\;subr %2,%1,%0\;subbr %d2,%1,%d0\;\"
                             \"subbr %3,%1,%t0\;subbr %3,%1,%q0\",
             
     /* R,r,r */          \"asr %d2,#15,%3\;sub %1,%2,%I0\;subb %d1,%d2,%I0\;\"
                             \"subb %t1,%3,%I0\;subb %q1,%3,%s0\",
             
     /* R,0,r */          \"asr %d2,#15,%3\;subr %2,%1,%I0\;subbr %d2,%1,%I0\;\"
                             \"subbr %3,%1,%I0\;subbr %3,%1,%0\",
             
     /* R,R,r */          \"asr %d2,#15,%3\;subr %2,%I1,%I0\;subbr %d2,%I1,%I0\;\"
                             \"subbr %3,%I1,%I0\;subbr %3,%1,%0\",
             
     /* r,R,r */          \"asr %d2,#15,%3\;subr %2,%I1,%0\;subbr %d2,%I1,%d0\;\"
                              \"subbr %3,%I1,%t0\;subbr %3,%1,%q0\",
  };

  char *psv_psv_patterns[] = {
     /* r,r,r */          \"asr %d2,#15,%3\;sub %1,%2,%0\;subb %d1,%d2,%d0\;\"
                             \"subb %t1,%3,%t0\;subb %q1,%3,%q0\",
             
     /* >,r,r */          \"asr %d2,#15,%3\;sub %1,%2,%0\;subb %d1,%d2,%0\;\"
                             \"subb %t1,%3,%0\;subb %q1,%3,%0\",
             
     /* >,0,r */          \"asr %d2,#15,%3\;subr %2,%s1,%0\;subbr %d2,%s1,%0\;\"
                             \"subbr %3,%s1,%0\;subbr %3,%s1,%0\",
             
     /* >,>,r */          \"asr %d2,#15,%3\;\"
                          \"subr %2,%1,%0\;\"
                          \"nop\;\"
                          \"subbr %d2,%1,%0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%0\",
             
     /* r,>,r */          \"asr %d2,#15,%3\;\"
                          \"subr %2,%1,%0\;\"
                          \"nop\;\"
                          \"subbr %d2,%1,%d0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%t0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%q0\",
             
     /* R,r,r */          \"asr %d2,#15,%3\;sub %1,%2,%I0\;subb %d1,%d2,%I0\;\"
                             \"subb %t1,%3,%I0\;subb %q1,%3,%s0\",
             
     /* R,0,r */          \"asr %d2,#15,%3\;subr %2,%1,%I0\;subbr %d2,%1,%I0\;\"
                             \"subbr %3,%1,%I0\;subbr %3,%1,%0\",
             
     /* R,R,r */          \"asr %d2,#15,%3\;\"
                          \"subr %2,%I1,%I0\;\"
                          \"nop\;\"
                          \"subbr %d2,%I1,%I0\;\"
                          \"nop\;\"
                          \"subbr %3,%I1,%I0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%0\",
             
     /* r,R,r */          \"asr %d2,#15,%3\;\"
                          \"subr %2,%I1,%0\;\"
                          \"nop\;\"
                          \"subbr %d2,%I1,%d0\;\"
                          \"nop\;\"
                          \"subbr %3,%I1,%t0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  char **patterns;
  int regno;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }  

              x = XEXP(operands[1],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[1],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
  ]
)

(define_insn "*subdisi3_ze"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (minus:DI
           (match_operand:DI 1 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")
           (zero_extend:DI
              (match_operand:SI 2 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
))
  (clobber (match_scratch:HI 3                   "=X,X,&r,&r,&r,X,&r,&r,&r"))
  ]
  ""
  "*
{
   char *noerrata_patterns[] = {
     /* r,r,r */          \"sub %1,%2,%0\;subb %d1,%d2,%d0\;\"
                              \"subb %t1,#0,%t0\;subb %q1,#0,%q0\",
             
     /* >,r,r */          \"sub %1,%2,%0\;subb %d1,%d2,%0\;\"
                              \"subb %t1,#0,%0\;subb %q1,#0,%s0\",
             
     /* >,0,r */          \"clr %3\;subr %2,%s1,%0\;subbr %d2,%s1,%0\;\"
                              \"subbr %3,%s1,%0\;subbr %3,%s1,%0\",
             
     /* >,>,r */          \"clr %3\;subr %2,%1,%0\;subbr %d2,%1,%0\;\"
                              \"subbr %3,%1,%0\;subbr %3,%1,%0\",
             
     /* r,>,r */          \"clr %3\;subr %2,%1,%0\;subbr %d2,%1,%d0\;\"
                              \"subbr %3,%1,%t0\;subbr %3,%1,%q0\",
             
     /* R,r,r */          \"sub %1,%2,%I0\;subb %d1,%d2,%I0\;\"
                              \"subb %t1,#0,%I0\;subb %q1,#0,%0\",
             
     /* R,0,r */          \"clr %3\;subr %2,%1,%I0\;subbr %d2,%1,%I0\;\"
                              \"subbr %3,%1,%I0\;subbr %3,%1,%0\",
             
     /* R,R,r */          \"clr %3\;subr %2,%I1,%I0\;subbr %d2,%I1,%I0\;\"
                              \"subbr %3,%I1,%I0\;subbr %3,%1,%0\",
             
     /* r,R,r */          \"clr %3\;subr %2,%I1,%0\;subbr %d2,%I1,%d0\;\"
                              \"subbr %3,%I1,%t0\;subbr %3,%1,%q0\",
  };

  char *psv_psv_patterns[] = {
     /* r,r,r */          \"sub %1,%2,%0\;subb %d1,%d2,%d0\;\"
                              \"subb %t1,#0,%t0\;subb %q1,#0,%q0\",
             
     /* >,r,r */          \"sub %1,%2,%0\;subb %d1,%d2,%0\;\"
                              \"subb %t1,#0,%0\;subb %q1,#0,%s0\",
             
     /* >,0,r */          \"clr %3\;subr %2,%s1,%0\;subbr %d2,%s1,%0\;\"
                              \"subbr %3,%s1,%0\;subbr %3,%s1,%0\",
             
     /* >,>,r */          \"clr %3\;\"
                          \"subr %2,%1,%0\;\"
                          \"nop\;\"
                          \"subbr %d2,%1,%0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%0\",
             
     /* r,>,r */          \"clr %3\;\"
                          \"subr %2,%1,%0\;\"
                          \"nop\;\"
                          \"subbr %d2,%1,%d0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%t0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%q0\",
             
     /* R,r,r */          \"sub %1,%2,%I0\;subb %d1,%d2,%I0\;\"
                              \"subb %t1,#0,%I0\;subb %q1,#0,%0\",
             
     /* R,0,r */          \"clr %3\;subr %2,%1,%I0\;subbr %d2,%1,%I0\;\"
                              \"subbr %3,%1,%I0\;subbr %3,%1,%0\",
             
     /* R,R,r */          \"clr %3\;\"
                          \"subr %2,%I1,%I0\;\"
                          \"nop\;\"
                          \"subbr %d2,%I1,%I0\;\"
                          \"nop\;\"
                          \"subbr %3,%I1,%I0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%0\",
             
     /* r,R,r */          \"clr %3\;\"
                          \"subr %2,%I1,%0\;\"
                          \"nop\;\"
                          \"subbr %d2,%I1,%d0\;\"
                          \"nop\;\"
                          \"subbr %3,%I1,%t0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%q0\",
  };


  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  char **patterns;
  int regno;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[1],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[1],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
  ]
)

;(define_insn "subdi3"
;  [(set (match_operand:DI 0 "pic30_register_operand"          "=r")
;        (minus:DI (match_operand:DI 1 "pic30_register_operand" "r")
;                  (match_operand:DI 2 "pic30_register_operand" "r")))]
;  ""
;  "sub %1,%2,%0\;subb %d1,%d2,%d0\;subb %t1,%t2,%t0\;subb %q1,%q2,%q0"
;  [
;   (set_attr "cc" "math")
;   (set_attr "type" "def")
;  ]
;)

(define_insn "subdi3"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (minus:DI
           (match_operand:DI 1 "pic30_register_operand"    "r,r,r,r, r,r,r,r, r")
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")))
  ]
  ""
  "*
{
   char *noerrata_patterns[] = {
     /* r,r,r */          \"sub %1,%2,%0\;subb %d1,%d2,%d0\;\"
                              \"subb %t1,%t2,%t0\;subb %q1,%q2,%q0\",

     /* >,r,r */          \"sub %1,%2,%0\;subb %d1,%d2,%0\;\"
                              \"subb %t1,%t2,%0\;subb %q1,%q2,%0\",

     /* >,r,0 */          \"sub %1,%s2,%0\;subb %d1,%s2,%0\;\"
                              \"subb %t1,%s2,%0\;subb %q1,%s2,%0\",

     /* >,r,> */          \"sub %1,%2,%0\;subb %d1,%2,%0\;\"
                              \"subb %t1,%2,%0\;subb %q1,%2,%0\",

     /* r,r,> */          \"sub %1,%2,%0\;subb %d1,%2,%d0\;\"
                              \"subb %t1,%2,%t0\;subb %q1,%2,%q0\",

     /* R,r,r */          \"sub %1,%2,%I0\;subb %d1,%d2,%I0\;\"
                              \"subb %t1,%t2,%I0\;subb %q1,%q2,%0\",

     /* R,r,0 */          \"sub %1,%2,%I0\;subb %d1,%2,%I0\;\"
                              \"subb %t1,%2,%I0\;subb %q1,%2,%0\",

     /* R,r,R */          \"sub %1,%I2,%I0\;subb %d1,%I2,%I0\;\"
                              \"subb %t1,%I2,%I0\;subb %q1,%2,%0\",

     /* r,r,R */          \"sub %1,%I2,%0\;subb %d1,%I2,%d0\;\"
                              \"subb %t1,%I2,%t0\;subb %q1,%2,%q0\",
  };

  char *psv_psv_patterns[] = {
     /* r,r,r */          \"sub %1,%2,%0\;subb %d1,%d2,%d0\;\"
                              \"subb %t1,%t2,%t0\;subb %q1,%q2,%q0\",

     /* >,r,r */          \"sub %1,%2,%0\;subb %d1,%d2,%0\;\"
                              \"subb %t1,%t2,%0\;subb %q1,%q2,%0\",

     /* >,r,0 */          \"sub %1,%s2,%0\;subb %d1,%s2,%0\;\"
                              \"subb %t1,%s2,%0\;subb %q1,%s2,%0\",

     /* >,r,> */          \"sub %1,%2,%0\;\"
                          \"nop\;\"
                          \"subb %d1,%2,%0\;\"
                          \"nop\;\"
                          \"subb %t1,%2,%0\;\"
                          \"nop\;\"
                          \"subb %q1,%2,%0\",

     /* r,r,> */          \"sub %1,%2,%0\;\"
                          \"nop\;\"
                          \"subb %d1,%2,%d0\;\"
                          \"nop\;\"
                          \"subb %t1,%2,%t0\;\"
                          \"nop\;\"
                          \"subb %q1,%2,%q0\",

     /* R,r,r */          \"sub %1,%2,%I0\;subb %d1,%d2,%I0\;\"
                              \"subb %t1,%t2,%I0\;subb %q1,%q2,%0\",

     /* R,r,0 */          \"sub %1,%2,%I0\;subb %d1,%2,%I0\;\"
                              \"subb %t1,%2,%I0\;subb %q1,%2,%0\",

     /* R,r,R */          \"sub %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"subb %d1,%I2,%I0\;\"
                          \"nop\;\"
                          \"subb %t1,%I2,%I0\;\"
                          \"nop\;\"
                          \"subb %q1,%2,%0\",

     /* r,r,R */          \"sub %1,%I2,%0\;\"
                          \"nop\;\"
                          \"subb %d1,%I2,%d0\;\"
                          \"nop\;\"
                          \"subb %t1,%I2,%t0\;\"
                          \"nop\;\"
                          \"subb %q1,%2,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  char **patterns;
  int regno;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
  ]
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; multiply instructions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; 16-bit product

;; 8 x 8 => 16 (unsigned)

(define_expand "umulqihi3"
  [(set (match_operand:HI 0 "pic30_register_operand" "")
    (mult:HI 
      (zero_extend:HI (match_operand:QI 1 "pic30_register_operand" ""))
      (zero_extend:HI (match_operand:QI 2 "pic30_reg_imm_or_near_operand" ""))))
  ]
;; NULLSTONE CSE fails when enabled
  "0"
  "
  {
    if (GET_CODE(operands[2]) == CONST_INT) {
      int pow2 = INTVAL(operands[2]);
      if (pic30_one_bit_set_p(pow2)) {
        emit_insn(gen_umulqihi3pow2(operands[0], operands[1], operands[2]));
      } else {
        emit_insn(gen_umulqihi3imm(operands[0], operands[1], operands[2]));
      }
    } else {
      emit_insn(gen_umulqihi3gen(operands[0], operands[1], operands[2]));
    }
    DONE;
  }"
)

(define_insn "umulqihi3gen"
  [(set (match_operand:HI     0 "pic30_creg_operand"       "=c,c")
        (mult:HI 
          (zero_extend:HI 
            (match_operand:QI 1 "pic30_wreg_operand"       "%a,a"))
          (zero_extend:HI 
            (match_operand:QI 2 "pic30_reg_or_near_operand" "r,U"))))]
  ""
  "@
   mul.b %m2
   mul.b %2"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def")
  ]
)

(define_insn "umulqihi3imm"
  [(set (match_operand:HI 0 "pic30_creg_operand" "=c")
        (mult:HI 
          (zero_extend:HI (match_operand:QI 1 "pic30_wreg_operand" "%a"))
          (match_operand:HI 2 "immediate_operand" "i")))
  ]
; Ensure the operand fits in a byte
  "(((INTVAL(operands[2])) & 0xFF) == (INTVAL(operands[2])))"
  "mov.b #%2,%0\;mul.b %m0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def")
  ]
)

(define_insn "umulqihi3pow2"
  [(set (match_operand:HI 0 "pic30_register_operand"                   "=r")
        (mult:HI 
          (zero_extend:HI (match_operand:QI 1 "pic30_register_operand" "%r"))
          (match_operand:HI 2 "immediate_operand"                       "i")))]
  "(pic30_one_bit_set(GET_MODE(operands[0]),operands[2],1))"
  "ze %1,%0\;sl %0,#%b2,%0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

;; 16 x 16 => 16

;; this expansion is helpful in constant propagation
;; (but in general, it leads to code expansion, since
;; it causes all integer multiplication to be inline)

(define_expand "mulhi3"
  [(set (match_operand:HI 0 "pic30_register_operand" "")
        (mult:HI (match_operand:HI 1 "pic30_register_operand" "")
                 (match_operand:HI 2 "pic30_reg_or_imm_operand" "")))]
  ""
  "
{ rtx temp_reg = 0, temp_opnd1 = 0, temp_opnd2 = 0;
  int valid_immediate = 0;

  if (immediate_operand(operands[2], VOIDmode)) {
    if (INTVAL(operands[2]) == 2) {
      emit_insn(gen_mulhi3imm(operands[0], operands[1], operands[2]));
      DONE;
    } else if (pic30_P_operand(operands[2],VOIDmode)) {
      valid_immediate = 1;
    } else {
      temp_opnd2  = gen_reg_rtx(HImode);

      emit_move_insn(temp_opnd2, operands[2]);
    }
  }
  if (pic30_ecore_target()) {
    if (valid_immediate) {
      emit_insn(
        gen_mulhi3imm(operands[0],
                        temp_opnd1 ? temp_opnd1 : operands[1],
                        temp_opnd2 ? temp_opnd2 : operands[2])
      );
    } else {
      emit_insn(
        gen_emulhi3(operands[0],
                    temp_opnd1 ? temp_opnd1 : operands[1],
                    temp_opnd2 ? temp_opnd2 : operands[2])
      );
    }
  } else {
    temp_reg = gen_reg_rtx(SImode);
    if (valid_immediate) {
      emit_insn(
        gen_mulhisi3_imm(temp_reg,
                         temp_opnd1 ? temp_opnd1 : operands[1],
                         temp_opnd2 ? temp_opnd2 : operands[2])
      );
    } else {
      emit_insn(
        gen_mulhisi3(temp_reg,
                     temp_opnd1 ? temp_opnd1 : operands[1],
                     temp_opnd2 ? temp_opnd2 : operands[2])
      );
    }
    convert_move(operands[0], temp_reg, 0);
  }
  DONE;
}")

(define_expand "mulp16apsv3"
  [(set (match_operand:P16APSV 0 "pic30_register_operand" "")
        (mult:P16APSV 
          (match_operand:P16APSV 1 "pic30_reg_or_near_operand" "")
          (match_operand:P16APSV 2 "pic30_reg_or_imm_operand" "")))]
  ""
  "
{ rtx temp_reg = 0, temp_opnd1 = 0, temp_opnd2 = 0;
  int valid_immediate = 0;

  if (immediate_operand(operands[2], VOIDmode)) {
    if (INTVAL(operands[2]) == 2) {
      emit_insn(gen_mulp16apsvsi3_imm(operands[0], operands[1], operands[2]));
      DONE;
    } else if (pic30_P_operand(operands[2],VOIDmode)) {
      valid_immediate = 1;
    } else {
      temp_opnd2  = gen_reg_rtx(HImode);

      emit_move_insn(temp_opnd2, operands[2]);
    }
  }
  if (pic30_near_operand(operands[1], HImode)) {
    temp_opnd1 = gen_reg_rtx(HImode);
    
    emit_move_insn(temp_opnd1, operands[1]);
  }
  if (pic30_ecore_target()) {
    if (valid_immediate) {
      emit_insn(
        gen_mulp16apsv3_imm(operands[0],
                             temp_opnd1 ? temp_opnd1 : operands[1],
                             temp_opnd2 ? temp_opnd2 : operands[2])
      );
    } else {
      emit_insn(
        gen_mulp16apsv3(operands[0],
                         temp_opnd1 ? temp_opnd1 : operands[1],
                         temp_opnd2 ? temp_opnd2 : operands[2])
      );
    }
  } else {
    temp_reg = gen_reg_rtx(SImode);
    if (valid_immediate) {
      emit_insn(
        gen_mulp16apsvsi3_imm(temp_reg,
                              temp_opnd1 ? temp_opnd1 : operands[1],
                              temp_opnd2 ? temp_opnd2 : operands[2])
      );
    } else {
      emit_insn(
        gen_mulp16apsvsi3(temp_reg,
                          temp_opnd1 ? temp_opnd1 : operands[1],
                          temp_opnd2 ? temp_opnd2 : operands[2])
      );
    }
    convert_move(operands[0], temp_reg, 0);
  }
  DONE;
}")

(define_insn "mulhi3imm_DATA"
  [(set (match_operand:HI 0 "pic30_mode2_operand"         "=a,r<>,r<>,R,R")
        (mult:HI 
            (match_operand:HI 1 "pic30_near_mode2_operand" "U,r,  R<>,r,R<>")
            (match_operand:HI 2 "immediate_operand"        "i,i,  i,  i,i")))]
  "(INTVAL(operands[2]) == 2)"
  "@
     sl %1,WREG
     sl %1,%0
     sl %1,%0
     sl %1,%0
     sl %1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,def,defuse,use,use")
  ]
)

(define_insn "mulhi3imm_APSV"
  [(set (match_operand:HI 0 "pic30_mode2_operand"              "=a,r<>,r<>,R,R")
        (mult:HI 
          (match_operand:HI 1 "pic30_near_mode2_APSV_operand" "U,r,R<>,r,R<>")
          (match_operand:HI 2 "immediate_operand"             "i,i,  i,  i,i")))
  ]
  "(INTVAL(operands[2]) == 2)"
  "@
     sl %1,WREG
     sl %1,%0
     sl %1,%0
     sl %1,%0
     sl %1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,def,defuse,use,use")
  ]
)

(define_expand "mulhi3imm"
  [(set (match_operand:HI 0 "pic30_mode2_operand" "=a,r<>,r<>,R,R")
        (mult:HI
            (match_operand:HI 1 "pic30_near_mode2_APSV_operand" "U,r,R<>,r,R<>")
            (match_operand:HI 2 "immediate_operand" "i,i,  i,  i,i")))]
  "(INTVAL(operands[2]) == 2)"
  "
{
  if (pic30_near_mode2_operand(operands[1],GET_MODE(operands[1])))
    emit(gen_mulhi3imm_DATA(operands[0],operands[1],operands[2]));
  else
    emit(gen_mulhi3imm_APSV(operands[0],operands[1],operands[2]));
  DONE;
}")

; 32-bit product
; /* *_extend of an immediate_operand is illegal, apparantly 
;    so need two separate sequences */

(define_insn "umulhisi3imm"
  [(set (match_operand:SI 0 "pic30_register_operand"      "=r")
        (mult:SI 
          (zero_extend:SI 
             (match_operand:HI 1 "pic30_register_operand" "%r"))
          (match_operand:SI 2 "pic30_P_operand"            "P")))]
  ""
  "mul.uu %1,#%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def")
  ]
)

(define_insn "umulhisi3_DATA"
  [(set (match_operand:SI     0 "pic30_register_operand" "=r,r")
        (mult:SI 
          (zero_extend:SI 
            (match_operand:HI 1 "pic30_register_operand" "%r,r"))
          (zero_extend:SI 
            (match_operand:HI 2 "pic30_mode2_operand"    "r,R<>"))))]
  ""
  "mul.uu %1,%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,defuse")
  ]
)

(define_insn "umulhisi3_APSV"
  [(set (match_operand:SI     0 "pic30_register_operand"  "=r,r")
        (mult:SI 
          (zero_extend:SI 
            (match_operand:HI 1 "pic30_register_operand"  "%r,r"))
          (zero_extend:SI 
            (match_operand:HI 2 "pic30_mode2_APSV_operand" "r,R<>"))))]
  ""
  "mul.uu %1,%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,defuse")
  ]
)

(define_expand "umulhisi3"
  [(set (match_operand:SI     0 "pic30_register_operand" "=r,r")
        (mult:SI
          (zero_extend:SI
            (match_operand:HI 1 "pic30_register_operand" "%r,r"))
          (zero_extend:SI
            (match_operand:HI 2 "pic30_mode2_APSV_operand"    "r,R<>"))))]
  ""
  "
{
  if (pic30_mode2_operand(operands[2], GET_MODE(operands[2]))) {
    emit(
      gen_umulhisi3_DATA(operands[0], operands[1], operands[2])
    );
  } else {
    emit(
      gen_umulhisi3_APSV(operands[0], operands[1], operands[2])
    );
  }
  DONE;
}")

(define_insn "mulp16apsv3imm_DATA"
  [(set (match_operand:P16APSV 0 "pic30_mode2_operand"       "=a,r<>,r<>,R,R")
        (mult:P16APSV 
          (match_operand:P16APSV 1 "pic30_near_mode2_operand" "U,r,  R<>,r,R<>")
          (match_operand:P16APSV 2 "immediate_operand"        "i,i,  i,  i,i")))
  ]
  "(INTVAL(operands[2]) == 2)"
  "@
     sl %1,WREG
     sl %1,%0
     sl %1,%0
     sl %1,%0
     sl %1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,def,defuse,use,use")
  ]
)

(define_insn "mulp16apsv3imm_APSV"
  [(set (match_operand:P16APSV 0 "pic30_mode2_operand"         "=a,r<>,r<>,R,R")
        (mult:P16APSV 
            (match_operand:P16APSV 1 "pic30_near_mode2_APSV_operand" "U,r,R<>,r,R<>")
            (match_operand:P16APSV 2 "immediate_operand" "i,i,  i,  i,i")))]
  "(INTVAL(operands[2]) == 2)"
  "@
     sl %1,WREG
     sl %1,%0
     sl %1,%0
     sl %1,%0
     sl %1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,def,defuse,use,use")
  ]
)

(define_expand "emulp16apsv3imm"
  [(set (match_operand:P16APSV 0 "pic30_mode2_operand" "=a,D<>,D<>,R,R")
        (mult:P16APSV
          (match_operand:P16APSV 1 "pic30_near_mode2_APSV_operand" "U,D,R<>,D,R<>")
          (match_operand:P16APSV 2 "immediate_operand" "i,i,  i,  i,i")))]
  "(INTVAL(operands[2]) == 2) && pic30_ecore_target()"
  "
{
  if (pic30_near_mode2_operand(operands[1],GET_MODE(operands[1])))
    emit(gen_mulp16apsv3imm_DATA(operands[0],operands[1],operands[2]));
  else
    emit(gen_mulp16apsv3imm_APSV(operands[0],operands[1],operands[2]));
  DONE;
}")

; 32-bit product
; /* *_extend of an immediate_operand is illegal, apparantly 
;    so need two separate sequences */

(define_insn "umulp16apsvsi3imm"
  [(set (match_operand:SI 0 "pic30_register_operand"                      "=r")
    (mult:SI (zero_extend:SI (match_operand:P16APSV 1 "pic30_register_operand" "%r"))
             (match_operand:SI 2 "pic30_P_operand"                   "P")))]
  ""
  "mul.uu %1,#%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def")
  ]
)

(define_insn "*umulp16apsvsi3sfr"
  [(set (match_operand:SI     0 "pic30_register_operand"         "=C,C,&r,r")
        (mult:SI 
          (zero_extend:SI 
            (match_operand:P16APSV 1 "pic30_wreg_operand"        "%a,a, a,a"))
          (zero_extend:SI 
            (match_operand:P16APSV 2 "pic30_reg_or_near_operand" " r,U, U,r"))))]
  ""
  "@
   mul.w %m2
   mul.w %2
   mov %2,%0\;mul.uu %1,%0,%0
   mul.uu %1,%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def")
  ]
)

;; 16 x 16 => 32 (signed)

;; /* *_extend of an immediate_operand is illegal, apparantly -
;;   so need separate patterns */

(define_insn "mulhisi3_imm"
  [(set (match_operand:SI 0 "pic30_register_operand"    "=r")
        (mult:SI 
          (sign_extend:SI (match_operand:HI 1 "pic30_register_operand" "%r"))
                          (match_operand:SI 2 "pic30_P_operand"        "P")))]
  ""
  "mul.su %1,#%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def")
  ]
)

(define_insn "mulhisi3_DATA"
  [(set (match_operand:SI     0 "pic30_register_operand" "=r,r")
        (mult:SI 
          (sign_extend:SI 
            (match_operand:HI 1 "pic30_register_operand" "%r,r"))
          (sign_extend:SI 
            (match_operand:HI 2 "pic30_mode2_operand"    "r,R<>"))))]
  ""
  "mul.ss %1,%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,defuse")
  ]
)

(define_insn "mulhisi3_APSV"
  [(set (match_operand:SI     0 "pic30_register_operand" "=r,r")
        (mult:SI 
          (sign_extend:SI 
            (match_operand:HI 1 "pic30_register_operand" "%r,r"))
          (sign_extend:SI 
            (match_operand:HI 2 "pic30_mode2_APSV_operand"    "r,R<>"))))]
  ""
  "mul.ss %1,%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,defuse")
  ]
)

(define_expand "mulhisi3"
  [(set (match_operand:SI     0 "pic30_register_operand" "=r,r")
        (mult:SI
          (sign_extend:SI
            (match_operand:HI 1 "pic30_register_operand" "%r,r"))
          (sign_extend:SI
            (match_operand:HI 2 "pic30_mode2_APSV_operand"    "r,R<>"))))]
  ""
  "
{
  if (pic30_mode2_operand(operands[2],GET_MODE(operands[2])))
    emit(gen_mulhisi3_DATA(operands[0],operands[1],operands[2]));
  else
    emit(gen_mulhisi3_APSV(operands[0],operands[1],operands[2]));
  DONE;
}")

(define_insn "mulp16apsvsi3_imm"
  [(set (match_operand:SI 0 "pic30_register_operand"    "=r")
        (mult:SI 
          (sign_extend:SI (match_operand:P16APSV 1 "pic30_register_operand" "%r"))
                          (match_operand:SI 2 "pic30_P_operand"        "P")))]
  ""
  "mul.su %1,#%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def")
  ]
)

(define_insn "mulp16apsvsi3_DATA"
  [(set (match_operand:SI  0 "pic30_accum_or_reg_operand" "=r,r, w")
        (mult:SI 
          (sign_extend:SI 
            (match_operand 1 "pic30_register_operand"     "%r,r, z"))
          (sign_extend:SI 
            (match_operand 2 "pic30_mode2_operand"        "r,R<>,z"))))]
  ""
  "@
   mul.ss %1,%2,%0
   mul.ss %1,%2,%0
   mpy %1*%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,defuse,def")
  ]
)

(define_insn "mulp16apsvsi3_APSV"
  [(set (match_operand:SI     0 "pic30_register_operand" "=r,r")
        (mult:SI 
          (sign_extend:SI 
            (match_operand 1 "pic30_register_operand" "%r,r"))
          (sign_extend:SI 
            (match_operand 2 "pic30_mode2_APSV_operand"    "r,R<>"))))]
  ""
  "mul.ss %1,%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,defuse")
  ]
)

(define_expand "mulp16apsvsi3"
  [(set (match_operand:SI     0 "pic30_accum_or_reg_operand" "=r,r")
        (mult:SI
          (sign_extend:SI
            (match_operand:P16APSV 1 "pic30_register_operand" "%r,r"))
          (sign_extend:SI
            (match_operand:P16APSV 2 "pic30_mode2_APSV_operand"    "r,R<>"))))]
  ""
  "
{
  if (pic30_mode2_operand(operands[2],GET_MODE(operands[2])))
    emit(gen_mulp16apsvsi3_DATA(operands[0],operands[1],operands[2]));
  else
    emit(gen_mulp16apsvsi3_APSV(operands[0],operands[1],operands[2]));
  DONE;
}")


(define_insn "umulhip32eds3_imm"
  [(set (match_operand:P32EDS 0 "pic30_register_operand" "=r")
    (mult:P32EDS 
      (zero_extend:P32EDS 
        (match_operand:HI     1 "pic30_register_operand" "%r"))
      (match_operand:P32EDS   2 "pic30_P_operand"                   "P")))]
  ""
  "mul.uu %1,#%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def")
  ]
)

(define_insn "umulhip32eds3_DATA"
  [(set (match_operand:P32EDS 0 "pic30_register_operand" "=r,r")
        (mult:P32EDS 
          (zero_extend:P32EDS 
            (match_operand:HI 1 "pic30_register_operand" "%r,r"))
          (zero_extend:P32EDS 
            (match_operand:HI 2 "pic30_mode2_operand"    "r,R<>"))))]
  ""
  "mul.uu  %1,%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,defuse")
  ]
)

(define_insn "umulhip32eds3_APSV"
  [(set (match_operand:P32EDS 0 "pic30_register_operand" "=r,r")
        (mult:P32EDS 
          (zero_extend:P32EDS 
            (match_operand:HI 1 "pic30_register_operand" "%r,r"))
          (zero_extend:P32EDS 
            (match_operand:HI 2 "pic30_mode2_APSV_operand"    "r,R<>"))))]
  ""
  "mul.uu  %1,%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,defuse")
  ]
)

(define_expand "umulhip32eds3"
  [(set (match_operand:P32EDS 0 "pic30_register_operand" "=r,r")
        (mult:P32EDS
          (zero_extend:P32EDS
            (match_operand:HI 1 "pic30_register_operand" "%r,r"))
          (zero_extend:P32EDS
            (match_operand:HI 2 "pic30_mode2_APSV_operand"    "r,R<>"))))]
  ""
  "
{
  if (pic30_mode2_operand(operands[2],GET_MODE(operands[2])))
    emit(gen_umulhip32eds3_DATA(operands[0],operands[1],operands[2]));
  else
    emit(gen_umulhip32eds3_APSV(operands[0],operands[1],operands[2]));
  DONE;
}")

(define_insn "umulhip32peds3_imm"
  [(set (match_operand:P32PEDS 0 "pic30_register_operand" "=r")
    (mult:P32PEDS 
      (zero_extend:P32PEDS 
        (match_operand:HI     1 "pic30_register_operand" "%r"))
      (match_operand:P32PEDS   2 "pic30_P_operand"                   "P")))]
  ""
  "mul.uu %1,#%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def")
  ]
)

(define_insn "umulhip32peds3_DATA"
  [(set (match_operand:P32PEDS 0 "pic30_register_operand" "=r,r")
        (mult:P32PEDS 
          (zero_extend:P32PEDS 
            (match_operand:HI 1 "pic30_register_operand" "%r,r"))
          (zero_extend:P32PEDS 
            (match_operand:HI 2 "pic30_mode2_operand"    "r,R<>"))))]
  ""
  "mul.uu  %1,%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,defuse")
  ]
)

(define_insn "umulhip32peds3_APSV"
  [(set (match_operand:P32PEDS 0 "pic30_register_operand" "=r,r")
        (mult:P32PEDS 
          (zero_extend:P32PEDS 
            (match_operand:HI 1 "pic30_register_operand" "%r,r"))
          (zero_extend:P32PEDS 
            (match_operand:HI 2 "pic30_mode2_APSV_operand"    "r,R<>"))))]
  ""
  "mul.uu  %1,%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,defuse")
  ]
)

(define_expand "umulhip32peds3"
  [(set (match_operand:P32PEDS 0 "pic30_register_operand" "=r,r")
        (mult:P32PEDS
          (zero_extend:P32PEDS
            (match_operand:HI 1 "pic30_register_operand" "%r,r"))
          (zero_extend:P32PEDS
            (match_operand:HI 2 "pic30_mode2_APSV_operand"    "r,R<>"))))]
  ""
  "
{
  if (pic30_mode2_operand(operands[2],GET_MODE(operands[2])))
    emit(gen_umulhip32peds3_DATA(operands[0],operands[1],operands[2]));
  else
    emit(gen_umulhip32peds3_APSV(operands[0],operands[1],operands[2]));
  DONE;
}")

; ECORE
; /* *_extend of an immediate_operand is illegal, apparently
;    so need two separate sequences */

;(define_insn "umulhi3imm"
;  [(set (match_operand:HI 0 "pic30_D_register_operand"                    "=D")
;        (mult:HI (match_operand:HI 1 "pic30_register_operand"           "%r")
;                 (match_operand:HI 2 "pic30_P_operand"                   "P")))]
;  "pic30_ecore_target()"
;  "mulw.uu %1,#%2,%0"
;  [
;   (set_attr "cc" "change0")
;   (set_attr "type" "def")
;  ]
;)
;
;(define_insn "umulhi3_DATA"
;  [(set (match_operand:HI     0 "pic30_D_register_operand" "=D,D")
;        (mult:HI
;            (match_operand:HI 1 "pic30_register_operand" "%r,r")
;            (match_operand:HI 2 "pic30_mode2_operand"      "r,R<>")))]
;  "pic30_ecore_target()"
;  "mulw.uu  %1,%2,%0"
;  [
;   (set_attr "cc" "change0")
;   (set_attr "type" "def,defuse")
;  ]
;)
;
;(define_insn "umulhi3_APSV"
;  [(set (match_operand:HI     0 "pic30_D_register_operand"   "=D,D")
;        (mult:HI
;            (match_operand:HI 1 "pic30_register_operand"   "%r,r")
;            (match_operand:HI 2 "pic30_mode2_APSV_operand"   "r,R<>")))]
;  "pic30_ecore_target()"
;  "mulw.uu  %1,%2,%0"
;  [
;   (set_attr "cc" "change0")
;   (set_attr "type" "def,defuse")
;  ]
;)
;
;(define_insn "umulp16apsv3_imm"
;  [(set (match_operand:P16APSV 0 "pic30_D_register_operand"              "=D")
;        (mult:P16APSV (match_operand:P16APSV 1 "pic30_register_operand" "%r")
;                      (match_operand:P16APSV 2 "pic30_P_operand"         "P")))]
;  "pic30_ecore_target()"
;  "mulw.uu %1,#%2,%0"
;  [
;   (set_attr "cc" "change0")
;   (set_attr "type" "def")
;  ]
;)
;
;(define_insn "umulp16apsv3_DATA"
;  [(set (match_operand:P16APSV     0 "pic30_D_register_operand" "=D,D")
;        (mult:P16APSV
;            (match_operand:P16APSV 1 "pic30_register_operand" "%r,r")
;            (match_operand:P16APSV 2 "pic30_mode2_operand"    "r,R<>")))]
;  "pic30_ecore_target()"
;  "mulw.uu  %1,%2,%0"
;  [
;   (set_attr "cc" "change0")
;   (set_attr "type" "def,defuse")
;  ]
;)
;
;(define_insn "umulp16apsv3_APSV"
;  [(set (match_operand:P16APSV     0 "pic30_D_register_operand"   "=D,D")
;        (mult:P16APSV
;            (match_operand:P16APSV 1 "pic30_register_operand"   "%r,r")
;            (match_operand:P16APSV 2 "pic30_mode2_APSV_operand" "r,R<>")))]
;  "pic30_ecore_target()"
;  "mulw.uu  %1,%2,%0"
;  [
;   (set_attr "cc" "change0")
;   (set_attr "type" "def,defuse")
;  ]
;)
;
;(define_expand "umulp16apsv3"
;  [(set (match_operand:P16APSV     0 "pic30_D_register_operand"   "=D,D")
;        (mult:P16APSV
;            (match_operand:P16APSV 1 "pic30_register_operand"   "%r,r")
;            (match_operand:P16APSV 2 "pic30_mode2_APSV_operand" "r,R<>")))]
;  "pic30_ecore_target()"
;  "
;{
;  if (pic30_mode2_operand(operands[2],GET_MODE(operands[2])))
;    emit(gen_umulp16apsv3_DATA(operands[0],operands[1],operands[2]));
;  else
;    emit(gen_umulp16apsv3_APSV(operands[0],operands[1],operands[2]));
;  DONE;
;}")

;(define_insn "*mulp16apsv3sfr"
;  [(set (match_operand:P16APSV     0 "pic30_creg_operand"        "=C,C")
;        (mult:P16APSV
;            (match_operand:P16APSV 1 "pic30_wreg_operand"        "%a,a")
;            (match_operand:P16APSV 2 "pic30_reg_or_near_operand" "r,U")))]
;  "pic30_ecore_target()"
;  "@
;   mulw.w %m2
;   mulw.w %2"
;  [
;   (set_attr "cc" "change0")
;   (set_attr "type" "def")
;  ]
;)

;; 16 x 16 => 16 (signed)
 
(define_insn "mulhi3_imm"
  [(set (match_operand:HI 0 "pic30_D_register_operand"   "=D")
        (mult:HI
          (match_operand:HI 1 "pic30_register_operand" "%r")
          (match_operand:HI 2 "pic30_P_operand"        "P")))]
  "pic30_ecore_target()"
  "mulw.su %1,#%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def")
  ]
)

(define_insn "mulhi3_DATA"
  [(set (match_operand:HI     0 "pic30_D_register_operand" "=D,D")
        (mult:HI
            (match_operand:HI 1 "pic30_register_operand" "%r,r")
            (match_operand:HI 2 "pic30_mode2_operand"    "r,R<>")))]
  "pic30_ecore_target()"
  "mulw.ss %1,%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,defuse")
  ]
)

(define_insn "mulhi3_APSV"
  [(set (match_operand:HI     0 "pic30_D_register_operand"   "=D,D")
        (mult:HI
            (match_operand:HI 1 "pic30_register_operand"   "%r,r")
            (match_operand:HI 2 "pic30_mode2_APSV_operand" "r,R<>")))]
  "pic30_ecore_target()"
  "mulw.ss %1,%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,defuse")
  ]
)

(define_expand "emulhi3"
  [(set (match_operand:HI     0 "pic30_D_register_operand"   "=D,D")
        (mult:HI
            (match_operand:HI 1 "pic30_register_operand"   "%r,r")
            (match_operand:HI 2 "pic30_mode2_APSV_operand" "r,R<>")))]
  "pic30_ecore_target()"
  "
{
  if (pic30_mode2_operand(operands[2],GET_MODE(operands[2])))
    emit(gen_mulhi3_DATA(operands[0],operands[1],operands[2]));
  else
    emit(gen_mulhi3_APSV(operands[0],operands[1],operands[2]));
  DONE;
}")

(define_insn "mulp16apsv3_imm"
  [(set (match_operand:P16APSV 0 "pic30_D_register_operand"    "=D")
        (mult:P16APSV
          (match_operand:P16APSV 1 "pic30_register_operand" "%r")
          (match_operand:P16APSV 2 "pic30_P_operand"        "P")))]
  "pic30_ecore_target()"
  "mulw.su %1,#%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def")
  ]
)

(define_insn "mulp16apsv3_DATA"
  [(set (match_operand:P16APSV     0 "pic30_D_register_operand" "=D,D")
        (mult:P16APSV
          (match_operand:P16APSV 1 "pic30_register_operand" "%r,r")
          (match_operand:P16APSV 2 "pic30_mode2_operand"    "r,R<>")))]
  "pic30_ecore_target()"
  "mulw.ss %1,%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,defuse")
  ]
)

(define_insn "mulp16apsv3_APSV"
  [(set (match_operand:P16APSV   0 "pic30_D_register_operand" "=D,D")
        (mult:P16APSV
          (match_operand:P16APSV 1 "pic30_register_operand" "%r,r")
          (match_operand:P16APSV 2 "pic30_mode2_APSV_operand" "r,R<>")))]
  "pic30_ecore_target()"
  "mulw.ss %1,%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,defuse")
  ]
)

(define_expand "emulp16apsv3"
  [(set (match_operand:P16APSV     0 "pic30_D_register_operand" "=D,D")
        (mult:P16APSV
          (match_operand:P16APSV 1 "pic30_register_operand" "%r,r")
          (match_operand:P16APSV 2 "pic30_mode2_APSV_operand"    "r,R<>")))]
  "pic30_ecore_target()"
  "
{
  if (pic30_mode2_operand(operands[2],GET_MODE(operands[2])))
    emit(gen_mulp16apsv3_DATA(operands[0],operands[1],operands[2]));
  else
    emit(gen_mulp16apsv3_APSV(operands[0],operands[1],operands[2]));
  DONE;
}")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; builtin 16x16->32 instructions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_insn "mulsu_DATA"
  [(set (match_operand:SI 0 "pic30_register_operand"               "=r,r,  r,r")
        (unspec:SI [
                    (match_operand:HI 1 "pic30_mode2_or_P_operand" "r ,r,  r,P")
                    (match_operand:HI 2 "pic30_mode2_or_P_operand" "r ,R<>,P,r")
                   ]
                    UNSPECV_MULSU))
  ]
  ""
  "@
   mul.su %1,%2,%0
   mul.su %1,%2,%0
   mul.su %1,#%2,%0
   mul.uu %2,#%1,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,defuse,def,def")
  ]
)

(define_insn "mulsu_APSV"
  [(set (match_operand:SI 0 "pic30_register_operand"               "=r,r,  r")
        (unspec:SI [
	  (match_operand:HI 1 "pic30_register_operand"   "r,r,  r")
	  (match_operand:HI 2 "pic30_mode2_or_P_APSV_operand" "r,R<>,P")
	] UNSPECV_MULSU))
  ]
  ""
  "@
   mul.su %1,%2,%0
   mul.su %1,%2,%0
   mul.su %1,#%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,defuse,def")
  ]
)

(define_expand "mulsu"
  [(set (match_operand:SI 0 "pic30_register_operand"          "=r,r,  r,r")
        (unspec:SI [
          (match_operand:HI 1 "pic30_mode2_or_P_APSV_operand" "r ,r,  r,P")
          (match_operand:HI 2 "pic30_mode2_or_P_APSV_operand" "r ,R<>,P,r")
        ] UNSPECV_MULSU))
  ]
  ""
  "
{
  if (pic30_mode2_or_P_operand(operands[2],GET_MODE(operands[2])))
    emit(gen_mulsu_DATA(operands[0],operands[1],operands[2]));
  else
    emit(gen_mulsu_APSV(operands[0],operands[1],operands[2]));
  DONE;
}")

;
; For the purpose of RAW stalls, an accumulator register can never
;   be used as a pointer
;
(define_insn "mulsu_acc"
  [(set (match_operand:HI 0 "pic30_accumulator_operand" "=w,w,w,w")
        (subreg:HI (unspec:SI [
                    (match_operand:HI 1 "pic30_mode2_or_P_operand" "r,r,  r,P")
                    (match_operand:HI 2 "pic30_mode2_or_P_operand" "r,R<>,P,r")
                   ]
                    UNSPECV_MULSU) 0
         ))
  ]
  ""
  "@
   mul.su %1,%2,%0
   mul.su %1,%2,%0
   mul.su %1,#%2,%0
   mul.uu %2,#%1,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "etc,use,etc,etc")
  ]
)

(define_insn "muluu_DATA"
  [(set (match_operand:SI 0 "pic30_register_operand"               "=r,r,  r,r")
        (unspec:SI [
                    (match_operand:HI 1 "pic30_mode2_or_P_operand" "r ,r,  r,P")
                    (match_operand:HI 2 "pic30_mode2_or_P_operand" "r ,R<>,P,r")
                   ]
                    UNSPECV_MULUU))
  ]
  ""
  "@
   mul.uu %1,%2,%0
   mul.uu %1,%2,%0
   mul.uu %1,#%2,%0
   mul.uu %2,#%1,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,defuse,def,def")
  ]
)

(define_insn "muluu_APSV"
  [(set (match_operand:SI 0 "pic30_register_operand"               "=r,r,  r")
        (unspec:SI [
	  (match_operand:HI 1 "pic30_register_operand"   "r,r,  r")
	  (match_operand:HI 2 "pic30_mode2_or_P_APSV_operand" "r,R<>,P")
	] UNSPECV_MULUU))
  ]
  ""
  "@
   mul.uu %1,%2,%0
   mul.uu %1,%2,%0
   mul.uu %1,#%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,defuse,def")
  ]
)

(define_expand "muluu"
  [(set (match_operand:SI 0 "pic30_register_operand"          "=r,r,  r,r")
        (unspec:SI [
          (match_operand:HI 1 "pic30_mode2_or_P_APSV_operand" "r ,r,  r,P")
          (match_operand:HI 2 "pic30_mode2_or_P_APSV_operand" "r ,R<>,P,r")
        ] UNSPECV_MULUU))
  ]
  ""
  "
{
  if (pic30_mode2_or_P_APSV_operand(operands[2],GET_MODE(operands[2])))
    emit(gen_muluu_APSV(operands[0],operands[1],operands[2]));
  else
    emit(gen_muluu_DATA(operands[0],operands[1],operands[2]));
  DONE;
}")

;
; For the purpose of RAW stalls, an accumulator register can never
;   be used as a pointer
;
(define_insn "muluu_acc"
  [(set (match_operand:HI 0 "pic30_accumulator_operand"  "=w,w,w,w")
        (subreg:HI (unspec:SI [
                    (match_operand:HI 1 "pic30_mode2_or_P_operand" "r,r,  r,P")
                    (match_operand:HI 2 "pic30_mode2_or_P_operand" "r,R<>,P,r")
                   ]
                    UNSPECV_MULUU) 0
        ))
  ]
  ""
  "@
   mul.uu %1,%2,%0
   mul.uu %1,%2,%0
   mul.uu %1,#%2,%0
   mul.uu %2,#%1,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "etc,use,etc,etc")
  ]
)

(define_insn "mulus_DATA"
  [(set (match_operand:SI 0 "pic30_register_operand"               "=r,r")
        (unspec:SI [
	            (match_operand:HI 1 "pic30_register_operand"    "r,r")
	            (match_operand:HI 2 "pic30_mode2_operand" "r,R<>")
	           ]
		    UNSPECV_MULUS))
  ]
  ""
  "mul.us %1,%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,defuse")
  ]
)

(define_insn "mulus_APSV"
  [(set (match_operand:SI 0 "pic30_register_operand"               "=r,r")
        (unspec:SI [
	  (match_operand:HI 1 "pic30_register_operand"    "r,r")
	  (match_operand:HI 2 "pic30_mode2_APSV_operand" "r,R<>")
	] UNSPECV_MULUS))
  ]
  ""
  "mul.us %1,%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,defuse")
  ]
)

(define_expand "mulus"
  [(set (match_operand:SI 0 "pic30_register_operand"               "=r,r")
        (unspec:SI [
          (match_operand:HI 1 "pic30_register_operand"    "r,r")    
          (match_operand:HI 2 "pic30_mode2_APSV_operand" "r,R<>")
        ] UNSPECV_MULUS))
  ]
  ""
  "
{
  if (pic30_mode2_operand(operands[2],GET_MODE(operands[2])))
    emit(gen_mulus_DATA(operands[0],operands[1],operands[2]));
  else
    emit(gen_mulus_APSV(operands[0],operands[1],operands[2]));
  DONE;
}")

;
; For the purpose of RAW stalls, an accumulator register can never
;   be used as a pointer
;
(define_insn "mulus_acc"
  [(set (match_operand:HI 0 "pic30_accumulator_operand" "=w,w")
        (subreg:HI (unspec:SI [
                    (match_operand:HI 1 "pic30_register_operand"    "r,r")
                    (match_operand:HI 2 "pic30_mode2_operand" "r,R<>")
                   ]
                    UNSPECV_MULUS) 0
                  ))
  ]
  ""
  "mul.us %1,%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "etc,use")
  ]
)

(define_insn "mulss_DATA"
  [(set (match_operand:SI 0 "pic30_register_operand"               "=r,r")
        (unspec:SI [
	            (match_operand:HI 1 "pic30_register_operand"    "r,r")
	            (match_operand:HI 2 "pic30_mode2_operand" "r,R<>")
	           ]
		    UNSPECV_MULSS))
  ]
  ""
  "mul.ss %1,%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,defuse")
  ]
)

(define_insn "mulss_APSV"
  [(set (match_operand:SI 0 "pic30_register_operand"               "=r,r")
        (unspec:SI [
	  (match_operand:HI 1 "pic30_register_operand"    "r,r")
	  (match_operand:HI 2 "pic30_mode2_APSV_operand" "r,R<>")
	] UNSPECV_MULSS))
  ]
  ""
  "mul.ss %1,%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,defuse")
  ]
)

(define_expand "mulss"
  [(set (match_operand:SI 0 "pic30_register_operand"               "=r,r")
        (unspec:SI [
          (match_operand:HI 1 "pic30_register_operand"    "r,r")    
          (match_operand:HI 2 "pic30_mode2_APSV_operand" "r,R<>")
        ] UNSPECV_MULSS))
  ]
  ""
  "
{
  if (pic30_mode2_operand(operands[2],GET_MODE(operands[2])))
    emit(gen_mulss_DATA(operands[0],operands[1],operands[2]));
  else
    emit(gen_mulss_APSV(operands[0],operands[1],operands[2]));
  DONE;
}")

;
; For the purpose of RAW stalls, an accumulator register can never
;   be used as a pointer
;
(define_insn "mulss_acc"
  [(set (match_operand:HI 0 "pic30_accumulator_operand" "=w,w")
        (subreg:HI  (unspec:SI [
            (match_operand:HI 1 "pic30_register_operand" "r,r")
            (match_operand:HI 2 "pic30_mode2_operand" "r,R<>")
          ] UNSPECV_MULSS) 0
         ))
  ]
  ""
  "mul.ss %1,%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "etc,use")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 32 x 32 => 32 (signed / unsigned) ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;
;;  For e-core machine we don't want to use the normal mechanism because
;;    the normal mulhi wants an even register (which is better for)
;;    16-bit mul but not for composing 32-bit muls
;;

(define_expand "mulsi3"
  [(set (match_operand:SI 0 "pic30_register_operand" "")
        (mult:SI (match_operand:SI 1 "pic30_register_operand" "")
                 (match_operand:SI 2 "pic30_reg_or_imm_operand" "")))]
  "pic30_ecore_target() && 0"
  "
{
   int intval = 0;
   rtx (*mulhisi)(rtx, rtx, rtx);
   rtx (*umulhisi)(rtx, rtx, rtx);

   rtx high_2 = 0, low_2 =0;
   rtx high_1, low_1;
   rtx partial;

   /*                  */
   /*           a b    */
   /*x          c d    */
   /*--------------    */
   /*       ext d.b    */
   /*+  xxx d.a        */
   /*+  xxx c.b        */
   /*                  */

   low_1 = gen_reg_rtx(HImode);
   high_1 = gen_reg_rtx(HImode);
   low_2 = gen_reg_rtx(HImode);
   high_2 = gen_reg_rtx(HImode);
   intval = immediate_operand(operands[2], VOIDmode);
   if (intval) {
     rtx temp;

     intval = pic30_P_operand(operands[2], VOIDmode);
     temp = GEN_INT((INTVAL(operands[2])) & 0xFFFF);
     if (!intval) {
       emit_move_insn(low_2, temp);
       temp = GEN_INT((INTVAL(operands[2]) >> 16) & 0xFFFF);
       emit_move_insn(high_2, temp);
     } else low_2 = temp;
   } else {
     emit_move_insn(low_2,gen_rtx_SUBREG(HImode,operands[2], 0));
     emit_move_insn(high_2,gen_rtx_SUBREG(HImode,operands[2], 2));
   }
   emit_move_insn(low_1,gen_rtx_SUBREG(HImode,operands[1], 0));
   emit_move_insn(high_1,gen_rtx_SUBREG(HImode,operands[1], 2));
   if (intval) {
     mulhisi = gen_mulhisi3_imm;
     umulhisi = gen_umulhisi3imm;
   } else {
     mulhisi = gen_mulhisi3;
     umulhisi = gen_umulhisi3;
   }

   partial = gen_reg_rtx(SImode);

   emit(
     /* d.a */
     mulhisi(partial,
             high_1,
             low_2)
   );
   if (!intval) {
     emit(
       /* c.b */
       mulhisi(operands[0],
               low_1,
               high_2)
     );
     emit (
       gen_addhi3(gen_rtx_SUBREG(HImode,partial,0),
                  gen_rtx_SUBREG(HImode,operands[0],0),
                  gen_rtx_SUBREG(HImode,partial,0))
     );
   }
   emit(
     /* d.b */
     umulhisi(operands[0],
              low_1,
              low_2)
   );
   emit (
     gen_addhi3(gen_rtx_SUBREG(HImode, operands[0], 2),
                gen_rtx_SUBREG(HImode,operands[0],2),
                gen_rtx_SUBREG(HImode,partial,0))
   );
   DONE;
}")

(define_expand "umulsi3"
  [(set (match_operand:SI 0 "pic30_register_operand" "")
        (mult:SI (match_operand:SI 1 "pic30_register_operand" "")
                 (match_operand:SI 2 "pic30_reg_or_imm_operand" "")))]
  "pic30_ecore_target()"
  "
{  rtx low_2, low_1, high_2, high_1, temp_1;

   /*          */
   /*      a b */
   /*x     c d */
   /*--------- */
   /*  d.a d.b */
   /*  c.b     */
   /*          */

   low_1 = gen_rtx_SUBREG(HImode, operands[1], 0);
   low_2 = gen_rtx_SUBREG(HImode, operands[2], 0);
   high_1 = gen_rtx_SUBREG(HImode, operands[1], 2);
   high_2 = gen_rtx_SUBREG(HImode, operands[2], 2);
   temp_1 = gen_reg_rtx(SImode);
   emit(
     gen_umulhisi3(temp_1, low_1, high_2)        /* c.b */
   );
   emit(
     gen_umulhisi3(operands[0], high_1, low_2)   /* d.a */
   );
   emit (
     gen_addhi3(temp_1, gen_rtx_SUBREG(HImode,operands[0],0), temp_1)
   );
   emit(
     gen_umulhisi3(operands[0], low_1, low_2)   /* d.b */
   );
   emit (
     gen_addhi3(temp_1, temp_1, gen_rtx_SUBREG(HImode,operands[0],2))
   );
  emit (
     gen_movhi(gen_rtx_SUBREG(HImode,operands[0],2), temp_1)
  );
  DONE;
}")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; divide instructions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; builtin 32/16 instructions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_insn "divsd"
  [(set (match_operand:HI   0 "pic30_register_operand"  "=a,?b")
        (unspec_volatile:HI [
	  (match_operand:SI 1 "pic30_register_operand"   "r, r")
	  (match_operand:HI 2 "pic30_ereg_operand"       "e, e")
	] UNSPECV_DIVSD))
   (clobber 
        (match_scratch:HI   3                           "=b, a"))
   (clobber (reg:HI RCOUNT))
  ]
  ""
  "@
   repeat #__TARGET_DIVIDE_CYCLES\;div.sd %1,%2
   repeat #__TARGET_DIVIDE_CYCLES\;div.sd %1,%2\;mov w0,w1"
  [
    (set_attr "cc" "clobber")  ; should have a new CC of div
    (set_attr "type" "def")
  ]
)

(define_insn "modsd"
  [(set (match_operand:HI   0 "pic30_register_operand" "=b,?a")
        (unspec_volatile:HI [
          (match_operand:SI 1 "pic30_register_operand"  "r, r")
          (match_operand:HI 2 "pic30_ereg_operand"      "e, e")
        ] UNSPECV_MODSD))
   (clobber 
        (match_scratch:HI   3                          "=a, b"))
   (clobber (reg:HI RCOUNT))
  ]
  ""
  "@
   repeat #__TARGET_DIVIDE_CYCLES\;div.sd %1,%2
   repeat #__TARGET_DIVIDE_CYCLES\;div.sd %1,%2\;mov w1,w0"
  [
    (set_attr "cc" "clobber")  ; should have a new CC of div
    (set_attr "type" "def")
  ]
)

(define_insn "divf"
  [(set (match_operand:HI   0 "pic30_register_operand" "=a,?b")
        (unspec_volatile:HI [
          (match_operand:HI 1 "pic30_register_operand"  "r, r")
          (match_operand:HI 2 "pic30_ereg_operand"      "e, e")
        ] UNSPECV_DIVF))
   (clobber 
        (match_scratch:HI   3                          "=b, a"))
   (clobber (reg:HI RCOUNT))
  ]
  ""
  "@
   repeat #__TARGET_DIVIDE_CYCLES\;divf %1,%2
   repeat #__TARGET_DIVIDE_CYCLES\;divf %1,%2\;mov w0,%0"
  [
    (set_attr "cc" "clobber")  ; should have new cc of div
    (set_attr "type" "def")
  ]
)

(define_insn "divud"
  [(set (match_operand:HI 0 "pic30_register_operand"   "=a,?b")
        (unspec_volatile:HI [
	  (match_operand:SI 1 "pic30_register_operand"  "r, r")
	  (match_operand:HI 2 "pic30_ereg_operand"      "e, e")
	] UNSPECV_DIVUD))
   (clobber 
        (match_scratch:HI   3                          "=b, a"))
   (clobber (reg:HI RCOUNT))
  ]
  ""
  "@
   repeat #__TARGET_DIVIDE_CYCLES\;div.ud %1,%2
   repeat #__TARGET_DIVIDE_CYCLES\;div.ud %1,%2\;mov w0,w1"
  [
    (set_attr "cc" "clobber")  ; should have new CC of div
    (set_attr "type" "def")
  ]
)

(define_insn "modud"
  [(set (match_operand:HI 0 "pic30_register_operand"   "=b,?a")
        (unspec_volatile:HI [
          (match_operand:SI 1 "pic30_register_operand"  "r, r")
          (match_operand:HI 2 "pic30_ereg_operand"      "e, e")
        ] UNSPECV_MODUD))
   (clobber 
        (match_scratch:HI   3                          "=a, b"))
   (clobber (reg:HI RCOUNT))
  ]
  ""
  "@
   repeat #__TARGET_DIVIDE_CYCLES\;div.ud %1,%2
   repeat #__TARGET_DIVIDE_CYCLES\;div.ud %1,%2\;mov w1,w0"
  [
    (set_attr "cc" "clobber")  ; should have new CC of div
    (set_attr "type" "def")
  ]
)

(define_insn "divmodsd"
  [(set (match_operand:HI 0 "pic30_register_operand"   "=a,?b")
        (unspec_volatile:HI [
          (match_operand:SI 1 "pic30_register_operand"  "r, r")
          (match_operand:HI 2 "pic30_ereg_operand"      "e, e")
        ] UNSPECV_DIVMODSD))
   (set (mem:HI 
          (match_operand:HI 3 "pic30_register_operand" " e, e"))
        (unspec_volatile:HI [
          (match_dup 1)
          (match_dup 2)
        ] UNSPECV_DIVMODSD))
   (clobber 
        (match_scratch:HI   4                          "=b, a"))
   (clobber (reg:HI RCOUNT))
  ]
  ""
  "@
   repeat #__TARGET_DIVIDE_CYCLES\;div.sd %1,%2\;mov w1,[%3]
   repeat #__TARGET_DIVIDE_CYCLES\;div.sd %1,%2\;mov w1,[%3]\;mov w0,w1"
  [
    (set_attr "cc" "clobber")   ; should have new CC of div
    (set_attr "type" "def")
  ]
)

(define_insn "divmodud"
  [(set (match_operand:HI 0 "pic30_register_operand"  "=a,?b")
        (unspec_volatile:HI [
          (match_operand:SI 1 "pic30_register_operand" "r, r")
          (match_operand:HI 2 "pic30_ereg_operand"     "e, e")
        ] UNSPECV_DIVMODUD))
   (set (mem:HI 
          (match_operand:HI 3 "pic30_register_operand" "e, e"))
        (unspec_volatile:HI [
          (match_dup 1)
          (match_dup 2)
        ] UNSPECV_DIVMODUD))
   (clobber 
        (match_scratch:HI   4                          "=b, a"))
   (clobber (reg:HI RCOUNT))
  ]
  ""
  "@
   repeat #__TARGET_DIVIDE_CYCLES\;div.ud %1,%2\;mov w1,[%3]
   repeat #__TARGET_DIVIDE_CYCLES\;div.ud %1,%2\;mov w1,[%3]\;mov w0,w1"
  [
    (set_attr "cc" "clobber")  ; should have new CC of div
    (set_attr "type" "def")
  ]
)

(define_insn "divmodhi4"
  [(set (match_operand:HI   0 "pic30_register_operand" "=a,?b")
        (div:HI
          (match_operand:HI 1 "pic30_register_operand"  "r, r")
          (match_operand:HI 2 "pic30_ereg_operand"      "e, e")))
   (set (match_operand:HI   3 "pic30_register_operand" "=b, a")
        (mod:HI 
          (match_dup 1)
          (match_dup 2)))
   (clobber (reg:HI RCOUNT))
  ]
  ""
  "*
   switch (which_alternative) {
     default: gcc_assert(0);
     case 0:  return \"repeat #__TARGET_DIVIDE_CYCLES\;div.sw %1,%2\";
     case 1:  if (pic30_errata_mask & exch_errata) {
                return \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                       \"div.sw %1,%2\;push w1\;mov w0,w1\;pop w0\";
              } else {
                return \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                       \"div.sw %1,%2\;exch w0,w1\";
              }
  }"
  [
    (set_attr "cc" "clobber")  ; should have new CC of div
    (set_attr "type" "def")
  ]
)

(define_insn "udivmodhi4"
  [(set (match_operand:HI   0 "pic30_register_operand" "=a,?b")
        (udiv:HI
          (match_operand:HI 1 "pic30_register_operand"  "r, r")
          (match_operand:HI 2 "pic30_ereg_operand"      "e, e")))
   (set (match_operand:HI   3 "pic30_register_operand" "=b, a")
        (mod:HI 
          (match_dup 1)
          (match_dup 2)))
   (clobber (reg:HI RCOUNT))
  ]
  ""
  "*
   switch (which_alternative) {
     default: gcc_assert(0);
     case 0:  return \"repeat #__TARGET_DIVIDE_CYCLES\;div.uw %1,%2\";
     case 1:  if (pic30_errata_mask & exch_errata) {
                return \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                       \"div.uw %1,%2\;push w1\;mov w0,w1\;pop w0\";
              } else {
                return \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                       \"div.uw %1,%2\;exch w0,w1\";
              }
  }"
  [
    (set_attr "cc" "clobber")  ; should have new CC of div
    (set_attr "type" "def")
  ]
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; square root instructions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Other arithmetic instructions:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Absolute value
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;
;; Half integer
;;;;;;;;;;;;;;;;;;

(define_insn "abshi2"
   [(set (match_operand:HI 0 "pic30_register_operand"        "=r")
         (abs:HI (match_operand:HI 1 "pic30_register_operand" "0")))]
   ""
   "btsc %1,#15\;neg %1,%0"
   [
     (set_attr "cc" "clobber")
     (set_attr "type" "def")
   ]
)

;;;;;;;;;;;;;;;;;;
;; Single float
;;;;;;;;;;;;;;;;;;

(define_insn "abssf2"
  [(set (match_operand:SF 0 "pic30_register_operand"        "=r")
        (abs:SF (match_operand:SF 1 "pic30_register_operand" "0")))]
  ""
  "bclr %d0,#15"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

;;;;;;;;;;;;;;;;;;
;; Double float
;;;;;;;;;;;;;;;;;;

(define_insn "absdf2"
  [(set (match_operand:DF 0 "pic30_register_operand"        "=r")
        (abs:DF (match_operand:DF 1 "pic30_register_operand" "0")))]
  ""
  "bclr %q0,#15"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Negation
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;
;; Quarter integer 
;;;;;;;;;;;;;;;;;;

(define_insn "negqi2_DATA"
  [(set (match_operand:QI 0 "pic30_mode2_operand"        "=r<>,r<>,R,R")
        (neg:QI (match_operand:QI 1 "pic30_mode2_operand" "r,  R<>,r,R<>")))]
  ""
  "neg.b %1,%0"
  [
   (set_attr "cc" "set")
   (set_attr "type" "def,defuse,use,use")
  ]
)

(define_insn "negqi2_APSV"
  [(set (match_operand:QI 0 "pic30_mode2_operand"        "=r<>,r<>,R,R")
        (neg:QI 
           (match_operand:QI 1 "pic30_mode2_APSV_operand" "r,  R<>,r,R<>")))]
  ""
  "neg.b %1,%0"
  [
   (set_attr "cc" "set")
   (set_attr "type" "def,defuse,use,use")
  ]
)

(define_expand "negqi2"
  [(set (match_operand:QI 0 "pic30_mode2_operand"        "=r<>,r<>,R,R")
        (neg:QI 
           (match_operand:QI 1 "pic30_mode2_APSV_operand" "r,  R<>,r,R<>")))]
  ""
  "
{
  if (pic30_mode2_operand(operands[1],GET_MODE(operands[1])))
    emit(gen_negqi2_DATA(operands[0],operands[1]));
  else
    emit(gen_negqi2_APSV(operands[0],operands[1]));
  DONE;
}")

(define_insn "*negqi2_sfr0"
  [(set (match_operand:QI 0 "pic30_wreg_operand"        "=a")
        (neg:QI (match_operand:QI 1 "pic30_near_operand" "U")))]
  ""
  "neg.b %1,WREG"
  [
   (set_attr "cc" "set")
   (set_attr "type" "def")
  ]
)

; leave this match_dup, operand 0 will not require a reload (CAW)
(define_insn "*negqi2_sfr1"
  [(set (match_operand:QI 0 "pic30_near_operand"        "=U")
        (neg:QI (match_dup 0)))]
  ""
  "neg.b %0"
  [(set_attr "cc" "set")])

;;;;;;;;;;;;;;;;;;
;; Half integer 
;;;;;;;;;;;;;;;;;;

(define_insn "neghi2_DATA"
  [(set (match_operand:HI 0 "pic30_mode2_operand"        "=r<>,r<>,R,R")
        (neg:HI (match_operand:HI 1 "pic30_mode2_operand" "r,  R<>,r,R<>")))]
  ""
  "neg %1,%0"
  [
   (set_attr "cc" "set")
   (set_attr "type" "def,defuse,use,use")
  ]
)

(define_insn "neghi2_APSV"
  [(set (match_operand:HI 0 "pic30_mode2_operand"        "=r<>,r<>,R,R")
        (neg:HI 
          (match_operand:HI 1 "pic30_mode2_APSV_operand" "r,  R<>,r,R<>")))]
  ""
  "neg %1,%0"
  [
   (set_attr "cc" "set")
   (set_attr "type" "def,defuse,use,use")
  ]
)

(define_expand "neghi2"
  [(set (match_operand:HI 0 "pic30_mode2_operand"        "=r<>,r<>,R,R")
        (neg:HI 
          (match_operand:HI 1 "pic30_mode2_APSV_operand" "r,  R<>,r,R<>")))]
  ""
  "
{
  if (pic30_mode2_operand(operands[1],GET_MODE(operands[1])))
    emit(gen_neghi2_DATA(operands[0],operands[1]));
  else
    emit(gen_neghi2_DATA(operands[0],operands[1]));
  DONE;
}")

(define_insn "*neghi2_sfr0"
  [(set (match_operand:HI 0 "pic30_wreg_operand"                "=a,a")
        (neg:HI (match_operand:HI 1 "pic30_reg_or_near_operand" " U,r")))]
  ""
  "@
   neg %1,WREG
   neg %1,%0"
  [
   (set_attr "cc" "set")
   (set_attr "type" "def")
  ]
)

; leave this match_dup, there is no operand 2 to interfere with a reload (CAW)
(define_insn "*neghi2_sfr1"
  [(set (match_operand:HI 0 "pic30_reg_or_near_operand"        "=U,r")
        (neg:HI (match_dup 0)))]
  ""
  "neg %0"
  [
   (set_attr "cc" "set")
   (set_attr "type" "etc,def")
  ]
)

;;;;;;;;;;;;;;;;;;
;; Single integer 
;;;;;;;;;;;;;;;;;;

(define_insn "negsi2"
  [(set (match_operand:SI 0 "pic30_register_operand"        "=r")
        (neg:SI (match_operand:SI 1 "pic30_register_operand" "r")))]
  ""
  "subr %1,#0,%0\;subbr %d1,#0,%d0"
  [
   (set_attr "cc" "set")
   (set_attr "type" "def")
  ]
)

;;;;;;;;;;;;;;;;;;
;; Single float
;;;;;;;;;;;;;;;;;;

(define_insn "negsf2"
  [(set (match_operand:SF 0        "pic30_register_operand" "=r")
        (neg:SF (match_operand:SF 1 "pic30_register_operand" "0")))]
  ""
  "btg %d0,#15"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

; leave this match_dup, operand 0 will not require a reload (CAW)
(define_insn "*negsf2sfr"
  [(set (match_operand:SF 0        "pic30_near_operand" "=U")
        (neg:SF (match_dup 0)))]
  ""
  "btg.b %0+3,#7"
  [(set_attr "cc" "clobber")])

;;;;;;;;;;;;;;;;;;
;; Double float
;;;;;;;;;;;;;;;;;;

(define_insn "negdf2"
  [(set (match_operand:DF 0        "pic30_register_operand" "=r")
        (neg:DF (match_operand:DF 1 "pic30_register_operand" "0")))]
  ""
  "btg %q0,#15"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; bit-logical instructions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;
;; Quarter integer 
;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;
;; Set Bit ;;
;;;;;;;;;;;;;

(define_insn "bitsetqi"
  [(set (match_operand:QI 0 "pic30_mode2_operand"        "=r,R<>")
        (ior:QI (match_operand:QI 1 "pic30_mode2_operand" "0,0")
                (match_operand 2 "const_int_operand"      "i,i")))]
  "(pic30_one_bit_set_p(INTVAL(operands[2])&0x00ff))"
  "bset.b %0,#%b2"
  [
   (set_attr "type" "def,etc")
  ]
)

; leave this match_dup, operand 1 cannot interfere with reload (CAW)
(define_insn "bitsetqi_sfr"
  [(set (match_operand:QI 0 "pic30_near_operand"        "=U")
        (ior:QI  (match_dup 0)
                 (match_operand 1 "const_int_operand" "i")))]
  "pic30_one_bit_set_p(INTVAL(operands[1]) & 0x00ff)"
  "bset.b %0,#%b1"
  [
    (set_attr "type" "etc")
  ]
)

;;;;;;;;;;;;;;;
;; Reset Bit ;;
;;;;;;;;;;;;;;;

(define_insn "bitclrqi"
  [(set (match_operand:QI 0 "pic30_mode2_operand"        "=r,R,<>")
        (and:QI (match_operand:QI 1 "pic30_mode2_operand" "0,0,0")
                (match_operand 2 "const_int_operand"      "i,i,i")))]
  "(pic30_one_bit_set_p((~INTVAL(operands[2])&0xff)))"
  "bclr.b %0,#%B2"
  [
   (set_attr "type" "def,use,defuse")
  ]
)

; leave this match_dup, operand 1 cannot interfere with reload (CAW)
(define_insn "bitclrqi_sfr"
  [(set (match_operand:QI 0 "pic30_near_operand"        "=U")
        (and:QI  (match_dup 0)
                 (match_operand 1 "const_int_operand" "i")))]
  "(pic30_one_bit_set_p((~INTVAL (operands[1])) & 0x00ff))"
  "bclr.b %0,#%B1"
  [
    (set_attr "type" "use")
  ]
)


;;;;;;;;;;;;;;;;
;; Toggle Bit ;;
;;;;;;;;;;;;;;;;

(define_insn "bittogqi"
  [(set (match_operand:QI 0 "pic30_mode2_operand"        "=r,R,<>")
        (xor:QI (match_operand:QI 1 "pic30_mode2_operand" "0,0,0")
                (match_operand 2 "const_int_operand"      "i,i,i")))]
  "(pic30_one_bit_set_p(INTVAL(operands[2])&0xffff))"
  "btg.b %0,#%b2"
  [
   (set_attr "type" "def,use,defuse")
  ]
)

; leave this match_dup, operand 1 cannot interfere with reload (CAW)
(define_insn "bittogqi_sfr"
  [(set (match_operand:QI 0 "pic30_near_operand"        "=U")
        (xor:QI  (match_dup 0)
                 (match_operand 1 "const_int_operand" "i")))]
  "pic30_one_bit_set_p(INTVAL(operands[1]) & 0x00ff)"
  "btg.b %0,#%b1"
  [
    (set_attr "type" "use")
  ]
)

;;;;;;;;;;;;;;
;; Test Bit ;;
;;;;;;;;;;;;;;

(define_insn "*bittstqi_and"
  [(set (cc0)
        (and (match_operand:QI 0 "pic30_reg_or_near_operand" "r,U")
             (match_operand 1 "immediate_operand" "i,i")))]
  "(pic30_one_bit_set(GET_MODE(operands[0]),operands[1],1))"
  "@
   btst %0,#%b1
   btst.b %0,#%b1"
  [
    (set_attr "cc" "set")
    (set_attr "type" "etc,use")
  ]
)
 
          
(define_insn "newbittstqi"
  [(set (cc0)
        (compare
           (zero_extract (match_operand 0 "pic30_reg_or_near_operand" "r,U")
		         (const_int 1)
		         (match_operand 1 "const_int_operand" "i,i"))
           (const_int 0))
    )]
  "(INTVAL(operands[1]) < 8)"
  "@
   btst %0,#%1
   btst.b %0,#%1"
  [
    (set_attr "cc" "set")
    (set_attr "type" "etc,use")
  ]
)

(define_insn "*bittstqi"
  [(set (cc0)
        (zero_extract (match_operand:QI 0 "pic30_reg_or_near_operand" "r,U")
		      (const_int 1)
		      (match_operand 1 "const_int_operand" "i,i")))]
  ""
  "@
   btst %0,#%1
   btst.b %0,#%1"
  [
    (set_attr "cc" "set")
    (set_attr "type" "etc,use")
  ]
)

;;;;;;;;;;;;;;;;;;
;; Half integer ;;
;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;
;; Set Bit ;;
;;;;;;;;;;;;;

;; the pre/post modify modes have been removed due to errata in Rev A silicon
;;   the pre/post modify modes are valid for REV_A3

(define_insn "bitsethi"
  [(set (match_operand:HI 0 "pic30_mode2_operand"         "=r,R,<>")
        (ior:HI  (match_operand:HI 1 "pic30_mode2_operand" "0,0,0")
                 (match_operand 2 "const_int_operand"      "i,i,i")))]
  "(pic30_one_bit_set(GET_MODE(operands[0]),operands[2],1))"
  "bset %0,#%b2"
  [
   (set_attr "type" "def,use,defuse")
  ]
)

; leave this match_dup, operand 1 cannot interfere with reload (CAW)
(define_insn "bitsethi_sfr"
  [(set (match_operand:HI 0 "pic30_near_operand"         "=U")
        (ior:HI  (match_dup 0)
                 (match_operand 1 "const_int_operand"  "i")))]
  "(pic30_one_bit_set(GET_MODE(operands[0]),operands[1],1))"
  "*
   {
     if ((INTVAL(operands[1])&0xffff) >= 256)
       return \"bset.b %0+1,#%b1-8\";
     else
       return \"bset.b %0,#%b1\";
   }"
  [
    (set_attr "type" "use")
  ]
)

;;;;;;;;;;;;;;;
;; Reset Bit ;;
;;;;;;;;;;;;;;;

;; the pre/post modify modes have been removed due to errata in Rev A silicon
;;   the pre/post modify modes are valid for REV_A3

(define_insn "bitclrhi"
  [(set (match_operand:HI 0 "pic30_mode2_operand"         "=r,R,<>")
        (and:HI  (match_operand:HI 1 "pic30_mode2_operand" "0,0,0")
                 (match_operand 2 "const_int_operand"      "i,i,i")))]
  "(pic30_one_bit_set_p((~INTVAL(operands[2])) & 0xffff))"
  "bclr %0,#%B2"
  [
   (set_attr "type" "def,use,defuse")
  ]
)

; leave this match_dup, operand 1 cannot interfere with reload (CAW)
;        (and:HI  (match_operand:HI 1 "pic30_near_operand"  "0")
(define_insn "bitclrhi_sfr"
  [(set (match_operand:HI 0 "pic30_near_operand"           "=U")
        (and:HI  (match_dup 0)
                 (match_operand 1 "const_int_operand" "i")))]
  "(pic30_one_bit_set_p((~INTVAL(operands[1])) & 0xffff))"
  "*
   {
     if (pic30_which_bit(~INTVAL(operands[1])) > 7)
       return \"bclr.b %0+1,#%B1-8\";
     else
       return \"bclr.b %0,#%B1\";
   }"
  [
    (set_attr "type" "use")
  ]
)

;;;;;;;;;;;;;;;;
;; Toggle Bit ;;
;;;;;;;;;;;;;;;;

;; the pre/post modify modes have been removed due to errata in Rev A silicon
;;   the pre/post modify modes are valid for REV_A3

(define_insn "bittoghi"
  [(set (match_operand:HI 0 "pic30_mode2_operand"         "=r,R,<>")
        (xor:HI  (match_operand:HI 1 "pic30_mode2_operand" "0,0,0")
                 (match_operand 2 "const_int_operand"      "i,i,i")))]
  "(pic30_one_bit_set(GET_MODE(operands[0]),operands[2],1))"
  "btg %0,#%b2"
  [
   (set_attr "type" "def,use,defuse")
  ]
)

; leave this match_dup, operand 1 cannot interfere with reload (CAW)
(define_insn "bittoghi_sfr"
  [(set (match_operand:HI 0 "pic30_near_operand"           "=U")
        (xor:HI  (match_dup 0)
                 (match_operand 1 "const_int_operand" "i")))]
  "(pic30_one_bit_set(GET_MODE(operands[0]),operands[1],1))"
  "*
   {
     if ((INTVAL(operands[1])&0xffff) >= 256)
       return \"btg.b %0+1,#%b1-8\";
     else
       return \"btg.b %0,#%b1\";
   }"
  [
    (set_attr "type" "use")
  ]
)

;;;;;;;;;;;;;;
;; Test Bit ;;
;;;;;;;;;;;;;;

(define_insn "*bittsthi_and_DATA"
  [(set (cc0)
        (and (match_operand:HI 0 "pic30_near_mode2_operand" "r,R,<>,U")
             (match_operand 1 "immediate_operand"           "i,i,i, i")))]
  "(pic30_one_bit_set(GET_MODE(operands[0]),operands[1],1))"
  "@
   btst %0,#%b1
   btst %0,#%b1
   btst %0,#%b1
   btst.b %0+%b1/8,#%b1%%8"
  [
   (set_attr "cc" "set")
   (set_attr "type" "etc,use,use,etc")
  ]
)

(define_insn "*bittsthi_and_APSV"
  [(set (cc0)
        (and (match_operand:HI 0 "pic30_near_mode2_APSV_operand" "r,R,<>,U")
             (match_operand 1 "immediate_operand"           "i,i,i, i")))]
  "(pic30_one_bit_set(GET_MODE(operands[0]),operands[1],1))"
  "@
   btst %0,#%b1
   btst %0,#%b1
   btst %0,#%b1
   btst.b %0+%b1/8,#%b1%%8"
  [
   (set_attr "cc" "set")
   (set_attr "type" "etc,use,use,etc")
  ]
)

(define_insn "*bittsthi_DATA"
  [(set (cc0) 
        (zero_extract:HI
          (match_operand:HI 0 "pic30_near_mode2_operand" "r,R,<>,U")
          (const_int 1)
          (match_operand 1 "const_int_operand"           "i,i,i, i")))]
  ""
  "@
   btst %0,#%1
   btst %0,#%1
   btst %0,#%1
   btst.b %0+%1/8,#%1%%8"
  [
   (set_attr "cc" "set")
   (set_attr "type" "etc,use,use,etc")
  ]
)

(define_insn "*bittsthi_APSV"
  [(set (cc0) 
        (zero_extract:HI
           (match_operand:HI 0 "pic30_near_mode2_APSV_operand" "r,R,<>,U")
           (const_int 1)
           (match_operand 1 "const_int_operand"           "i,i,i, i")))]
  ""
  "@
   btst %0,#%1
   btst %0,#%1
   btst %0,#%1
   btst.b %0+%1/8,#%1%%8"
  [
   (set_attr "cc" "set")
   (set_attr "type" "etc,use,use,etc")
  ]
)

(define_insn "*newbittsthi_DATA"
  [(set (cc0) 
        (compare 
          (zero_extract
            (match_operand:HI 0 "pic30_near_mode2_operand" "r,R,<>,U")
            (const_int 1)
            (match_operand 1 "const_int_operand"           "i,i,i, i"))
          (const_int 0))
   )]
  ""
  "@
   btst %0,#%1
   btst %0,#%1
   btst %0,#%1
   btst.b %0+%1/8,#%1%%8"
  [
   (set_attr "cc" "set")
   (set_attr "type" "etc,use,use,etc")
  ]
)

(define_insn "*newbittsthi_APSV"
  [(set (cc0) 
        (compare 
          (zero_extract
            (match_operand:HI 0 "pic30_near_mode2_APSV_operand" "r,R,<>,U")
            (const_int 1)
            (match_operand 1 "const_int_operand"           "i,i,i, i"))
          (const_int 0))
   )]
  ""
  "@
   btst %0,#%1
   btst %0,#%1
   btst %0,#%1
   btst.b %0+%1/8,#%1%%8"
  [
   (set_attr "cc" "set")
   (set_attr "type" "etc,use,use,etc")
  ]
)

;;;;;;;;;;;;;;;;;;;;
;; Single integer ;;
;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;
;; Set Bit ;;
;;;;;;;;;;;;;

(define_insn "bitsetsiR"
  [(set (match_operand:SI 0 "pic30_reg_or_R_operand"         "=r,R")
        (ior:SI  (match_operand:SI 1 "pic30_reg_or_R_operand" "0,0")
                 (match_operand 2 "const_int_operand"         "i,i")))]
  "(pic30_one_bit_set(GET_MODE(operands[0]),operands[2],1))"
  "*
   {
     switch (which_alternative) {
       case 0:
         if (pic30_which_bit(INTVAL(operands[2])) < 16) {
           return \"bset %0,#%b2\";
	 } else {
           return \"bset %d0,#%b2-16\";
         }
       case 1:
         if (pic30_which_bit(INTVAL(operands[2])) < 16) {
           return \"bset %0,#%b2\";
         } else {
           return \"btst %I0,#%b2-16\;bset %D0,#%b2-16\";
         }
       default:
         gcc_assert(0);
         return \"nop\";
       }
   }"
  [
   (set_attr "type" "def,use")
  ]
)

(define_insn "*bitsetsir"
  [(set (match_operand:SI 0 "pic30_register_operand"         "=r")
        (ior:SI  (match_operand:SI 1 "pic30_register_operand" "0")
                 (match_operand 2 "const_int_operand"   "i")))]
  "(pic30_one_bit_set(GET_MODE(operands[0]),operands[2],1))"
  "*
   {
     if (pic30_which_bit(INTVAL(operands[2])) < 16) {
       return \"bset %0,#%b2\";
     } else {
       return \"bset %d0,#%b2-16\";
     }
   }"
  [
   (set_attr "type" "def")
  ]
)

; leave this match_dup, operand 1 cannot interfere with reload (CAW)
(define_insn "*bitsetsi_sfr"
  [(set (match_operand:SI 0 "pic30_near_operand"         "=U")
        (ior:SI  (match_dup 0)
                 (match_operand 1 "const_int_operand"  "i")))]
  "(pic30_one_bit_set(GET_MODE(operands[0]),operands[1],1))"
  "*
   {
     unsigned int n = INTVAL(operands[1]);

     if (n >= 0x1000000)
       return \"bset.b %0+3,#%b1-24\";
     else if (n >= 0x10000)
       return \"bset.b %0+2,#%b1-16\";
     else if (n >= 0x0100)
       return \"bset.b %0+1,#%b1-8\";
     else return \"bset.b %0+0,#%b1\";
   }"
  [
    (set_attr "type" "etc")
  ]
)

;;;;;;;;;;;;;;;
;; Reset Bit ;;
;;;;;;;;;;;;;;;

; leave this match_dup, operand 1 cannot interfere with reload (CAW)
(define_insn "*bitclrsi_sfr"
  [(set (match_operand:SI 0 "pic30_near_operand"         "=U")
        (and:SI  (match_dup 0)
                 (match_operand 1 "const_int_operand"  "i")))]
  "(pic30_one_bit_set(GET_MODE(operands[0]),operands[1],1))"
  "*
   {
     int n = pic30_which_bit(~INTVAL(operands[1]));

     if (n > 23)
       return \"bclr.b %0+3,#%B1-24\";
     else if (n > 15)
       return \"bclr.b %0+2,#%B1-16\";
     else if (n > 7)
       return \"bclr.b %0+1,#%B1-8\";
     else return \"bclr.b %0+0,#%B1\";
   }"
  [
    (set_attr "type" "etc")
  ]
)

(define_insn "*bitclrsi"
  [(set (match_operand:SI 0 "pic30_register_operand"         "=r")
        (and:SI  (match_operand:SI 1 "pic30_register_operand" "0")
                 (match_operand 2 "const_int_operand"   "i")))]
  "(pic30_one_bit_set(GET_MODE(operands[0]),operands[2],0))"
  "*
   {
     int n = pic30_which_bit(~INTVAL(operands[2]));

     if (n > 15)
       return \"bclr %d0,#%B2-16\";
     else
       return \"bclr %0,#%B2\";
   }"
  [
   (set_attr "type" "def")
  ]
)

;;;;;;;;;;;;;;;;
;; Toggle Bit ;;
;;;;;;;;;;;;;;;;

(define_insn "bittogsi"
  [(set (match_operand:SI 0 "pic30_register_operand"         "=r")
        (xor:SI  (match_operand:SI 1 "pic30_register_operand" "0")
                 (match_operand 2 "const_int_operand"   "i")))]
  "(pic30_one_bit_set(GET_MODE(operands[0]),operands[2],1))"
  "*
   {
     unsigned int n = INTVAL(operands[2]);
     if (n >= 65536)
       return \"btg %d0,#%b2-16\";
     else
       return \"btg %0,#%b2\";
   }"
  [
   (set_attr "type" "def")
  ]
)

; leave this match_dup, operand 1 cannot interfere with reload (CAW)
(define_insn "bittogsi_sfr"
  [(set (match_operand:SI 0 "pic30_near_operand"         "=U")
        (xor:SI  (match_dup 0)
                 (match_operand 1 "const_int_operand"  "i")))]
  "(pic30_one_bit_set(GET_MODE(operands[0]),operands[1],1))"
  "*
   {
     unsigned int n = INTVAL(operands[1]);
     if (n >= 0x01000000)
       return \"btg.b %0+3,#%b1-24\";
     else if (n >= 0x00010000)
       return \"btg.b %0+2,#%b1-16\";
     else if (n >= 0x00000100)
       return \"btg.b %0+1,#%b1-8\";
     else return \"btg.b %0+0,#%b1-0\";
   }"
  [
    (set_attr "type" "etc")
  ]
)

;;;;;;;;;;;;;;
;; Test Bit ;;
;;;;;;;;;;;;;;

(define_insn "*bittstsir_and"
  [(set (cc0) 
        (and (match_operand:SI 0 "pic30_register_operand"  "r")
             (match_operand 1 "const_int_operand" "i")))]
  "(pic30_one_bit_set(GET_MODE(operands[0]),operands[1],1))"
  "*
   {
     if (INTVAL(operands[1]) < (1<<16)) {
       return \"btst %0,#%b1\";
     } else {
       return \"btst %d0,#%b1-16\";
     }
   }"
  [(set_attr "cc" "set")])

(define_insn "*bittstsi_sfr_and"
  [(set (cc0) 
        (and (match_operand:SI 0 "pic30_near_operand" "U")
             (match_operand 1 "const_int_operand"  "i")))]
  "(pic30_one_bit_set(GET_MODE(operands[0]),operands[1],1))"
  "btst.b %0+%b1/8,#%b1%%8"
  [(set_attr "cc" "set")])

(define_insn "*bittstsiR"
  [(set (cc0) (zero_extract (match_operand:SI 0 "pic30_reg_or_R_operand" "r,R")
			    (const_int 1)
			    (match_operand 1 "const_int_operand" "i,i")))]
  "INTVAL(operands[1]) < 16"
  "btst %0,#%1"
  [
   (set_attr "cc" "set")
   (set_attr "type" "etc,use")
  ]
)

(define_insn "*bittstsiR_and"
  [(set (cc0)
        (and (match_operand:SI 0 "pic30_reg_or_R_operand"  "r,R")
             (match_operand 1 "const_int_operand"          "i,i")))]
  "(pic30_one_bit_set(GET_MODE(operands[0]),operands[1],1)) &&
   pic30_which_bit(INTVAL(operands[1])) < 16"
  "btst %0,#%b1"
  [
   (set_attr "cc" "set")
   (set_attr "type" "etc,use")
  ]
)

(define_insn "*bittstsir"
  [(set (cc0) (zero_extract (match_operand:SI 0 "pic30_register_operand" "r")
			    (const_int 1)
			    (match_operand 1 "const_int_operand" "i")))]
  ""
  "*
   {
     if (INTVAL(operands[1]) < 16) {
       return \"btst %0,#%1\";
     } else {
       return \"btst %d0,#%1-16\";
     }
   }"
  [(set_attr "cc" "set")])

(define_insn "*bittstsi_sfr"
  [(set (cc0) (zero_extract (match_operand:SI 0 "pic30_near_operand" "U")
			    (const_int 1)
			    (match_operand 1 "const_int_operand"  "i")))]
  ""
  "btst.b %0+%1/8,#%1%%8"
  [(set_attr "cc" "set")])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; AND
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;
;; quarter integer
;;;;;;;;;;;;;;;;;;

(define_insn "andqi3_DATA"
  [(set (match_operand:QI 0 "pic30_mode2_operand"
               "=r<>,r<>,R,R,  r<>,R,r<>,R,  r<>,R,r")
        (and:QI 
           (match_operand:QI 1 "pic30_mode1J_operand"
               "%r,  r,  r,r,  r,  r,R<>,R<>,P,  P,0")
           (match_operand:QI 2 "pic30_mode1J_operand"
               "r,  R<>,r,R<>,P,  P,r,  r,  r,  r,J")))]
  ""
  "@
   and.b %1,%2,%0
   and.b %1,%2,%0
   and.b %1,%2,%0
   and.b %1,%2,%0
   and.b %1,#%2,%0
   and.b %1,#%2,%0
   and.b %2,%1,%0
   and.b %2,%1,%0
   and.b %2,#%1,%0
   and.b %2,#%1,%0
   and.b #%2,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,defuse,use,use,def,use,defuse,use,def,use,def")
  ]
)

(define_insn "andqi3_APSV"
  [(set (match_operand:QI 0 "pic30_mode2_operand"
               "=r<>,r<>,R,R,  r<>,R,r<>,R,  r<>,R,r")
        (and:QI 
           (match_operand:QI 1 "pic30_mode1J_APSV_operand"
               "%r,  r,  r,r,  r,  r,R<>,R<>,P,  P,0")
           (match_operand:QI 2 "pic30_mode1J_APSV_operand"
               "r,  R<>,r,R<>,P,  P,r,  r,  r,  r,J")))]
  ""
  "@
   and.b %1,%2,%0
   and.b %1,%2,%0
   and.b %1,%2,%0
   and.b %1,%2,%0
   and.b %1,#%2,%0
   and.b %1,#%2,%0
   and.b %2,%1,%0
   and.b %2,%1,%0
   and.b %2,#%1,%0
   and.b %2,#%1,%0
   and.b #%2,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,defuse,etc,use,def,use,defuse,use,def,use,def")
  ]
)

(define_expand "andqi3"
  [(set (match_operand:QI 0 "pic30_mode2_operand"
               "=r<>,r<>,R,R,  r<>,R,r<>,R,  r<>,R,r")
        (and:QI
           (match_operand:QI 1 "pic30_mode1J_or_1bitclr_APSV_operand"
               "%r,  r,  r,r,  r,  r,R<>,R<>,P,  P,0")
           (match_operand:QI 2 "pic30_mode1J_or_1bitclr_APSV_operand"
               "r,  R<>,r,R<>,P,  P,r,  r,  r,  r,J")))]
  ""
  "
{
  if (pic30_one_bit_set(GET_MODE(operands[0]),operands[1],0)) {
    emit(
      gen_bitclrqi(operands[0], operands[2], operands[1])
    );
  } else if (pic30_one_bit_set(GET_MODE(operands[0]),operands[2],0)) {
    emit(
      gen_bitclrqi(operands[0], operands[1], operands[2])
    );
  } else if (pic30_mode1J_operand(operands[1],GET_MODE(operands[1])) &&
             pic30_mode1J_operand(operands[2],GET_MODE(operands[2]))) {
    emit(
      gen_andqi3_DATA(operands[0],operands[1],operands[2])
    );
  } else {
    emit(
      gen_andqi3_APSV(operands[0],operands[1],operands[2])
    );
  }
  DONE;
}")

(define_insn_and_split "*andqi3_sfr0"
  [(set (match_operand:QI 0 "pic30_register_operand"           "=a,a, d")
        (and:QI (match_operand:QI 1 "pic30_register_operand"   "%a,d, d")
                (match_operand:QI 2 "pic30_near_operand" " U,U, U")))
   (clobber (match_scratch:HI 3                          "=X,X,&r"))]
  ""
  "@
   and.b %2,WREG
   mov.b %1,w0\;and.b %2,WREG
   mov #%2,%3\;and.b %1,[%3],%0"
  "reload_completed"
  [
   (const_int 0)
  ]
"
{
  if (!pic30_wreg_operand(operands[0], QImode) &&
      !pic30_wreg_operand(operands[1], QImode))
  {
    rtx pop = gen_rtx_MEM(QImode, operands[3]);
    emit_insn(gen_movhi_address(operands[3], XEXP(operands[2],0)));
    emit_insn(gen_andqi3(operands[0], operands[1], pop));
    DONE;
  }
  else
  {
    FAIL;
  }
}
"
  [
   (set_attr "cc" "set")
   (set_attr "type" "def")
  ]
)

(define_insn_and_split "*andqi3_sfr2"
  [(set (match_operand:QI 0 "pic30_near_operand"             "=U,U")
        (and:QI (match_operand:QI 1 "pic30_register_operand" "%a,d")
                (match_dup 0)))
   (clobber (match_scratch:HI 2                              "=X,&r"))]
  ""
  "@
   and.b %0
   mov #%0,%2\;and.b %1,[%2],[%2]"
  "reload_completed"
  [
   (const_int 0)
  ]
"
{
  if (!pic30_wreg_operand(operands[1], QImode))
  {
    rtx pop = gen_rtx_MEM(QImode, operands[2]);
    emit_insn(gen_movhi_address(operands[2], XEXP(operands[0],0)));
    emit_insn(gen_andqi3(pop, operands[1], pop));
    DONE;
  }
  else
  {
    FAIL;
  }
}
"
  [
   (set_attr "cc" "set")
   (set_attr "type" "etc")
  ]
)

;;;;;;;;;;;;;;;
;; half integer
;;;;;;;;;;;;;;;

(define_insn "andhi3_DATA"
  [(set (match_operand:HI 0 "pic30_mode2_operand"
              "=r<>,r<>,R,R,  R<>,r,R,  r<>,R,r<>")
        (and:HI 
          (match_operand:HI 1 "pic30_mode1P_operand"
              "%r,  r,  r,r,  r,  r,R<>,R<>,P,P")
          (match_operand:HI 2 "pic30_mode1P_operand"
              "r,  R<>,r,R<>,P,  P,r,  r,  r,r")))]
  ""
  "@
   and %1,%2,%0
   and %1,%2,%0
   and %1,%2,%0
   and %1,%2,%0
   and %1,#%2,%0
   and %1,#%2,%0
   and %2,%1,%0
   and %2,%1,%0
   and %2,#%1,%0
   and %2,#%1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,defuse,use,use,def,use,use,defuse,use,def")
  ]
)

(define_insn "andhi3_APSV"
  [(set (match_operand:HI 0 "pic30_mode2_operand"
              "=r<>,r<>,R,R,  R<>,r,R,  r<>,R,r<>")
        (and:HI 
          (match_operand:HI 1 "pic30_mode1P_APSV_operand"
              "%r,  r,  r,r,  r,  r,R<>,R<>,P,P")
          (match_operand:HI 2 "pic30_mode1P_APSV_operand"
              "r,  R<>,r,R<>,P,  P,r,  r,  r,r")))]
  ""
  "@
   and %1,%2,%0
   and %1,%2,%0
   and %1,%2,%0
   and %1,%2,%0
   and %1,#%2,%0
   and %1,#%2,%0
   and %2,%1,%0
   and %2,%1,%0
   and %2,#%1,%0
   and %2,#%1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,defuse,use,use,def,use,use,defuse,use,def")
  ]
)

(define_expand "andhi3"
  [(set (match_operand:HI 0 "pic30_mode2_operand"
              "=r<>,r<>,R,R,  R<>,r,R,  r<>,R,r<>")
        (and:HI
          (match_operand:HI 1 "pic30_mode1P_or_1bitclr_APSV_operand"
              "%r,  r,  r,r,  r,  r,R<>,R<>,P,P")
          (match_operand:HI 2 "pic30_mode1P_or_1bitclr_APSV_operand"
              "r,  R<>,r,R<>,P,  P,r,  r,  r,r")))]
  ""
  "
{
  if (pic30_one_bit_set(GET_MODE(operands[0]),operands[1],0)) {
    emit(
      gen_bitclrhi(operands[0], operands[2], operands[1])
    );
  } else if (pic30_one_bit_set(GET_MODE(operands[0]),operands[2],0)) {
    emit(
      gen_bitclrhi(operands[0], operands[1], operands[2])
    );
  } else if (pic30_mode1P_operand(operands[1],GET_MODE(operands[1])) &&
             pic30_mode1P_operand(operands[2],GET_MODE(operands[2]))) {
    emit(
      gen_andhi3_DATA(operands[0],operands[1],operands[2])
    );
  } else if (pic30_reg_or_near_operand(operands[1],GET_MODE(operands[1])) &&
             pic30_reg_or_near_operand(operands[0],GET_MODE(operands[0]))) {
    emit(
      gen_andhi3_sfr(operands[0],operands[1],operands[2])
    );
  } else {
    emit(
      gen_andhi3_APSV(operands[0],operands[1],operands[2])
    );
  }
  DONE;
}")

(define_insn "andhi3_sfr"
  [(set (match_operand:HI   0 "pic30_reg_or_near_operand" "=U,U,U,a,r,r")
        (and:HI
          (match_operand:HI 1 "pic30_reg_or_near_operand" "%0,0,r,U,U,r")
          (match_operand:HI 2 "pic30_register_operand"    " a,r,r,a,r,r"))
   )
   (clobber 
          (match_scratch:HI 3                             "=X,r,r,X,&r,X"))
    
  ]
  ""
  "@
   and %0
   mov #%0,%3\;and %2,[%3],[%3]
   and %1,%2,%3\;mov %3,%0
   and %1,WREG
   mov %1,%3\;and %2,%3,%0
   and %1,%2,%0"
  [
    (set_attr "cc" "math")
    (set_attr "type" "etc,etc,etc,def,def,def")
  ]
)

(define_insn "*andhi3_imm"
  [(set (match_operand:HI 0 "pic30_register_operand"         "=r")
        (and:HI (match_operand:HI 1 "pic30_register_operand" "%0")
                 (match_operand:HI 2 "pic30_J_operand"  "J")))]
  ""
  "and #%2,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
  ]
)

;(define_insn "andhi3_sfr0"
;  [(set (match_operand:HI 0 "pic30_near_operand"         "=U,??U,??U")
;        (and:HI (match_operand:HI 1 "pic30_register_operand"   "%a,??d,??r")
;                (match_operand:HI 2 "pic30_near_operand"  "0,  0,??U")))
;		(clobber (match_scratch:HI 3             "=X,  X, &r"))]
;  ""
;  "*
;   switch (which_alternative) {
;     default: gcc_assert(0);
;     case 0: return \"and %0\";
;     case 1: if (pic30_errata_mask & exch_errata)
;               return \"push w0\;mov %1,w0\;and %0\;pop w0\";
;             else
;               return \"exch w0,%1\;and %0\;exch w0,%1\";
;     case 2: return \"mov %2,%3\;and %3,%1,%3\;mov %3,%0\";
;   }
;  "
;  [(set_attr "cc" "math")])
;
;(define_insn "andhi3_sfr1"
;  [(set (match_operand:HI 0 "pic30_near_operand"         "=U,??U,??U")
;        (and:HI (match_operand:HI 1 "pic30_near_operand" "%0,  0,??U")
;                (match_operand:HI 2 "pic30_register_operand"    "a,??d,??r")))
;		(clobber (match_scratch:HI 3             "=X,  X, &r"))]
;  ""
;  "*
;   switch (which_alternative) {
;     default: gcc_assert(0);
;     case 0: return \"and %0\";
;     case 1: if (pic30_errata_mask & exch_errata)
;               return \"push w0\;mov %2,w0\;and %0\;pop w0\";
;             else
;               return \"exch w0,%2\;and %0\;exch w0,%2\";
;     case 2: return \"mov %1,%3\;and %3,%2,%3\;mov %3,%0\";
;   }
;  "
;  [(set_attr "cc" "math")])

;;;;
;;    gcc will FORCE a reload for a memory operation if it is a SUBREG -
;;    if the pattern doesn't have a register option, then reload will fail
;;    even though some machines (like dsPIC) can read a byte or hi mode just
;;    fine
;;;;
(define_insn_and_split "*andhi3_sfr2"
  [(set (match_operand:HI 0 "pic30_register_operand"          "=a,  r, r")
        (and:HI (match_operand:HI 1 "pic30_register_operand"  " 0,  r, r")
                (match_operand:HI 2 "pic30_reg_or_near_operand"
                                                              " U,  U, r")))
                (clobber (match_scratch:HI 3                  "=X,  &r,X"))]
  ""
  "@
   and %2,WREG
   mov %2,%3\;and %3,%1,%0
   and %1,%2,%0"
  "reload_completed"
  [
   (set (match_dup 3) (match_dup 2))
   (set (match_dup 0) (and:HI (match_dup 3) (match_dup 1)))
  ]
"
{
  if ((pic30_wreg_operand(operands[0], HImode) &&
      (pic30_wreg_operand(operands[1], HImode))) ||
      (pic30_register_operand(operands[2], HImode)))
  {
      FAIL;
  }
}
"
  [
   (set_attr "cc" "set")
   (set_attr "type" "def")
  ]
)

;;;;;;;;;;;;;;;;;
;; single integer
;;;;;;;;;;;;;;;;;
;  _APSV_ odd pattern
(define_expand "andsi3"
 [(set (match_operand:SI 0 "pic30_mode2_operand"
			"=r<>,r<>,&r<>,R,R,R,R, R, r<>")
       (and:SI (match_operand:SI 1 "pic30_mode1P_operand"
			"%r,  r,   r,  r,r,r,r, r, r")
               (match_operand:SI 2 "pic30_mode1P_operand"
			 "r  ,<>,  R,  0,R,r,<>,P, P")))]
 ""
 "
{ rtx operand0_lo,operand0_hi;
  rtx operand1_lo,operand1_hi;
  rtx operand2_lo,operand2_hi;
  rtx operand_0;

  rtx operands_1 = force_reg(SImode, operands[1]);
  rtx operands_2 = force_reg(SImode, operands[2]);

  if (GET_CODE(operands_2) == CONST_INT) {
    operand0_lo = gen_reg_rtx(HImode);
    operand1_lo = gen_reg_rtx(HImode);
    operand1_hi = gen_reg_rtx(HImode);
    operand_0 = gen_reg_rtx(SImode);
  
    emit_insn(gen_movhi(operand1_lo, gen_rtx_SUBREG(HImode,operands_1,0)));
    emit_insn(gen_movhi(operand1_hi, gen_rtx_SUBREG(HImode,operands_1,2)));
    emit_insn(gen_andhi3(operand0_lo, operand1_lo, operands_2));
    emit_insn(gen_movsi_const0(operands[0]));
    emit_insn(gen_movsi(operand_0,gen_rtx_ZERO_EXTEND(SImode, operand0_lo)));
    emit_insn(gen_iorsi3(operands[0], operands[0], operand_0));
    DONE;
  } else {
    operand0_lo = gen_reg_rtx(HImode);
    operand0_hi = gen_reg_rtx(HImode);
    operand1_lo = gen_reg_rtx(HImode);
    operand1_hi = gen_reg_rtx(HImode);
    operand2_lo = gen_reg_rtx(HImode);
    operand2_hi = gen_reg_rtx(HImode);
    operand_0 = gen_reg_rtx(SImode);

    emit_insn(gen_movhi(operand1_lo, gen_rtx_SUBREG(HImode,operands_1,0)));
    emit_insn(gen_movhi(operand1_hi, gen_rtx_SUBREG(HImode,operands_1,2)));
    emit_insn(gen_movhi(operand2_lo, gen_rtx_SUBREG(HImode,operands_2,0)));
    emit_insn(gen_movhi(operand2_hi, gen_rtx_SUBREG(HImode,operands_2,2)));
    emit_insn(gen_andhi3(operand0_lo, operand1_lo, operand2_lo));
    emit_insn(gen_andhi3(operand0_hi, operand1_hi, operand2_hi));
    emit_insn(gen_movsi(operand_0,gen_rtx_ZERO_EXTEND(SImode, operand0_hi)));
    /* ashlsi3 does not accept a mode2 operand */
    emit_insn(gen_ashlsi3(operand_0, operand_0, GEN_INT(16)));
    emit_insn(gen_movsi(operands[0], operand_0));
    emit_insn(gen_movsi(operand_0,gen_rtx_ZERO_EXTEND(SImode, operand0_lo)));
    emit_insn(gen_iorsi3(operands[0], operands[0], operand_0));
    DONE;
  }

}")

; leave this match_dup, operand 1 cannot interfere with reload (CAW)
(define_insn_and_split "*andsi3_sfr0"
  [(set (match_operand:SI 0 "pic30_data_operand"      "=T")
        (and:SI (match_dup 0)
                (match_operand:SI 1 "pic30_register_operand" "r")))
   (clobber (match_scratch:HI 2 "=&r"))]
  ""
  "mov #%0,%2\;and %1,[%2],[%2]\;and %d1,[++%2],[%2]"
  "reload_completed"
  [
   (const_int 0)
  ]
"
  {
  	rtx pop = gen_rtx_MEM(SImode, operands[2]);
	emit_insn(gen_movhi_address(operands[2], XEXP(operands[0],0)));
	emit_insn(gen_andsi3(pop, operands[1], pop));
	DONE;
  }
"
  [
   (set_attr "cc" "clobber")
  ]
)

; leave this match_dup, operand 1 cannot interfere with reload (CAW)
(define_insn_and_split "*andsi3_sfr1"
  [(set (match_operand:SI 0 "pic30_data_operand"      "=T")
        (and:SI (match_operand:SI 1 "pic30_register_operand" "r")
                (match_dup 0)))
   (clobber (match_scratch:HI 2         "=&r"))]
  ""
  "mov #%0,%2\;and %1,[%2],[%2]\;and %d1,[++%2],[%2]"
  "reload_completed"
  [
   (const_int 0)
  ]
"
  {
  	rtx pop = gen_rtx_MEM(SImode, operands[2]);
	emit_insn(gen_movhi_address(operands[2], XEXP(operands[0],0)));
	emit_insn(gen_andsi3(pop, operands[1], pop));
	DONE;
  }
"
  [
   (set_attr "cc" "clobber")
  ]
)

;;;;;;;;;;;;;;;;;
;; double integer
;;;;;;;;;;;;;;;;;

(define_insn "*andhidi3_se"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (and:DI
           (sign_extend:DI
              (match_operand:HI 1 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")))
  (clobber (match_scratch:HI 3                   "=&r,&r,&r,&r,&r,&r,&r,&r,&r"))
  ]
  ""
  "*
{
   char *noerrata_patterns[] = {
     /* r,r,r */          \"asr %1,#15,%3\;and %1,%2,%0\;and %3,%d2,%d0\;\"
                              \"and %3,%t2,%t0\;and %3,%q2,%q0\",

     /* >,r,r */          \"asr %1,#15,%3\;and %1,%2,%0\;and %3,%d2,%0\;\"
                              \"and %3,%t2,%0\;and %3,%q2,%0\",

     /* >,r,0 */          \"asr %1,#15,%3\;and %1,%s2,%0\;and %3,%s2,%0\;\"
                              \"and %3,%s2,%0\;and %3,%s2,%0\",

     /* >,r,> */          \"asr %1,#15,%3\;and %1,%2,%0\;and %3,%2,%0\;\"
                              \"and %3,%2,%0\;and %3,%2,%0\",

     /* r,r,> */          \"asr %1,#15,%3\;and %1,%2,%0\;and %3,%2,%d0\;\"
                              \"and %3,%2,%t0\;and %3,%2,%q0\",

     /* R,r,r */          \"asr %1,#15,%3\;and %1,%2,%I0\;and %3,%d2,%I0\;\"
                              \"and %3,%t2,%I0\;and %3,%q2,%s0\",

     /* R,r,0 */          \"asr %1,#15,%3\;and %1,%2,%I0\;and %3,%2,%I0\;\"
                              \"and %3,%2,%I0\;and %3,%2,%s0\",

     /* R,r,R */          \"asr %1,#15,%3\;and %1,%I2,%I0\;and %3,%I2,%I0\;\"
                              \"and %3,%I2,%I0\;and %3,%2,%0\",

     /* r,r,R */          \"asr %1,#15,%3\;and %1,%I2,%0\;and %3,%I2,%d0\;\"
                              \"and %3,%I2,%t0\;and %3,%2,%q0\",
  };

  char *psv_psv_patterns[] = {
     /* r,r,r */          \"asr %1,#15,%3\;and %1,%2,%0\;and %3,%d2,%d0\;\"
                              \"and %3,%t2,%t0\;and %3,%q2,%q0\",

     /* >,r,r */          \"asr %1,#15,%3\;and %1,%2,%0\;and %3,%d2,%0\;\"
                              \"and %3,%t2,%0\;and %3,%q2,%0\",

     /* >,r,0 */          \"asr %1,#15,%3\;and %1,%s2,%0\;and %3,%s2,%0\;\"
                              \"and %3,%s2,%0\;and %3,%s2,%0\",

     /* >,r,> */          \"asr %1,#15,%3\;\"
                          \"and %1,%2,%0\;\"
                          \"nop\;\"
                          \"and %3,%2,%0\;\"
                          \"nop\;\"
                          \"and %3,%2,%0\;\"
                          \"nop\;\"
                          \"and %3,%2,%0\",

     /* r,r,> */          \"asr %1,#15,%3\;\"
                          \"and %1,%2,%0\;\"
                          \"nop\;\"
                          \"and %3,%2,%d0\;\"
                          \"nop\;\"
                          \"and %3,%2,%t0\;\"
                          \"nop\;\"
                          \"and %3,%2,%q0\",

     /* R,r,r */          \"asr %1,#15,%3\;and %1,%2,%I0\;and %3,%d2,%I0\;\"
                              \"and %3,%t2,%I0\;and %3,%q2,%s0\",

     /* R,r,0 */          \"asr %1,#15,%3\;and %1,%2,%I0\;and %3,%2,%I0\;\"
                              \"and %3,%2,%I0\;and %3,%2,%s0\",

     /* R,r,R */          \"asr %1,#15,%3\;\"
                          \"and %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"and %3,%I2,%I0\;\"
                          \"nop\;\"
                          \"and %3,%I2,%I0\;\"
                          \"nop\;\"
                          \"and %3,%2,%0\",

     /* r,r,R */          \"asr %1,#15,%3\;\"
                          \"and %1,%I2,%0\;\"
                          \"nop\;\"
                          \"and %3,%I2,%d0\;\"
                          \"nop\;\"
                          \"and %3,%I2,%t0\;\"
                          \"nop\;\"
                          \"and %3,%2,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  char **patterns;
  int regno;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
  ]
)

(define_insn "*andhidi3_ze"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (and:DI
           (zero_extend:DI
              (match_operand:HI 1 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R"))
   )
  ]
  ""
  "*
{
   char *noerrata_patterns[] = {
     /* r,r,r */          \"and %1,%2,%0\;clr %d0\;mul.uu %t0,#0,%t0\",

     /* >,r,r */          \"and %1,%2,%0\;clr %0\;clr %0\;clr %0\",

     /* >,r,0 */          \"and %1,%s2,%0\;clr %0\;clr %0\;clr %0\",

     /* >,r,> */          \"and %1,%2,%0\;clr %0\;clr %0\;clr %0\",

     /* r,r,> */          \"and %1,%2,%0\;clr %d0\;mul.uu %t0,#0,%t0\",

     /* R,r,r */          \"and %1,%2,%I0\;clr %I0\;clr %I0\;clr %0\",

     /* R,r,0 */          \"and %1,%2,%I0\;clr %I0\;clr %I0\;clr %I0\",

     /* R,r,R */          \"and %1,%2,%I0\;clr %I0\;clr %I0\;clr %I0\",

     /* r,r,R */          \"and %1,%2,%0\;clr %d0\;mul.uu %t0,#0,%t0\"
  };

  char *psv_psv_patterns[] = {
     /* r,r,r */          \"and %1,%2,%0\;clr %d0\;mul.uu %t0,#0,%t0\",

     /* >,r,r */          \"and %1,%2,%0\;clr %0\;clr %0\;clr %0\",

     /* >,r,0 */          \"and %1,%s2,%0\;clr %0\;clr %0\;clr %0\",

     /* >,r,> */          \"and %1,%2,%0\;\"
                          \"clr %0\;\"
                          \"clr %0\;\"
                          \"clr %0\",

     /* r,r,> */          \"and %1,%2,%0\;\"
                          \"clr %d0\;\"
                          \"mul.uu %t0,#0,%t0\",

     /* R,r,r */          \"and %1,%2,%I0\;clr %I0\;clr %I0\;clr %0\",

     /* R,r,0 */          \"and %1,%2,%I0\;clr %I0\;clr %I0\;clr %I0\",

     /* R,r,R */          \"and %1,%2,%I0\;\"
                          \"clr %I0\;\"
                          \"clr %I0\;\"
                          \"clr %I0\",

     /* r,r,R */          \"and %1,%2,%0\;\"
                          \"clr %d0\;\"
                          \"mul.uu %t0,#0,%t0\"
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  char **patterns;
  int regno;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 3:  /* >,r,> */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;add #6,%r2\");
              }
              return szInsns;

     case 4:  /* r,r,> */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;add #6,%r2\");
              }
              return szInsns;

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
  ]
)

(define_insn "*andsidi3_se"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (and:DI
           (sign_extend:DI
              (match_operand:SI 1 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")))
  (clobber (match_scratch:HI 3                   "=&r,&r,&r,&r,&r,&r,&r,&r,&r"))
  ]
  ""
  "*
{
  char *noerrata_patterns[] = {
     /* r,r,r */          \"asr %d1,#15,%3\;and %1,%2,%0\;and %d1,%d2,%d0\;\"
                              \"and %3,%t2,%t0\;and %3,%q2,%q0\",

     /* >,r,r */          \"asr %d1,#15,%3\;and %1,%2,%0\;and %d1,%d2,%0\;\"
                              \"and %3,%t2,%0\;and %3,%q2,%0\",

     /* >,r,0 */          \"asr %d1,#15,%3\;and %1,%s2,%0\;and %d1,%s2,%0\;\"
                              \"and %3,%s2,%0\;and %3,%s2,%0\",

     /* >,r,> */          \"asr %d1,#15,%3\;and %1,%2,%0\;and %d1,%2,%0\;\"
                              \"and %3,%2,%0\;and %3,%2,%0\",

     /* r,r,> */          \"asr %d1,#15,%3\;and %1,%2,%0\;and %d1,%2,%d0\;\"
                              \"and %3,%2,%t0\;and %3,%2,%q0\",

     /* R,r,r */          \"asr %d1,#15,%3\;and %1,%2,%I0\;and %d1,%d2,%I0\;\"
                              \"and %3,%t2,%I0\;and %3,%q2,%s0\",

     /* R,r,0 */          \"asr %d1,#15,%3\;and %1,%2,%I0\;and %d1,%2,%I0\;\"
                              \"and %3,%2,%I0\;and %3,%2,%s0\",

     /* R,r,R */          \"asr %d1,#15,%3\;and %1,%I2,%I0\;and %d1,%I2,%I0\;\"
                              \"and %3,%I2,%I0\;and %3,%2,%0\",

     /* r,r,R */          \"asr %d1,#15,%3\;and %1,%I2,%0\;and %d1,%I2,%d0\;\"
                              \"and %3,%I2,%t0\;and %3,%2,%q0\",
  };

  char *psv_psv_patterns[] = {
     /* r,r,r */          \"asr %d1,#15,%3\;and %1,%2,%0\;and %d1,%d2,%d0\;\"
                              \"and %3,%t2,%t0\;and %3,%q2,%q0\",

     /* >,r,r */          \"asr %d1,#15,%3\;and %1,%2,%0\;and %d1,%d2,%0\;\"
                              \"and %3,%t2,%0\;and %3,%q2,%0\",

     /* >,r,0 */          \"asr %d1,#15,%3\;and %1,%s2,%0\;and %d1,%s2,%0\;\"
                              \"and %3,%s2,%0\;and %3,%s2,%0\",

     /* >,r,> */          \"asr %d1,#15,%3\;\"
                          \"and %1,%2,%0\;\"
                          \"nop\;\"
                          \"and %d1,%2,%0\;\"
                          \"nop\;\"
                          \"and %3,%2,%0\;\"
                          \"nop\;\"
                          \"and %3,%2,%0\",

     /* r,r,> */          \"asr %d1,#15,%3\;\"
                          \"and %1,%2,%0\;\"
                          \"nop\;\"
                          \"and %d1,%2,%d0\;\"
                          \"nop\;\"
                          \"and %3,%2,%t0\;\"
                          \"nop\;\"
                          \"and %3,%2,%q0\",

     /* R,r,r */          \"asr %d1,#15,%3\;and %1,%2,%I0\;and %d1,%d2,%I0\;\"
                              \"and %3,%t2,%I0\;and %3,%q2,%s0\",

     /* R,r,0 */          \"asr %d1,#15,%3\;and %1,%2,%I0\;and %d1,%2,%I0\;\"
                              \"and %3,%2,%I0\;and %3,%2,%s0\",

     /* R,r,R */          \"asr %d1,#15,%3\;\"
                          \"and %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"and %d1,%I2,%I0\;\"
                          \"nop\;\"
                          \"and %3,%I2,%I0\;\"
                          \"nop\;\"
                          \"and %3,%2,%0\",

     /* r,r,R */          \"asr %d1,#15,%3\;\"
                          \"and %1,%I2,%0\;\"
                          \"nop\;\"
                          \"and %d1,%I2,%d0\;\"
                          \"nop\;\"
                          \"and %3,%I2,%t0\;\"
                          \"nop\;\"
                          \"and %3,%2,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  char **patterns;
  int regno;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
  ]
)

(define_insn "*andsidi3_ze"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (and:DI
           (zero_extend:DI
              (match_operand:SI 1 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R"))
   )
  ]
  ""
  "*
{
   char *noerrata_patterns[] = {
     /* r,r,r */          \"and %1,%2,%0\;and %d1,%d2,%d0\;mul.uu %t0,#0,%t0\",

     /* >,r,r */          \"and %1,%2,%0\;and %d1,%d2,%0\;clr %0\;clr %0\",

     /* >,r,0 */          \"and %1,%s2,%0\;and %d1,%s2,%0\;clr %0\;clr %0\",

     /* >,r,> */          \"and %1,%2,%0\;and %d1,%2,%0\;clr %0\;clr %0\",

     /* r,r,> */          \"and %1,%2,%0\;and %d1,%2,%d0\;mul.uu %t0,#0,%t0\",

     /* R,r,r */          \"and %1,%2,%I0\;and %d1,%d2,%I0\;clr %I0\;clr %0\",

     /* R,r,0 */          \"and %1,%2,%I0\;and %d1,%2,%I0\;clr %I0\;clr %0\",

     /* R,r,R */          \"and %1,%I2,%I0\;and %d1,%D2,%I0\;clr %I0\;clr %0\",

     /* r,r,R */          \"and %1,%I2,%0\;and %d1,%D2,%d0\;mul.uu %t0,#0,%t0\",
  };

  char *psv_psv_patterns[] = {
     /* r,r,r */          \"and %1,%2,%0\;and %d1,%d2,%d0\;mul.uu %t0,#0,%t0\",

     /* >,r,r */          \"and %1,%2,%0\;and %d1,%d2,%0\;clr %0\;clr %0\",

     /* >,r,0 */          \"and %1,%s2,%0\;and %d1,%s2,%0\;clr %0\;clr %0\",

     /* >,r,> */          \"and %1,%2,%0\;\"
                          \"nop\;\"
                          \"and %d1,%2,%0\;\"
                          \"clr %0\;\"
                          \"clr %0\",

     /* r,r,> */          \"and %1,%2,%0\;\"
                          \"nop\;\"
                          \"and %d1,%2,%d0\;\"
                          \"mul.uu %t0,#0,%t0\",

     /* R,r,r */          \"and %1,%2,%I0\;and %d1,%d2,%I0\;clr %I0\;clr %0\",

     /* R,r,0 */          \"and %1,%2,%I0\;and %d1,%2,%I0\;clr %I0\;clr %0\",

     /* R,r,R */          \"and %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"and %d1,%D2,%I0\;\"
                          \"clr %I0\;\"
                          \"clr %0\",

     /* r,r,R */          \"and %1,%I2,%0\;\"
                          \"nop\;\"
                          \"and %d1,%D2,%d0\;\"
                          \"mul.uu %t0,#0,%t0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  char **patterns;
  int regno;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops++;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 3:  /* >,r,> */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;add #4,%r2\");
              }
              return szInsns;

     case 4:  /* r,r,> */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;add #4,%r2\");
              }
              return szInsns;

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
  ]
)

(define_insn "*anddihi3_se"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (and:DI
           (match_operand:DI 1 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")
           (sign_extend:DI
              (match_operand:HI 2 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
        )
    )
  (clobber (match_scratch:HI 3                   "=&r,&r,&r,&r,&r,&r,&r,&r,&r"))
  ]
  ""
  "*
{
   char *noerrata_patterns[] = {
     /* r,r,r */          \"asr %2,#15,%3\;and %1,%2,%0\;and %d1,%3,%d0\;\"
                              \"and %t1,%3,%t0\;and %q1,%3,%q0\",

     /* >,r,r */          \"asr %2,#15,%3\;and %1,%2,%0\;and %d1,%3,%0\;\"
                              \"and %t1,%3,%0\;and %q1,%3,%0\",

     /* >,0,r */          \"asr %2,#15,%3\;and %2,%s1,%0\;and %3,%s1,%0\;\"
                              \"and %3,%s1,%0\;and %3,%s1,%0\",

     /* >,>,r */          \"asr %2,#15,%3\;and %2,%1,%0\;and %3,%1,%0\;\"
                              \"and %3,%1,%0\;and %3,%1,%0\",

     /* r,>,r */          \"asr %2,#15,%3\;and %2,%1,%0\;and %3,%1,%d0\;\"
                              \"and %3,%1,%t0\;and %3,%1,%q0\",

     /* R,r,r */          \"asr %2,#15,%3\;and %1,%2,%I0\;and %3,%d1,%I0\;\"
                              \"and %3,%t1,%I0\;and %3,%q1,%s0\",

     /* R,0,r */          \"asr %2,#15,%3\;and %2,%1,%I0\;and %3,%1,%I0\;\"
                              \"and %3,%1,%I0\;and %3,%1,%0\",

     /* R,R,r */          \"asr %2,#15,%3\;and %2,%I1,%I0\;and %3,%I1,%I0\;\"
                              \"and %3,%I1,%I0\;and %3,%1,%0\",

     /* r,R,r */          \"asr %2,#15,%3\;and %2,%I1,%0\;and %3,%I1,%d0\;\"
                              \"and %3,%I1,%t0\;and %3,%1,%q0\",
  };

  char *psv_psv_patterns[] = {
     /* r,r,r */          \"asr %2,#15,%3\;and %1,%2,%0\;and %d1,%3,%d0\;\"
                              \"and %t1,%3,%t0\;and %q1,%3,%q0\",

     /* >,r,r */          \"asr %2,#15,%3\;and %1,%2,%0\;and %d1,%3,%0\;\"
                              \"and %t1,%3,%0\;and %q1,%3,%0\",

     /* >,0,r */          \"asr %2,#15,%3\;and %2,%s1,%0\;and %3,%s1,%0\;\"
                              \"and %3,%s1,%0\;and %3,%s1,%0\",

     /* >,>,r */          \"asr %2,#15,%3\;\"
                          \"and %2,%1,%0\;\"
                          \"nop\;\"
                          \"and %3,%1,%0\;\"
                          \"nop\;\"
                          \"and %3,%1,%0\;\"
                          \"nop\;\"
                          \"and %3,%1,%0\",

     /* r,>,r */          \"asr %2,#15,%3\;\"
                          \"and %2,%1,%0\;\"
                          \"nop\;\"
                          \"and %3,%1,%d0\;\"
                          \"nop\;\"
                          \"and %3,%1,%t0\;\"
                          \"nop\;\"
                          \"and %3,%1,%q0\",

     /* R,r,r */          \"asr %2,#15,%3\;and %1,%2,%I0\;and %3,%d1,%I0\;\"
                              \"and %3,%t1,%I0\;and %3,%q1,%s0\",

     /* R,0,r */          \"asr %2,#15,%3\;and %2,%1,%I0\;and %3,%1,%I0\;\"
                              \"and %3,%1,%I0\;and %3,%1,%0\",

     /* R,R,r */          \"asr %2,#15,%3\;\"
                          \"and %2,%I1,%I0\;\"
                          \"nop\;\"
                          \"and %3,%I1,%I0\;\"
                          \"nop\;\"
                          \"and %3,%I1,%I0\;\"
                          \"nop\;\"
                          \"and %3,%1,%0\",

     /* r,R,r */          \"asr %2,#15,%3\;\"
                          \"and %2,%I1,%0\;\"
                          \"nop\;\"
                          \"and %3,%I1,%d0\;\"
                          \"nop\;\"
                          \"and %3,%I1,%t0\;\"
                          \"nop\;\"
                          \"and %3,%1,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  char **patterns;
  int regno;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,0,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,R,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[1],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;

     case 8:  /* r,R,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[1],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "clobber")
     (set_attr "type" "def")
  ]
)

(define_insn "*anddihi3_ze"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (and:DI
           (match_operand:DI 1 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")
           (zero_extend:DI
              (match_operand:HI 2 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
        )
   )
  ]
  ""
  "*
{
   char *patterns[] = {
     /* r,r,r */          \"and %1,%2,%0\;clr %d0\;mul.uu %t0,#0,%t0\",

     /* >,r,r */          \"and %1,%2,%0\;clr %0\;clr %0\;clr %0\",

     /* >,0,r */          \"and %2,%s1,%0\;clr %0\;clr %0\;clr %0\",

     /* >,>,r */          \"and %2,%1,%0\;clr %0\;clr %0\;clr %0\",

     /* r,>,r */          \"and %2,%1,%0\;clr %d0\;mul.uu %t0,#0,%t0\",

     /* R,r,r */          \"and %1,%2,%I0\;clr %I0\;clr %I0\;clr %0\",

     /* R,0,r */          \"and %2,%1,%I0\;clr %I0\;clr %I0\;clr %0\",

     /* R,R,r */          \"and %2,%1,%I0\;clr %I0\;clr %I0\;clr %0\",

     /* r,R,r */          \"and %2,%1,%0\;clr %d0\;mul.uu %t0,#0,%t0\"
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[160];
  int regno;
  rtx x;

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 3:  /* >,>,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;add #6,%r1\");
              }
              return szInsns;

     case 4:  /* r,>,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;add #6,%r1\");
              }
              return szInsns;

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,0,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
   }
}"
   [
     (set_attr "cc" "clobber")
     (set_attr "type" "def")
  ]
)

(define_insn "*anddisi3_se"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (and:DI
           (match_operand:DI 1 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")
           (sign_extend:DI
              (match_operand:SI 2 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
        )
   )
  (clobber (match_scratch:HI 3                   "=&r,&r,&r,&r,&r,&r,&r,&r,&r"))
  ]
  ""
  "*
{
   char *noerrata_patterns[] = {
     /* r,r,r */          \"asr %d2,#15,%3\;and %1,%2,%0\;and %d1,%d2,%d0\;\"
                              \"and %t1,%3,%t0\;and %q1,%3,%q0\",

     /* >,r,r */          \"asr %d2,#15,%3\;and %1,%2,%0\;and %d1,%d2,%0\;\"
                              \"and %t2,%3,%0\;and %q1,%3,%0\",

     /* >,0,r */          \"asr %d2,#15,%3\;and %2,%s1,%0\;and %d2,%s1,%0\;\"
                              \"and %3,%s1,%0\;and %3,%s1,%0\",

     /* >,>,r */          \"asr %d2,#15,%3\;and %2,%1,%0\;and %d2,%1,%0\;\"
                              \"and %3,%1,%0\;and %3,%1,%0\",

     /* r,>,r */          \"asr %d2,#15,%3\;and %2,%1,%0\;and %d2,%1,%d0\;\"
                              \"and %3,%1,%t0\;and %3,%1,%q0\",

     /* R,r,r */          \"asr %d2,#15,%3\;and %1,%2,%I0\;and %d1,%d2,%I0\;\"
                              \"and %t1,%3,%I0\;and %q1,%3,%0\",

     /* R,0,r */          \"asr %d2,#15,%3\;and %2,%1,%I0\;and %d2,%1,%I0\;\"
                              \"and %3,%1,%I0\;and %3,%1,%0\",

     /* R,R,r */          \"asr %d2,#15,%3\;and %2,%I1,%I0\;and %d2,%I1,%I0\;\"
                              \"and %2,%I1,%I0\;and %3,%1,%0\",

     /* r,R,r */          \"asr %d2,#15,%3\;and %2,%I1,%0\;and %d2,%I1,%d0\;\"
                              \"and %3,%I1,%t0\;and %3,%1,%q0\",
  };

  char *psv_psv_patterns[] = {
     /* r,r,r */          \"asr %d2,#15,%3\;and %1,%2,%0\;and %d1,%d2,%d0\;\"
                              \"and %t1,%3,%t0\;and %q1,%3,%q0\",

     /* >,r,r */          \"asr %d2,#15,%3\;and %1,%2,%0\;and %d1,%d2,%0\;\"
                              \"and %t2,%3,%0\;and %q1,%3,%0\",

     /* >,0,r */          \"asr %d2,#15,%3\;and %2,%s1,%0\;and %d2,%s1,%0\;\"
                              \"and %3,%s1,%0\;and %3,%s1,%0\",

     /* >,>,r */          \"asr %d2,#15,%3\;\"
                          \"and %2,%1,%0\;\"
                          \"nop\;\"
                          \"and %d2,%1,%0\;\"
                          \"nop\;\"
                          \"and %3,%1,%0\;\"
                          \"nop\;\"
                          \"and %3,%1,%0\",

     /* r,>,r */          \"asr %d2,#15,%3\;\"
                          \"and %2,%1,%0\;\"
                          \"nop\;\"
                          \"and %d2,%1,%d0\;\"
                          \"nop\;\"
                          \"and %3,%1,%t0\;\"
                          \"nop\;\"
                          \"and %3,%1,%q0\",

     /* R,r,r */          \"asr %d2,#15,%3\;and %1,%2,%I0\;and %d1,%d2,%I0\;\"
                              \"and %t1,%3,%I0\;and %q1,%3,%0\",

     /* R,0,r */          \"asr %d2,#15,%3\;and %2,%1,%I0\;and %d2,%1,%I0\;\"
                              \"and %3,%1,%I0\;and %3,%1,%0\",

     /* R,R,r */          \"asr %d2,#15,%3\;\"
                          \"and %2,%I1,%I0\;\"
                          \"nop\;\"
                          \"and %d2,%I1,%I0\;\"
                          \"nop\;\"
                          \"and %2,%I1,%I0\;\"
                          \"nop\;\"
                          \"and %3,%1,%0\",

     /* r,R,r */          \"asr %d2,#15,%3\;\"
                          \"and %2,%I1,%0\;\"
                          \"nop\;\"
                          \"and %d2,%I1,%d0\;\"
                          \"nop\;\"
                          \"and %3,%I1,%t0\;\"
                          \"nop\;\"
                          \"and %3,%1,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  char **patterns;
  int regno;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,0,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,R,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[1],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;

     case 8:  /* r,R,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[1],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "clobber")
     (set_attr "type" "def")
  ]
)

(define_insn "*anddisi3_ze"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (and:DI
           (match_operand:DI 1 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")
           (zero_extend:DI
              (match_operand:SI 2 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
        )
   )
  ]
  ""
  "*
{
  char *noerrata_patterns[] = {
     /* r,r,r */          \"and %1,%2,%0\;and %d1,%d2,%d0\;mul.uu %t0,#0,%t0\",

     /* >,r,r */          \"and %1,%2,%0\;and %d1,%d2,%0\;clr %0\;clr %0\",

     /* >,0,r */          \"and %2,%s1,%0\;and %d2,%s1,%0\;clr %0\;clr %0\",

     /* >,>,r */          \"and %2,%1,%0\;and %d2,%1,%0\;clr %0\;clr %0\",

     /* r,>,r */          \"and %2,%1,%0\;and %d2,%1,%d0\;mul.uu %t0,#0,%t0\",

     /* R,r,r */          \"and %1,%2,%I0\;and %d1,%d2,%I0\;clr %I0\;clr %0\",

     /* R,0,r */          \"and %2,%1,%I0\;and %d2,%1,%I0\;clr %I0\;clr %0\",

     /* R,R,r */          \"and %2,%I1,%I0\;and %d2,%D1,%I0\;clr %I0\;clr %0\",

     /* r,R,r */          \"and %2,%I1,%0\;and %d2,%D1,%d0\;mul.uu %t0,#0,%t0\",
  };

  char *psv_psv_patterns[] = {
     /* r,r,r */          \"and %1,%2,%0\;and %d1,%d2,%d0\;mul.uu %t0,#0,%t0\",

     /* >,r,r */          \"and %1,%2,%0\;and %d1,%d2,%0\;clr %0\;clr %0\",

     /* >,0,r */          \"and %2,%s1,%0\;and %d2,%s1,%0\;clr %0\;clr %0\",

     /* >,>,r */          \"and %2,%1,%0\;\"
                          \"nop\;\"
                          \"and %d2,%1,%0\;\"
                          \"clr %0\;\"
                          \"clr %0\",

     /* r,>,r */          \"and %2,%1,%0\;\"
                          \"nop\;\"
                          \"and %d2,%1,%d0\;\"
                          \"mul.uu %t0,#0,%t0\",

     /* R,r,r */          \"and %1,%2,%I0\;\"
                          \"nop\;\"
                          \"and %d1,%d2,%I0\;\"
                          \"clr %I0\;\"
                          \"clr %0\",

     /* R,0,r */          \"and %2,%1,%I0\;\"
                          \"and %d2,%1,%I0\;\"
                          \"clr %I0\;\"
                          \"clr %0\",

     /* R,R,r */          \"and %2,%I1,%I0\;\"
                          \"nop\;\"
                          \"and %d2,%D1,%I0\;\"
                          \"clr %I0\;\"
                          \"clr %0\",

     /* r,R,r */          \"and %2,%I1,%0\;\"
                          \"nop\;\"
                          \"and %d2,%D1,%d0\;\"
                          \"mul.uu %t0,#0,%t0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[170];
  char **patterns;
  int regno;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops++;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 3:  /* >,>,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[1],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;add #4,%r1\");
              }
              return szInsns;

     case 4:  /* r,>,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[1],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;add #4,%r1\");
              }
              return szInsns;

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,0,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,R,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
   }
}"
   [
     (set_attr "cc" "clobber")
     (set_attr "type" "def")
  ]
)

(define_insn "anddi3"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (and:DI
           (match_operand:DI 1 "pic30_register_operand"    "r,r,r,r, r,r,r,r, r")
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")))
  ]
  ""
  "*
{
   char *noerrata_patterns[] = {
     /* r,r,r */          \"and %1,%2,%0\;and %d1,%d2,%d0\;\"
                              \"and %t1,%t2,%t0\;and %q1,%q2,%q0\",

     /* >,r,r */          \"and %1,%2,%0\;and %d1,%d2,%0\;\"
                              \"and %t1,%t2,%0\;and %q1,%q2,%0\",

     /* >,r,0 */          \"and %1,%s2,%0\;and %d1,%s2,%0\;\"
                              \"and %t1,%s2,%0\;and %q1,%s2,%0\",

     /* >,r,> */          \"and %1,%2,%0\;and %d1,%2,%0\;\"
                              \"and %t1,%2,%0\;and %q1,%2,%0\",

     /* r,r,> */          \"and %1,%2,%0\;and %d1,%2,%d0\;\"
                              \"and %t1,%2,%t0\;and %q1,%2,%q0\",

     /* R,r,r */          \"and %1,%2,%I0\;and %d1,%d2,%I0\;\"
                              \"and %t1,%t2,%I0\;and %q1,%q2,%0\",

     /* R,r,0 */          \"and %1,%2,%I0\;and %d1,%2,%I0\;\"
                              \"and %t1,%2,%I0\;and %q1,%2,%0\",

     /* R,r,R */          \"and %1,%I2,%I0\;and %d1,%I2,%I0\;\"
                              \"and %t1,%I2,%I0\;and %q1,%2,%0\",

     /* r,r,R */          \"and %1,%I2,%0\;and %d1,%I2,%d0\;\"
                              \"and %t1,%I2,%t0\;and %q1,%2,%q0\",
  };

  char *psv_psv_patterns[] = {
     /* r,r,r */          \"and %1,%2,%0\;and %d1,%d2,%d0\;\"
                              \"and %t1,%t2,%t0\;and %q1,%q2,%q0\",

     /* >,r,r */          \"and %1,%2,%0\;and %d1,%d2,%0\;\"
                              \"and %t1,%t2,%0\;and %q1,%q2,%0\",

     /* >,r,0 */          \"and %1,%s2,%0\;and %d1,%s2,%0\;\"
                              \"and %t1,%s2,%0\;and %q1,%s2,%0\",

     /* >,r,> */          \"and %1,%2,%0\;\"
                          \"nop\;\"
                          \"and %d1,%2,%0\;\"
                          \"nop\;\"
                          \"and %t1,%2,%0\;\"
                          \"nop\;\"
                          \"and %q1,%2,%0\",

     /* r,r,> */          \"and %1,%2,%0\;\"
                          \"nop\;\"
                          \"and %d1,%2,%d0\;\"
                          \"nop\;\"
                          \"and %t1,%2,%t0\;\"
                          \"nop\;\"
                          \"and %q1,%2,%q0\",

     /* R,r,r */          \"and %1,%2,%I0\;and %d1,%d2,%I0\;\"
                              \"and %t1,%t2,%I0\;and %q1,%q2,%0\",

     /* R,r,0 */          \"and %1,%2,%I0\;\"
                          \"and %d1,%2,%I0\;\"
                          \"and %t1,%2,%I0\;\"
                          \"and %q1,%2,%0\",

     /* R,r,R */          \"and %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"and %d1,%I2,%I0\;\"
                          \"nop\;\"
                          \"and %t1,%I2,%I0\;\"
                          \"nop\;\"
                          \"and %q1,%2,%0\",

     /* r,r,R */          \"and %1,%I2,%0\;\"
                          \"nop\;\"
                          \"and %d1,%I2,%d0\;\"
                          \"nop\;\"
                          \"and %t1,%I2,%t0\;\"
                          \"nop\;\"
                          \"and %q1,%2,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  char **patterns;
  int regno;
  rtx x;
 
  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "clobber")
     (set_attr "type" "def")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OR
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;
;; quarter integer
;;;;;;;;;;;;;;;;;;

(define_insn "*iorqi3_imm"
  [(set (match_operand:QI 0 "pic30_register_operand"         "=r")
        (ior:QI (match_operand:QI 1 "pic30_register_operand" "%0")
                (match_operand:QI 2 "pic30_J_operand"   "J")))]
  ""
  "ior.b #%2,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
  ]
)

(define_insn "iorqi3_DATA"
  [(set (match_operand:QI 0 "pic30_mode2_operand"
              "=r<>,r<>,R,R,  r<>,R,r<>,R,  r<>,R")
        (ior:QI 
           (match_operand:QI 1 "pic30_mode1P_operand"
              "%r,  r,  r,r,  r,  r,R<>,R<>,P,  P")
           (match_operand:QI 2 "pic30_mode1P_operand"
              "r,  R<>,r,R<>,P,  P,r,  r,  r,  r")))]
  ""
  "@
   ior.b %1,%2,%0
   ior.b %1,%2,%0
   ior.b %1,%2,%0
   ior.b %1,%2,%0
   ior.b %1,#%2,%0
   ior.b %1,#%2,%0
   ior.b %2,%1,%0
   ior.b %2,%1,%0
   ior.b %2,#%1,%0
   ior.b %2,#%1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,defuse,use,use,def,use,defuse,use,def,use")
  ]
)

(define_insn "iorqi3_APSV"
  [(set (match_operand:QI 0 "pic30_mode2_operand"
              "=r<>,r<>,R,R,  r<>,R,r<>,R,  r<>,R")
        (ior:QI 
           (match_operand:QI 1 "pic30_mode1P_APSV_operand"
              "%r,  r,  r,r,  r,  r,R<>,R<>,P,  P")
           (match_operand:QI 2 "pic30_mode1P_APSV_operand"
              "r,  R<>,r,R<>,P,  P,r,  r,  r,  r")))]
  ""
  "@
   ior.b %1,%2,%0
   ior.b %1,%2,%0
   ior.b %1,%2,%0
   ior.b %1,%2,%0
   ior.b %1,#%2,%0
   ior.b %1,#%2,%0
   ior.b %2,%1,%0
   ior.b %2,%1,%0
   ior.b %2,#%1,%0
   ior.b %2,#%1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,defuse,use,use,def,use,defuse,use,def,use")
  ]
)

(define_expand "iorqi3"
  [(set (match_operand:QI 0 "pic30_mode2_operand"
              "=r<>,r<>,R,R,  r<>,R,r<>,R,  r<>,R")
        (ior:QI
           (match_operand:QI 1 "pic30_mode1P_or_1bit_APSV_operand"
              "%r,  r,  r,r,  r,  r,R<>,R<>,P,  P")
           (match_operand:QI 2 "pic30_mode1P_or_1bit_APSV_operand"
              "r,  R<>,r,R<>,P,  P,r,  r,  r,  r")))]
  ""
  "
{
  if (pic30_one_bit_set(GET_MODE(operands[0]),operands[1],1)) {
    emit(
      gen_bitsetqi(operands[0], operands[2], operands[1])
    );
  } else if (pic30_one_bit_set(GET_MODE(operands[0]),operands[2],1)) {
    emit(
      gen_bitsetqi(operands[0], operands[1], operands[2])
    );
  } else if (pic30_mode1P_operand(operands[1],GET_MODE(operands[1])) &&
             pic30_mode1P_operand(operands[2],GET_MODE(operands[2]))) {
    emit(
      gen_iorqi3_DATA(operands[0],operands[1],operands[2])
    );
  } else {
    emit(
     gen_iorqi3_APSV(operands[0],operands[1],operands[2])
    );
  }
  DONE;
}")

(define_insn_and_split "*iorqi3_sfr0"
  [(set (match_operand:QI 0 "pic30_register_operand"           "=a,a,r")
        (ior:QI (match_operand:QI 1 "pic30_register_operand"   "%a,d,r")
                (match_operand:QI 2 "pic30_near_operand" " U,U,U")))
   (clobber (match_scratch: HI 3                         "=X,X,&r"))]
  ""
  "@
   ior.b %2,WREG
   mov.b %1,w0\;ior.b %2,WREG
   mov #%2,%3\;ior.b %1,[%3],%0"
  "reload_completed"
  [
   (const_int 0)
  ]
"
{
  if (!pic30_wreg_operand(operands[0], QImode) &&
      !pic30_wreg_operand(operands[1], QImode))
  {
  	rtx pop = gen_rtx_MEM(QImode, operands[3]);
	emit_insn(gen_movhi_address(operands[3], XEXP(operands[2],0)));
	emit_insn(gen_iorqi3(operands[0], operands[1], pop));
  	DONE;
  }
  else
  {
  	FAIL;
  }
}
"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
  ]
)

; leave this match_dup, operand 1 cannot interfere with reload (CAW)
 (define_insn "*iorqi3_sfr1"
   [(set (match_operand:QI 0 "pic30_near_operand"      "=U, U")
         (ior:QI (match_dup 0)
                 (match_operand:QI 1 "pic30_register_operand" "a, !d")))
    (clobber (match_scratch:HI 2          "=X, &r"))]
   ""
   "@
    ior.b %0
    mov #%0,%2\;ior.b %1,[%2],[%2]"
   [(set_attr "cc" "math")])

;;;;;;;;;;;;;;;
;; half integer
;;;;;;;;;;;;;;;

; this match_can cause issues iff operand 1 is dies in this instruction and
;   we decide to use it to reload operand 0 (CAW)
(define_insn "iorhi3_sfr0"
  [(set (match_operand:HI 0         "pic30_reg_or_near_operand" "=U,a,r")
        (ior:HI (match_operand:HI 1 "pic30_register_operand"    "%a,0,r")
                (match_operand:HI 2 "pic30_reg_or_near_operand" " 0,U,r")))
  ]
  ""
  "@
   ior %0
   ior %2,WREG
   ior %2,%1,%0"
  [
    (set_attr "cc" "math")
    (set_attr "type" "etc,def,def")
  ]
)

(define_insn "*iorhi3_imm"
  [(set (match_operand:HI 0 "pic30_register_operand"          "=r")
        (ior:HI (match_operand:HI 1 "pic30_register_operand" "0")
                (match_operand:HI 2 "pic30_J_operand" "J")))]
  ""
  "ior #%2,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
  ]
)

(define_insn "*iorhi3_imma"
  [(set (match_operand:HI 0 "pic30_register_operand"          "=r")
        (ior:HI (match_operand:HI 1 "pic30_J_operand" "J")
                (match_operand:HI 2 "pic30_register_operand" "0")))]
  ""
  "ior #%1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
  ]
)

(define_insn "iorhi3_DATA"
  [(set (match_operand:HI 0 "pic30_mode2_operand"
              "=r<>,r<>,R,  R,r<>,R,r<>,R,  r<>,R")
        (ior:HI 
           (match_operand:HI 1 "pic30_mode1P_operand"
              "%r,  r,  r,  r,r,  r,R<>,R<>,P,  P")
           (match_operand:HI 2 "pic30_mode1P_operand"
              "R<>,r,  R<>,r,P,  P,r,  r,  r,  r")))
  ]
  ""
  "@
   ior %1,%2,%0
   ior %1,%2,%0
   ior %1,%2,%0
   ior %1,%2,%0
   ior %1,#%2,%0
   ior %1,#%2,%0
   ior %2,%1,%0
   ior %2,%1,%0
   ior %2,#%1,%0
   ior %2,#%1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "defuse,def,use,use,def,use,defuse,use,def,use")
  ]
)

(define_insn "iorhi3_APSV"
  [(set (match_operand:HI 0 "pic30_mode2_operand"
              "=r<>,r<>,R,  R,r<>,R,r<>,R,  r<>,R")
        (ior:HI 
           (match_operand:HI 1 "pic30_mode1P_APSV_operand"
              "%r,  r,  r,  r,r,  r,R<>,R<>,P,  P")
           (match_operand:HI 2 "pic30_mode1P_APSV_operand"
              "R<>,r,  R<>,r,P,  P,r,  r,  r,  r")))
  ]
  ""
  "@
   ior %1,%2,%0
   ior %1,%2,%0
   ior %1,%2,%0
   ior %1,%2,%0
   ior %1,#%2,%0
   ior %1,#%2,%0
   ior %2,%1,%0
   ior %2,%1,%0
   ior %2,#%1,%0
   ior %2,#%1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "defuse,def,use,use,def,use,defuse,use,def,use")
  ]
)

(define_expand "iorhi3"
  [(set (match_operand:HI 0 "pic30_mode2_operand"
              "=r<>,r<>,R,  R,r<>,R,r<>,R,  r<>,R")
        (ior:HI
           (match_operand:HI 1 "pic30_mode1P_or_1bit_APSV_operand"
              "%r,  r,  r,  r,r,  r,R<>,R<>,P,  P")
           (match_operand:HI 2 "pic30_mode1P_or_1bit_APSV_operand"
              "R<>,r,  R<>,r,P,  P,r,  r,  r,  r")))
  ]
  ""
  "
{
  if (pic30_one_bit_set(GET_MODE(operands[0]),operands[1],1)) {
    emit(
      gen_bitsethi(operands[0], operands[2], operands[1])
    );
  } else if (pic30_one_bit_set(GET_MODE(operands[0]),operands[2],1)) {
    emit(
      gen_bitsethi(operands[0], operands[1], operands[2])
    );
  } else if (pic30_mode1P_operand(operands[1],GET_MODE(operands[1])) &&
           pic30_mode1P_operand(operands[2],GET_MODE(operands[2]))) {
    emit(
      gen_iorhi3_DATA(operands[0],operands[1],operands[2])
    );
  } else {
    emit(
      gen_iorhi3_APSV(operands[0],operands[1],operands[2])
    );
  }
  DONE;
}")

(define_insn "*iorhi3_sfr1"
   [(set (match_operand:HI 0 "pic30_near_operand"            "=U, U")
         (ior:HI (match_dup 0)
                 (match_operand:HI 1 "pic30_register_operand" "a, !d")))
    (clobber (match_scratch:HI 2                             "=X, &r"))]
   ""
   "@
    ior %0
    mov #%0,%2\;ior %1,[%2],[%2]"
   [(set_attr "cc" "math")])


;;;;;;;;;;;;;;;;;
;; single integer
;;;;;;;;;;;;;;;;;

(define_insn "iorsi3_DATA"
 [(set (match_operand:SI 0 "pic30_mode2_operand"
             "=r,&r, R,R,R, r,R,<>,<>,R,<>")
       (ior:SI 
          (match_operand:SI 1 "pic30_mode1P_operand"
             "%r, r, r,r,r, 0,r, r, r, r, r")
          (match_operand:SI 2 "pic30_mode1P_operand"
             " r, R, 0,R,r, P,P, <>,R,<>,P")))]
 ""
 "*
  static char *noerrata_normal_patterns[] = {
    \"ior %1,%2,%0\;ior %d1,%d2,%d0\",
    \"ior %1,%I2,%0\;ior %d1,%D2,%d0\",
    \"ior %1,%2,%I0\;ior %d1,%2,%D0\",
    \"ior %1,%I2,%I0\;ior %d1,%D2,%D0\",
    \"ior %1,%2,%I0\;ior %d1,%d2,%D0\",
    \"ior %1,#%2,%0\",
    \"ior %1,#%2,%I0\;mov %d1,%D0\",
    \"ior %1,%2,%0\;ior %d1,%2,%0\",
    \"ior %1,%I2,%0\;ior %d1,%D2,%0\",
    \"ior %1,%2,%I0\;ior %d1,%2,%D0\",
    \"ior %1,#%2,%0\;ior %d1,#0,%0\"
  };

  static char *noerrata_pre_patterns[] = {
    \"add %r0,#4,%r0\;ior %1,%I2,%I0\;ior %d1,%D2,%D0\",
    \"add %r2,#4,%r2\;ior %1,%I2,%I0\;ior %d1,%D2,%D0\",
    \"add %r0,#4,%r0\;ior %1,#%2,%I0\;ior %d1,#0,%D0\"
  };

  static char *psv_psv_normal_patterns[] = {
    \"ior %1,%2,%0\;ior %d1,%d2,%d0\",
    \"ior %1,%I2,%0\;nop\;ior %d1,%D2,%d0\",
    \"ior %1,%2,%I0\;ior %d1,%2,%D0\",
    \"ior %1,%I2,%I0\;nop\;ior %d1,%D2,%D0\",
    \"ior %1,%2,%I0\;ior %d1,%d2,%D0\",
    \"ior %1,#%2,%0\",
    \"ior %1,#%2,%I0\;mov %d1,%D0\",
    \"ior %1,%2,%0\;nop\;ior %d1,%2,%0\",
    \"ior %1,%I2,%0\;nop\;ior %d1,%D2,%0\",
    \"ior %1,%2,%I0\;nop\;ior %d1,%2,%D0\",
    \"ior %1,#%2,%0\;nop\;ior %d1,#0,%0\"
  };

  static char *psv_psv_pre_patterns[] = {
    \"add %r0,#4,%r0\;ior %1,%I2,%I0\;nop\;ior %d1,%D2,%D0\",
    \"add %r2,#4,%r2\;ior %1,%I2,%I0\;nop\;ior %d1,%D2,%D0\",
    \"add %r0,#4,%r0\;ior %1,#%2,%I0\;nop\;ior %d1,#0,%D0\"
  };

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    if (pic30_pre_modify(operands[0]) && pic30_pre_modify(operands[2])) {
      /* special case for both operands being pre-modify */
      pic30_rtx_nops++;
      return \"add %r0,#4,%r0\;\"
             \"add %r2,#4,%r2\;\"
             \"ior %1,%I2,%I0\;\"
             \"nop\;\"
             \"ior %d1,%D2,%D0\";
    } else if (which_alternative == 7) {
      /* special case for alternative 7, with two chances but only one taken */
      if (pic30_pre_modify(operands[0])) {
        pic30_rtx_nops++;
        return \"add %r0,#4,%r0\;\"
               \"ior %1,%2,%I0\;\"
                \"nop\;\"
               \"ior %d1,%2,%D0\";
      } else if (pic30_pre_modify(operands[2])) {
        pic30_rtx_nops++;
        return \"add %r2,#4,%r2\;\"
               \"ior %1,%I2,%0\;\"
               \"nop\;\"
               \"ior %d1,%D2,%0\";
      }
    } else if (pic30_pre_modify(operands[0]) || pic30_pre_modify(operands[2])) {
      pic30_rtx_nops++;
      return psv_psv_pre_patterns[which_alternative - 8];
    }
    return psv_psv_normal_patterns[which_alternative];
  } else {
    if (pic30_pre_modify(operands[0]) && pic30_pre_modify(operands[2])) {
      /* special case for both operands being pre-modify */
      return \"add %r0,#4,%r0\;\"
             \"add %r2,#4,%r2\;\"
             \"ior %1,%I2,%I0\;\"
             \"ior %d1,%D2,%D0\";
    } else if (which_alternative == 7) {
      /* special case for alternative 7, with two chances but only one taken */
      if (pic30_pre_modify(operands[0])) {
        return \"add %r0,#4,%r0\;\"
               \"ior %1,%2,%I0\;\"
               \"ior %d1,%2,%D0\";
      } else if (pic30_pre_modify(operands[2])) {
        return \"add %r2,#4,%r2\;\"
               \"ior %1,%I2,%0\;\"
               \"ior %d1,%D2,%0\";
      }
    } else if (pic30_pre_modify(operands[0]) || pic30_pre_modify(operands[2])) {
      return noerrata_pre_patterns[which_alternative - 8];
    }
    return noerrata_normal_patterns[which_alternative];
  }
 "
 [
  (set_attr "cc" "clobber")
  (set_attr "type" "def,defuse,use,use,use,def,use,use,use,use,use")
 ]
)

(define_insn "iorsi3_APSV"
 [(set (match_operand:SI 0 "pic30_mode2_operand"
             "=r,&r, R,R,R, r,R,<>,<>,R,<>")
       (ior:SI 
          (match_operand:SI 1 "pic30_mode1P_APSV_operand"
             "%r, r, r,r,r, 0,r, r, r, r, r")
          (match_operand:SI 2 "pic30_mode1P_APSV_operand"
             " r, R, 0,R,r, P,P, <>,R,<>,P")))]
 ""
 "*
  static char *noerrata_normal_patterns[] = {
    \"ior %1,%2,%0\;ior %d1,%d2,%d0\",
    \"ior %1,%I2,%0\;ior %d1,%D2,%d0\",
    \"ior %1,%2,%I0\;ior %d1,%2,%D0\",
    \"ior %1,%I2,%I0\;ior %d1,%D2,%D0\",
    \"ior %1,%2,%I0\;ior %d1,%d2,%D0\",
    \"ior %1,#%2,%0\",
    \"ior %1,#%2,%I0\;mov %d1,%D0\",
    \"ior %1,%2,%0\;ior %d1,%2,%0\",
    \"ior %1,%I2,%0\;ior %d1,%D2,%0\",
    \"ior %1,%2,%I0\;ior %d1,%2,%D0\",
    \"ior %1,#%2,%0\;ior %d1,#0,%0\"
  };

  static char *noerrata_pre_patterns[] = {
    \"add %r0,#4,%r0\;ior %1,%I2,%I0\;ior %d1,%D2,%D0\",
    \"add %r2,#4,%r2\;ior %1,%I2,%I0\;ior %d1,%D2,%D0\",
    \"add %r0,#4,%r0\;ior %1,#%2,%I0\;ior %d1,#0,%D0\"
  };

  static char *psv_psv_normal_patterns[] = {
    \"ior %1,%2,%0\;ior %d1,%d2,%d0\",
    \"ior %1,%I2,%0\;nop\;ior %d1,%D2,%d0\",
    \"ior %1,%2,%I0\;ior %d1,%2,%D0\",
    \"ior %1,%I2,%I0\;nop\;ior %d1,%D2,%D0\",
    \"ior %1,%2,%I0\;ior %d1,%d2,%D0\",
    \"ior %1,#%2,%0\",
    \"ior %1,#%2,%I0\;mov %d1,%D0\",
    \"ior %1,%2,%0\;nop\;ior %d1,%2,%0\",
    \"ior %1,%I2,%0\;nop\;ior %d1,%D2,%0\",
    \"ior %1,%2,%I0\;nop\;ior %d1,%2,%D0\",
    \"ior %1,#%2,%0\;nop\;ior %d1,#0,%0\"
  };

  static char *psv_psv_pre_patterns[] = {
    \"add %r0,#4,%r0\;ior %1,%I2,%I0\;nop\;ior %d1,%D2,%D0\",
    \"add %r2,#4,%r2\;ior %1,%I2,%I0\;nop\;ior %d1,%D2,%D0\",
    \"add %r0,#4,%r0\;ior %1,#%2,%I0\;nop\;ior %d1,#0,%D0\"
  };

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops++;
    if (pic30_pre_modify(operands[0]) && pic30_pre_modify(operands[2])) {
      /* special case for both operands being pre-modify */
      return \"add %r0,#4,%r0\;\"
             \"add %r2,#4,%r2\;\"
             \"ior %1,%I2,%I0\;\"
             \"nop\;\"
             \"ior %d1,%D2,%D0\";
    } else if (which_alternative == 6) {
      /* special case for alternative 6, with two chances but only one taken */
      if (pic30_pre_modify(operands[0])) {
        return \"add %r0,#4,%r0\;\"
               \"ior %1,%2,%I0\;\"
               \"nop\;\"
               \"ior %d1,%2,%D0\";
      } else if (pic30_pre_modify(operands[2])) {
        return \"add %r2,#4,%r2\;\"
               \"ior %1,%I2,%0\;\"
               \"nop\;\"
               \"ior %d1,%D2,%0\";
      }
    } else if (pic30_pre_modify(operands[0]) || pic30_pre_modify(operands[2])) {
      return psv_psv_pre_patterns[which_alternative - 7];
    }
    return psv_psv_normal_patterns[which_alternative];
  } else {
    if (pic30_pre_modify(operands[0]) && pic30_pre_modify(operands[2])) {
      /* special case for both operands being pre-modify */
      return \"add %r0,#4,%r0\;\"
             \"add %r2,#4,%r2\;\"
             \"ior %1,%I2,%I0\;\"
             \"ior %d1,%D2,%D0\";
    } else if (which_alternative == 6) {
      /* special case for alternative 6, with two chances but only one taken */
      if (pic30_pre_modify(operands[0])) {
        return \"add %r0,#4,%r0\;\"
               \"ior %1,%2,%I0\;\"
               \"ior %d1,%2,%D0\";
      } else if (pic30_pre_modify(operands[2])) {
        return \"add %r2,#4,%r2\;\"
               \"ior %1,%I2,%0\;\"
               \"ior %d1,%D2,%0\";
      }
    } else if (pic30_pre_modify(operands[0]) || pic30_pre_modify(operands[2])) {
      return noerrata_pre_patterns[which_alternative - 7];
    }
    return noerrata_normal_patterns[which_alternative];
  }
 "
 [
  (set_attr "cc" "clobber")
  (set_attr "type" "def,defuse,use,use,use,def,use,use,use,use,use")
 ]
)

(define_expand "iorsi3"
 [(set (match_operand:SI 0 "pic30_mode2_operand"
             "=r<>,&r<>,R,R,R,  R,r, r,<>")
       (ior:SI
          (match_operand:SI 1 "pic30_mode1P_or_1bit_APSV_operand"
             "%r,   r,  r,r,r,  r,0, r,r")
          (match_operand:SI 2 "pic30_mode1P_or_1bit_APSV_operand"
             "r<>, R,  0,R,r<>,P,P, P,P")))]
 ""
 "
{
  if ((pic30_one_bit_set(GET_MODE(operands[0]),operands[1],1) && 
       pic30_reg_or_R_operand(operands[2],VOIDmode))) {
    emit(
      gen_bitsetsiR(operands[0], operands[2], operands[1])
    );
  } else if ((pic30_one_bit_set(GET_MODE(operands[0]),operands[2],1) && 
            pic30_reg_or_R_operand(operands[1], VOIDmode))) {
    emit(
      gen_bitsetsiR(operands[0], operands[1], operands[2])
    );
  } else if (pic30_mode1P_operand(operands[1],GET_MODE(operands[1])) &&
             pic30_mode1P_operand(operands[2],GET_MODE(operands[2]))) {
    emit(
      gen_iorsi3_DATA(operands[0],operands[1],operands[2])
    );
  } else {
    emit(
      gen_iorsi3_APSV(operands[0],operands[1],operands[2])
    );
  }
  DONE;
}")

; leave this match_dup, operand 0 will not require a reload (CAW)
(define_insn "*iorsi3_sfr0"
  [(set (match_operand:SI 0 "pic30_data_operand" "=T")
        (ior:SI (match_dup 0)
                (match_operand:SI 1 "pic30_register_operand" "r")))
   (clobber (match_scratch:HI 2 "=&r"))]
  ""
  "mov #%0,%2\;ior %1,[%2],[%2]\;ior %d1,[++%2],[%2]"
  [(set_attr "cc" "clobber")])

; leave this match_dup, operand 0 will not require a reload (CAW)
(define_insn "*iorsi3_sfr1"
  [(set (match_operand:SI 0 "pic30_data_operand"        "=T")
        (ior:SI (match_operand:SI 1 "pic30_register_operand"  "r")
                (match_dup 0)))
   (clobber (match_scratch:HI 2            "=&r"))]
  ""
  "
   mov #%0,%2\;ior %1,[%2],[%2]\;ior %d1,[++%2],[%2]"
  [(set_attr "cc" "clobber")])

;;;;;;;;;;;;;;;;;
;; double integer
;;;;;;;;;;;;;;;;;

(define_insn "*iorhidi3_se"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (ior:DI
           (sign_extend:DI
              (match_operand:HI 1 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")
        )
   )
  (clobber (match_scratch:HI 3                   "=&r,&r,&r,&r,&r,&r,&r,&r,&r"))
  ]
  ""
  "*
{
   char *noerrata_patterns[] = {
     /* r,r,r */          \"asr %1,#15,%3\;ior %1,%2,%0\;ior %3,%d2,%d0\;\"
                              \"ior %3,%t2,%t0\;ior %3,%q2,%q0\",

     /* >,r,r */          \"asr %1,#15,%3\;ior %1,%2,%0\;ior %3,%d2,%0\;\"
                              \"ior %3,%t2,%0\;ior %3,%q2,%0\",

     /* >,r,0 */          \"asr %1,#15,%3\;ior %1,%s2,%0\;ior %3,%s2,%0\;\"
                              \"ior %3,%s2,%0\;ior %3,%s2,%0\",

     /* >,r,> */          \"asr %1,#15,%3\;ior %1,%2,%0\;ior %3,%2,%0\;\"
                              \"ior %3,%2,%0\;ior %3,%2,%0\",

     /* r,r,> */          \"asr %1,#15,%3\;ior %1,%2,%0\;ior %3,%2,%d0\;\"
                              \"ior %3,%2,%t0\;ior %3,%2,%q0\",

     /* R,r,r */          \"asr %1,#15,%3\;ior %1,%2,%I0\;ior %3,%d2,%I0\;\"
                              \"ior %3,%t2,%I0\;ior %3,%q2,%0\",

     /* R,r,0 */          \"asr %1,#15,%3\;ior %1,%2,%I0\;ior %3,%2,%I0\;\"
                              \"ior %3,%2,%I0\;ior %3,%2,%0\",

     /* R,r,R */          \"asr %1,#15,%3\;ior %1,%I2,%I0\;ior %3,%I2,%I0\;\"
                              \"ior %3,%I2,%I0\;ior %3,%2,%0\",

     /* r,r,R */          \"asr %1,#15,%3\;ior %1,%I2,%0\;ior %3,%I2,%d0\;\"
                              \"ior %3,%I2,%t0\;ior %3,%2,%q0\",
  };

  char *psv_psv_patterns[] = {
     /* r,r,r */          \"asr %1,#15,%3\;ior %1,%2,%0\;ior %3,%d2,%d0\;\"
                              \"ior %3,%t2,%t0\;ior %3,%q2,%q0\",

     /* >,r,r */          \"asr %1,#15,%3\;ior %1,%2,%0\;ior %3,%d2,%0\;\"
                              \"ior %3,%t2,%0\;ior %3,%q2,%0\",

     /* >,r,0 */          \"asr %1,#15,%3\;\"
                          \"ior %1,%s2,%0\;\"
                          \"nop\;\"
                          \"ior %3,%s2,%0\;\"
                          \"nop\;\"
                          \"ior %3,%s2,%0\;\"
                          \"nop\;\"
                          \"ior %3,%s2,%0\",

     /* >,r,> */          \"asr %1,#15,%3\;\"
                          \"ior %1,%2,%0\;\"
                          \"nop\;\"
                          \"ior %3,%2,%0\;\"
                          \"nop\;\"
                          \"ior %3,%2,%0\;\"
                          \"nop\;\"
                          \"ior %3,%2,%0\",

     /* r,r,> */          \"asr %1,#15,%3\;\"
                          \"ior %1,%2,%0\;\"
                          \"nop\;\"
                          \"ior %3,%2,%d0\;\"
                          \"nop\;\"
                          \"ior %3,%2,%t0\;\"
                          \"nop\;\"
                          \"ior %3,%2,%q0\",

     /* R,r,r */          \"asr %1,#15,%3\;ior %1,%2,%I0\;ior %3,%d2,%I0\;\"
                              \"ior %3,%t2,%I0\;ior %3,%q2,%0\",

     /* R,r,0 */          \"asr %1,#15,%3\;\"
                          \"ior %1,%2,%I0\;\"
                          \"ior %3,%2,%I0\;\"
                          \"ior %3,%2,%I0\;\"
                          \"ior %3,%2,%0\",

     /* R,r,R */          \"asr %1,#15,%3\;\"
                          \"ior %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"ior %3,%I2,%I0\;\"
                          \"nop\;\"
                          \"ior %3,%I2,%I0\;\"
                          \"nop\;\"
                          \"ior %3,%2,%0\",

     /* r,r,R */          \"asr %1,#15,%3\;\"
                          \"ior %1,%I2,%0\;\"
                          \"nop\;\"
                          \"ior %3,%I2,%d0\;\"
                          \"nop\;\"
                          \"ior %3,%I2,%t0\;\"
                          \"nop\;\"
                          \"ior %3,%2,%q0\",
  };

  char **patterns;

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  int regno;
  rtx x;

  if (pic30_psrd_psrd_errata_movd(NULL,operands[2])) {
    /* movd version relies on the compiler never generating a mov.d */
    patterns = noerrata_patterns;
  } else if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
  ]
)

(define_insn "*iorhidi3_ze"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (ior:DI
           (zero_extend:DI
              (match_operand:HI 1 "pic30_register_operand"    "r,r,r,r, r,r,r,r, r"))
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")
        )
   )
  ]
  ""
  "*
{
  char *noerrata_patterns[] = {
     /* r,r,r */          \"ior %1,%2,%0\;\"
                          \"mov %d2,%d0\;\"
                          \"mov.d %t2,%t0\",

     /* >,r,r */          \"ior %1,%2,%0\;\"
                          \"mov %d2,%0\;\"
                          \"mov.d %t2,%0\",

     /* >,r,0 */          \"ior %1,%s2,%s0\;\"
                          \"add #8,%r0\",

     /* >,r,> */          \"ior %1,%2,%0\;\"
                          \"mov %2,%0\;\"
                          \"mov.d %2,%0\",

     /* r,r,> */          \"ior %1,%2,%0\;\"
                          \"mov %2,%d0\;\"
                          \"mov.d %2,%t0\",

     /* R,r,r */          \"ior %1,%2,%0\;\"
                          \"mov %d2,%Q0\;\"
                          \"mov %t2,%R0\;\"
                          \"mov %q2,%S0\",

     /* R,r,0 */          \"ior %1,%2,%0\",

     /* R,r,R */          \"ior %1,%I2,%I0\;\"
                          \"mov %I2,%I0\;\"
                          \"mov %I2,%I0\;\"
                          \"mov %2,%0\",

     /* r,r,R */          \"ior %1,%2,%0\;\"
                          \"mov %Q2,%d0\;\"
                          \"mov %R2,%t0\;\"
                          \"mov %S2,%q0\"
  };

  char *psv_psv_patterns[] = {
     /* r,r,r */          \"ior %1,%2,%0\;\"
                          \"mov %d2,%d0\;\"
                          \"mov.d %t2,%t0\",

     /* >,r,r */          \"ior %1,%2,%0\;\"
                          \"mov %d2,%0\;\"
                          \"mov.d %t2,%0\",

     /* >,r,0 */          \"ior %1,%s2,%s0\;\"
                          \"add #8,%r0\",

     /* >,r,> */          \"ior %1,%2,%0\;\"
                          \"nop\;\"
                          \"mov %2,%0\;\"
                          \"nop\;\"
                          \"mov.d %2,%0\",

     /* r,r,> */          \"ior %1,%2,%0\;\"
                          \"nop\;\"
                          \"mov %2,%d0\;\"
                          \"nop\;\"
                          \"mov.d %2,%t0\",

     /* R,r,r */          \"ior %1,%2,%0\;\"
                          \"mov %d2,%Q0\;\"
                          \"mov %t2,%R0\;\"
                          \"mov %q2,%S0\",

     /* R,r,0 */          \"ior %1,%2,%0\",

     /* R,r,R */          \"ior %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"mov %I2,%I0\;\"
                          \"nop\;\"
                          \"mov %I2,%I0\;\"
                          \"nop\;\"
                          \"mov %2,%0\",

     /* r,r,R */          \"ior %1,%2,%0\;\"
                          \"nop\;\"
                          \"mov %Q2,%d0\;\"
                          \"nop\;\"
                          \"mov %R2,%t0\;\"
                          \"nop\;\"
                          \"mov %S2,%q0\"
  };

  char *psv_psv_movd_patterns[] = {
     /* r,r,r */          \"ior %1,%2,%0\;\"
                          \"mov %d2,%d0\;\"
                          \"mov.d %t2,%t0\",

     /* >,r,r */          \"ior %1,%2,%0\;\"
                          \"mov %d2,%0\;\"
                          \"mov.d %t2,%0\",

     /* >,r,0 */          \"ior %1,%s2,%s0\;\"
                          \"add #8,%r0\",

     /* >,r,> */          \"ior %1,%2,%0\;\"
                          \"mov %2,%0\;\"
                          \"mov %2,%0\;\"
                          \"mov %2,%0\",

     /* r,r,> */          \"ior %1,%2,%0\;\"
                          \"mov %2,%d0\;\"
                          \"mov %2,%t0\;\"
                          \"mov %2,%q0\",

     /* R,r,r */          \"ior %1,%2,%0\;\"
                          \"mov %d2,%Q0\;\"
                          \"mov %t2,%R0\;\"
                          \"mov %q2,%S0\",

     /* R,r,0 */          \"ior %1,%2,%0\",

     /* R,r,R */          \"ior %1,%I2,%I0\;\"
                          \"mov %I2,%I0\;\"
                          \"mov %I2,%I0\;\"
                          \"mov %2,%0\",

     /* r,r,R */          \"ior %1,%2,%0\;\"
                          \"mov %Q2,%d0\;\"
                          \"mov %R2,%t0\;\"
                          \"mov %S2,%q0\"
  };

  char **patterns;

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  int regno;
  rtx x;

  if (pic30_psrd_psrd_errata_movd(NULL,operands[2])) {
    patterns = psv_psv_movd_patterns;
  } else if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

              }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
  ]
)

(define_insn "*iorsidi3_se"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (ior:DI
           (sign_extend:DI
              (match_operand:SI 1 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")))
  (clobber (match_scratch:HI 3                   "=&r,&r,&r,&r,&r,&r,&r,&r,&r"))
  ]
  ""
  "*
{
  char *noerrata_patterns[] = {
     /* r,r,r */          \"asr %d1,#15,%3\;ior %1,%2,%0\;ior %d1,%d2,%d0\;\"
                              \"ior %3,%t2,%t0\;ior %3,%q2,%q0\",

     /* >,r,r */          \"asr %d1,#15,%3\;ior %1,%2,%0\;ior %d1,%d2,%0\;\"
                              \"ior %3,%t2,%0\;ior %3,%q2,%0\",

     /* >,r,0 */          \"asr %d1,#15,%3\;ior %1,%s2,%0\;ior %d1,%s2,%0\;\"
                              \"ior %3,%s2,%0\;ior %3,%s2,%0\",

     /* >,r,> */          \"asr %d1,#15,%3\;ior %1,%2,%0\;ior %d1,%2,%0\;\"
                              \"ior %3,%2,%0\;ior %3,%2,%0\",

     /* r,r,> */          \"asr %d1,#15,%3\;ior %1,%2,%0\;ior %d1,%2,%d0\;\"
                              \"ior %3,%2,%t0\;ior %3,%2,%q0\",

     /* R,r,r */          \"asr %d1,#15,%3\;ior %1,%2,%I0\;ior %d1,%d2,%I0\;\"
                              \"ior %3,%t2,%I0\;ior %3,%q2,%0\",

     /* R,r,0 */          \"asr %d1,#15,%3\;ior %1,%2,%I0\;ior %d1,%2,%I0\;\"
                              \"ior %3,%2,%I0\;ior %3,%2,%0\",

     /* R,r,R */          \"asr %d1,#15,%3\;ior %1,%I2,%I0\;ior %d1,%I2,%I0\;\"
                              \"ior %4,%I2,%I0\;ior %3,%2,%0\",

     /* r,r,R */          \"asr %d1,#15,%3\;ior %1,%I2,%0\;ior %d1,%I2,%d0\;\"
                              \"ior %3,%I2,%t0\;ior %3,%2,%q0\",
  };

  char *psv_psv_patterns[] = {
     /* r,r,r */          \"asr %d1,#15,%3\;ior %1,%2,%0\;ior %d1,%d2,%d0\;\"
                              \"ior %3,%t2,%t0\;ior %3,%q2,%q0\",

     /* >,r,r */          \"asr %d1,#15,%3\;ior %1,%2,%0\;ior %d1,%d2,%0\;\"
                              \"ior %3,%t2,%0\;ior %3,%q2,%0\",

     /* >,r,0 */          \"asr %d1,#15,%3\;\"
                          \"ior %1,%s2,%0\;\"
                          \"nop\;\"
                          \"ior %d1,%s2,%0\;\"
                          \"nop\;\"
                          \"ior %3,%s2,%0\;\"
                          \"nop\;\"
                          \"ior %3,%s2,%0\",

     /* >,r,> */          \"asr %d1,#15,%3\;\"
                          \"ior %1,%2,%0\;\"
                          \"nop\;\"
                          \"ior %d1,%2,%0\;\"
                          \"nop\;\"
                          \"ior %3,%2,%0\;\"
                          \"nop\;\"
                          \"ior %3,%2,%0\",

     /* r,r,> */          \"asr %d1,#15,%3\;\"
                          \"ior %1,%2,%0\;\"
                          \"nop\;\"
                          \"ior %d1,%2,%d0\;\"
                          \"nop\;\"
                          \"ior %3,%2,%t0\;\"
                          \"nop\;\"
                          \"ior %3,%2,%q0\",

     /* R,r,r */          \"asr %d1,#15,%3\;ior %1,%2,%I0\;ior %d1,%d2,%I0\;\"
                              \"ior %3,%t2,%I0\;ior %3,%q2,%0\",

     /* R,r,0 */          \"asr %d1,#15,%3\;\"
                          \"ior %1,%2,%I0\;\"
                          \"ior %d1,%2,%I0\;\"
                          \"ior %3,%2,%I0\;\"
                          \"ior %3,%2,%0\",

     /* R,r,R */          \"asr %d1,#15,%3\;\"
                          \"ior %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"ior %d1,%I2,%I0\;\"
                          \"nop\;\"
                          \"ior %3,%I2,%I0\;\"
                          \"nop\;\"
                          \"ior %3,%2,%0\",

     /* r,r,R */          \"asr %d1,#15,%3\;\"
                          \"ior %1,%I2,%0\;\"
                          \"nop\;\"
                          \"ior %d1,%I2,%d0\;\"
                          \"nop\;\"
                          \"ior %3,%I2,%t0\;\"
                          \"nop\;\"
                          \"ior %3,%2,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  int regno;
  rtx x;
  char **patterns;

  if (pic30_psrd_psrd_errata_movd(NULL,operands[2])) {
    /* movd version relies on the compiler never generating a mov.d */
    patterns = noerrata_patterns;
  } else if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
  ]
)

(define_insn "*iorsidi3_ze"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (ior:DI
           (zero_extend:DI
              (match_operand:SI 1 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")))
  ]
  ""
  "*
{
  char *noerrata_patterns[] = {
     /* r,r,r */          \"ior %1,%2,%0\;ior %d1,%d2,%d0\;mov.d %t2,%t0\",

     /* >,r,r */          \"ior %1,%2,%0\;ior %d1,%d2,%0\;mov.d %t2,%0\",

     /* >,r,0 */          \"ior %1,%s2,%0\;ior %d1,%s2,%0\;add #4,%r0\",

     /* >,r,> */          \"ior %1,%2,%0\;ior %d1,%2,%0\;\"
                              \"mov %2,%0\; mov %2,%0\",

     /* r,r,> */          \"ior %1,%2,%0\;ior %d1,%2,%d0\;mov.d %2,%t0\",

     /* R,r,r */          \"ior %1,%2,%I0\;ior %d1,%d2,%D0\;mov %t2,%R0\;mov %q2,%S0\",

     /* R,r,0 */          \"ior %1,%2,%I0\;ior %d1,%2,%D0\",

     /* R,r,R */          \"ior %1,%I2,%I0\;ior %d1,%I2,%I0\;mov %I2,%I0\;mov %2,%0\",

     /* r,r,R */          \"ior %1,%I2,%0\;ior %d1,%D2,%d0\;mov %R2,%t0\;mov %S2,%q0\"
  };

  char *psv_psv_patterns[] = {
     /* r,r,r */          \"ior %1,%2,%0\;ior %d1,%d2,%d0\;mov.d %t2,%t0\",

     /* >,r,r */          \"ior %1,%2,%0\;ior %d1,%d2,%0\;mov.d %t2,%0\",

     /* >,r,0 */          \"ior %1,%s2,%0\;\"
                          \"nop\;\"
                          \"ior %d1,%s2,%0\;\"
                          \"add #4,%r0\",

     /* >,r,> */          \"ior %1,%2,%0\;\"
                          \"nop\;\"
                          \"ior %d1,%2,%0\;\"
                          \"nop\;\"
                          \"mov %2,%0\;\"
                          \"nop\;\"
                          \"mov %2,%0\",

     /* r,r,> */          \"ior %1,%2,%0\;\"
                          \"nop\;\"
                          \"ior %d1,%2,%d0\;\"
                          \"nop\;\"
                          \"mov.d %2,%t0\",

     /* R,r,r */          \"ior %1,%2,%I0\;ior %d1,%d2,%D0\;mov %t2,%R0\;mov %q2,%S0\",

     /* R,r,0 */          \"ior %1,%2,%I0\;\"
                          \"ior %d1,%2,%D0\",

     /* R,r,R */          \"ior %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"ior %d1,%I2,%I0\;\"
                          \"nop\;\"
                          \"mov %I2,%I0\;\"
                          \"nop\;\"
                          \"mov %2,%0\",

     /* r,r,R */          \"ior %1,%I2,%0\;\"
                          \"nop\;\"
                          \"ior %d1,%D2,%d0\;\"
                          \"nop\;\"
                          \"mov %R2,%t0\;\"
                          \"nop\;\"
                          \"mov %S2,%q0\"
  };

  char *psv_psv_movd_patterns[] = {
     /* r,r,r */          \"ior %1,%2,%0\;ior %d1,%d2,%d0\;mov.d %t2,%t0\",

     /* >,r,r */          \"ior %1,%2,%0\;ior %d1,%d2,%0\;mov.d %t2,%0\",

     /* >,r,0 */          \"ior %1,%s2,%0\;\"
                          \"ior %d1,%s2,%0\;\"
                          \"add #4,%r0\",

     /* >,r,> */          \"ior %1,%2,%0\;\"
                          \"ior %d1,%2,%0\;\"
                          \"mov %2,%0\;\"
                          \"mov %2,%0\",

     /* r,r,> */          \"ior %1,%2,%0\;\"
                          \"ior %d1,%2,%d0\;\"
                          \"mov %2,%t0\;\"
                          \"mov %2,%q0\",

     /* R,r,r */          \"ior %1,%2,%I0\;ior %d1,%d2,%D0\;mov %t2,%R0\;mov %q2,%S0\",

     /* R,r,0 */          \"ior %1,%2,%I0\;ior %d1,%2,%D0\",

     /* R,r,R */          \"ior %1,%I2,%I0\;\"
                          \"ior %d1,%I2,%I0\;\"
                          \"mov %I2,%I0\;\"
                          \"mov %2,%0\",

     /* r,r,R */          \"ior %1,%I2,%0\;\"
                          \"ior %d1,%D2,%d0\;\"
                          \"mov %R2,%t0\;\"
                          \"mov %S2,%q0\"
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  int regno;
  rtx x;
  char **patterns;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    patterns = psv_psv_movd_patterns;
  } else if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
              }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
  ]
)

(define_insn "*iordihi3_se"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (ior:DI
           (match_operand:DI 1 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")
           (sign_extend:DI
              (match_operand:HI 2 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
        )
   )
  (clobber (match_scratch:HI 3                   "=&r,&r,&r,&r,&r,&r,&r,&r,&r"))
  ]
  ""
  "*
{
  char *noerrata_patterns[] = {
     /* r,r,r */          \"asr %2,#15,%3\;ior %2,%1,%0\;ior %3,%d1,%d0\;\"
                              \"ior %3,%t1,%t0\;ior %3,%q1,%q0\",

     /* >,r,r */          \"asr %2,#15,%3\;ior %2,%1,%0\;ior %3,%d1,%0\;\"
                              \"ior %3,%t1,%0\;ior %3,%q1,%0\",

     /* >,0,r */          \"asr %2,#15,%3\;ior %2,%s1,%0\;ior %3,%s1,%0\;\"
                              \"ior %3,%s1,%0\;ior %3,%s1,%0\",

     /* >,>,r */          \"asr %2,#15,%3\;ior %2,%1,%0\;ior %3,%1,%0\;\"
                              \"ior %3,%1,%0\;ior %3,%1,%0\",

     /* r,>,r */          \"asr %2,#15,%3\;ior %2,%1,%0\;ior %3,%1,%d0\;\"
                              \"ior %3,%1,%t0\;ior %3,%1,%q0\",

     /* R,r,r */          \"asr %2,#15,%3\;ior %2,%1,%I0\;ior %3,%d1,%I0\;\"
                              \"ior %3,%t1,%I0\;ior %3,%q1,%s0\",

     /* R,0,r */          \"asr %2,#15,%3\;ior %2,%1,%I0\;ior %3,%1,%I0\;\"
                              \"ior %3,%1,%I0\;ior %3,%1,%s0\",

     /* R,R,r */          \"asr %2,#15,%3\;ior %2,%I1,%I0\;ior %3,%I1,%I0\;\"
                              \"ior %3,%I1,%I0\;ior %3,%1,%0\",

     /* r,R,r */          \"asr %2,#15,%3\;ior %1,%I1,%0\;ior %3,%I1,%d0\;\"
                              \"ior %3,%I1,%t0\;ior %3,%1,%q0\",
  };

  char *psv_psv_patterns[] = {
     /* r,r,r */          \"asr %2,#15,%3\;ior %2,%1,%0\;ior %3,%d1,%d0\;\"
                              \"ior %3,%t1,%t0\;ior %3,%q1,%q0\",

     /* >,r,r */          \"asr %2,#15,%3\;ior %2,%1,%0\;ior %3,%d1,%0\;\"
                              \"ior %3,%t1,%0\;ior %3,%q1,%0\",

     /* >,0,r */          \"asr %2,#15,%3\;ior %2,%s1,%0\;ior %3,%s1,%0\;\"
                              \"ior %3,%s1,%0\;ior %3,%s1,%0\",

     /* >,>,r */          \"asr %2,#15,%3\;\"
                          \"ior %2,%1,%0\;\"
                          \"nop\;\"
                          \"ior %3,%1,%0\;\"
                          \"nop\;\"
                          \"ior %3,%1,%0\;\"
                          \"nop\;\"
                          \"ior %3,%1,%0\",

     /* r,>,r */          \"asr %2,#15,%3\;\"
                          \"ior %2,%1,%0\;\"
                          \"nop\;\"
                          \"ior %3,%1,%d0\;\"
                          \"nop\;\"
                          \"ior %3,%1,%t0\;\"
                          \"nop\;\"
                          \"ior %3,%1,%q0\",

     /* R,r,r */          \"asr %2,#15,%3\;ior %2,%1,%I0\;ior %3,%d1,%I0\;\"
                              \"ior %3,%t1,%I0\;ior %3,%q1,%s0\",

     /* R,0,r */          \"asr %2,#15,%3\;ior %2,%1,%I0\;ior %3,%1,%I0\;\"
                              \"ior %3,%1,%I0\;ior %3,%1,%s0\",

     /* R,R,r */          \"asr %2,#15,%3\;\"
                          \"ior %2,%I1,%I0\;\"
                          \"nop\;\"
                          \"ior %3,%I1,%I0\;\"
                          \"nop\;\"
                          \"ior %3,%I1,%I0\;\"
                          \"nop\;\"
                          \"ior %3,%1,%0\",

     /* r,R,r */          \"asr %2,#15,%3\;\"
                          \"ior %1,%I1,%0\;\"
                          \"nop\;\"
                          \"ior %3,%I1,%d0\;\"
                          \"nop\;\"
                          \"ior %3,%I1,%t0\;\"
                          \"nop\;\"
                          \"ior %3,%1,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  int regno;
  rtx x;
  char **patterns;

  if (pic30_psrd_psrd_errata_movd(NULL,operands[2])) {
    /* movd version relies on the compiler never generating a mov.d */
    patterns = noerrata_patterns;
  } else if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,0,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,R,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[1],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;

     case 8:  /* r,R,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[1],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "clobber")
     (set_attr "type" "def")
  ]
)

(define_insn "*iordihi3_ze"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (ior:DI
           (match_operand:DI 1 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")
           (zero_extend:DI
              (match_operand:HI 2 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
        )
   )
  (clobber (match_scratch:HI 3                   "=X,X,&r,&r,&r,X,&r,&r,&r"))
  ]
  ""
  "*
{
  char *noerrata_patterns[] = {
     /* r,r,r */          \"ior %1,%2,%0\;mov %d1,%d0\;mov.d %t1,%t0\",

     /* >,r,r */          \"ior %1,%2,%0\;mov %d1,%0\;mov.d %t1,%0\",

     /* >,0,r */          \"ior %2,%s1,%s0\;add #8,%r0\",

     /* >,>,r */          \"ior %2,%s1,%s0\;mov %1,%0\;mov %1,%0\;mov %1,%0\",

     /* r,>,r */          \"ior %2,%1,%0\;mov %1,%d0\;mov.d %1,%t0\",

     /* R,r,r */          \"ior %1,%2,%0\;mov %d1,%Q0\;mov %t1,%R0\;mov %q1,%S0\",

     /* R,0,r */          \"ior %2,%1,%0\",

     /* R,R,r */          \"ior %2,%I1,%I0\;mov %I1,%I0\;mov %I1,%I0\;mov %1,%0\",

     /* r,R,r */          \"ior %2,%1,%0\;mov %Q1,%d0\;mov %R1,%t0\;mov %S1,%q0\"
  };

  char *psv_psv_patterns[] = {
     /* r,r,r */          \"ior %1,%2,%0\;mov %d1,%d0\;mov.d %t1,%t0\",

     /* >,r,r */          \"ior %1,%2,%0\;mov %d1,%0\;mov.d %t1,%0\",

     /* >,0,r */          \"ior %2,%s1,%s0\;add #8,%r0\",

     /* >,>,r */          \"ior %2,%s1,%s0\;mov %1,%0\;mov %1,%0\;mov %1,%0\",

     /* r,>,r */          \"ior %2,%1,%0\;\"
                          \"nop\;\"
                          \"mov %1,%d0\;\"
                          \"nop\;\"
                          \"mov.d %1,%t0\",

     /* R,r,r */          \"ior %1,%2,%0\;mov %d1,%Q0\;mov %t1,%R0\;mov %q1,%S0\",

     /* R,0,r */          \"ior %2,%1,%0\",

     /* R,R,r */          \"ior %2,%I1,%I0\;\"
                          \"nop\;\"
                          \"mov %I1,%I0\;\"
                          \"nop\;\"
                          \"mov %I1,%I0\;\"
                          \"nop\;\"
                          \"mov %1,%0\",

     /* r,R,r */          \"ior %2,%1,%0\;\"
                          \"nop\;\"
                          \"mov %Q1,%d0\;\"
                          \"nop\;\"
                          \"mov %R1,%t0\;\"
                          \"nop\;\"
                          \"mov %S1,%q0\"
  };

  char *psv_psv_movd_patterns[] = {
     /* r,r,r */          \"ior %1,%2,%0\;mov %d1,%d0\;mov.d %t1,%t0\",

     /* >,r,r */          \"ior %1,%2,%0\;mov %d1,%0\;mov.d %t1,%0\",

     /* >,0,r */          \"ior %2,%s1,%s0\;add #8,%r0\",

     /* >,>,r */          \"ior %2,%s1,%s0\;mov %1,%0\;mov %1,%0\;mov %1,%0\",

     /* r,>,r */          \"ior %2,%1,%0\;\"
                          \"mov %1,%d0\;\"
                          \"mov %1,%t0\;\"
                          \"mov %1,%q0\",

     /* R,r,r */          \"ior %1,%2,%0\;\"
                          \"mov %d1,%Q0\;\"
                          \"mov %t1,%R0\;\"
                          \"mov %q1,%S0\",

     /* R,0,r */          \"ior %2,%1,%0\",

     /* R,R,r */          \"ior %2,%I1,%I0\;\"
                          \"mov %I1,%I0\;\"
                          \"mov %I1,%I0\;\"
                          \"mov %1,%0\",

     /* r,R,r */          \"ior %2,%1,%0\;\"
                          \"mov %Q1,%d0\;\"
                          \"mov %R1,%t0\;\"
                          \"mov %S1,%q0\"
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  int regno;
  rtx x;
  char **patterns;

  if (pic30_psrd_psrd_errata_movd(NULL,operands[2])) {
    patterns = psv_psv_movd_patterns;
  } else if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
              }
}"
   [
     (set_attr "cc" "clobber")
     (set_attr "type" "def")
  ]
)

(define_insn "*iordisi3_se"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (ior:DI
           (match_operand:DI 1 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")
           (sign_extend:DI
              (match_operand:SI 2 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
        )
   )
  (clobber (match_scratch:HI 3                   "=&r,&r,&r,&r,&r,&r,&r,&r,&r"))
  ]
  ""
  "*
{
  char *noerrata_patterns[] = {
     /* r,r,r */          \"asr %d2,#15,%3\;ior %2,%1,%0\;ior %d2,%d1,%d0\;\"
                              \"ior %3,%t1,%t0\;ior %3,%q1,%q0\",

     /* >,r,r */          \"asr %d2,#15,%3\;ior %2,%1,%0\;ior %d2,%d1,%0\;\"
                              \"ior %3,%t1,%0\;ior %3,%q1,%0\",

     /* >,0,r */          \"asr %d2,#15,%3\;ior %2,%s1,%0\;ior %d2,%s1,%0\;\"
                              \"ior %3,%s1,%0\;ior %3,%s1,%0\",

     /* >,>,r */          \"asr %d2,#15,%3\;ior %2,%1,%0\;ior %d2,%1,%0\;\"
                              \"ior %3,%1,%0\;ior %3,%1,%0\",

     /* r,>,r */          \"asr %d2,#15,%3\;ior %2,%1,%0\;ior %d2,%1,%d0\;\"
                              \"ior %3,%1,%t0\;ior %3,%1,%q0\",

     /* R,r,r */          \"asr %d2,#15,%3\;ior %2,%1,%I0\;ior %d2,%d1,%I0\;\"
                              \"ior %3,%t1,%I0\;ior %3,%q1,%0\",

     /* R,0,r */          \"asr %d2,#15,%3\;ior %2,%1,%I0\;ior %d2,%1,%I0\;\"
                              \"ior %3,%1,%I0\;ior %3,%1,%0\",

     /* R,R,r */          \"asr %d2,#15,%3\;ior %2,%I1,%I0\;ior %d2,%I1,%I0\;\"
                              \"ior %3,%I1,%I0\;ior %3,%1,%0\",

     /* r,R,r */          \"asr %d2,#15,%3\;ior %2,%I1,%0\;ior %d1,%I1,%d0\;\"
                              \"ior %3,%I1,%t0\;ior %3,%1,%q0\",
  };

  char *psv_psv_patterns[] = {
     /* r,r,r */          \"asr %d2,#15,%3\;ior %2,%1,%0\;ior %d2,%d1,%d0\;\"
                              \"ior %3,%t1,%t0\;ior %3,%q1,%q0\",

     /* >,r,r */          \"asr %d2,#15,%3\;ior %2,%1,%0\;ior %d2,%d1,%0\;\"
                              \"ior %3,%t1,%0\;ior %3,%q1,%0\",

     /* >,0,r */          \"asr %d2,#15,%3\;ior %2,%s1,%0\;ior %d2,%s1,%0\;\"
                              \"ior %3,%s1,%0\;ior %3,%s1,%0\",

     /* >,>,r */          \"asr %d2,#15,%3\;\"
                          \"ior %2,%1,%0\;\"
                          \"nop\;\"
                          \"ior %d2,%1,%0\;\"
                          \"nop\;\"
                          \"ior %3,%1,%0\;\"
                          \"nop\;\"
                          \"ior %3,%1,%0\",

     /* r,>,r */          \"asr %d2,#15,%3\;\"
                          \"ior %2,%1,%0\;\"
                          \"nop\;\"
                          \"ior %d2,%1,%d0\;\"
                          \"nop\;\"
                          \"ior %3,%1,%t0\;\"
                          \"nop\;\"
                          \"ior %3,%1,%q0\",

     /* R,r,r */          \"asr %d2,#15,%3\;ior %2,%1,%I0\;ior %d2,%d1,%I0\;\"
                              \"ior %3,%t1,%I0\;ior %3,%q1,%0\",

     /* R,0,r */          \"asr %d2,#15,%3\;ior %2,%1,%I0\;ior %d2,%1,%I0\;\"
                              \"ior %3,%1,%I0\;ior %3,%1,%0\",

     /* R,R,r */          \"asr %d2,#15,%3\;\"
                          \"ior %2,%I1,%I0\;\"
                          \"nop\;\"
                          \"ior %d2,%I1,%I0\;\"
                          \"nop\;\"
                          \"ior %3,%I1,%I0\;\"
                          \"nop\;\"
                          \"ior %3,%1,%0\",

     /* r,R,r */          \"asr %d2,#15,%3\;\"
                          \"ior %2,%I1,%0\;\"
                          \"nop\;\"
                          \"ior %d1,%I1,%d0\;\"
                          \"nop\;\"
                          \"ior %3,%I1,%t0\;\"
                          \"nop\;\"
                          \"ior %3,%1,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  int regno;
  rtx x;
  char **patterns;

  if (pic30_psrd_psrd_errata_movd(NULL,operands[2])) {
    /* movd version relies on the compiler never generating a mov.d */
    patterns = noerrata_patterns;
  } else if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops += 3;
    patterns = psv_psv_patterns;
  }  else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,0,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,R,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[1],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;

     case 8:  /* r,R,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[1],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "clobber")
     (set_attr "type" "def")
  ]
)

(define_insn "*iordisi3_ze"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (ior:DI
           (match_operand:DI 1 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")
           (zero_extend:DI
              (match_operand:SI 2 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
        )
   )
  ]
  ""
  "*
{
  char *noerrata_patterns[] = {
     /* r,r,r */          \"ior %1,%2,%0\;ior %d1,%d2,%d0\;mov.d %t1,%t0\",

     /* >,r,r */          \"ior %1,%2,%0\;ior %d1,%d2,%0\;mov.d %t1,%0\",

     /* >,0,r */          \"ior %2,%s1,%0\;ior %d2,%s1,%0\;add #4,%r0\",

     /* >,>,r */          \"ior %2,%1,%0\;ior %d2,%1,%0\;\"
                              \"mov %1,%0\;mov %1,%0\",

     /* r,>,r */          \"ior %2,%1,%0\;ior %d2,%1,%d0\;mov.d %1,%t0\",

     /* R,r,r */          \"ior %2,%1,%I0\;ior %d2,%d1,%D0\;mov %t1,%R0\;mov %q1,%S0\",

     /* R,0,r */          \"ior %2,%1,%I0\;ior %d2,%1,%D0\",

     /* R,R,r */          \"ior %2,%I1,%I0\;ior %d2,%I1,%I0\;mov %I1,%I0\;mov %1,%0\",

     /* r,R,r */          \"ior %2,%I1,%0\;ior %d2,%D1,%d0\;mov %R1,%t0\;mov %S1,%q0\"
  };

  char *psv_psv_patterns[] = {
     /* r,r,r */          \"ior %1,%2,%0\;ior %d1,%d2,%d0\;mov.d %t1,%t0\",

     /* >,r,r */          \"ior %1,%2,%0\;ior %d1,%d2,%0\;mov.d %t1,%0\",

     /* >,0,r */          \"ior %2,%s1,%0\;ior %d2,%s1,%0\;add #4,%r0\",

     /* >,>,r */          \"ior %2,%1,%0\;\"
                          \"nop\;\"
                          \"ior %d2,%1,%0\;\"
                          \"nop\;\"
                          \"mov %1,%0\;\"
                          \"nop\;\"
                          \"mov %1,%0\",

     /* r,>,r */          \"ior %2,%1,%0\;\"
                          \"nop\;\"
                          \"ior %d2,%1,%d0\;\"
                          \"nop\;\"
                          \"mov.d %1,%t0\",

     /* R,r,r */          \"ior %2,%1,%I0\;ior %d2,%d1,%D0\;mov %t1,%R0\;mov %q1,%S0\",

     /* R,0,r */          \"ior %2,%1,%I0\;ior %d2,%1,%D0\",

     /* R,R,r */          \"ior %2,%I1,%I0\;\"
                          \"nop\;\"
                          \"ior %d2,%I1,%I0\;\"
                          \"nop\;\"
                          \"mov %I1,%I0\;\"
                          \"nop\;\"
                          \"mov %1,%0\",

     /* r,R,r */          \"ior %2,%I1,%0\;\"
                          \"nop\;\"
                          \"ior %d2,%D1,%d0\;\"
                          \"nop\;\"
                          \"mov %R1,%t0\;\"
                          \"nop\;\"
                          \"mov %S1,%q0\"
  };

  char *psv_psv_movd_patterns[] = {
     /* r,r,r */          \"ior %1,%2,%0\;ior %d1,%d2,%d0\;mov.d %t1,%t0\",

     /* >,r,r */          \"ior %1,%2,%0\;ior %d1,%d2,%0\;mov.d %t1,%0\",

     /* >,0,r */          \"ior %2,%s1,%0\;ior %d2,%s1,%0\;add #4,%r0\",

     /* >,>,r */          \"ior %2,%1,%0\;\"
                          \"ior %d2,%1,%0\;\"
                          \"mov %1,%0\;\"
                          \"mov %1,%0\",

     /* r,>,r */          \"ior %2,%1,%0\;\"
                          \"ior %d2,%1,%d0\;\"
                          \"mov %1,%t0\;\"
                          \"mov %1,%q0\",

     /* R,r,r */          \"ior %2,%1,%I0\;\"
                          \"ior %d2,%d1,%D0\"
                          \"\;mov %t1,%R0\"
                          \"\;mov %q1,%S0\",

     /* R,0,r */          \"ior %2,%1,%I0\;ior %d2,%1,%D0\",

     /* R,R,r */          \"ior %2,%I1,%I0\;\"
                          \"ior %d2,%I1,%I0\;\"
                          \"mov %I1,%I0\;\"
                          \"mov %1,%0\",

     /* r,R,r */          \"ior %2,%I1,%0\;\"
                          \"ior %d2,%D1,%d0\;\"
                          \"mov %R1,%t0\;\"
                          \"mov %S1,%q0\"
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  int regno;
  rtx x;
  char **patterns;

  if (pic30_psrd_psrd_errata_movd(NULL,operands[2])) {
    patterns = psv_psv_movd_patterns;
  } else if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops += 3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
              }
}"
   [
     (set_attr "cc" "clobber")
     (set_attr "type" "def")
  ]
)

(define_insn "iordi3"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (ior:DI
           (match_operand:DI 1 "pic30_register_operand"    "r,r,r,r, r,r,r,r, r")
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")))
  ]
  ""
  "*
{
  char *noerrata_patterns[] = {
     /* r,r,r */          \"ior %1,%2,%0\;ior %d1,%d2,%d0\;\"
                              \"ior %t1,%t2,%t0\;ior %q1,%q2,%q0\",

     /* >,r,r */          \"ior %1,%2,%0\;ior %d1,%d2,%0\;\"
                              \"ior %t1,%t2,%0\;ior %q1,%q2,%0\",

     /* >,r,0 */          \"ior %1,%s2,%0\;ior %d1,%s2,%0\;\"
                              \"ior %t1,%s2,%0\;ior %q1,%s2,%0\",

     /* >,r,> */          \"ior %1,%2,%0\;ior %d1,%2,%0\;\"
                              \"ior %t1,%2,%0\;ior %q1,%2,%0\",

     /* r,r,> */          \"ior %1,%2,%0\;ior %d1,%2,%d0\;\"
                              \"ior %t1,%2,%t0\;ior %q1,%2,%q0\",

     /* R,r,r */          \"ior %1,%2,%I0\;ior %d1,%d2,%I0\;\"
                              \"ior %t1,%t2,%I0\;ior %q1,%q2,%0\",

     /* R,r,0 */          \"ior %1,%2,%I0\;ior %d1,%2,%I0\;\"
                              \"ior %t1,%2,%I0\;ior %q1,%2,%0\",

     /* R,r,R */          \"ior %1,%I2,%I0\;ior %d1,%I2,%I0\;\"
                              \"ior %t1,%I2,%I0\;ior %q1,%2,%0\",

     /* r,r,R */          \"ior %1,%I2,%0\;ior %d1,%I2,%d0\;\"
                              \"ior %t1,%I2,%t0\;ior %q1,%2,%q0\",
  };

  char *psv_psv_patterns[] = {
     /* r,r,r */          \"ior %1,%2,%0\;ior %d1,%d2,%d0\;\"
                              \"ior %t1,%t2,%t0\;ior %q1,%q2,%q0\",

     /* >,r,r */          \"ior %1,%2,%0\;ior %d1,%d2,%0\;\"
                              \"ior %t1,%t2,%0\;ior %q1,%q2,%0\",

     /* >,r,0 */          \"ior %1,%s2,%0\;ior %d1,%s2,%0\;\"
                              \"ior %t1,%s2,%0\;ior %q1,%s2,%0\",

     /* >,r,> */          \"ior %1,%2,%0\;\"
                          \"nop\;\"
                          \"ior %d1,%2,%0\;\"
                          \"nop\;\"
                          \"ior %t1,%2,%0\;\"
                          \"nop\;\"
                          \"ior %q1,%2,%0\",

     /* r,r,> */          \"ior %1,%2,%0\;\"
                          \"nop\;\"
                          \"ior %d1,%2,%d0\;\"
                          \"nop\;\"
                          \"ior %t1,%2,%t0\;\"
                          \"nop\;\"
                          \"ior %q1,%2,%q0\",

     /* R,r,r */          \"ior %1,%2,%I0\;ior %d1,%d2,%I0\;\"
                              \"ior %t1,%t2,%I0\;ior %q1,%q2,%0\",

     /* R,r,0 */          \"ior %1,%2,%I0\;ior %d1,%2,%I0\;\"
                              \"ior %t1,%2,%I0\;ior %q1,%2,%0\",

     /* R,r,R */          \"ior %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"ior %d1,%I2,%I0\;\"
                          \"nop\;\"
                          \"ior %t1,%I2,%I0\;\"
                          \"nop\;\"
                          \"ior %q1,%2,%0\",

     /* r,r,R */          \"ior %1,%I2,%0\;\"
                          \"nop\;\"
                          \"ior %d1,%I2,%d0\;\"
                          \"nop\;\"
                          \"ior %t1,%I2,%t0\;\"
                          \"nop\;\"
                          \"ior %q1,%2,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  int regno;
  rtx x;
  char **patterns;

  if (pic30_psrd_psrd_errata_movd(NULL,operands[2])) {
    /* movd version relies on the compiler never generating a mov.d */
    patterns = noerrata_patterns;
  } else if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops += 3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "clobber")
     (set_attr "type" "def")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; XOR
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;
;; quarter integer
;;;;;;;;;;;;;;;;;;

(define_insn "*xorqi3_imm"
  [(set (match_operand:QI         0 "pic30_register_operand" "=r")
        (xor:QI (match_operand:QI 1 "pic30_register_operand" "%0")
                (match_operand:QI 2 "pic30_J_operand"        " J")))]
  ""
  "xor.b #%2,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
  ]
)

(define_insn "xorqi3_DATA"
  [(set (match_operand:QI 0 "pic30_mode2_operand"
              "=r<>,r<>,R,R,  r<>,R,r<>,R,  r<>,R")
        (xor:QI 
           (match_operand:QI 1 "pic30_mode1P_operand"
              "%r,  r,  r,r,  r,  r,R<>,R<>,P,  P")
           (match_operand:QI 2 "pic30_mode1P_operand"
              " r,  R<>,r,R<>,P,  P,r,  r,  r,  r")))]
  ""
  "@
   xor.b %1,%2,%0
   xor.b %1,%2,%0
   xor.b %1,%2,%0
   xor.b %1,%2,%0
   xor.b %1,#%2,%0
   xor.b %1,#%2,%0
   xor.b %2,%1,%0
   xor.b %2,%1,%0
   xor.b %2,#%1,%0
   xor.b %2,#%1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,defuse,use,use,def,use,defuse,use,def,use")
  ]
)

(define_insn "xorqi3_APSV"
  [(set (match_operand:QI 0 "pic30_mode2_operand"
              "=r<>,r<>,R,R,  r<>,R,r<>,R,  r<>,R")
        (xor:QI 
           (match_operand:QI 1 "pic30_mode1P_APSV_operand"
              "%r,  r,  r,r,  r,  r,R<>,R<>,P,  P")
           (match_operand:QI 2 "pic30_mode1P_APSV_operand"
              " r,  R<>,r,R<>,P,  P,r,  r,  r,  r")))]
  ""
  "@
   xor.b %1,%2,%0
   xor.b %1,%2,%0
   xor.b %1,%2,%0
   xor.b %1,%2,%0
   xor.b %1,#%2,%0
   xor.b %1,#%2,%0
   xor.b %2,%1,%0
   xor.b %2,%1,%0
   xor.b %2,#%1,%0
   xor.b %2,#%1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,defuse,use,use,def,use,defuse,use,def,use")
  ]
)

(define_expand "xorqi3"
  [(set (match_operand:QI 0 "pic30_mode2_operand"
              "=r<>,r<>,R,R,  r<>,R,r<>,R,  r<>,R")
        (xor:QI
           (match_operand:QI 1 "pic30_mode1P_APSV_operand"
              "%r,  r,  r,r,  r,  r,R<>,R<>,P,  P")
           (match_operand:QI 2 "pic30_mode1P_APSV_operand"
              " r,  R<>,r,R<>,P,  P,r,  r,  r,  r")))]
  ""
  "
{
  if (pic30_mode1P_operand(operands[1],GET_MODE(operands[1])) &&
      pic30_mode1P_operand(operands[2],GET_MODE(operands[2])))
    emit(gen_xorqi3_DATA(operands[0],operands[1],operands[2]));
  else
    emit(gen_xorqi3_APSV(operands[0],operands[1],operands[2]));
  DONE;
}")

(define_insn_and_split "*xorqi3_sfr0"
  [(set (match_operand:QI 0 "pic30_register_operand"           "=a,a, r")
        (xor:QI (match_operand:QI 1 "pic30_register_operand"   "%a,d, r")
                (match_operand:QI 2 "pic30_near_operand" " U,U, U")))
   (clobber (match_scratch:HI 3                          "=X,X,&r"))]
  ""
  "@
   xor.b %2,WREG
   mov.b %1,w0\;xor.b %2,WREG
   mov #%2,%3\;xor.b %1,[%3],%0"
  "reload_completed"
  [
   (const_int 0)
  ]
"
{
  if (!pic30_wreg_operand(operands[0], QImode) &&
      !pic30_wreg_operand(operands[1], QImode)) {
    rtx pop = gen_rtx_MEM(QImode, operands[3]);
    emit_insn(gen_movhi_address(operands[3], XEXP(operands[2],0)));
    emit_insn(gen_xorqi3(operands[0], operands[1], pop));
    DONE;
  } else {
    FAIL;
  }
}
"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
  ]
)

; leave this match_dup, operand 0 will not require a reload (CAW)
(define_insn "*xorqi3_sfr1"
  [(set (match_operand:QI 0 "pic30_near_operand"       "=U,!???U")
        (xor:QI (match_dup 0)
                (match_operand:QI 1 "pic30_register_operand"  "a,!???d")))]
  ""
  "*
   switch (which_alternative) {
     default: gcc_assert(0);
     case 0: return \"xor.b %0\";
     case 1: if (pic30_errata_mask & exch_errata)
               return \"push w0\;mov %1,w0\;xor.b %0\;pop w0\";
             else
               return \"exch w0,%1\;xor.b %0\;exch w0,%1\";
   }
  "
  [
    (set_attr "cc" "math")
    (set_attr "type" "etc")
  ]
)

;;;;;;;;;;;;;;;
;; half integer
;;;;;;;;;;;;;;;

(define_insn "xorhi3_DATA"
  [(set (match_operand:HI 0 "pic30_mode2_operand"
              "=r<>,r<>, R,R,  r<>,R,r<>,R,  r<>,R")
        (xor:HI 
           (match_operand:HI 1 "pic30_mode1P_operand"
              "%r,  r,   r,r,  r,  r,R<>,R<>,P,  P")
           (match_operand:HI 2 "pic30_mode1P_operand"
              "r,  R<>, r,R<>,P,  P,r,  r,  r,  r")))]
  ""
  "@
   xor %1,%2,%0
   xor %1,%2,%0
   xor %1,%2,%0
   xor %1,%2,%0
   xor %1,#%2,%0
   xor %1,#%2,%0
   xor %2,%1,%0
   xor %2,%1,%0
   xor %2,#%1,%0
   xor %2,#%1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,defuse,use,use,def,use,defuse,use,def,use")
  ]
)

(define_insn "xorhi3_APSV"
  [(set (match_operand:HI 0 "pic30_mode2_operand"
              "=r<>,r<>, R,R,  r<>,R,r<>,R,  r<>,R")
        (xor:HI 
           (match_operand:HI 1 "pic30_mode1P_APSV_operand"
              "%r,  r,   r,r,  r,  r,R<>,R<>,P,  P")
           (match_operand:HI 2 "pic30_mode1P_APSV_operand"
              "r,  R<>, r,R<>,P,  P,r,  r,  r,  r")))]
  ""
  "@
   xor %1,%2,%0
   xor %1,%2,%0
   xor %1,%2,%0
   xor %1,%2,%0
   xor %1,#%2,%0
   xor %1,#%2,%0
   xor %2,%1,%0
   xor %2,%1,%0
   xor %2,#%1,%0
   xor %2,#%1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,defuse,use,use,def,use,defuse,use,def,use")
  ]
)

(define_expand "xorhi3"
  [(set (match_operand:HI 0 "pic30_mode2_operand"
              "=r<>,r<>, R,R,  r<>,R,r<>,R,  r<>,R")
        (xor:HI
           (match_operand:HI 1 "pic30_mode1P_APSV_operand"
              "%r,  r,   r,r,  r,  r,R<>,R<>,P,  P")
           (match_operand:HI 2 "pic30_mode1P_APSV_operand"
              "r,  R<>, r,R<>,P,  P,r,  r,  r,  r")))]
  ""
  "
{
  if (pic30_mode1P_operand(operands[1],GET_MODE(operands[1])) &&
      pic30_mode1P_operand(operands[2],GET_MODE(operands[2])))
    emit(gen_xorhi3_DATA(operands[0],operands[1],operands[2]));
  else
    emit(gen_xorhi3_APSV(operands[0],operands[1],operands[2]));
  DONE;
}")

(define_insn "xorhi3_sfr0"
  [(set (match_operand:HI 0         "pic30_reg_or_near_operand" "=U,a,r")
        (xor:HI (match_operand:HI 1 "pic30_register_operand"    "%a,0,r")
                (match_operand:HI 2 "pic30_reg_or_near_operand" " 0,U,r")))
  ]
  ""
  "@
   xor %0
   xor %2,WREG
   xor %2,%1,%0"
  [
    (set_attr "cc" "math")
    (set_attr "type" "etc,def,def")
  ]
)

; leave this match_dup, operand 0 will not require a reload (CAW)
(define_insn "xorhi3_sfr2"
  [(set (match_operand:HI 0 "pic30_near_operand" "=U")
        (xor:HI (match_dup 0)
                (match_operand:HI 1 "pic30_immediate_1bit_operand" "i")))]
  ""
  "*
   { unsigned int bit_num;
     static char insn[48];

     if (GET_CODE(operands[1]) == CONST_INT) {
       int i;
       i = INTVAL(operands[1]);
   
       i = i & 0xFFFF;
       /* apparantly I can't use log here */
       for (bit_num = 0 ; bit_num <= 16; bit_num++)
         if (((1 << bit_num) & i) == i) break;
       if (bit_num == 16) abort();
       sprintf(insn, \"btg %%0,#%d\",bit_num);
       return insn;
     } else abort();
   }"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "etc")
  ]
)

; leave this match_dup, operand 0 will not require a reload (CAW)
(define_insn "xorhi3_sfr3"
  [(set (match_operand:HI 0 "pic30_near_operand" "=U")
        (xor:HI (match_operand:HI 1 "pic30_immediate_1bit_operand" "i")
                (match_dup 0)))]
  ""
  "*
   { unsigned int bit_num;
     static char insn[48];

     if (GET_CODE(operands[1]) == CONST_INT) {
       int i;
       i = INTVAL(operands[1]);
  
       i = i & 0xFFFF;
       /* apparantly I can't use log here */
       for (bit_num = 0 ; bit_num <= 16; bit_num++)
         if (((1 << bit_num) & i) == i) break;
       if (bit_num == 16) abort();
       sprintf(insn, \"btg %%0,#%d\",bit_num);
       return insn;
     } else abort();
   }"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "etc")
  ]
)

(define_insn "*xorhi3_imm"
  [(set (match_operand:HI 0 "pic30_register_operand"         "=r")
        (xor:HI (match_operand:HI 1 "pic30_register_operand" "%0")
                (match_operand:HI 2 "pic30_J_operand"   "J")))]
  ""
  "xor #%2,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
  ]
)

; this match_can cause issues iff operand 1 is dies in this instruction and
;   we decide to use it to reload operand 0 (CAW)
(define_insn "*xorhi3_sfr0"
  [(set (match_operand:HI 0 "pic30_reg_or_near_operand" "+a,U,!???d,!???U")
        (xor:HI (match_dup 0)
                (match_operand:HI 1 "pic30_reg_or_near_operand"
                                                        "U,a,!???U,!???d")))]
  ""
  "*
   switch (which_alternative) {
     default: gcc_assert(0);
     case 0: return \"xor %1,WREG\";
     case 1: return \"xor %0\";
     case 2: if (pic30_errata_mask & exch_errata)
               return \"push w0\;mov w0,%0\;xor %1,WREG\;mov w0,%0\;pop w0\";
             else
               return \"exch w0,%0\;xor %1,WREG\;exch w0,%0\";
     case 3: if (pic30_errata_mask & exch_errata)
               return \"push w0\;mov %1,w0\;xor %0\;pop w0\";
             else
               return \"exch w0,%1\;xor %0\;exch w0,%1\";
   }"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def,etc,def,etc")
  ]
)

; this match_can cause issues iff operand 1 is dies in this instruction and
;   we decide to use it to reload operand 0 (CAW)
(define_insn "*xorhi3_sfr1"
  [(set (match_operand:HI 0 "pic30_reg_or_near_operand" "+a,U,!???d,!???U")
        (xor:HI (match_operand:HI 1 "pic30_reg_or_near_operand"
                                                        "U,a,!???U,!???d")
                (match_dup 0)))]
  ""
  "*
   switch (which_alternative) {
     default: gcc_assert(0);
     case 0: return \"xor %1,WREG\";
     case 1: return \"xor %0\";
     case 2: if (pic30_errata_mask & exch_errata)
               return \"push w0\;mov %0,w0\;xor %1,WREG\;mov w0,%0\;pop w0\";
             else
               return \"exch w0,%0\;xor %1,WREG\;exch w0,%0\";
     case 3: if (pic30_errata_mask & exch_errata)
               return \"push w0\;mov %1,w0\;xor %0\;pop w0\";
             else
               return \"exch w0,%1\;xor %0\;exch w0,%1\";
   }"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def,etc,def,etc")
  ]
)

;;;;;;;;;;;;;;;;;
;; single integer
;;;;;;;;;;;;;;;;;

(define_insn "xorsi3_DATA"
 [(set (match_operand:SI 0 "pic30_mode2_operand"
             "=r,&r, R,R,R, r,R,<>,<>,R,<>")
       (xor:SI 
          (match_operand:SI 1 "pic30_register_operand"
             "%r, r, r,r,r, 0,r, r, r, r, r")
          (match_operand:SI 2 "pic30_mode1P_operand"
             " r, R, 0,R,r, P,P, <>,R,<>,P")))]
 ""
 "*
  static char *normal_patterns[] = {
    \"xor %1,%2,%0\;xor %d1,%d2,%d0\",
    \"xor %1,%I2,%0\;xor %d1,%D2,%d0\",
    \"xor %1,%2,%I0\;xor %d1,%2,%D0\",
    \"xor %1,%I2,%I0\;xor %d1,%D2,%D0\",
    \"xor %1,%2,%I0\;xor %d1,%d2,%D0\",
    \"xor %1,#%2,%0\",
    \"xor %1,#%2,%I0\;mov %d1,%D0\",
    \"xor %1,%2,%0\;xor %d1,%2,%0\",
    \"xor %1,%I2,%0\;xor %d1,%D2,%0\",
    \"xor %1,%2,%I0\;xor %d1,%2,%D0\",
    \"xor %1,#%2,%0\;xor %d1,#0,%0\"
  };

  static char *pre_patterns[] = {
    \"add %r0,#4,%r0\;xor %1,%I2,%I0\;xor %d1,%D2,%D0\",
    \"add %r2,#4,%r2\;xor %1,%I2,%I0\;xor %d1,%D2,%D0\",
    \"add %r0,#4,%r0\;xor %1,#%2,%I0\;xor %d1,#0,%D0\"
  };

  static char *psv_psv_normal_patterns[] = {
    \"xor %1,%2,%0\;xor %d1,%d2,%d0\",
    \"xor %1,%I2,%0\;nop\;xor %d1,%D2,%d0\",
    \"xor %1,%2,%I0\;xor %d1,%2,%D0\",
    \"xor %1,%I2,%I0\;nop\;xor %d1,%D2,%D0\",
    \"xor %1,%2,%I0\;xor %d1,%d2,%D0\",
    \"xor %1,#%2,%0\",
    \"xor %1,#%2,%I0\;mov %d1,%D0\",
    \"xor %1,%2,%0\;nop\;xor %d1,%2,%0\",
    \"xor %1,%I2,%0\;nop\;xor %d1,%D2,%0\",
    \"xor %1,%2,%I0\;nop\;xor %d1,%2,%D0\",
    \"xor %1,#%2,%0\;nop\;xor %d1,#0,%0\"
  };

  static char *psv_psv_pre_patterns[] = {
    \"add %r0,#4,%r0\;xor %1,%I2,%I0\;nop\;xor %d1,%D2,%D0\",
    \"add %r2,#4,%r2\;xor %1,%I2,%I0\;nop\;xor %d1,%D2,%D0\",
    \"add %r0,#4,%r0\;xor %1,#%2,%I0\;nop\;xor %d1,#0,%D0\"
  };

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops++;
    if (pic30_pre_modify(operands[0]) && pic30_pre_modify(operands[2])) {
      /* special case for both operands being pre-modify */
      return \"add %r0,#4,%r0\;\"
             \"add %r2,#4,%r2\;\"
             \"xor %1,%I2,%I0\;\"
             \"nop\;\"
             \"xor %d1,%D2,%D0\";
    } else if (which_alternative == 7) {
      /* special case for alternative 7, with two chances but only one taken */
      if (pic30_pre_modify(operands[0])) {
        return \"add %r0,#4,%r0\;\"
               \"xor %1,%2,%I0\;\"
               \"nop\;\"
               \"xor %d1,%2,%D0\";
      } else if (pic30_pre_modify(operands[2])) {
        return \"add %r2,#4,%r2\;\"
               \"xor %1,%I2,%0\;\"
               \"nop\;\"
               \"xor %d1,%D2,%0\";
      }
    } else if (pic30_pre_modify(operands[0]) || pic30_pre_modify(operands[2])) {
      return pre_patterns[which_alternative - 8];
    }
    return psv_psv_normal_patterns[which_alternative];
  } else {
    if (pic30_pre_modify(operands[0]) && pic30_pre_modify(operands[2])) {
      /* special case for both operands being pre-modify */
      return \"add %r0,#4,%r0\;\"
             \"add %r2,#4,%r2\;\"
             \"xor %1,%I2,%I0\;\"
             \"xor %d1,%D2,%D0\";
    } else if (which_alternative == 7) {
      /* special case for alternative 7, with two chances but only one taken */
      if (pic30_pre_modify(operands[0])) {
        return \"add %r0,#4,%r0\;\"
               \"xor %1,%2,%I0\;\"
               \"xor %d1,%2,%D0\";
      } else if (pic30_pre_modify(operands[2])) {
        return \"add %r2,#4,%r2\;\"
               \"xor %1,%I2,%0\;\"
               \"xor %d1,%D2,%0\";
      }
    } else if (pic30_pre_modify(operands[0]) || pic30_pre_modify(operands[2])) {
      return pre_patterns[which_alternative - 8];
    }
    return normal_patterns[which_alternative];
  }
 "
 [
  (set_attr "cc" "clobber")
  (set_attr "type" "def,defuse,use,use,use,def,use,use,use,use,use")
 ]
)

(define_insn "xorsi3_APSV"
 [(set (match_operand:SI 0 "pic30_mode2_operand"
             "=r,&r, R,R,R, r,R,<>,<>,R,<>")
       (xor:SI 
          (match_operand:SI 1 "pic30_register_operand"
             "%r, r, r,r,r, 0,r, r, r, r, r")
          (match_operand:SI 2 "pic30_mode1P_APSV_operand"
             " r, R, 0,R,r, P,P, <>,R,<>,P")))]
 ""
 "*
  static char *normal_patterns[] = {
    \"xor %1,%2,%0\;xor %d1,%d2,%d0\",
    \"xor %1,%I2,%0\;xor %d1,%D2,%d0\",
    \"xor %1,%2,%I0\;xor %d1,%2,%D0\",
    \"xor %1,%I2,%I0\;xor %d1,%D2,%D0\",
    \"xor %1,%2,%I0\;xor %d1,%d2,%D0\",
    \"xor %1,#%2,%0\",
    \"xor %1,#%2,%I0\;mov %d1,%D0\",
    \"xor %1,%2,%0\;xor %d1,%2,%0\",
    \"xor %1,%I2,%0\;xor %d1,%D2,%0\",
    \"xor %1,%2,%I0\;xor %d1,%2,%D0\",
    \"xor %1,#%2,%0\;xor %d1,#0,%0\"
  };

  static char *pre_patterns[] = {
    \"add %r0,#4,%r0\;xor %1,%I2,%I0\;xor %d1,%D2,%D0\",
    \"add %r2,#4,%r2\;xor %1,%I2,%I0\;xor %d1,%D2,%D0\",
    \"add %r0,#4,%r0\;xor %1,#%2,%I0\;xor %d1,#0,%D0\"
  };

  static char *psv_psv_normal_patterns[] = {
    \"xor %1,%2,%0\;xor %d1,%d2,%d0\",
    \"xor %1,%I2,%0\;xor %d1,%D2,%d0\",
    \"xor %1,%2,%I0\;xor %d1,%2,%D0\",
    \"xor %1,%I2,%I0\;xor %d1,%D2,%D0\",
    \"xor %1,%2,%I0\;xor %d1,%d2,%D0\",
    \"xor %1,#%2,%0\",
    \"xor %1,#%2,%I0\;mov %d1,%D0\",
    \"xor %1,%2,%0\;xor %d1,%2,%0\",
    \"xor %1,%I2,%0\;xor %d1,%D2,%0\",
    \"xor %1,%2,%I0\;xor %d1,%2,%D0\",
    \"xor %1,#%2,%0\;xor %d1,#0,%0\"
  };

  static char *psv_psv_pre_patterns[] = {
    \"add %r0,#4,%r0\;xor %1,%I2,%I0\;xor %d1,%D2,%D0\",
    \"add %r2,#4,%r2\;xor %1,%I2,%I0\;xor %d1,%D2,%D0\",
    \"add %r0,#4,%r0\;xor %1,#%2,%I0\;xor %d1,#0,%D0\"
  };

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops++;
    if (pic30_pre_modify(operands[0]) && pic30_pre_modify(operands[2])) {
      /* special case for both operands being pre-modify */
      return \"add %r0,#4,%r0\;\"
             \"add %r2,#4,%r2\;\"
             \"xor %1,%I2,%I0\;\"
             \"nop\;\"
             \"xor %d1,%D2,%D0\";
    } else if (which_alternative == 7) {
      /* special case for alternative 7, with two chances but only one taken */
      if (pic30_pre_modify(operands[0])) {
        return \"add %r0,#4,%r0\;\"
               \"xor %1,%2,%I0\;\"
               \"nop\;\"
               \"xor %d1,%2,%D0\";
      } else if (pic30_pre_modify(operands[2])) {
        return \"add %r2,#4,%r2\;\"
               \"xor %1,%I2,%0\;\"
               \"nop\;\"
               \"xor %d1,%D2,%0\";
      }
    } else if (pic30_pre_modify(operands[0]) || pic30_pre_modify(operands[2])) {
      return pre_patterns[which_alternative - 8];
    }
    return psv_psv_normal_patterns[which_alternative];
  } else {
    if (pic30_pre_modify(operands[0]) && pic30_pre_modify(operands[2])) {
      /* special case for both operands being pre-modify */
      return \"add %r0,#4,%r0\;\"
             \"add %r2,#4,%r2\;\"
             \"xor %1,%I2,%I0\;\"
             \"xor %d1,%D2,%D0\";
    } else if (which_alternative == 7) {
      /* special case for alternative 7, with two chances but only one taken */
      if (pic30_pre_modify(operands[0])) {
        return \"add %r0,#4,%r0\;\"
               \"xor %1,%2,%I0\;\"
               \"xor %d1,%2,%D0\";
      } else if (pic30_pre_modify(operands[2])) {
        return \"add %r2,#4,%r2\;\"
               \"xor %1,%I2,%0\;\"
               \"xor %d1,%D2,%0\";
      }
    } else if (pic30_pre_modify(operands[0]) || pic30_pre_modify(operands[2])) {
      return pre_patterns[which_alternative - 8];
    }
    return normal_patterns[which_alternative];
  }
 "
 [
  (set_attr "cc" "clobber")
  (set_attr "type" "def,defuse,use,use,use,def,use,use,use,use,use")
 ]
)

(define_expand "xorsi3"
 [(set (match_operand:SI 0 "pic30_mode2_operand"
             "=r<>,&r<>,R,R,R,  R,r,&r,<>")
       (xor:SI
          (match_operand:SI 1 "pic30_register_operand"
             "%r,   r,  r,r,r,  r,0, r,r")
          (match_operand:SI 2 "pic30_mode1P_APSV_operand"
             "r<>, R,  0,R,r<>,P,P, P,P")))]
 ""
 "
{
  if (pic30_mode1P_operand(operands[1],GET_MODE(operands[1])) &&
      pic30_mode1P_operand(operands[2],GET_MODE(operands[2])))
    emit(gen_xorsi3_DATA(operands[0],operands[1],operands[2]));
  else
    emit(gen_xorsi3_APSV(operands[0],operands[1],operands[2]));
  DONE;
}")



;;;;;;;;;;;;;;;;;
;; double integer
;;;;;;;;;;;;;;;;;

(define_insn "*xorhidi3_se"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (xor:DI
           (sign_extend:DI
              (match_operand:HI 1 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")))
  (clobber (match_scratch:HI 3                   "=&r,&r,&r,&r,&r,&r,&r,&r,&r"))
  ]
  ""
  "*
{
  char *noerrata_patterns[] = {
     /* r,r,r */          \"asr %1,#15,%3\;xor %1,%2,%0\;xor %3,%d2,%d0\;\"
                              \"xor %3,%t2,%t0\;xor %3,%q2,%q0\",

     /* >,r,r */          \"asr %1,#15,%3\;xor %1,%2,%0\;xor %3,%d2,%0\;\"
                              \"xor %3,%t2,%0\;xor %3,%q2,%0\",

     /* >,r,0 */          \"asr %1,#15,%3\;xor %1,%s2,%0\;xor %3,%s2,%0\;\"
                              \"xor %3,%s2,%0\;xor %3,%s2,%0\",

     /* >,r,> */          \"asr %1,#15,%3\;xor %1,%2,%0\;xor %3,%2,%0\;\"
                              \"xor %3,%2,%0\;xor %3,%2,%0\",

     /* r,r,> */          \"asr %1,#15,%3\;xor %1,%2,%0\;xor %3,%2,%d0\;\"
                              \"xor %3,%2,%t0\;xor %3,%2,%q0\",

     /* R,r,r */          \"asr %1,#15,%3\;xor %1,%2,%I0\;xor %3,%d2,%I0\;\"
                              \"xor %3,%t2,%I0\;xor %3,%q2,%0\",

     /* R,r,0 */          \"asr %1,#15,%3\;xor %1,%2,%I0\;xor %3,%2,%I0\;\"
                              \"xor %3,%2,%I0\;xor %3,%2,%0\",

     /* R,r,R */          \"asr %1,#15,%3\;xor %1,%I2,%I0\;xor %3,%I2,%I0\;\"
                              \"xor %3,%I2,%I0\;xor %3,%2,%0\",

     /* r,r,R */          \"asr %1,#15,%3\;xor %1,%I2,%0\;xor %3,%I2,%d0\;\"
                              \"xor %3,%I2,%t0\;xor %3,%2,%q0\",
  };

  char *psv_psv_patterns[] = {
     /* r,r,r */          \"asr %1,#15,%3\;xor %1,%2,%0\;xor %3,%d2,%d0\;\"
                              \"xor %3,%t2,%t0\;xor %3,%q2,%q0\",

     /* >,r,r */          \"asr %1,#15,%3\;xor %1,%2,%0\;xor %3,%d2,%0\;\"
                              \"xor %3,%t2,%0\;xor %3,%q2,%0\",

     /* >,r,0 */          \"asr %1,#15,%3\;xor %1,%s2,%0\;xor %3,%s2,%0\;\"
                              \"xor %3,%s2,%0\;xor %3,%s2,%0\",

     /* >,r,> */          \"asr %1,#15,%3\;\"
                          \"xor %1,%2,%0\;\"
                          \"nop\;\"
                          \"xor %3,%2,%0\;\"
                          \"nop\;\"
                          \"xor %3,%2,%0\;\"
                          \"nop\;\"
                          \"xor %3,%2,%0\",

     /* r,r,> */          \"asr %1,#15,%3\;\"
                          \"xor %1,%2,%0\;\"
                          \"nop\;\"
                          \"xor %3,%2,%d0\;\"
                          \"nop\;\"
                          \"xor %3,%2,%t0\;\"
                          \"nop\;\"
                          \"xor %3,%2,%q0\",

     /* R,r,r */          \"asr %1,#15,%3\;xor %1,%2,%I0\;xor %3,%d2,%I0\;\"
                              \"xor %3,%t2,%I0\;xor %3,%q2,%0\",

     /* R,r,0 */          \"asr %1,#15,%3\;\"
                          \"xor %1,%2,%I0\;\"
                          \"nop\;\"
                          \"xor %3,%2,%I0\;\"
                          \"nop\;\"
                          \"xor %3,%2,%I0\;\"
                          \"nop\;\"
                          \"xor %3,%2,%0\",

     /* R,r,R */          \"asr %1,#15,%3\;\"
                          \"xor %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"xor %3,%I2,%I0\;\"
                          \"nop\;\"
                          \"xor %3,%I2,%I0\;\"
                          \"nop\;\"
                          \"xor %3,%2,%0\",

     /* r,r,R */          \"asr %1,#15,%3\;\"
                          \"xor %1,%I2,%0\;\"
                          \"nop\;\"
                          \"xor %3,%I2,%d0\;\"
                          \"nop\;\"
                          \"xor %3,%I2,%t0\;\"
                          \"nop\;\"
                          \"xor %3,%2,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  int regno;
  rtx x;
  char **patterns;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops += 3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
  ]
)

(define_insn "*xorhidi3_ze"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (xor:DI
           (zero_extend:DI
              (match_operand:HI 1 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")))
  (clobber (match_scratch:HI 3                   "=X,X,&r,&r,&r,X,&r,&r,&r"))
  ]
  ""
  "*
{
  char *noerrata_patterns[] = {
     /* r,r,r */          \"xor %1,%2,%0\;mov %d2,%d0\;mov.d %t2,%t0\",

     /* >,r,r */          \"xor %1,%2,%0\;mov %d2,%0\;mov.d %t2,%0\",

     /* >,r,0 */          \"xor %1,%s2,%s0\;add #8,%r0\",

     /* >,r,> */          \"xor %1,%2,%0\;mov %2,%0\;mov %2,%0\;mov %2,%0\",

     /* r,r,> */          \"xor %1,%2,%0\;mov %2,%d0\;mov.d %2,%t0\",

     /* R,r,r */          \"xor %1,%2,%0\;mov %d2,%Q0\;mov %t2,%R0\;mov %q2,%S0\",

     /* R,r,0 */          \"xor %1,%2,%0\",

     /* R,r,R */          \"xor %1,%I2,%I0\;mov %I2,%I0\;mov %I2,%I0\;mov %2,%0\",

     /* r,r,R */          \"xor %1,%2,%0\;mov %Q2,%d0\;mov %R2,%t0\;mov %S2,%q0\"
  };

  char *psv_psv_patterns[] = {
     /* r,r,r */          \"xor %1,%2,%0\;mov %d2,%d0\;mov.d %t2,%t0\",

     /* >,r,r */          \"xor %1,%2,%0\;mov %d2,%0\;mov.d %t2,%0\",

     /* >,r,0 */          \"xor %1,%s2,%s0\;add #8,%r0\",

     /* >,r,> */          \"xor %1,%2,%0\;\"
                          \"nop\;\"
                          \"mov %2,%0\;\"
                          \"nop\;\"
                          \"mov %2,%0\;mov %2,%0\",

     /* r,r,> */          \"xor %1,%2,%0\;\"
                          \"nop\;\"
                          \"mov %2,%d0\;\"
                          \"nop\;\"
                          \"mov.d %2,%t0\",

     /* R,r,r */          \"xor %1,%2,%0\;mov %d2,%Q0\;mov %t2,%R0\;mov %q2,%S0\",

     /* R,r,0 */          \"xor %1,%2,%0\",

     /* R,r,R */          \"xor %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"mov %I2,%I0\;\"
                          \"nop\;\"
                          \"mov %I2,%I0\;\"
                          \"nop\;\"
                          \"mov %2,%0\",

     /* r,r,R */          \"xor %1,%2,%0\;\"
                          \"nop\;\"
                          \"mov %Q2,%d0\;\"
                          \"nop\;\"
                          \"mov %R2,%t0\;\"
                          \"nop\;\"
                          \"mov %S2,%q0\"
  };
  
  char *psv_psv_movd_patterns[] = {
     /* r,r,r */          \"xor %1,%2,%0\;mov %d2,%d0\;mov.d %t2,%t0\",

     /* >,r,r */          \"xor %1,%2,%0\;mov %d2,%0\;mov.d %t2,%0\",

     /* >,r,0 */          \"xor %1,%s2,%s0\;add #8,%r0\",

     /* >,r,> */          \"xor %1,%2,%0\;\"
                          \"mov %2,%0\;\"
                          \"mov %2,%0\;\"
                          \"mov %2,%0\",

     /* r,r,> */          \"xor %1,%2,%0\;\"
                          \"mov %2,%d0\;\"
                          \"mov %2,%t0\;\"
                          \"mov %2,%q0\",

     /* R,r,r */          \"xor %1,%2,%0\;\"
                          \"mov %d2,%Q0\;\"
                          \"mov %t2,%R0\;\"
                          \"mov %q2,%S0\",

     /* R,r,0 */          \"xor %1,%2,%0\",

     /* R,r,R */          \"xor %1,%I2,%I0\;\"
                          \"mov %I2,%I0\;\"
                          \"mov %I2,%I0\;\"
                          \"mov %2,%0\",

     /* r,r,R */          \"xor %1,%2,%0\;\"
                          \"mov %Q2,%d0\;\"
                          \"mov %R2,%t0\;\"
                          \"mov %S2,%q0\"
  };
  

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  int regno;
  rtx x;
  char **patterns;

  if (pic30_psrd_psrd_errata_movd(NULL,operands[2])) {
    patterns = psv_psv_movd_patterns;
  } else if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops += 3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

#if 0
     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;
#endif

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
#if 0
     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
#endif
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
  ]
)

(define_insn "*xorsidi3_se"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (xor:DI
           (sign_extend:DI
              (match_operand:SI 1 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")))
  (clobber (match_scratch:HI 3                   "=&r,&r,&r,&r,&r,&r,&r,&r,&r"))
  ]
  ""
  "*
{
  char *noerrata_patterns[] = {
     /* r,r,r */          \"asr %d1,#15,%3\;xor %1,%2,%0\;xor %d1,%d2,%d0\;\"
                              \"xor %3,%t2,%t0\;xor %3,%q2,%q0\",

     /* >,r,r */          \"asr %d1,#15,%3\;xor %1,%2,%0\;xor %d1,%d2,%0\;\"
                              \"xor %3,%t2,%0\;xor %3,%q2,%0\",

     /* >,r,0 */          \"asr %d1,#15,%3\;xor %1,%s2,%0\;xor %d1,%s2,%0\;\"
                              \"xor %3,%s2,%0\;xor %3,%s2,%0\",

     /* >,r,> */          \"asr %d1,#15,%3\;xor %1,%2,%0\;xor %d1,%2,%0\;\"
                              \"xor %3,%2,%0\;xor %3,%2,%0\",

     /* r,r,> */          \"asr %d1,#15,%3\;xor %1,%2,%0\;xor %d1,%2,%d0\;\"
                              \"xor %3,%2,%t0\;xor %3,%2,%q0\",

     /* R,r,r */          \"asr %d1,#15,%3\;xor %1,%2,%I0\;xor %d1,%d2,%I0\;\"
                              \"xor %3,%t2,%I0\;xor %3,%q2,%0\",

     /* R,r,0 */          \"asr %d1,#15,%3\;xor %1,%2,%I0\;xor %d1,%2,%I0\;\"
                              \"xor %3,%2,%I0\;xor %3,%2,%0\",

     /* R,r,R */          \"asr %d1,#15,%3\;xor %1,%I2,%I0\;xor %d1,%I2,%I0\;\"
                              \"xor %3,%I2,%I0\;xor %3,%2,%0\",

     /* r,r,R */          \"asr %d1,#15,%3\;xor %1,%I2,%0\;xor %d1,%I2,%d0\;\"
                              \"xor %3,%I2,%t0\;xor %3,%2,%q0\",
  };

  char *psv_psv_patterns[] = {
     /* r,r,r */          \"asr %d1,#15,%3\;xor %1,%2,%0\;xor %d1,%d2,%d0\;\"
                              \"xor %3,%t2,%t0\;xor %3,%q2,%q0\",

     /* >,r,r */          \"asr %d1,#15,%3\;xor %1,%2,%0\;xor %d1,%d2,%0\;\"
                              \"xor %3,%t2,%0\;xor %3,%q2,%0\",

     /* >,r,0 */          \"asr %d1,#15,%3\;xor %1,%s2,%0\;xor %d1,%s2,%0\;\"
                              \"xor %3,%s2,%0\;xor %3,%s2,%0\",

     /* >,r,> */          \"asr %d1,#15,%3\;\"
                          \"xor %1,%2,%0\;\"
                          \"nop\;\"
                          \"xor %d1,%2,%0\;\"
                          \"nop\;\"
                          \"xor %3,%2,%0\;\"
                          \"nop\;\"
                          \"xor %3,%2,%0\",

     /* r,r,> */          \"asr %d1,#15,%3\;\"
                          \"xor %1,%2,%0\;\"
                          \"nop\;\"
                          \"xor %d1,%2,%d0\;\"
                          \"nop\;\"
                          \"xor %3,%2,%t0\;\"
                          \"nop\;\"
                          \"xor %3,%2,%q0\",

     /* R,r,r */          \"asr %d1,#15,%3\;xor %1,%2,%I0\;xor %d1,%d2,%I0\;\"
                              \"xor %3,%t2,%I0\;xor %3,%q2,%0\",

     /* R,r,0 */          \"asr %d1,#15,%3\;xor %1,%2,%I0\;xor %d1,%2,%I0\;\"
                              \"xor %3,%2,%I0\;xor %3,%2,%0\",

     /* R,r,R */          \"asr %d1,#15,%3\;\"
                          \"xor %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"xor %d1,%I2,%I0\;\"
                          \"nop\;\"
                          \"xor %3,%I2,%I0\;\"
                          \"nop\;\"
                          \"xor %3,%2,%0\",

     /* r,r,R */          \"asr %d1,#15,%3\;\"
                          \"xor %1,%I2,%0\;\"
                          \"nop\;\"
                          \"xor %d1,%I2,%d0\;\"
                          \"nop\;\"
                          \"xor %3,%I2,%t0\;\"
                          \"nop\;\"
                          \"xor %3,%2,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  int regno;
  rtx x;
  char **patterns;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops += 3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
  ]
)

(define_insn "*xorsidi3_ze"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (xor:DI
           (zero_extend:DI
              (match_operand:SI 1 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")))
  ]
  ""
  "*
{
  char *noerrata_patterns[] = {
     /* r,r,r */          \"xor %1,%2,%0\;xor %d1,%d2,%d0\;mov.d %t2,%t0\",

     /* >,r,r */          \"xor %1,%2,%0\;xor %d1,%d2,%0\;mov.d %t2,%0\",

     /* >,r,0 */          \"xor %1,%s2,%0\;xor %d1,%s2,%0\;add #4,%0\",

     /* >,r,> */          \"xor %1,%2,%0\;xor %d1,%2,%0\;\"
                              \"mov %2,%0\;mov %2,%0\",

     /* r,r,> */          \"xor %1,%2,%0\;xor %d1,%2,%d0\;mov.d %2,%t0\",

     /* R,r,r */          \"xor %1,%2,%I0\;xor %d1,%d2,%D0\;mov %t2,%R0\;mov %q2,%S0\",

     /* R,r,0 */          \"xor %1,%2,%I0\;xor %d1,%2,%D0\",

     /* R,r,R */          \"xor %1,%I2,%I0\;xor %d1,%I2,%I0\;mov %I2,%I0\;mov %2,%0\",

     /* r,r,R */          \"xor %1,%I2,%0\;xor %d1,%D2,%d0\;mov %R2,%t0\;mov %S2,%q0\"
  };

  char *psv_psv_patterns[] = {
     /* r,r,r */          \"xor %1,%2,%0\;xor %d1,%d2,%d0\;mov.d %t2,%t0\",

     /* >,r,r */          \"xor %1,%2,%0\;xor %d1,%d2,%0\;mov.d %t2,%0\",

     /* >,r,0 */          \"xor %1,%s2,%0\;xor %d1,%s2,%0\;add #4,%0\",

     /* >,r,> */          \"xor %1,%2,%0\;\"
                          \"nop\;\"
                          \"xor %d1,%2,%0\;\"
                          \"nop\;\"
                          \"mov %2,%0\;\"
                          \"nop\;\"
                          \"mov %2,%0\",

     /* r,r,> */          \"xor %1,%2,%0\;\"
                          \"nop\;\"
                          \"xor %d1,%2,%d0\;\"
                          \"nop\;\"
                          \"mov.d %2,%t0\",

     /* R,r,r */          \"xor %1,%2,%I0\;xor %d1,%d2,%D0\;mov %t2,%R0\;mov %q2,%S0\",

     /* R,r,0 */          \"xor %1,%2,%I0\;xor %d1,%2,%D0\",

     /* R,r,R */          \"xor %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"xor %d1,%I2,%I0\;\"
                          \"nop\;\"
                          \"mov %I2,%I0\;\"
                          \"nop\;\"
                          \"mov %2,%0\",

     /* r,r,R */          \"xor %1,%I2,%0\;\"
                          \"nop\;\"
                          \"xor %d1,%D2,%d0\;\"
                          \"nop\;\"
                          \"mov %R2,%t0\;\"
                          \"nop\;\"
                          \"mov %S2,%q0\"
  };

  char *psv_psv_movd_patterns[] = {
     /* r,r,r */          \"xor %1,%2,%0\;xor %d1,%d2,%d0\;mov.d %t2,%t0\",

     /* >,r,r */          \"xor %1,%2,%0\;xor %d1,%d2,%0\;mov.d %t2,%0\",

     /* >,r,0 */          \"xor %1,%s2,%0\;xor %d1,%s2,%0\;add #4,%0\",

     /* >,r,> */          \"xor %1,%2,%0\;\"
                          \"xor %d1,%2,%0\;\"
                          \"mov %2,%0\;\"
                          \"mov %2,%0\",

     /* r,r,> */          \"xor %1,%2,%0\;\"
                          \"xor %d1,%2,%d0\;\"
                          \"mov %2,%t0\;\"
                          \"mov %2,%q0\",

     /* R,r,r */          \"xor %1,%2,%I0\;\"
                          \"xor %d1,%d2,%D0\;\"
                          \"mov %t2,%R0\;\"
                          \"mov %q2,%S0\",

     /* R,r,0 */          \"xor %1,%2,%I0\;xor %d1,%2,%D0\",

     /* R,r,R */          \"xor %1,%I2,%I0\;\"
                          \"xor %d1,%I2,%I0\;\"
                          \"mov %I2,%I0\;\"
                          \"mov %2,%0\",

     /* r,r,R */          \"xor %1,%I2,%0\;\"
                          \"xor %d1,%D2,%d0\;\"
                          \"mov %R2,%t0\;\"
                          \"mov %S2,%q0\"
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  int regno;
  rtx x;
  char **patterns;

  if (pic30_psrd_psrd_errata_movd(NULL,operands[2])) {
    patterns = psv_psv_movd_patterns;
  } else if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops += 3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

#if 0
     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;
#endif

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

#if 0
     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
#endif
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
  ]
)

(define_insn "*xordihi3_se"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (xor:DI
           (match_operand:DI 1 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")
           (sign_extend:DI
              (match_operand:HI 2 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
        )
   )
  (clobber (match_scratch:HI 3                   "=&r,&r,&r,&r,&r,&r,&r,&r,&r"))
  ]
  ""
  "*
{
  char *noerrata_patterns[] = {
     /* r,r,r */          \"asr %2,#15,%3\;xor %2,%1,%0\;xor %3,%d1,%d0\;\"
                              \"xor %3,%t1,%t0\;xor %3,%q1,%q0\",

     /* >,r,r */          \"asr %2,#15,%3\;xor %2,%1,%0\;xor %3,%d1,%0\;\"
                              \"xor %3,%t1,%0\;xor %3,%q1,%0\",

     /* >,0,r */          \"asr %2,#15,%3\;xor %2,%s1,%0\;xor %3,%s1,%0\;\"
                              \"xor %3,%s1,%0\;xor %3,%s1,%0\",

     /* >,>,r */          \"asr %2,#15,%3\;xor %2,%1,%0\;xor %3,%1,%0\;\"
                              \"xor %3,%1,%0\;xor %3,%1,%0\",

     /* r,>,r */          \"asr %2,#15,%3\;xor %2,%1,%0\;xor %3,%1,%d0\;\"
                              \"xor %3,%1,%t0\;xor %3,%1,%q0\",

     /* R,r,r */          \"asr %2,#15,%3\;xor %2,%1,%I0\;xor %3,%d1,%I0\;\"
                              \"xor %3,%t1,%I0\;xor %3,%q1,%0\",

     /* R,0,r */          \"asr %2,#15,%3\;xor %2,%1,%I0\;xor %3,%1,%I0\;\"
                              \"xor %3,%1,%I0\;xor %3,%1,%0\",

     /* R,R,r */          \"asr %2,#15,%3\;xor %2,%I1,%I0\;xor %3,%I1,%I0\;\"
                              \"xor %3,%I1,%I0\;xor %3,%1,%0\",

     /* r,R,r */          \"asr %2,#15,%3\;xor %2,%I1,%0\;xor %3,%I1,%d0\;\"
                              \"xor %3,%I1,%t0\;xor %3,%1,%q0\",
  };

  char *psv_psv_patterns[] = {
     /* r,r,r */          \"asr %2,#15,%3\;xor %2,%1,%0\;xor %3,%d1,%d0\;\"
                              \"xor %3,%t1,%t0\;xor %3,%q1,%q0\",

     /* >,r,r */          \"asr %2,#15,%3\;xor %2,%1,%0\;xor %3,%d1,%0\;\"
                              \"xor %3,%t1,%0\;xor %3,%q1,%0\",

     /* >,0,r */          \"asr %2,#15,%3\;xor %2,%s1,%0\;xor %3,%s1,%0\;\"
                              \"xor %3,%s1,%0\;xor %3,%s1,%0\",

     /* >,>,r */          \"asr %2,#15,%3\;\"
                          \"xor %2,%1,%0\;\"
                          \"nop\;\"
                          \"xor %3,%1,%0\;\"
                          \"nop\;\"
                          \"xor %3,%1,%0\;\"
                          \"nop\;\"
                          \"xor %3,%1,%0\",

     /* r,>,r */          \"asr %2,#15,%3\;\"
                          \"xor %2,%1,%0\;\"
                          \"nop\;\"
                          \"xor %3,%1,%d0\;\"
                          \"nop\;\"
                          \"xor %3,%1,%t0\;\"
                          \"nop\;\"
                          \"xor %3,%1,%q0\",

     /* R,r,r */          \"asr %2,#15,%3\;xor %2,%1,%I0\;xor %3,%d1,%I0\;\"
                              \"xor %3,%t1,%I0\;xor %3,%q1,%0\",

     /* R,0,r */          \"asr %2,#15,%3\;xor %2,%1,%I0\;xor %3,%1,%I0\;\"
                              \"xor %3,%1,%I0\;xor %3,%1,%0\",

     /* R,R,r */          \"asr %2,#15,%3\;\"
                          \"xor %2,%I1,%I0\;\"
                          \"nop\;\"
                          \"xor %3,%I1,%I0\;\"
                          \"nop\;\"
                          \"xor %3,%I1,%I0\;\"
                          \"nop\;\"
                          \"xor %3,%1,%0\",

     /* r,R,r */          \"asr %2,#15,%3\;\"
                          \"xor %2,%I1,%0\;\"
                          \"nop\;\"
                          \"xor %3,%I1,%d0\;\"
                          \"nop\;\"
                          \"xor %3,%I1,%t0\;\"
                          \"nop\;\"
                          \"xor %3,%1,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  int regno;
  rtx x;
  char **patterns;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops += 3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,0,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,R,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[1],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;

     case 8:  /* r,R,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[1],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "clobber")
     (set_attr "type" "def")
  ]
)

(define_insn "*xordihi3_ze"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (xor:DI
           (match_operand:DI 1 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")
           (zero_extend:DI
              (match_operand:HI 2 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
        )
   )
  ]
  ""
  "*
{
  char *noerrata_patterns[] = {
     /* r,r,r */          \"xor %1,%2,%0\;mov %d1,%d0\;mov.d %t1,%t0\",

     /* >,r,r */          \"xor %1,%2,%0\;mov %d1,%0\;mov.d %t1,%0\",

     /* >,0,r */          \"xor %2,%s1,%s0\;add #8,%r0\",

     /* >,>,r */          \"xor %2,%1,%0\;mov %1,%0\;mov %1,%0\;mov %1,%0\",

     /* r,>,r */          \"xor %2,%1,%0\;mov %1,%d0\;mov.d %1,%t0\",

     /* R,r,r */          \"xor %2,%1,%0\;mov %d1,%Q0\;mov %t1,%R0\;mov %q1,%S0\",

     /* R,0,r */          \"xor %2,%1,%0\",

     /* R,R,r */          \"xor %2,%I1,%I0\;mov %I1,%I0\;mov %I1,%I0\;mov %1,%0\",

     /* r,R,r */          \"xor %2,%1,%0\;mov %Q1,%d0\;mov %R1,%t0\;mov %S1,%q0\"
  };

  char *psv_psv_patterns[] = {
     /* r,r,r */          \"xor %1,%2,%0\;mov %d1,%d0\;mov.d %t1,%t0\",

     /* >,r,r */          \"xor %1,%2,%0\;mov %d1,%0\;mov.d %t1,%0\",

     /* >,0,r */          \"xor %2,%s1,%s0\;add #8,%r0\",

     /* >,>,r */          \"xor %2,%1,%0\;\"
                          \"nop\;\"
                          \"mov %1,%0\;\"
                          \"nop\;\"
                          \"mov %1,%0\;\"
                          \"nop\;\"
                          \"mov %1,%0\",

     /* r,>,r */          \"xor %2,%1,%0\;\"
                          \"nop\;\"
                          \"mov %1,%d0\;\"
                          \"nop\;\"
                          \"mov.d %1,%t0\",

     /* R,r,r */          \"xor %2,%1,%0\;mov %d1,%Q0\;mov %t1,%R0\;mov %q1,%S0\",

     /* R,0,r */          \"xor %2,%1,%0\",

     /* R,R,r */          \"xor %2,%I1,%I0\;\"
                          \"nop\;\"
                          \"mov %I1,%I0\;\"
                          \"nop\;\"
                          \"mov %I1,%I0\;\"
                          \"nop\;\"
                          \"mov %1,%0\",

     /* r,R,r */          \"xor %2,%1,%0\;\"
                          \"nop\;\"
                          \"mov %Q1,%d0\;\"
                          \"nop\;\"
                          \"mov %R1,%t0\;\"
                          \"nop\;\"
                          \"mov %S1,%q0\"
  };

  char *psv_psv_movd_patterns[] = {
     /* r,r,r */          \"xor %1,%2,%0\;mov %d1,%d0\;mov.d %t1,%t0\",

     /* >,r,r */          \"xor %1,%2,%0\;mov %d1,%0\;mov.d %t1,%0\",

     /* >,0,r */          \"xor %2,%s1,%s0\;add #8,%r0\",

     /* >,>,r */          \"xor %2,%1,%0\;\"
                          \"mov %1,%0\;\"
                          \"mov %1,%0\;\"
                          \"mov %1,%0\",

     /* r,>,r */          \"xor %2,%1,%0\;\"
                          \"mov %1,%d0\;\"
                          \"mov %1,%t0\;\"
                          \"mov %1,%q0\",

     /* R,r,r */          \"xor %2,%1,%0\;\"
                          \"mov %d1,%Q0\;\"
                          \"mov %t1,%R0\;\"
                          \"mov %q1,%S0\",

     /* R,0,r */          \"xor %2,%1,%0\",

     /* R,R,r */          \"xor %2,%I1,%I0\;\"
                          \"mov %I1,%I0\;\"
                          \"mov %I1,%I0\;\"
                          \"mov %1,%0\",

     /* r,R,r */          \"xor %2,%1,%0\;\"
                          \"mov %Q1,%d0\;\"
                          \"mov %R1,%t0\;\"
                          \"mov %S1,%q0\"
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  int regno;
  rtx x;
  char **patterns;

  if (pic30_psrd_psrd_errata_movd(NULL,operands[2])) {
    patterns = psv_psv_movd_patterns;
  } else if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops += 3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

#if 0
     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;
#endif

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

#if 0
     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
#endif
   }
}"
   [
     (set_attr "cc" "clobber")
     (set_attr "type" "def")
  ]
)

(define_insn "*xordisi3_se"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (xor:DI
           (match_operand:DI 1 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")
           (sign_extend:DI
              (match_operand:SI 2 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
        )
   )
  (clobber (match_scratch:HI 3                   "=&r,&r,&r,&r,&r,&r,&r,&r,&r"))
  ]
  ""
  "*
{
  char *noerrata_patterns[] = {
     /* r,r,r */          \"asr %d2,#15,%3\;xor %2,%1,%0\;xor %d2,%d1,%d0\;\"
                              \"xor %3,%t1,%t0\;xor %3,%q1,%q0\",

     /* >,r,r */          \"asr %d2,#15,%3\;xor %2,%1,%0\;xor %d2,%d1,%0\;\"
                              \"xor %3,%t1,%0\;xor %3,%q1,%0\",

     /* >,0,r */          \"asr %d2,#15,%3\;xor %2,%s1,%0\;xor %d2,%s1,%0\;\"
                              \"xor %3,%s1,%0\;xor %3,%s1,%0\",

     /* >,>,r */          \"asr %d2,#15,%3\;xor %2,%1,%0\;xor %d2,%1,%0\;\"
                              \"xor %3,%1,%0\;xor %3,%1,%0\",

     /* r,>,r */          \"asr %d2,#15,%3\;xor %2,%1,%0\;xor %d2,%1,%d0\;\"
                              \"xor %3,%1,%t0\;xor %3,%1,%q0\",

     /* R,r,r */          \"asr %d2,#15,%3\;xor %2,%1,%I0\;xor %d2,%d1,%I0\;\"
                              \"xor %3,%t1,%I0\;xor %3,%q1,%0\",

     /* R,0,r */          \"asr %d2,#15,%3\;xor %2,%1,%I0\;xor %d2,%1,%I0\;\"
                              \"xor %3,%1,%I0\;xor %3,%1,%0\",

     /* R,R,r */          \"asr %d2,#15,%3\;xor %2,%I1,%I0\;xor %d2,%I1,%I0\;\"
                              \"xor %3,%I1,%I0\;xor %3,%1,%0\",

     /* r,R,r */          \"asr %d2,#15,%3\;xor %2,%I1,%0\;xor %d2,%I1,%d0\;\"
                              \"xor %3,%I1,%t0\;xor %3,%1,%q0\",
  };

  char *psv_psv_patterns[] = {
     /* r,r,r */          \"asr %d2,#15,%3\;xor %2,%1,%0\;xor %d2,%d1,%d0\;\"
                              \"xor %3,%t1,%t0\;xor %3,%q1,%q0\",

     /* >,r,r */          \"asr %d2,#15,%3\;xor %2,%1,%0\;xor %d2,%d1,%0\;\"
                              \"xor %3,%t1,%0\;xor %3,%q1,%0\",

     /* >,0,r */          \"asr %d2,#15,%3\;xor %2,%s1,%0\;xor %d2,%s1,%0\;\"
                              \"xor %3,%s1,%0\;xor %3,%s1,%0\",

     /* >,>,r */          \"asr %d2,#15,%3\;\"
                          \"xor %2,%1,%0\;\"
                          \"nop\;\"
                          \"xor %d2,%1,%0\;\"
                          \"nop\;\"
                          \"xor %3,%1,%0\;\"
                          \"nop\;\"
                          \"xor %3,%1,%0\",

     /* r,>,r */          \"asr %d2,#15,%3\;\"
                          \"xor %2,%1,%0\;\"
                          \"nop\;\"
                          \"xor %d2,%1,%d0\;\"
                          \"nop\;\"
                          \"xor %3,%1,%t0\;\"
                          \"nop\;\"
                          \"xor %3,%1,%q0\",

     /* R,r,r */          \"asr %d2,#15,%3\;xor %2,%1,%I0\;xor %d2,%d1,%I0\;\"
                              \"xor %3,%t1,%I0\;xor %3,%q1,%0\",

     /* R,0,r */          \"asr %d2,#15,%3\;xor %2,%1,%I0\;xor %d2,%1,%I0\;\"
                              \"xor %3,%1,%I0\;xor %3,%1,%0\",

     /* R,R,r */          \"asr %d2,#15,%3\;\"
                          \"xor %2,%I1,%I0\;\"
                          \"nop\;\"
                          \"xor %d2,%I1,%I0\;\"
                          \"nop\;\"
                          \"xor %3,%I1,%I0\;\"
                          \"nop\;\"
                          \"xor %3,%1,%0\",

     /* r,R,r */          \"asr %d2,#15,%3\;\"
                          \"xor %2,%I1,%0\;\"
                          \"nop\;\"
                          \"xor %d2,%I1,%d0\;\"
                          \"nop\;\"
                          \"xor %3,%I1,%t0\;\"
                          \"nop\;\"
                          \"xor %3,%1,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  int regno;
  rtx x;
  char **patterns;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops += 3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,0,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,R,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[1],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;

     case 8:  /* r,R,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[1],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "clobber")
     (set_attr "type" "def")
  ]
)

(define_insn "*xordisi3_ze"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (xor:DI
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")
           (zero_extend:DI
              (match_operand:SI 1 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
        )
   )
  ]
  ""
  "*
{
  char *noerrata_patterns[] = {
     /* r,r,r */          \"xor %1,%2,%0\;xor %d1,%d2,%d0\;mov.d %t1,%t0\",

     /* >,r,r */          \"xor %1,%2,%0\;xor %d1,%d2,%0\;mov.d %t1,%0\",

     /* >,0,r */          \"xor %2,%s1,%0\;xor %d2,%s1,%0\;add #4,%r0\",

     /* >,>,r */          \"xor %2,%1,%0\;xor %d2,%1,%0\;\"
                              \"mov %1,%0\;mov %1,%0\",

     /* r,>,r */          \"xor %2,%1,%0\;xor %d2,%1,%d0\;mov.d %1,%t0\",

     /* R,r,r */          \"xor %2,%1,%I0\;xor %d2,%d1,%D0\;mov %t1,%R0\;mov %q1,%S0\",

     /* R,0,r */          \"xor %2,%1,%I0\;xor %d2,%1,%D0\",

     /* R,R,r */          \"xor %2,%I1,%I0\;xor %d2,%I1,%I0\;mov %I1,%I0\;mov %1,%0\",

     /* r,R,r */          \"xor %2,%I1,%0\;xor %d2,%D1,%d0\;mov %R1,%t0\;mov %S1,%q0\"
  };

  char *psv_psv_patterns[] = {
     /* r,r,r */          \"xor %1,%2,%0\;xor %d1,%d2,%d0\;mov.d %t1,%t0\",

     /* >,r,r */          \"xor %1,%2,%0\;xor %d1,%d2,%0\;mov.d %t1,%0\",

     /* >,0,r */          \"xor %2,%s1,%0\;xor %d2,%s1,%0\;add #4,%r0\",

     /* >,>,r */          \"xor %2,%1,%0\;\"
                          \"nop\;\"
                          \"xor %d2,%1,%0\;\"
                          \"nop\;\"
                          \"mov %1,%0\;\"
                          \"nop\;\"
                          \"mov %1,%0\",

     /* r,>,r */          \"xor %2,%1,%0\;\"
                          \"nop\;\"
                          \"xor %d2,%1,%d0\;\"
                          \"nop\;\"
                          \"mov.d %1,%t0\",

     /* R,r,r */          \"xor %2,%1,%I0\;xor %d2,%d1,%D0\;mov %t1,%R0\;mov %q1,%S0\",

     /* R,0,r */          \"xor %2,%1,%I0\;xor %d2,%1,%D0\",

     /* R,R,r */          \"xor %2,%I1,%I0\;\"
                          \"nop\;\"
                          \"xor %d2,%I1,%I0\;\"
                          \"nop\;\"
                          \"mov %I1,%I0\;\"
                          \"nop\;\"
                          \"mov %1,%0\",

     /* r,R,r */          \"xor %2,%I1,%0\;\"
                          \"nop\;\"
                          \"xor %d2,%D1,%d0\;\"
                          \"nop\;\"
                          \"mov %R1,%t0\;\"
                          \"nop\;\"
                          \"mov %S1,%q0\"
  };

  char *psv_psv_movd_patterns[] = {
     /* r,r,r */          \"xor %1,%2,%0\;xor %d1,%d2,%d0\;mov.d %t1,%t0\",

     /* >,r,r */          \"xor %1,%2,%0\;xor %d1,%d2,%0\;mov.d %t1,%0\",

     /* >,0,r */          \"xor %2,%s1,%0\;xor %d2,%s1,%0\;add #4,%r0\",

     /* >,>,r */          \"xor %2,%1,%0\;\"
                          \"xor %d2,%1,%0\;\"
                          \"mov %1,%0\;\"
                          \"mov %1,%0\",

     /* r,>,r */          \"xor %2,%1,%0\;\"
                          \"xor %d2,%1,%d0\;\"
                          \"mov %1,%t0\;\"
                          \"mov %1,%q0\",

     /* R,r,r */          \"xor %2,%1,%I0\;\"
                          \"xor %d2,%d1,%D0\;\"
                          \"mov %t1,%R0\;\"
                          \"mov %q1,%S0\",

     /* R,0,r */          \"xor %2,%1,%I0\;xor %d2,%1,%D0\",

     /* R,R,r */          \"xor %2,%I1,%I0\;\"
                          \"xor %d2,%I1,%I0\;\"
                          \"mov %I1,%I0\;\"
                          \"mov %1,%0\",

     /* r,R,r */          \"xor %2,%I1,%0\;\"
                          \"xor %d2,%D1,%d0\;\"
                          \"mov %R1,%t0\;\"
                          \"mov %S1,%q0\"
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  int regno;
  rtx x;
  char **patterns;

  if (pic30_psrd_psrd_errata_movd(NULL,operands[2])) {
    patterns = psv_psv_movd_patterns;
  } else if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops += 3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

#if 0
     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;
#endif

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

#if 0
     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
#endif
   }
}"
   [
     (set_attr "cc" "clobber")
     (set_attr "type" "def")
  ]
)

(define_insn "xordi3"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (xor:DI
           (match_operand:DI 1 "pic30_register_operand"    "r,r,r,r, r,r,r,r, r")
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")))
  ]
  ""
  "*
{
  char *noerrata_patterns[] = {
     /* r,r,r */          \"xor %1,%2,%0\;xor %d1,%d2,%d0\;\"
                              \"xor %t1,%t2,%t0\;xor %q1,%q2,%q0\",

     /* >,r,r */          \"xor %1,%2,%0\;xor %d1,%d2,%0\;\"
                              \"xor %t1,%t2,%0\;xor %q1,%q2,%0\",

     /* >,r,0 */          \"xor %1,%s2,%0\;xor %d1,%s2,%0\;\"
                              \"xor %t1,%s2,%0\;xor %q1,%s2,%0\",

     /* >,r,> */          \"xor %1,%s2,%0\;xor %d1,%2,%0\;\"
                              \"xor %t1,%2,%0\;xor %q1,%2,%0\",

     /* r,r,> */          \"xor %1,%2,%0\;xor %d1,%2,%d0\;\"
                              \"xor %t1,%2,%t0\;xor %q1,%2,%q0\",

     /* R,r,r */          \"xor %1,%2,%I0\;xor %d1,%d2,%I0\;\"
                              \"xor %t1,%t2,%I0\;xor %q1,%q2,%0\",

     /* R,r,0 */          \"xor %1,%2,%I0\;xor %d1,%2,%I0\;\"
                              \"xor %t1,%2,%I0\;xor %q1,%2,%0\",

     /* R,r,R */          \"xor %1,%I2,%I0\;xor %d1,%I2,%I0\;\"
                              \"xor %t1,%I2,%I0\;xor %q1,%2,%0\",

     /* r,r,R */          \"xor %1,%I2,%0\;xor %d1,%I2,%d0\;\"
                              \"xor %t1,%I2,%t0\;xor %q1,%2,%q0\",
  };

  char *psv_psv_patterns[] = {
     /* r,r,r */          \"xor %1,%2,%0\;xor %d1,%d2,%d0\;\"
                              \"xor %t1,%t2,%t0\;xor %q1,%q2,%q0\",

     /* >,r,r */          \"xor %1,%2,%0\;xor %d1,%d2,%0\;\"
                              \"xor %t1,%t2,%0\;xor %q1,%q2,%0\",

     /* >,r,0 */          \"xor %1,%s2,%0\;xor %d1,%s2,%0\;\"
                              \"xor %t1,%s2,%0\;xor %q1,%s2,%0\",

     /* >,r,> */          \"xor %1,%s2,%0\;\"
                          \"nop\;\"
                          \"xor %d1,%2,%0\;\"
                          \"nop\;\"
                          \"xor %t1,%2,%0\;\"
                          \"nop\;\"
                          \"xor %q1,%2,%0\",

     /* r,r,> */          \"xor %1,%2,%0\;\"
                          \"nop\;\"
                          \"xor %d1,%2,%d0\;\"
                          \"nop\;\"
                          \"xor %t1,%2,%t0\;\"
                          \"nop\;\"
                          \"xor %q1,%2,%q0\",

     /* R,r,r */          \"xor %1,%2,%I0\;xor %d1,%d2,%I0\;\"
                              \"xor %t1,%t2,%I0\;xor %q1,%q2,%0\",

     /* R,r,0 */          \"xor %1,%2,%I0\;xor %d1,%2,%I0\;\"
                              \"xor %t1,%2,%I0\;xor %q1,%2,%0\",

     /* R,r,R */          \"xor %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"xor %d1,%I2,%I0\;\"
                          \"nop\;\"
                          \"xor %t1,%I2,%I0\;\"
                          \"nop\;\"
                          \"xor %q1,%2,%0\",

     /* r,r,R */          \"xor %1,%I2,%0\;\"
                          \"nop\;\"
                          \"xor %d1,%I2,%d0\;\"
                          \"nop\;\"
                          \"xor %t1,%I2,%t0\;\"
                          \"nop\;\"
                          \"xor %q1,%2,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  int regno;
  rtx x;
  char **patterns;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops += 3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "clobber")
     (set_attr "type" "def")
  ]
)


;(define_insn "xordi3"
;  [(set (match_operand:DI 0 "pic30_register_operand"         "=r")
;        (xor:DI (match_operand:DI 1 "pic30_register_operand" "%r")
;                (match_operand:DI 2 "pic30_register_operand"  "r")))]
;  ""
;  "xor %2,%1,%0\;xor %d2,%d1,%d0\;xor %t2,%t1,%t0\;xor %q2,%q1,%q0"
;  [
;   (set_attr "cc" "clobber")
;   (set_attr "type" "def")
;  ]
;)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; NOT
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;
;; QImode ;;
;;;;;;;;;;;;

(define_insn "one_cmplqi2_DATA"
  [(set (match_operand:QI 0 "pic30_mode2_operand"        "=r<>,r<>,R,R")
        (not:QI (match_operand:QI 1 "pic30_mode2_operand" "r,  R<>,r,R<>")))]
  ""
  "com.b %1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,defuse,use,use")
  ]
)

(define_insn "one_cmplqi2_APSV"
  [(set (match_operand:QI 0 "pic30_mode2_operand"        "=r<>,r<>,R,R")
        (not:QI 
           (match_operand:QI 1 "pic30_mode2_APSV_operand" "r,  R<>,r,R<>")))]
  ""
  "com.b %1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,defuse,use,use")
  ]
)

; leave this match_dup, operand 0 will not require a reload (CAW)
(define_insn "*one_cmplqi2_sfr"
  [(set (match_operand:QI 0 "pic30_near_operand"        "=U")
        (not:QI (match_dup 0)))]
  ""
  "com.b %0"
  [
    (set_attr "cc" "math")
    (set_attr "type" "etc")
  ]
)

(define_expand "one_cmplqi2"
  [(set (match_operand:QI 0 "general_operand")
        (not:QI (match_operand:QI 1 "general_operand")))]
  ""
  "{
      if (pic30_mode2_operand(operands[0],QImode)) {
        if (pic30_mode2_operand(operands[1],QImode)) {
          emit(gen_one_cmplqi2_DATA(operands[0],operands[1]));
          DONE;
        } else if (pic30_mode2_APSV_operand(operands[1],QImode)) {
          emit(gen_one_cmplqi2_APSV(operands[0],operands[1]));
          DONE;
        } else {
          rtx op1 = gen_reg_rtx(GET_MODE(operands[1]));

          emit_move_insn(op1, operands[1]);
          emit(gen_one_cmplqi2_DATA(operands[0],op1));
          DONE;
        }
      }
      FAIL;
   }"
)

;;;;;;;;;;;;
;; HImode ;;
;;;;;;;;;;;;

(define_insn "one_cmplhi2_DATA"
  [(set (match_operand:HI 0 "pic30_mode2_operand"        "=r<>,r<>,R,R")
        (not:HI 
           (match_operand:HI 1 "pic30_mode2_operand" "r,  R<>,r,R<>")))]
  ""
  "com %1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,defuse,use,use")
  ]
)

(define_insn "one_cmplhi2_APSV"
  [(set (match_operand:HI 0 "pic30_mode2_operand"        "=r<>,r<>,R,R")
        (not:HI 
           (match_operand:HI 1 "pic30_mode2_APSV_operand" "r,  R<>,r,R<>")))]
  ""
  "com %1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,defuse,use,use")
  ]
)

(define_expand "one_cmplhi2"
  [(set (match_operand: HI 0 "general_operand")
        (not: HI (match_operand:HI 1 "general_operand")))]
  ""
  "{
      if (pic30_mode2_operand(operands[0],HImode)) {
        if (pic30_mode2_operand(operands[1],HImode)) {
          emit(gen_one_cmplhi2_DATA(operands[0],operands[1]));
          DONE;
        } else if (pic30_mode2_APSV_operand(operands[1],HImode)) {
          emit(gen_one_cmplhi2_APSV(operands[0],operands[1]));
          DONE;
        } else {
          rtx op1 = gen_reg_rtx(GET_MODE(operands[1]));

          emit_move_insn(op1, operands[1]);
          emit(gen_one_cmplhi2_DATA(operands[0],op1));
          DONE;
        }
      }
      FAIL;
   }"
)

; leave this match_dup, operand 0 will not require a reload (CAW)
(define_insn "*one_cmplhi2_sfr"
  [(set (match_operand:HI 0 "pic30_near_operand"        "=U")
        (not:HI (match_dup 0)))]
  ""
  "com %0"
  [
    (set_attr "cc" "math")
    (set_attr "type" "etc")
  ]
)

;;;;;;;;;;;;
;; SImode ;;
;;;;;;;;;;;;

(define_insn "one_cmplsi2"
  [(set (match_operand:SI 0 "pic30_register_operand"        "=r")
        (not:SI (match_operand:SI 1 "pic30_register_operand" "r")))]
  ""
  "com %1,%0\;com %d1,%d0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

; leave this match_dup, operand 0 will not require a reload (CAW)
(define_insn "*one_cmplsi2_sfr"
  [(set (match_operand:SI 0 "pic30_near_operand"        "=U")
        (not:SI (match_dup 0)))]
  ""
  "com %0\;com %0+2"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "etc")
  ]
)

;; DImode

(define_insn "one_cmpldi2"
  [(set (match_operand:DI 0 "pic30_register_operand"        "=r")
        (not:DI (match_operand:DI 1 "pic30_register_operand" "r")))]
  ""
  "com %1,%0\;com %d1,%d0\;com %t1,%t0\;com %q1,%q0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

; leave this match_dup, operand 0 will not require a reload (CAW)
(define_insn "*one_cmpldi2_sfr"
  [(set (match_operand:DI 0 "pic30_near_operand"        "=U")
        (not:DI (match_dup 0)))]
  ""
  "com %0\;com %0+2\;com %0+4\;com %0+6"
  [(set_attr "cc" "clobber")])


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Find first one
;;
;; Represents one plus the index of the least significant 1-bit in X,
;; represented as an integer of mode M.  (The value is zero if X is
;; zero.)  The mode of X need not be M; depending on the target
;; machine, various mode combinations may be valid.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_insn "ffshi2_DATA"
  [(set (match_operand:HI 0 "pic30_register_operand"           "=r,r")
        (ffs:HI 
           (match_operand:HI 1 "pic30_mode2_operand" "r,R<>")))]
  ""
  "*
   {
     return \"ff1r %1,%0\";
   }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def,defuse")
  ]
)

(define_insn "ffshi2_APSV"
  [(set (match_operand:HI 0 "pic30_register_operand"           "=r,r")
        (ffs:HI 
           (match_operand:HI 1 "pic30_mode2_APSV_operand" "r,R<>")))]
  ""
  "*
   {
     return \"ff1r %1,%0\";
   }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def,defuse")
  ]
)

(define_expand "ffshi2"
  [(set (match_operand:HI 0 "pic30_register_operand"           "=r,r")
        (ffs:HI 
           (match_operand:HI 1 "pic30_mode2_operand" "r,R<>")))]
  ""
  "{
     if (pic30_mode2_APSV_operand(operands[1],GET_MODE(operands[1]))) {
       emit(
         gen_ffshi2_APSV(operands[0], operands[1])
       );
     } else {
       emit(
         gen_ffshi2_DATA(operands[0], operands[1])
       );
     }
     DONE;
   }")

(define_insn "ff1lhi2_DATA"
  [(set (match_operand:HI 0 "pic30_register_operand"           "=r,r")
        (unspec:HI [
          (match_operand:HI 1 "pic30_mode2_operand" "r,R<>")
        ] UNSPEC_FF1L))]
  ""
  "*
   {
     return \"ff1l %1,%0\";
   }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def,defuse")
  ]
)

(define_insn "ff1lhi2_APSV"
  [(set (match_operand:HI 0 "pic30_register_operand"           "=r,r")
        (unspec:HI [
          (match_operand:HI 1 "pic30_mode2_APSV_operand" "r,R<>")
         ] UNSPEC_FF1L))]
  ""
  "*
   {
     return \"ff1l %1,%0\";
   }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def,defuse")
  ]
)

(define_expand "ff1lhi2"
  [(set (match_operand:HI 0 "pic30_register_operand"           "=r,r")
        (unspec:HI [
           (match_operand:HI 1 "pic30_mode2_operand" "r,R<>")
         ] UNSPEC_FF1L))]
  ""
  "{
     if (pic30_mode2_APSV_operand(operands[1],GET_MODE(operands[1]))) {
       emit(
         gen_ff1lhi2_APSV(operands[0], operands[1])
       );
     } else {
       emit(
         gen_ff1lhi2_DATA(operands[0], operands[1])
       );
     }
     DONE;
   }")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Shift instructions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Arithmetic Shift Left instructions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;
;; QImode ;;
;;;;;;;;;;;;

(define_insn "*ashlqi3_gen_1_DATA"
  [(set (match_operand:QI 0 "pic30_mode2_operand"           "=r<>,r<>,R,R")
        (ashift:QI (match_operand:QI 1 "pic30_mode2_operand" "r,  R<>,r,R<>")
                   (match_operand:QI 2 "pic30_I_operand"     "I,  I,  I,I")))]
  ""
  "sl.b %1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,defuse,use,use")
  ]
)

(define_insn "*ashlqi3_gen_1_APSV"
  [(set (match_operand:QI 0 "pic30_mode2_operand"           "=r<>,r<>,R,R")
        (ashift:QI (match_operand:QI 1 "pic30_mode2_APSV_operand" "r,  R<>,r,R<>")
                   (match_operand:QI 2 "pic30_I_operand"     "I,  I,  I,I")))]
  ""
  "sl.b %1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,defuse,use,use")
  ]
)

(define_insn "*ashlqi3_sfr_1"
  [(set (match_operand:QI 0 "pic30_wreg_or_near_operand"   "=a,U")
        (ashift:QI (match_operand:QI 1 "pic30_near_operand" "U,0")
                   (match_operand:QI 2 "pic30_I_operand"    "I,I")))]
  ""
  "@
    sl.b %1,WREG
    sl.b %0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,etc")
  ]
)

;; For shift by n, we operate in word mode.
;; This is ok, since we are shifting left
;; (zeroes are inserted from the right).
;; However, the condition codes are not useful.

;; for register sl, must first mask off upper bits because
;;   if it was loaded with a mov.b (likely) into a dirty register (possible)
;;   then the word-sized shift value will saturate

(define_insn "ashlqi3_unused"
  [(set (match_operand:QI 0 "pic30_register_operand"                 "=r,r")
        (ashift:QI (match_operand:QI 1 "pic30_register_operand"       "r,r")
                   (match_operand:QI 2 "pic30_reg_or_P_operand" "r,P")))]
  "0"
  "@
    and.w #0xFF,%2\;sl %1,%2,%0
    sl %1,#%2,%0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ashlqi3"
  [(set (match_operand:QI 0 "pic30_register_operand"                 "=r,r")
        (ashift:QI (match_operand:QI 1 "pic30_register_operand"       "r,r")
                   (subreg:QI 
                     (match_operand:HI 2 "pic30_reg_or_P_operand" "r,P") 0)))]
  ""
  "@
    sl %1,%2,%0
    sl %1,#%2,%0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

;;;;;;;;;;;;
;; HImode ;;
;;;;;;;;;;;;

(define_insn "*ashlhi3_gen_1_DATA"
  [(set (match_operand:HI 0 "pic30_mode2_operand"           "=r<>,r<>,R,R")
        (ashift:HI (match_operand:HI 1 "pic30_mode2_operand" "r,  R<>,r,R<>")
                   (match_operand:HI 2 "pic30_I_operand"     "I,  I,  I,I")
        )
   )
  ]
  ""
  "@
    sl %1,%0
    sl %1,%0
    sl %1,%0
    sl %1,%0"
 [
  (set_attr "cc" "math")
  (set_attr "type" "def,defuse,use,use")
 ]
)

(define_insn "*ashlhi3_gen_1_APSV"
  [(set (match_operand:HI 0 "pic30_mode2_operand"           "=r<>,r<>,R,R")
        (ashift:HI 
           (match_operand:HI 1 "pic30_mode2_APSV_operand" "r,  R<>,r,R<>")
           (match_operand:HI 2 "pic30_I_operand"     "I,  I,  I,I")
        )
   )
  ]
  ""
  "@
    sl %1,%0
    sl %1,%0
    sl %1,%0
    sl %1,%0"
 [
  (set_attr "cc" "math")
  (set_attr "type" "def,defuse,use,use")
 ]
)

(define_insn_and_split "*ashlhi3_sfr0"
  [(set (match_operand:HI 0 "pic30_register_operand"             "=a,?d")
        (ashift:HI (match_operand:HI 1 "pic30_near_operand" "U, U")
                   (match_operand:HI 2 "pic30_I_operand"    "I, I")))]
  ""
  "@
   sl %1,WREG
   mov %1,%0\;sl %0,%0"
  "reload_completed"
  [
   (set (match_dup 0) (match_dup 1))
   (set (match_dup 0) (ashift:HI (match_dup 0) (const_int 1)))
  ]
"
{
  if (pic30_wreg_operand(operands[0], HImode)) {
    FAIL;
  }
}
"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
  ]
)

; leave this match_dup, operand 0 will not require a reload (CAW)
(define_insn "*ashlhi3_sfr1"
  [(set (match_operand:HI 0 "pic30_near_operand"           "=U")
        (ashift:HI (match_dup 0)
                   (match_operand:HI 1 "pic30_I_operand"    "I")))]
  ""
  "sl %0"
  [(set_attr "cc" "math")])

(define_insn "ashlhi3"
  [(set (match_operand:HI 0 "pic30_register_operand"                   "=r,r,r")
        (ashift:HI (match_operand:HI 1 "pic30_register_operand"         "r,r,r")
                   (match_operand:HI 2 "pic30_reg_or_imm_operand" "K,i,r")))]
  ""
  "*
{
	switch (which_alternative)
	{
	case 0:
    		return \"sl %1,#%2,%0\";
	case 1:
		if (INTVAL(operands[2]) < 0)
    			return \"asr %1,#%J2%%16,%0\";
		else
    			return \"sl %1,#%2%%16,%0\";
	case 2:
    		return \"sl %1,%2,%0\";
	default:
		gcc_assert(0);
	}
}"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
  ]
)

(define_insn "ashlp16apsv3"
  [(set (match_operand:P16APSV 0 "pic30_register_operand"      "=r,r,r")
        (ashift:P16APSV 
           (match_operand:P16APSV 1 "pic30_register_operand"   "r,r,r")
           (match_operand:P16APSV 2 "pic30_reg_or_imm_operand" "K,i,r")))]
  ""
  "*
{
	switch (which_alternative)
	{
	case 0:
    		return \"sl %1,#%2,%0\";
	case 1:
		if (INTVAL(operands[2]) < 0)
    			return \"asr %1,#%J2%%16,%0\";
		else
    			return \"sl %1,#%2%%16,%0\";
	case 2:
    		return \"sl %1,%2,%0\";
	default:
		gcc_assert(0);
	}
}"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
  ]
)

;;;;;;;;;;;;
;; SImode ;;
;;;;;;;;;;;;

(define_expand "ashlsi3"
  [(set (match_operand:SI 0 "pic30_register_operand" "")
        (ashift:SI (match_operand:SI 1 "pic30_register_operand" "")
                   (match_operand:HI 2 "pic30_reg_or_imm_operand" "")))]
  ""
  "
{
	if (GET_CODE(operands[2]) == CONST_INT)
	{
		switch (INTVAL(operands[2]))
		{
		case 0:
			emit_insn(gen_movsi(operands[0], operands[1]));
			break;
		case 1:
			emit_insn(gen_ashlsi3_imm1(operands[0],
						operands[1], operands[2]));
			break;
		case 8:
			emit_insn(gen_ashlsi3_imm8(operands[0],
						operands[1], operands[2]));
			break;
		case 2 ... 7:
		case 9 ... 15:
			emit_insn(gen_ashlsi3_imm2to15(operands[0],
						operands[1], operands[2]));
			break;
		case 16:
			emit_insn(gen_ashlsi3_imm16plus(operands[0],
						operands[1], operands[2]));
			break;
		case 17 ... 31:
			emit_insn(gen_ashlsi3_imm16plus(operands[0],
						operands[1], operands[2]));
			break;
		default:
			emit_insn(gen_movsi(operands[0], const0_rtx));
			break;
		}
	}
	else
	{
		emit_insn(gen_ashlsi3_reg(operands[0],operands[1],operands[2]));
	}
	DONE;
}")

(define_insn "ashlsi3_imm1"
  [(set (match_operand:SI 0            "pic30_register_operand" "=r")
        (ashift:SI (match_operand:SI 1 "pic30_register_operand"  "r")
                   (match_operand:HI 2 "pic30_I_operand"         "I")))]
  ""
  "add %1,%1,%0\;addc %d1,%d1,%d0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ashlsi3_imm8"
  [(set (match_operand:SI 0            "pic30_register_operand"  "=&r")
        (ashift:SI (match_operand:SI 1 "pic30_register_operand"   "r")
                   (match_operand:HI 2 "pic30_imm8_operand" "i")))
  ]
  ""
  "*
   {
     int idDst = REGNO(operands[0]);
     int idSrc = REGNO(operands[1]);
     if (idDst == idSrc) {
       return \"sl %d1,#%2,%d0\;\"
              \"swap %1\;\"
              \"mov.b %0,%d0\;\"
              \"clr.b %0\";
     } else {
       return \"sl %d1,#%2,%0\;\"
              \"lsr %1,#%k2,%d0\;\"
              \"ior %0,%d0,%d0\;\"
              \"sl %1,#%2,%0\";
     }
   }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ashlsi3_imm16plus"
  [(set (match_operand:SI 0            "pic30_register_operand"       "=r")
        (ashift:SI (match_operand:SI 1 "pic30_register_operand"        "r")
                   (match_operand:HI 2 "pic30_imm16plus_operand" "i")))]
  ""
  "sl %1,#%K2,%d0\;mov #0,%0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ashlsi3_imm2to15"
  [(set (match_operand:SI 0            "pic30_register_operand"      "=r,&r")
        (ashift:SI (match_operand:SI 1 "pic30_register_operand"       "r, r")
                   (match_operand:HI 2 "pic30_imm2to15_operand" "i, i")))
		   (clobber (match_scratch:HI 3               "=&r, X"))]
  ""
  "*
   {
      int idDst, idSrc;

      switch (which_alternative) {
        case 0:
          /*
           ** Take care that the source and dest don't overlap
           */
          idDst = REGNO(operands[0]);
          idSrc = REGNO(operands[1]);
          if (idDst >= idSrc) {
            return \"sl %d1,#%2,%3\;\"
                   \"lsr %1,#%k2,%d0\;\"
                   \"ior %3,%d0,%d0\;\"
                   \"sl %1,#%2,%0\";
          } else {
            return \"sl %1,#%2,%0\;\"
                   \"sl %d1,#%2,%3\;\"
                   \"lsr %1,#%k2,%d0\;\"
                   \"ior %3,%d0,%d0\";
          }
        default:
          /*
           ** The dest and source don't overlap
           ** so use dest lsw as a temporary
           */
          return \"sl %d1,#%2,%0\;\"
                 \"lsr %1,#%k2,%d0\;\"
                 \"ior %0,%d0,%d0\;\"
                 \"sl %1,#%2,%0\";
      }
   }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

;
;  True it sets a reg, but.... the last instruction is not a load.  etc
;
(define_insn "ashlsi3_reg"
  [(set (match_operand:SI            0 "pic30_register_operand" "=r")
        (ashift:SI (match_operand:SI 1 "pic30_register_operand" " 0")
                   (match_operand:HI 2 "pic30_register_operand" " r")))
   (clobber (match_scratch:HI        3                          "=2"))]
  ""
  "*
   {
      return 
#if (1)
      	      \".set ___BP___,0\n\"
#endif
              \".LB%=:\;\"
              \"dec %2,%2\;\"
              \"bra n,.LE%=\;\"
              \"add %1,%1,%0\;\"
              \"addc %d1,%d1,%d0\;\"
              \"bra .LB%=\n\"
              \".LE%=:\";
   }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "etc")
  ]
)
;
; P32EDS
;

(define_expand "ashlp32eds3"
  [(set (match_operand:P32EDS 0 "pic30_register_operand" "")
	(ashift:P32EDS (match_operand:P32EDS 1 "pic30_register_operand" "")
		   (match_operand:HI 2 "pic30_reg_or_imm_operand" "")))]
  ""
  "
{
	if (GET_CODE(operands[2]) == CONST_INT)
	{
		switch (INTVAL(operands[2]))
		{
		case 0:
			emit_insn(gen_movp32eds(operands[0], operands[1]));
			break;
		case 1:
			emit_insn(gen_ashlp32eds3_imm1(operands[0],
						operands[1], operands[2]));
			break;
		case 8:
			emit_insn(gen_ashlp32eds3_imm8(operands[0],
						operands[1], operands[2]));
			break;
		case 2 ... 7:
		case 9 ... 15:
			emit_insn(gen_ashlp32eds3_imm2to15(operands[0],
						operands[1], operands[2]));
			break;
		case 16:
			emit_insn(gen_ashlp32eds3_imm16plus(operands[0],
						operands[1], operands[2]));
			break;
		case 17 ... 31:
			emit_insn(gen_ashlp32eds3_imm16plus(operands[0],
						operands[1], operands[2]));
			break;
		default:
			emit_insn(gen_movp32eds(operands[0], const0_rtx));
			break;
		}
	}
	else
	{
		emit_insn(gen_ashlp32eds3_reg(operands[0],operands[1],operands[2]));
	}
	DONE;
}")

(define_insn "ashlp32eds3_imm1"
  [(set (match_operand:P32EDS 0            "pic30_register_operand" "=r")
	(ashift:P32EDS (match_operand:P32EDS 1 "pic30_register_operand"  "r")
		   (match_operand:HI 2 "pic30_I_operand"         "I")))]
  ""
  "add %1,%1,%0\;rlc %0,[w15]\;addc %d1,%d1,%d0\;bclr %0,#15"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ashlp32eds3_imm8"
  [(set (match_operand:P32EDS 0            "pic30_register_operand"  "=r")
	(ashift:P32EDS (match_operand:P32EDS 1 "pic30_register_operand"   "r")
		   (match_operand:HI 2 "pic30_imm8_operand" "i")))]
  ""
  "*
   {
     int idDst = REGNO(operands[0]);
     int idSrc = REGNO(operands[1]);
     if (idDst == idSrc) {
       return \"sl %d1,#%2,%d0\;\"
              \"swap %1\;\"
              \"mov.b %0,%d0\;\"
              \"clr.b %0\";
     } else {
       return \"sl %d1,#%2,%0\;\"
              \"lsr %1,#%k2,%d0\;\"
              \"ior %0,%d0,%d0\;\"
              \"sl %1,#%2,%0\";
     }
   }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ashlp32eds3_imm16plus"
  [(set (match_operand:P32EDS 0            "pic30_register_operand"       "=r")
	(ashift:P32EDS (match_operand:P32EDS 1 "pic30_register_operand"        "r")
		   (match_operand:HI 2 "pic30_imm16plus_operand" "i")))]
  ""
  "sl %1,#%K2,%d0\;mov #0,%0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ashlp32eds3_imm2to15"
  [(set (match_operand:P32EDS 0            "pic30_register_operand"      "=r,&r")
	(ashift:P32EDS (match_operand:P32EDS 1 "pic30_register_operand"       "r, r")
		   (match_operand:HI 2 "pic30_imm2to15_operand" "i, i")))
		   (clobber (match_scratch:HI 3               "=&r, X"))]
  ""
  "*
   {
     int idDst, idSrc;

     switch (which_alternative) {
       case 0:
         /*
          ** Take care that the source and dest don't overlap
          */
         idDst = REGNO(operands[0]);
         idSrc = REGNO(operands[1]);
         if (idDst >= idSrc) {
           return \"sl %d1,#%2,%3\;\"
                  \"lsr %1,#%k2,%d0\;\"
                  \"ior %3,%d0,%d0\;\"
                  \"sl %1,#%2,%0\";
         } else {
           return \"sl %1,#%2,%0\;\"
                  \"sl %d1,#%2,%3\;\"
                  \"lsr %1,#%k2,%d0\;\"
                  \"ior %3,%d0,%d0\";
        }
        default:
          /*
           ** The dest and source don't overlap
           ** so use dest lsw as a temporary
           */
           return \"sl %d1,#%2,%0\;\"
                  \"lsr %1,#%k2,%d0\;\"
                  \"ior %0,%d0,%d0\;\"
                  \"sl %1,#%2,%0\";
     }
   }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ashlp32eds3_reg"
  [(set (match_operand:P32EDS            0 "pic30_register_operand" "=r")
	(ashift:P32EDS (match_operand:P32EDS 1 "pic30_register_operand" " 0")
		   (match_operand:HI 2 "pic30_register_operand" " r")))
   (clobber (match_scratch:HI        3                          "=2"))]
  ""
  "*
   {
      return 
#if (1)
	      \".set ___BP___,0\n\"
#endif
	      \".LB%=:\;\"
	      \"dec %2,%2\;\"
	      \"bra n,.LE%=\;\"
	      \"add %1,%1,%0\;\"
	      \"addc %d1,%d1,%d0\;\"
	      \"bra .LB%=\n\"
	      \".LE%=:\";
   }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DImode arithmetic shift left.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_expand "ashldi3"
  [(set (match_operand:DI 0 "pic30_register_operand"            "")
        (ashift:DI (match_operand:DI 1 "pic30_register_operand"  "")
                   (match_operand:HI 2 "pic30_reg_or_imm_operand" "")))]
  ""
  "
{
	if (GET_CODE(operands[2]) == CONST_INT)
	{
		switch (INTVAL(operands[2]))
		{
		case 0:
			emit_insn(gen_movdi(operands[0], operands[1]));
			break;
		case 1:
			emit_insn(gen_ashldi3_imm1(operands[0],
						    operands[1], operands[2]));
			break;
#if 1
                case 2 ... 63:
			emit_insn(gen_ashldi3_immn(operands[0],
						   operands[1], operands[2]));
			break;
#else
		case 2 ... 15:
			emit_insn(gen_ashldi3_immn(operands[0],
						   operands[1], operands[2]));
			break;
		case 16:
			emit_insn(gen_ashldi3_imm16(operands[0],
						    operands[1], operands[2]));
			break;
		case 17 ... 31:
			emit_insn(gen_ashldi3_immn(operands[0],
						   operands[1], operands[2]));
			break;
		case 32:
			emit_insn(gen_ashldi3_imm32(operands[0],
						    operands[1], operands[2]));
			break;
		case 33 ... 47:
			emit_insn(gen_ashldi3_immn(operands[0],
						   operands[1], operands[2]));
			break;
		case 48:
			emit_insn(gen_ashldi3_imm48(operands[0],
						    operands[1], operands[2]));
			break;
		case 49 ... 63:
			emit_insn(gen_ashldi3_immn(operands[0],
						   operands[1], operands[2]));
			break;
#endif
		default:
			emit_insn(gen_movdi(operands[0], const0_rtx));
			break;
		}
	}
	else
	{
		emit_insn(gen_ashldi3_reg(operands[0],operands[1],operands[2]));
	}
	DONE;
}")

(define_insn "ashldi3_imm1"
  [(set (match_operand:DI            0 "pic30_register_operand" "=r")
        (ashift:DI (match_operand:DI 1 "pic30_register_operand" " r")
                   (match_operand:HI 2 "immediate_operand"      " i")))]
  "INTVAL(operands[2])==1"
  "sl %1,%0\;rlc %d1,%d0\;rlc %t1,%t0\;rlc %q1,%q0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ashldi3_imm16"
  [(set (match_operand:DI 0            "pic30_register_operand" "=r")
        (ashift:DI (match_operand:DI 1 "pic30_register_operand"  "r")
                   (match_operand:HI 2 "immediate_operand" "i")))]
  "INTVAL(operands[2])==16"
  "mov %t1,%q0\;mov %d1,%t0\;mov %1,%d0\;mov #0,%0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ashldi3_imm32"
  [(set (match_operand:DI 0            "pic30_register_operand" "=r")
        (ashift:DI (match_operand:DI 1 "pic30_register_operand"  "r")
                   (match_operand:HI 2 "immediate_operand" "i")))]
  "INTVAL(operands[2])==32"
  "mov.d %1,%t0\;mul.su %0,#0,%0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ashldi3_imm48"
  [(set (match_operand:DI 0            "pic30_register_operand" "=r")
        (ashift:DI (match_operand:DI 1 "pic30_register_operand"  "r")
                   (match_operand:HI 2 "immediate_operand" "i")))]
  "INTVAL(operands[2])==48"
  "mov %1,%q0\;mov #0,%t0\;mul.su %0,#0,%0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ashldi3_immn"
  [(set (match_operand:DI            0 "pic30_register_operand" "=r")
        (ashift:DI (match_operand:DI 1 "pic30_register_operand" " 0")
                   (match_operand:HI 2 "immediate_operand"      " i")))
   (clobber (match_scratch:HI        3                          "=&r"))]
  ""
  "*
{ static char buffer[256];
  char *f;
  int results = 0;
  rtx result_reg;
      
  /* how many results do we need?
     if all but the low reg is dead we can shift fewer values */
  result_reg = gen_rtx_REG(HImode, REGNO(operands[0]));
  if (!pic30_dead_or_set_p(insn, result_reg) &&
      !find_regno_note(insn, REG_UNUSED, REGNO(result_reg))) 
    results = 1;
  result_reg = gen_rtx_REG(HImode, REGNO(operands[0])+1);
  if (!pic30_dead_or_set_p(insn, result_reg) &&
      !find_regno_note(insn, REG_UNUSED, REGNO(result_reg)))
    results = 1+1;
  result_reg = gen_rtx_REG(HImode, REGNO(operands[0])+2);
  if (!pic30_dead_or_set_p(insn, result_reg) &&
      !find_regno_note(insn, REG_UNUSED, REGNO(result_reg)))
    results = 1+2;
  result_reg = gen_rtx_REG(HImode, REGNO(operands[0])+3);
  if (!pic30_dead_or_set_p(insn, result_reg) &&
      !find_regno_note(insn, REG_UNUSED, REGNO(result_reg)))
    results = 1+3;

  f = buffer;
  f += sprintf(buffer,\".set ___BP___,0 ; (%ld,%d)\;\", 
               INTVAL(operands[2]), results);
  if (INTVAL(operands[2]) < 16) {
    switch (results) {
      case 4:
        if (!optimize_size) {
          f += sprintf(f,
             \"sl %%q1,#%%2,%%q0\;\"
             \"lsr %%t1,#%ld,%%3\;\"
             \"ior %%3,%%q0,%%q0\;\"
             \"sl %%t1,#%%2,%%t0\;\"
             \"lsr %%d1,#%ld,%%3\;\"
             \"ior %%3,%%t0,%%t0\;\"
             \"sl %%d1,#%%2,%%d0\;\"
             \"lsr %%1,#%ld,%%3\;\"
             \"ior %%3,%%d0,%%d0\;\"
             \"sl %%1,#%%2,%%0\",
             16 - INTVAL(operands[2]), 
             16 - INTVAL(operands[2]), 
             16 - INTVAL(operands[2]));
        } else {
          f += sprintf(f,
            \"mov #%%2,%%3\;\"
            \".LB%%=:\;\"
            \"sl %%1,%%0\;\"
            \"rlc %%d1,%%d0\;\"
            \"rlc %%t1,%%t0\;\"
            \"rlc %%q1,%%q0\;\"
            \"dec %%3,%%3\;\"
            \"bra nz,.LB%%=\");
        }
        if ((unsigned)f - (unsigned)buffer > 256) 
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 3:
        f += sprintf(f,
           \"sl %%t1,#%%2,%%t0\;\"
           \"lsr %%d1,#%ld,%%3\;\"
           \"ior %%3,%%t0,%%t0\;\"
           \"sl %%d1,#%%2,%%d0\;\"
           \"lsr %%1,#%ld,%%3\;\"
           \"ior %%3,%%d0,%%d0\;\"
           \"sl %%1,#%%2,%%0\", 
           16 - INTVAL(operands[2]), 
           16 - INTVAL(operands[2]));
        if ((unsigned)f - (unsigned)buffer > 256) 
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 2:
        f += sprintf(f,
           \"sl %%d1,#%%2,%%d0\;\"
           \"lsr %%1,#%ld,%%3\;\"
           \"ior %%3,%%d0,%%d0\;\"
           \"sl %%1,#%%2,%%0\", 
           16 - INTVAL(operands[2]));
        if ((unsigned)f - (unsigned)buffer > 256) 
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 1:
        f += sprintf(f,
          \"sl %%1,#%%2,%%0\");
        if ((unsigned)f - (unsigned)buffer > 256) 
          error(\"Unexpected error during assembly generation\");
        return buffer;
    }
  } else if (INTVAL(operands[2]) == 16) {
    switch (results) {
      case 4:
        f += sprintf(f,
           \"mov %%t1,%%q0\;\"
           \"mov %%d1,%%t0\;\"
           \"mov %%1,%%d0\;\"
           \"clr %%0\");
        break;
      case 3:
        f += sprintf(f,
           \"mov %%d1,%%t0\;\"
           \"mov %%1,%%d0\;\"
           \"clr %%0\");
        break;
      case 2:
        f += sprintf(f,
           \"mov %%1,%%d0\;\"
           \"clr %%0\");
        break;
      case 1:
        f += sprintf(f,
           \"clr %%0\");
        break;
    }
    if ((unsigned)f - (unsigned)buffer > 256) 
      error(\"Unexpected error during assembly generation\");
    return buffer;
  } else if (INTVAL(operands[2]) < 32) {
    switch (results) {
      case 4:
        f += sprintf(f,
           \"sl %%t1,#%ld,%%q0\;\"
           \"lsr %%d1,#%ld,%%3\;\"
           \"ior %%3,%%q0,%%q0\;\"
           \"sl %%d1,#%ld,%%t0\;\"
           \"lsr %%1,#%ld,%%3\;\"
           \"ior %%3,%%t0,%%t0\;\"
           \"sl %%1,#%ld,%%d0\;\"
           \"clr %%0\",
           INTVAL(operands[2]) - 16,
           32 - INTVAL(operands[2]),
           INTVAL(operands[2]) - 16,
           32 - INTVAL(operands[2]),
           INTVAL(operands[2]) - 16);
        if ((unsigned)f - (unsigned)buffer > 256) 
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 3:
        f += sprintf(f,
           \"sl %%d1,#%ld,%%t0\;\"
           \"lsr %%1,#%ld,%%3\;\"
           \"ior %%3,%%t0,%%t0\;\"
           \"sl %%1,#%ld,%%d0\;\"
           \"clr %%0\",
           INTVAL(operands[2]) - 16,
           32 - INTVAL(operands[2]),
           INTVAL(operands[2]) - 16);
        if ((unsigned)f - (unsigned)buffer > 256) 
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 2:
        f += sprintf(f,
           \"sl %%1,#%ld,%%d0\;\"
           \"clr %%0\",
           INTVAL(operands[2]) - 16);
        if ((unsigned)f - (unsigned)buffer > 256) 
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 1:
        f += sprintf(f,\"clr %%0\");
        if ((unsigned)f - (unsigned)buffer > 256) 
          error(\"Unexpected error during assembly generation\");
        return buffer;
    }
  } else if (INTVAL(operands[2]) == 32) {
    switch (results) {
      case 4:
        f += sprintf(f,
           \"mov.d %%1,%%t0\;\"
           \"mul.uu %%0,#0,%%0\");
        break;
      case 3:
        f += sprintf(f,
           \"mov %%1,%%t0\;\"
           \"mul.uu %%0,#0,%%0\");
        break;
      case 2:
        f += sprintf(f,
           \"mul.uu %%0,#0,%%0\");
        break;
      case 1:
        f += sprintf(f,
           \"clr %%0\");
        break;
    }
    if ((unsigned)f - (unsigned)buffer > 256)
      error(\"Unexpected error during assembly generation\");
    return buffer;
  } else if (INTVAL(operands[2]) < 48) {
    switch (results) {
      case 4:
        f += sprintf(f,
           \"sl %%d1,#%ld,%%q0\;\"
           \"lsr %%1,#%ld,%%3\;\"
           \"ior %%3,%%q0,%%q0\;\"
           \"sl %%1,#%ld,%%t0\;\"
           \"mul.uu %%0,#0,%%0\",
           INTVAL(operands[2]) - 32,
           48 - INTVAL(operands[2]),
           INTVAL(operands[2]) - 32);
        if ((unsigned)f - (unsigned)buffer > 256) 
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 3:
        f += sprintf(f,
           \"sl %%1,#%ld,%%t0\;\"
           \"mul.uu %%0,#0,%%0\",
           INTVAL(operands[2]) - 32);
        if ((unsigned)f - (unsigned)buffer > 256) 
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 2:
        f += sprintf(f, \"mul.uu %%0,#0,%%0\");
        if ((unsigned)f - (unsigned)buffer > 256) 
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 1:
        f += sprintf(f, \"clr %%0\");
        if ((unsigned)f - (unsigned)buffer > 256) 
          error(\"Unexpected error during assembly generation\");
        return buffer;
    }
  } else if (INTVAL(operands[2]) == 48) {
    switch (results) {
      case 4:
        f += sprintf(f,
           \"mov %%1,%%q0\;\"
           \"clr %%t0\;\"
           \"mul.uu %%0,#0,%%0\");
        break;
      case 3:
        f += sprintf(f,
           \"clr %%t0\;\"
           \"mul.uu %%0,#0,%%0\");
        break;
      case 2:
        f += sprintf(f,
           \"mul.uu %%0,#0,%%0\");
        break;
      case 1:
        f += sprintf(f,
           \"clr %%0\");
        break;
    }
    if ((unsigned)f - (unsigned)buffer > 256)
      error(\"Unexpected error during assembly generation\");
    return buffer;
  } else if (INTVAL(operands[2]) < 64) {
    switch (results) {
      case 4: 
        f += sprintf(f, \"sl %%1,#%ld,%%q0\;\", INTVAL(operands[2])-48);
        /* FALLSTHROUGH */
      case 3:
        f += sprintf(f, \"clr %%t0\;\");
        /* FALLSTHROUGH */
      case 2:
        f += sprintf(f, \"mul.uu %%0,#0,%%0\"); 
        break;
      case 1:
        f += sprintf(f, \"clr %%0\");
        break;
    }
    if ((unsigned)f - (unsigned)buffer > 256) 
      error(\"Unexpected error during assembly generation\");
    return buffer;
  }
  gcc_assert(0);
  return \"nop\";
}"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ashldi3_reg"
  [(set (match_operand:DI            0 "pic30_register_operand" "=r")
        (ashift:DI (match_operand:DI 1 "pic30_register_operand" " 0")
                   (match_operand:HI 2 "pic30_register_operand" " r")))
   (clobber (match_scratch:HI        3                          "=2"))]
  ""
  "*
   {
      return 
#if (1)
      	      \".set ___BP___,0\n\"
#endif
              \".LB%=:\;\"
              \"dec %2,%2\;\"
              \"bra n,.LE%=\;\"
              \"sl %1,%0\;\"
              \"rlc %d1,%d0\;\"
              \"rlc %t1,%t0\;\"
              \"rlc %q1,%q0\;\"
              \"bra .LB%=\n\"
              \".LE%=:\";
   }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "etc")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Logical Shift Right instructions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;
;; QImode ;;
;;;;;;;;;;;;

(define_insn "*lshrqi3_one_DATA"
  [(set (match_operand:QI 0 "pic30_mode2_operand"             "=r<>,r<>,R,R")
        (lshiftrt:QI (match_operand:QI 1 "pic30_mode2_operand" "r,  R<>,r,R<>")
                     (match_operand:QI 2 "pic30_I_operand"     "I,  I,  I,I")))]
  ""
  "lsr.b %1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,defuse,use,use")
  ]
)

(define_insn "*lshrqi3_one_APSV"
  [(set (match_operand:QI 0 "pic30_mode2_operand"             "=r<>,r<>,R,R")
        (lshiftrt:QI 
           (match_operand:QI 1 "pic30_mode2_APSV_operand" "r,  R<>,r,R<>")
           (match_operand:QI 2 "pic30_I_operand"     "I,  I,  I,I")))]
  ""
  "lsr.b %1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,defuse,use,use")
  ]
)

(define_insn "*lshrqi3_sfr0"
  [(set (match_operand:QI 0 "pic30_register_operand"               "=a,r")
        (lshiftrt:QI (match_operand:QI 1 "pic30_near_operand" "U,U")
                     (match_operand:QI 2 "pic30_I_operand"    "I,I")))]
  ""
  "@
    lsr.b %1,WREG
    mov #%1,%0\;lsr.b [%0],%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
  ]
)

; leave this match_dup, operand 0 will not require a reload (CAW)
(define_insn "*lshrqi3_sfr1"
  [(set (match_operand:QI 0 "pic30_near_operand"          "=U")
        (lshiftrt:QI (match_dup 0)
                     (match_operand:QI 1 "pic30_I_operand" "I")))]
  ""
  "lsr %0"
  [(set_attr "cc" "math")])

;;;;;;;;;;;;
;; HImode ;;
;;;;;;;;;;;;

(define_insn "*lshrhi3_one_DATA"
  [(set (match_operand:HI 0 "pic30_mode2_operand"             "=r<>,r<>,R,R")
        (lshiftrt:HI (match_operand:HI 1 "pic30_mode2_operand" "r,  R<>,r,R<>")
                     (match_operand:HI 2 "pic30_I_operand"     "I,  I,  I,I")))]
  ""
  "lsr %1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,defuse,use,use")
  ]
)

(define_insn "*lshrhi3_one_APSV"
  [(set (match_operand:HI 0 "pic30_mode2_operand"             "=r<>,r<>,R,R")
        (lshiftrt:HI 
           (match_operand:HI 1 "pic30_mode2_APSV_operand" "r,  R<>,r,R<>")
           (match_operand:HI 2 "pic30_I_operand"     "I,  I,  I,I")))]
  ""
  "lsr %1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,defuse,use,use")
  ]
)

(define_insn "*lshrhi3_sfr0"
  [(set (match_operand:HI 0 "pic30_register_operand"               "=a,?r")
        (lshiftrt:HI (match_operand:HI 1 "pic30_data_operand" "U, T")
                     (match_operand:HI 2 "pic30_I_operand"    "I, I")))]
  ""
  "@
   lsr %1,WREG
   mov %1,%0\;lsr %0,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
  ]
)

; leave this match_dup, operand 0 will not require a reload (CAW)
(define_insn "*lshrhi3_sfr1"
  [(set (match_operand:HI 0 "pic30_near_operand"          "=U")
        (lshiftrt:HI (match_dup 0)
                     (match_operand:HI 1 "pic30_I_operand" "I")))]
  ""
  "lsr %0"
  [(set_attr "cc" "math")])

(define_insn "lshrhi3"
  [(set (match_operand:HI 0 "pic30_register_operand"                "=r,r,r")
        (lshiftrt:HI (match_operand:HI 1 "pic30_register_operand"   "r,r,r")
                     (match_operand:HI 2 "pic30_reg_or_imm_operand" "K,i,r")))]
  ""
  "@
    lsr %1,#%2,%0
    clr %0
    lsr %1,%2,%0"
  [
   (set_attr "cc" "math,change0,math")
   (set_attr "type" "def")
  ]
)

(define_insn "lshrp16apsv3"
  [(set (match_operand:P16APSV   0 "pic30_register_operand"   "=r,r,r")
        (lshiftrt:P16APSV
          (match_operand:P16APSV 1 "pic30_register_operand"   "r,r,r")
          (match_operand:P16APSV 2 "pic30_reg_or_imm_operand" "K,i,r")))]
  ""
  "@
    lsr %1,#%2,%0
    clr %0
    lsr %1,%2,%0"
  [
   (set_attr "cc" "math,change0,math")
   (set_attr "type" "def")
  ]
)

;;;;;;;;;;;;
;; SImode ;;
;;;;;;;;;;;;

(define_expand "lshrsi3"
  [(set (match_operand:SI 0 "pic30_register_operand"              "")
        (lshiftrt:SI (match_operand:SI 1 "pic30_register_operand"  "")
                     (match_operand:HI 2 "pic30_reg_or_imm_operand" "")))]
  ""
  "
{
	if (GET_CODE(operands[2]) == CONST_INT)
	{
		switch (INTVAL(operands[2]))
		{
		case 0:
			emit_insn(gen_movsi(operands[0], operands[1]));
			break;
		case 1:
			emit_insn(gen_lshrsi3_imm1(operands[0],
						operands[1], operands[2]));
			break;
		case 2 ... 15:
			emit_insn(gen_lshrsi3_imm2to15(operands[0],
						operands[1], operands[2]));
			break;
		case 16:
			emit_insn(gen_lshrsi3_imm16plus(operands[0],
						operands[1], operands[2]));
			break;
		case 17 ... 31:
			emit_insn(gen_lshrsi3_imm16plus(operands[0],
						operands[1], operands[2]));
			break;
		default:
			emit_insn(gen_movsi(operands[0], const0_rtx));
			break;
		}
	}
	else
	{
		emit_insn(gen_lshrsi3_reg(operands[0],operands[1],operands[2]));
	}
	DONE;
}")

(define_insn "lshrsi3_imm1"
  [(set (match_operand:SI 0 "pic30_register_operand"             "=r")
        (lshiftrt:SI (match_operand:SI 1 "pic30_register_operand" "r")
                     (match_operand:HI 2 "pic30_I_operand"  "I")))]
  ""
  "
    lsr %d1,%d0\;rrc %1,%0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "lshrsi3_imm16plus"
  [(set (match_operand:SI 0            "pic30_register_operand"         "=r")
        (lshiftrt:SI (match_operand:SI 1 "pic30_register_operand"        "r")
                     (match_operand:HI 2 "pic30_imm16plus_operand" "i")))]
  ""
  "*
{
  if (find_regno_note(insn, REG_UNUSED,  REGNO(operands[1])+1))
    return \"lsr %d1,#%K2,%0\";
  else
    return \"lsr %d1,#%K2,%0\;mov #0,%d0\";
}"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "lshrsi3_imm2to15"
  [(set (match_operand:SI 0            "pic30_register_operand"        "=r")
        (lshiftrt:SI (match_operand:SI 1 "pic30_register_operand"       "r")
                     (match_operand:HI 2 "pic30_imm2to15_operand" "i")))
		     (clobber (match_scratch:HI 3               "=&r"))]
  ""
  "*
   {
      /*
       ** Take care that the source and dest don't overlap
       */
      if (REGNO(operands[0]) <= REGNO(operands[1])) {
        return \"sl %d1,#%k2,%3\;\"
               \"lsr %1,#%2,%0\;\"
               \"ior %3,%0,%0\;\"
               \"lsr %d1,#%2,%d0\";
      } else {
        return \"lsr %d1,#%2,%d0\;\"
               \"sl %d1,#%k2,%3\;\"
               \"lsr %1,#%2,%0\;\"
               \"ior %3,%0,%0\";
      }
   }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "lshrsi3_reg"
  [(set (match_operand:SI 0 "pic30_register_operand"             "=r")
        (lshiftrt:SI (match_operand:SI 1 "pic30_register_operand" "0")
                     (match_operand:HI 2 "pic30_register_operand" "r")))
		     (clobber (match_scratch:HI 3          "=2"))]
  ""
  "*
   {
      return 
#if (1)
      	      \".set ___BP___,0\n\"
#endif
              \".LB%=:\;\"
              \"dec %2,%2\;\"
              \"bra n,.LE%=\;\"
              \"lsr %d1,%d0\;\"
              \"rrc %1,%0\;\"
              \"bra .LB%=\n\"
              \".LE%=:\";
   }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "etc")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DImode arithmetic shift left.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_expand "lshrdi3"
  [(set (match_operand:DI 0 "pic30_register_operand"              "")
        (lshiftrt:DI (match_operand:DI 1 "pic30_register_operand"  "")
                     (match_operand:HI 2 "pic30_reg_or_imm_operand" "")))]
  ""
  "
{
	if (GET_CODE(operands[2]) == CONST_INT)
	{
		switch (INTVAL(operands[2]))
		{
		case 0:
			emit_insn(gen_movdi(operands[0], operands[1]));
			break;
		case 1:
			emit_insn(gen_lshrdi3_imm1(operands[0],
						    operands[1], operands[2]));
			break;
#if 1
                case 2 ... 63:
			emit_insn(gen_lshrdi3_immn(operands[0],
						   operands[1], operands[2]));
			break;
#else
		case 2 ... 15:
			emit_insn(gen_lshrdi3_immn(operands[0],
						   operands[1], operands[2]));
			break;
		case 16:
			emit_insn(gen_lshrdi3_imm16(operands[0],
						    operands[1], operands[2]));
			break;
		case 17 ... 31:
			emit_insn(gen_lshrdi3_immn(operands[0],
						   operands[1], operands[2]));
			break;
		case 32:
			emit_insn(gen_lshrdi3_imm32(operands[0],
						    operands[1], operands[2]));
			break;
		case 33 ... 47:
			emit_insn(gen_lshrdi3_immn(operands[0],
						   operands[1], operands[2]));
			break;
		case 48:
			emit_insn(gen_lshrdi3_imm48(operands[0],
						    operands[1], operands[2]));
			break;
		case 49 ... 63:
			emit_insn(gen_lshrdi3_immn(operands[0],
						   operands[1], operands[2]));
			break;
#endif
		default:
			emit_insn(gen_movdi(operands[0], const0_rtx));
			break;
		}
	}
	else
	{
		emit_insn(gen_lshrdi3_reg(operands[0],operands[1],operands[2]));
	}
	DONE;
}")

(define_insn "lshrdi3_imm1"
  [(set (match_operand:DI 0            "pic30_register_operand"   "=r")
        (lshiftrt:DI (match_operand:DI 1 "pic30_register_operand"  "r")
                     (match_operand:HI 2 "immediate_operand" "i")))]
  "INTVAL(operands[2])==1"
  "lsr %q1,%q0\;rrc %t1,%t0\;rrc %d1,%d0\;rrc %1,%0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "lshrdi3_imm16"
  [(set (match_operand:DI 0            "pic30_register_operand"   "=r")
        (lshiftrt:DI (match_operand:DI 1 "pic30_register_operand"  "r")
                     (match_operand:HI 2 "immediate_operand" "i")))]
  "INTVAL(operands[2])==16"
  "mov %d1,%0\;mov %t1,%d0\;mul.uu %q1,#1,%t0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "lshrdi3_imm32"
  [(set (match_operand:DI 0            "pic30_register_operand"   "=r")
        (lshiftrt:DI (match_operand:DI 1 "pic30_register_operand"  "r")
                     (match_operand:HI 2 "immediate_operand" "i")))]
  "INTVAL(operands[2])==32"
  "mov.d %t1,%0\;mul.uu %t0,#0,%t0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "lshrdi3_imm48"
  [(set (match_operand:DI 0            "pic30_register_operand"   "=r")
        (lshiftrt:DI (match_operand:DI 1 "pic30_register_operand"  "r")
                     (match_operand:HI 2 "immediate_operand" "i")))]
  "INTVAL(operands[2])==48"
  "mul.uu %q1,#1,%0\;mul.uu %t0,#0,%t0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "lshrdi3_immn"
  [(set (match_operand:DI 0 "pic30_register_operand"              "=r")
        (lshiftrt:DI (match_operand:DI 1 "pic30_register_operand"  "0")
                     (match_operand:HI 2 "immediate_operand" "i")))
		     (clobber (match_scratch:HI 3           "=&r"))]
  ""
  "*
{ static char buffer[256];
  char *f;
  int results = 0;
  rtx result_reg;
      
  /* how many results do we need?
     if all but the low reg is dead we can shift fewer values */
  result_reg = gen_rtx_REG(HImode, REGNO(operands[0]));
  if (!pic30_dead_or_set_p(insn, result_reg) &&
      !find_regno_note(insn, REG_UNUSED, REGNO(result_reg))) 
    results = 1;
  result_reg = gen_rtx_REG(HImode, REGNO(operands[0])+1);
  if (!pic30_dead_or_set_p(insn, result_reg) &&
      !find_regno_note(insn, REG_UNUSED, REGNO(result_reg)))
    results = 1+1;
  result_reg = gen_rtx_REG(HImode, REGNO(operands[0])+2);
  if (!pic30_dead_or_set_p(insn, result_reg) &&
      !find_regno_note(insn, REG_UNUSED, REGNO(result_reg)))
    results = 1+2;
  result_reg = gen_rtx_REG(HImode, REGNO(operands[0])+3);
  if (!pic30_dead_or_set_p(insn, result_reg) &&
      !find_regno_note(insn, REG_UNUSED, REGNO(result_reg)))
    results = 1+3;

  f = buffer;
  f += sprintf(buffer,\".set ___BP___,0 ; (%ld,%d)\;\", 
               INTVAL(operands[2]), results);
  if (INTVAL(operands[2]) < 16) {
    switch (results) {
      case 4:
        if (!optimize_size) {
          f += sprintf(f,
             \"lsr %%1,#%%2,%%0\;\"
             \"sl %%d1,#%ld,%%3\;\"
             \"ior %%3,%%0,%%0\;\"
             \"lsr %%d1,#%%2,%%d0\;\"
             \"sl %%t1,#%ld,%%3\;\"
             \"ior %%3,%%d0,%%d0\;\"
             \"lsr %%t1,#%%2,%%t0\;\"
             \"sl %%q1,#%ld,%%3\;\"
             \"ior %%3,%%t0,%%t0\;\"
             \"lsr %%q1,#%%2,%%q0\",
             16 - INTVAL(operands[2]), 
             16 - INTVAL(operands[2]), 
             16 - INTVAL(operands[2]));
        } else {;;;;
          f += sprintf(f,
            \"mov #%%2,%%3\;\"
            \".LB%%=:\;\"
            \"lsr %%q1,%%q0\;\"
            \"rrc %%t1,%%t0\;\"
            \"rrc %%d1,%%d0\;\"
            \"rrc %%1,%%0\;\"
            \"dec %%3,%%3\;\"
            \"bra nz,.LB%%=\");
        }
        if ((unsigned)f - (unsigned)buffer > 256) 
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 3:
        f += sprintf(f,
           \"lsr %%1,#%%2,%%0\;\"
           \"sl %%d1,#%ld,%%3\;\"
           \"ior %%3,%%0,%%0\;\"
           \"lsr %%d1,#%%2,%%d0\;\"
           \"sl %%t1,#%ld,%%3\;\"
           \"ior %%3,%%d0,%%d0\;\"
           \"lsr %%t1,#%%2,%%t0\;\"
           \"sl %%q1,#%ld,%%3\;\"
           \"ior %%3,%%t0,%%t0\",
           16 - INTVAL(operands[2]), 
           16 - INTVAL(operands[2]),
           16 - INTVAL(operands[2]));
        if ((unsigned)f - (unsigned)buffer > 256) 
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 2:
        f += sprintf(f,
           \"lsr %%1,#%%2,%%0\;\"
           \"sl %%d1,#%ld,%%3\;\"
           \"ior %%3,%%0,%%0\;\"
           \"lsr %%d1,#%%2,%%d0\;\"
           \"sl %%t1,#%ld,%%3\;\"
           \"ior %%3,%%d0,%%d0\",
           16 - INTVAL(operands[2]), 
           16 - INTVAL(operands[2]));
        if ((unsigned)f - (unsigned)buffer > 256) 
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 1:
        f += sprintf(f,
          \"lsr %%1,#%%2,%%0\;\"
          \"sl %%d1,#%ld,%%3\;\"
          \"ior %%3,%%0,%%0\",
           16 - INTVAL(operands[2]));
        if ((unsigned)f - (unsigned)buffer > 256) 
          error(\"Unexpected error during assembly generation\");
        return buffer;
    }
  } else if (INTVAL(operands[2]) == 16) {
    switch (results) {
      case 4: 
      case 3:
        f += sprintf(f,
          \"mov %%d1,%%0\;\"
          \"mov %%t1,%%d0\;\"
          \"mul.uu %%q1,#1,%%t0\");
        break;
      case 2:
        f += sprintf(f,
          \"mov %%d1,%%0\;\"
          \"mov %%t1,%%d0\");
        break;
      case 1:
        f += sprintf(f,
          \"mov %%d1,%%0\");
        break;
     }
     if ((unsigned)f - (unsigned)buffer > 256) 
        error(\"Unexpected error during assembly generation\");
     return buffer;
  } else if (INTVAL(operands[2]) < 32) {
    switch (results) {
      case 4:
        f += sprintf(f,
           \"lsr %%d1,#%ld,%%0\;\"
           \"sl %%t1,#%ld,%%3\;\"
           \"ior %%3,%%0,%%0\;\"
           \"lsr %%t1,#%ld,%%d0\;\"
           \"sl %%q1,#%ld,%%3\;\"
           \"ior %%3,%%d0,%%d0\;\"
           \"lsr %%q1,#%ld,%%t0\;\"
           \"clr %%q0\",
           INTVAL(operands[2]) - 16,
           32 - INTVAL(operands[2]),
           INTVAL(operands[2]) - 16,
           32 - INTVAL(operands[2]),
           INTVAL(operands[2]) - 16);
        if ((unsigned)f - (unsigned)buffer > 256) 
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 3:
        f += sprintf(f,
           \"lsr %%d1,#%ld,%%0\;\"
           \"sl %%t1,#%ld,%%3\;\"
           \"ior %%3,%%0,%%0\;\"
           \"lsr %%t1,#%ld,%%d0\;\"
           \"sl %%q1,#%ld,%%3\;\"
           \"ior %%3,%%d0,%%d0\;\"
           \"lsr %%q1,#%ld,%%t0\",
           INTVAL(operands[2]) - 16,
           32 - INTVAL(operands[2]),
           INTVAL(operands[2]) - 16,
           32 - INTVAL(operands[2]),
           INTVAL(operands[2]) - 16);
        if ((unsigned)f - (unsigned)buffer > 256) 
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 2:
        f += sprintf(f,
           \"lsr %%d1,#%ld,%%0\;\"
           \"sl %%t1,#%ld,%%3\;\"
           \"ior %%3,%%0,%%0\;\"
           \"lsr %%t1,#%ld,%%d0\;\"
           \"sl %%q1,#%ld,%%3\;\"
           \"ior %%3,%%d0,%%d0\;\",
           INTVAL(operands[2]) - 16,
           32 - INTVAL(operands[2]),
           INTVAL(operands[2]) - 16,
           32 - INTVAL(operands[2]));
        if ((unsigned)f - (unsigned)buffer > 256) 
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 1:
        f += sprintf(f,
           \"lsr %%d1,#%ld,%%0\;\"
           \"sl %%t1,#%ld,%%3\;\"
           \"ior %%3,%%0,%%0\",
           INTVAL(operands[2]) - 16,
           32 - INTVAL(operands[2]));
        if ((unsigned)f - (unsigned)buffer > 256) 
          error(\"Unexpected error during assembly generation\");
        return buffer;
    }
  } else if (INTVAL(operands[2]) == 32) {
    switch (results) {
      case 4:
        f += sprintf(f,
          \"mov.d %%t1,%%0\;\"
          \"mul.uu %%t0,#0,%%t0\");
        break;
      case 3:
        f += sprintf(f,
          \"mov %%t1,%%0\;\"
          \"mul.uu %%t0,#0,%%t0\");
        break;
      case 2:
        f += sprintf(f,
          \"mov.d %%t1,%%0\");
        break;
      case 1:
        f += sprintf(f,
          \"mov.w %%t1,%%0\");
        break;
    }
    if ((unsigned)f - (unsigned)buffer > 256)
      error(\"Unexpected error during assembly generation\");
    return buffer;
  } else if (INTVAL(operands[2]) < 48) {
    switch (results) {
      case 4:
        f += sprintf(f,
           \"lsr %%t1,#%ld,%%0\;\"
           \"sl %%q1,#%ld,%%3\;\"
           \"ior %%3,%%0,%%0\;\"
           \"lsr %%q1,#%ld,%%d0\;\"
           \"mul.uu %%t0,#0,%%t0\",
           INTVAL(operands[2]) - 32,
           48 - INTVAL(operands[2]),
           INTVAL(operands[2]) - 32);
        if ((unsigned)f - (unsigned)buffer > 256) 
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 3:
        f += sprintf(f,
           \"lsr %%t1,#%ld,%%0\;\"
           \"sl %%q1,#%ld,%%3\;\"
           \"ior %%3,%%0,%%0\;\"
           \"lsr %%q1,#%ld,%%d0\;\"
           \"clr %%t0\",
           INTVAL(operands[2]) - 32,
           48 - INTVAL(operands[2]),
           INTVAL(operands[2]) - 32);
        if ((unsigned)f - (unsigned)buffer > 256) 
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 2:
        f += sprintf(f,
           \"lsr %%t1,#%ld,%%0\;\"
           \"sl %%q1,#%ld,%%3\;\"
           \"ior %%3,%%0,%%0\;\"
           \"lsr %%q1,#%ld,%%d0\",
           INTVAL(operands[2]) - 32,
           48 - INTVAL(operands[2]),
           INTVAL(operands[2]) - 32);
        if ((unsigned)f - (unsigned)buffer > 256) 
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 1:
        f += sprintf(f,
           \"lsr %%t1,#%ld,%%0\;\"
           \"sl %%q1,#%ld,%%3\;\"
           \"ior %%3,%%0,%%0\",
           INTVAL(operands[2]) - 32,
           48 - INTVAL(operands[2]));
        if ((unsigned)f - (unsigned)buffer > 256) 
          error(\"Unexpected error during assembly generation\");
        return buffer;
    }
  } else if (INTVAL(operands[2]) == 48) {
    switch (results) {
      case 4:
      case 3:
        f += sprintf(f,
          \"mul.uu %%q1,#1,%%0\;\"
          \"mul.uu %%t0,#0,%%t0\");
        break;
      case 2:
        f += sprintf(f,
          \"mul.uu %%q1,#1,%%0\");
        break;
      case 1:
        f += sprintf(f,
          \"mov %%q1,%%0\");
        break;
    }
    if ((unsigned)f - (unsigned)buffer > 256) 
      error(\"Unexpected error during assembly generation\");
    return buffer;
  } else if (INTVAL(operands[2]) < 64) {
    f += sprintf(f, \"lsr %%q1,#%ld,%%0\", INTVAL(operands[2])-48);
    switch (results) {
      case 4: 
        f += sprintf(f,
          \"\;mul.uu %%t0,#0,%%t0\;\"
          \"clr %%d0\");
        break;
      case 3:
        f += sprintf(f,
          \"\;clr %%t0\;\"
          \"clr %%d0\"); 
        break;
      case 2:
        f += sprintf(f,
          \"\;clr %%d0\"); 
        break;
    }
    if ((unsigned)f - (unsigned)buffer > 256) 
      error(\"Unexpected error during assembly generation\");
    return buffer;
  }
  gcc_assert(0);
  return \"nop\";
}"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "lshrdi3_reg"
  [(set (match_operand:DI 0 "pic30_register_operand"             "=r")
        (lshiftrt:DI (match_operand:DI 1 "pic30_register_operand" "0")
                     (match_operand:HI 2 "pic30_register_operand" "r")))
		     (clobber (match_scratch:HI 3          "=2"))]
  ""
  "*
   {
      return 
#if (1)
      	      \".set ___BP___,0\n\"
#endif
              \".LB%=:\;\"
              \"dec %2,%2\;\"
              \"bra n,.LE%=\;\"
              \"lsr %q1,%q0\;\"
              \"rrc %t1,%t0\;\"
              \"rrc %d1,%d0\;\"
              \"rrc %1,%0\;\"
              \"bra .LB%=\n\"
              \".LE%=:\";
   }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "etc")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Arithmetic shift right.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; QImode arithmetic shift right.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_insn "*ashrqi3_one_DATA"
  [(set (match_operand:QI 0 "pic30_mode2_operand"             "=r<>,r<>,R,R")
        (ashiftrt:QI (match_operand:QI 1 "pic30_mode2_operand" "r,  R<>,r,R<>")
                   (match_operand:QI 2 "pic30_I_operand"       "I,  I,  I,I")))]
  ""
  "asr.b %1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,defuse,use,use")
  ]
)

(define_insn "*ashrqi3_one_APSV"
  [(set (match_operand:QI 0 "pic30_mode2_operand"             "=r<>,r<>,R,R")
        (ashiftrt:QI 
           (match_operand:QI 1 "pic30_mode2_APSV_operand" "r,  R<>,r,R<>")
           (match_operand:QI 2 "pic30_I_operand"       "I,  I,  I,I")))]
  ""
  "asr.b %1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,defuse,use,use")
  ]
)

(define_insn "*ashrqi3_sfr"
  [(set (match_operand:QI 0 "pic30_wreg_or_near_operand"     "=a,U")
        (ashiftrt:QI (match_operand:QI 1 "pic30_near_operand" "U,0")
                   (match_operand:QI 2 "pic30_I_operand"      "I,I")))]
  ""
  "@
    asr.b %1,WREG
    asr.b %0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,etc")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; HImode arithmetic shift right.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_insn "*ashrhi3_one_DATA"
  [(set (match_operand:HI 0 "pic30_mode2_operand"             "=r<>,r<>,R,R")
        (ashiftrt:HI (match_operand:HI 1 "pic30_mode2_operand" "r,  R<>,r,R<>")
                     (match_operand:HI 2 "pic30_I_operand"     "I,  I,  I,I")))]
  ""
  "asr %1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,defuse,use,use")
  ]
)

(define_insn "*ashrhi3_one_APSV"
  [(set (match_operand:HI 0 "pic30_mode2_operand"             "=r<>,r<>,R,R")
        (ashiftrt:HI 
           (match_operand:HI 1 "pic30_mode2_APSV_operand" "r,  R<>,r,R<>")
           (match_operand:HI 2 "pic30_I_operand"     "I,  I,  I,I")))]
  ""
  "asr %1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,defuse,use,use")
  ]
)

(define_insn "*ashrhi3_sfr"
  [(set (match_operand:HI 0 "pic30_wreg_or_near_operand"     "=a,U")
        (ashiftrt:HI (match_operand:HI 1 "pic30_near_operand" "U,0")
                     (match_operand:HI 2 "pic30_I_operand"    "I,I")))]
  ""
  "@
    asr %1,WREG
    asr %0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,etc")
  ]
)

(define_insn "ashrhi3"
  [(set (match_operand:HI 0 "pic30_register_operand"                "=r,r,r")
        (ashiftrt:HI (match_operand:HI 1 "pic30_register_operand"   "r,r,r")
                     (match_operand:HI 2 "pic30_reg_or_imm_operand" "K,i,r")))]
  ""
  "*
   {
     switch (which_alternative) {
       case 0: return \"asr %1,#%2,%0\";
       case 1: if (INTVAL(operands[2]) < 0)
                 return \"sl %1,#%J2%%16,%0\";
               else return \"asr %1,#%2%%16,%0\";
       case 2: return \"asr %1,%2,%0\";
       default: gcc_assert(0);
     }
   }"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
  ]
)

(define_insn "ashrp16apsv3"
  [(set (match_operand:P16APSV   0 "pic30_register_operand"   "=r,r,r")
        (ashiftrt:P16APSV 
          (match_operand:P16APSV 1 "pic30_register_operand"   "r,r,r")
          (match_operand:P16APSV 2 "pic30_reg_or_imm_operand" "K,i,r")))]
  ""
  "*
   {
     switch (which_alternative) {
       case 0: return \"asr %1,#%2,%0\";
       case 1: if (INTVAL(operands[2]) < 0)
                 return \"sl %1,#%J2%%16,%0\";
               else return \"asr %1,#%2%%16,%0\";
       case 2: return \"asr %1,%2,%0\";
       default: gcc_assert(0);
     }
   }"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; SImode arithmetic shift right.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_expand "ashrsi3"
  [(set (match_operand:SI 0 "pic30_register_operand"              "")
        (ashiftrt:SI (match_operand:SI 1 "pic30_register_operand"  "")
                     (match_operand:HI 2 "pic30_reg_or_imm_operand" "")))]
  ""
  "
  {
    if (GET_CODE(operands[2]) == CONST_INT) {
      switch (INTVAL(operands[2])) {
        case 0: emit_insn(
                  gen_movsi(operands[0], operands[1])
                );
                break;
        case 1: emit_insn(
                  gen_ashrsi3_imm1(operands[0], operands[1], operands[2])
                );
                break;
        case 2 ... 15:
#if 0
               emit_insn(
               );
                 gen_ashrsi3_imm2to15(operands[0], operands[1], operands[2])
#else
               emit_insn(
                 gen_ashrsi3_imm2to15_low(
                   simplify_gen_subreg(HImode, operands[0], SImode, 0), 
                   operands[1], operands[2])
               );
               emit_insn(
                 gen_ashrhi3(
                   simplify_gen_subreg(HImode, operands[0], SImode, 2), 
                   simplify_gen_subreg(HImode, operands[1], SImode, 2),
                   operands[2])
               );
#endif
               break;
        case 16: 
               emit_insn(
                  gen_ashrsi3_imm16plus(operands[0], operands[1], operands[2])
               );
               break;
        case 17 ... 31:
               emit_insn(
                 gen_ashrsi3_imm16plus(operands[0], operands[1], operands[2])
               );
               break;
        default:
                emit_insn(
                  gen_movsi(operands[0], const0_rtx)
                );
                break;
      }
    } else {
      emit_insn(
        gen_ashrsi3_reg(operands[0],operands[1],operands[2])
      );
    }
    DONE;
  }"
)

(define_insn "ashrsi3_imm1"
  [(set (match_operand:SI 0 "pic30_register_operand"             "=r")
        (ashiftrt:SI (match_operand:SI 1 "pic30_register_operand" "r")
                     (match_operand:HI 2 "pic30_I_operand"  "I")))]
  ""
  "asr %d1,%d0\;rrc %1,%0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

;(define_insn "ashrsi3_imm2to15"
;  [(set (match_operand:SI 0            "pic30_register_operand"        "=r")
;        (ashiftrt:SI (match_operand:SI 1 "pic30_register_operand"       "r")
;                     (match_operand:HI 2 "pic30_imm2to15_operand" "i")))
;   (clobber (match_scratch:HI 3                "=&r"))]
;  ""
;  "*
;   {
;     /*
;      ** Take care that the source and dest don't overlap
;      */
;     if (REGNO(operands[0]) <= REGNO(operands[1])) {
;       return \"sl %d1,#%k2,%3\;\"
;              \"lsr %1,#%2,%0\;\"
;              \"ior %3,%0,%0\;\"
;              \"asr %d1,#%2,%d0\";
;     } else {
;       return \"asr %d1,#%2,%d0\;\"
;              \"sl %d1,#%k2,%3\;\"
;              \"lsr %1,#%2,%0\;\"
;              \"ior %3,%0,%0\";
;     }
;   }"
;  [
;   (set_attr "cc" "clobber")
;   (set_attr "type" "def")
;  ]
;)

(define_insn "ashrsi3_imm2to15_low"
  [(set (match_operand:HI 0            "pic30_register_operand"        "=r")
        (unspec:HI [
          (match_operand:SI 1 "pic30_register_operand"                  "r")
          (match_operand:HI 2 "pic30_imm2to15_operand"                  "i")
        ] UNSPEC_ASHIFTSI_LOW))
   (clobber (match_scratch:HI 3                                       "=&r"))]
  ""
  "*
   {
     return \"sl %d1,#%k2,%3\;\"
            \"lsr %1,#%2,%0\;\"
            \"ior %3,%0,%0\";
   }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

;(define_insn "org_ashrsi3_imm16plus"
;  [(set (match_operand:SI 0            "pic30_register_operand"         "=r")
;        (ashiftrt:SI (match_operand:SI 1 "pic30_register_operand"        "r")
;                     (match_operand:HI 2 "pic30_imm16plus_operand" "i")))]
;  ""
;  "asr %d1,#%K2,%0\;asr %0,#15,%d0"
;  [
;   (set_attr "cc" "clobber")
;   (set_attr "type" "def")
;  ]
;)

(define_expand "ashrsi3_imm16plus"
  [(set (match_operand:SI 0            "pic30_register_operand"         "=r")
        (ashiftrt:SI (match_operand:SI 1 "pic30_register_operand"        "r")
                     (match_operand:HI 2 "pic30_imm16plus_operand" "i")))]
  ""
  "{
     emit_insn(
       gen_ashrhi3(simplify_gen_subreg(HImode, operands[0], SImode, 0),
                   simplify_gen_subreg(HImode, operands[1], SImode, 2),
                   GEN_INT(INTVAL(operands[2])-16))
     );
     emit_insn(
       gen_ashrhi3(simplify_gen_subreg(HImode, operands[0], SImode, 2),
                   simplify_gen_subreg(HImode, operands[1], SImode, 2),
                   GEN_INT(15))
     );
     DONE;
   }
  "
)

(define_insn "ashrsi3_reg"
  [(set (match_operand:SI 0 "pic30_register_operand"             "=r")
        (ashiftrt:SI (match_operand:SI 1 "pic30_register_operand" "0")
                     (match_operand:HI 2 "pic30_register_operand" "r")))
		     (clobber (match_scratch:HI 3          "=2"))]
  ""
  "*
   {
     return 
#if (1)
      	      \".set ___BP___,0\n\"
#endif
              \".LB%=:\;\"
              \"dec %2,%2\;\"
              \"bra n,.LE%=\;\"
              \"asr %d1,%d0\;\"
              \"rrc %1,%0\;\"
              \"bra .LB%=\n\"
              \".LE%=:\";
   }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DImode arithmetic shift right.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_expand "ashrdi3"
  [(set (match_operand:DI 0 "pic30_register_operand"              "")
        (ashiftrt:DI (match_operand:DI 1 "pic30_register_operand"  "")
                     (match_operand:HI 2 "pic30_reg_or_imm_operand" "")))]
  ""
  "
  {
    if (GET_CODE(operands[2]) == CONST_INT) {
      switch (INTVAL(operands[2])) {
        case 0:
                emit_insn(
                  gen_movdi(operands[0], operands[1])
                );
                break;
        case 1:
	        emit_insn(
                  gen_ashrdi3_imm1(operands[0], operands[1], operands[2])
                );
                break;
        case 2 ... 63:
                emit_insn(
                  gen_ashrdi3_immn(operands[0], operands[1], operands[2])
                );
                break;
        default:
                emit_insn(
                  gen_movdi(operands[0], const0_rtx)
                );
                break;
      }
    } else {
      emit_insn(
        gen_ashrdi3_reg(operands[0],operands[1],operands[2])
      );
    }
    DONE;
  }"
)

(define_insn "ashrdi3_imm1"
  [(set (match_operand:DI 0            "pic30_register_operand"   "=r")
        (ashiftrt:DI (match_operand:DI 1 "pic30_register_operand"  "r")
                     (match_operand:HI 2 "immediate_operand" "i")))]
  "INTVAL(operands[2])==1"
  "asr %q1,%q0\;rrc %t1,%t0\;rrc %d1,%d0\;rrc %1,%0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ashrdi3_imm16"
  [(set (match_operand:DI 0            "pic30_register_operand"   "=r")
        (ashiftrt:DI (match_operand:DI 1 "pic30_register_operand"  "r")
                     (match_operand:HI 2 "immediate_operand" "i")))]
  "INTVAL(operands[2])==16"
  "mov %d1,%0\;mov %t1,%d0\;mul.su %q1,#1,%t0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ashrdi3_imm32"
  [(set (match_operand:DI 0            "pic30_register_operand"   "=r")
        (ashiftrt:DI (match_operand:DI 1 "pic30_register_operand"  "r")
                     (match_operand:HI 2 "immediate_operand" "i")))]
  "INTVAL(operands[2])==32"
  "mov.d %t1,%0\;asr %d0,#15,%t0\;mov %t0,%q0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ashrdi3_imm48"
  [(set (match_operand:DI 0            "pic30_register_operand"   "=r")
        (ashiftrt:DI (match_operand:DI 1 "pic30_register_operand"  "r")
                     (match_operand:HI 2 "immediate_operand" "i")))]
  "INTVAL(operands[2])==48"
  "mul.su %q1,#1,%0\;mul.su %d0,#1,%t0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ashrdi3_immn"
  [(set (match_operand:DI 0 "pic30_register_operand"              "=r")
        (ashiftrt:DI (match_operand:DI 1 "pic30_register_operand"  "0")
                     (match_operand:HI 2 "immediate_operand" "i")))
		     (clobber (match_scratch:HI 3           "=&r"))]
  ""
  "*
{ static char buffer[256];
  char *f;
  int results = 0;
  rtx result_reg;
      
  /* how many results do we need?
     if all but the low reg is dead we can shift fewer values */
  result_reg = gen_rtx_REG(HImode, REGNO(operands[0]));
  if (!pic30_dead_or_set_p(insn, result_reg) &&
      !find_regno_note(insn, REG_UNUSED, REGNO(result_reg))) 
    results = 1;
  result_reg = gen_rtx_REG(HImode, REGNO(operands[0])+1);
  if (!pic30_dead_or_set_p(insn, result_reg) &&
      !find_regno_note(insn, REG_UNUSED, REGNO(result_reg)))
    results = 1+1;
  result_reg = gen_rtx_REG(HImode, REGNO(operands[0])+2);
  if (!pic30_dead_or_set_p(insn, result_reg) &&
      !find_regno_note(insn, REG_UNUSED, REGNO(result_reg)))
    results = 1+2;
  result_reg = gen_rtx_REG(HImode, REGNO(operands[0])+3);
  if (!pic30_dead_or_set_p(insn, result_reg) &&
      !find_regno_note(insn, REG_UNUSED, REGNO(result_reg)))
    results = 1+3;

  f = buffer;
  f += sprintf(buffer,\".set ___BP___,0 ; (%ld,%d)\;\", 
               INTVAL(operands[2]), results);
  if (INTVAL(operands[2]) < 16) {
    switch (results) {
      case 4:
        if (!optimize_size) {
          f += sprintf(f,
             \"lsr %%1,#%%2,%%0\;\"
             \"sl %%d1,#%ld,%%3\;\"
             \"ior %%3,%%0,%%0\;\"
             \"lsr %%d1,#%%2,%%d0\;\"
             \"sl %%t1,#%ld,%%3\;\"
             \"ior %%3,%%d0,%%d0\;\"
             \"lsr %%t1,#%%2,%%t0\;\"
             \"sl %%q1,#%ld,%%3\;\"
             \"ior %%3,%%t0,%%t0\;\"
             \"asr %%q1,#%%2,%%q0\",
             16 - INTVAL(operands[2]), 
             16 - INTVAL(operands[2]), 
             16 - INTVAL(operands[2]));
        } else {
          f += sprintf(f,
            \"mov #%%2,%%3\;\"
            \".LB%%=:\;\"
            \"asr %%q1,%%q0\;\"
            \"rrc %%t1,%%t0\;\"
            \"rrc %%d1,%%d0\;\"
            \"rrc %%1,%%0\;\"
            \"dec %%3,%%3\;\"
            \"bra nz,.LB%%=\");
        }
        if ((unsigned)f - (unsigned)buffer > 256) 
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 3:
        f += sprintf(f,
           \"lsr %%1,#%%2,%%0\;\"
           \"sl %%d1,#%ld,%%3\;\"
           \"ior %%3,%%0,%%0\;\"
           \"lsr %%d1,#%%2,%%d0\;\"
           \"sl %%t1,#%ld,%%3\;\"
           \"ior %%3,%%d0,%%d0\;\"
           \"lsr %%t1,#%%2,%%t0\;\"
           \"sl %%q1,#%ld,%%3\;\"
           \"ior %%3,%%t0,%%t0\",
           16 - INTVAL(operands[2]), 
           16 - INTVAL(operands[2]), 
           16 - INTVAL(operands[2]));
        if ((unsigned)f - (unsigned)buffer > 256) 
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 2:
        f += sprintf(f,
           \"lsr %%1,#%%2,%%0\;\"
           \"sl %%d1,#%ld,%%3\;\"
           \"ior %%3,%%0,%%0\;\"
           \"lsr %%d1,#%%2,%%d0\;\"
           \"sl %%t1,#%ld,%%3\;\"
           \"ior %%3,%%d0,%%d0\",
           16 - INTVAL(operands[2]), 
           16 - INTVAL(operands[2]));
        if ((unsigned)f - (unsigned)buffer > 256) 
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 1:
        f += sprintf(f,
          \"lsr %%1,#%%2,%%0\;\"
          \"sl %%d1,#%ld,%%3\;\"
          \"ior %%3,%%0, %%0\;\",
           16 - INTVAL(operands[2]));
        if ((unsigned)f - (unsigned)buffer > 256) 
          error(\"Unexpected error during assembly generation\");
        return buffer;
    }
  } else if (INTVAL(operands[2]) == 16) {
    switch (results) {
      case 4:
      case 3:
        f += sprintf(f,
          \"mov %%d1,%%0\;\"
          \"mov %%t1,%%d0\;\"
          \"mul.su %%q1,#1,%%t0\");
        break;
      case 2:
        f += sprintf(f,
          \"mov %%d1,%%0\;\"
          \"mov %%t1,%%d0\");
        break;
      case 1:
        f += sprintf(f,
          \"mov %%d1,%%0\");
        break;
     }
     if ((unsigned)f - (unsigned)buffer > 256)
        error(\"Unexpected error during assembly generation\");
     return buffer;
  } else if (INTVAL(operands[2]) < 32) {
    switch (results) {
      case 4:
        f += sprintf(f,
           \"lsr %%d1,#%ld,%%0\;\"
           \"sl %%t1,#%ld,%%3\;\"
           \"ior %%3,%%0,%%0\;\"
           \"lsr %%t1,#%ld,%%d0\;\"
           \"sl %%q1,#%ld,%%3\;\"
           \"ior %%3,%%d0,%%d0\;\"
           \"asr %%q1,#%ld,%%t0\;\"
           \"asr %%q1,#15,%%q0\",
           INTVAL(operands[2]) - 16,
           32 - INTVAL(operands[2]),
           INTVAL(operands[2]) - 16,
           32 - INTVAL(operands[2]),
           INTVAL(operands[2]) - 16);
        if ((unsigned)f - (unsigned)buffer > 256) 
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 3:
        f += sprintf(f,
           \"lsr %%d1,#%ld,%%0\;\"
           \"sl %%t1,#%ld,%%3\;\"
           \"ior %%3,%%0,%%0\;\"
           \"lsr %%t1,#%ld,%%d0\;\"
           \"sl %%q1,#%ld,%%3\;\"
           \"ior %%3,%%d0,%%d0\;\"
           \"asr %%q1,#%ld,%%t0\",
           INTVAL(operands[2]) - 16,
           32 - INTVAL(operands[2]),
           INTVAL(operands[2]) - 16,
           32 - INTVAL(operands[2]),
           INTVAL(operands[2]) - 16);
        if ((unsigned)f - (unsigned)buffer > 256) 
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 2:
        f += sprintf(f,
           \"lsr %%d1,#%ld,%%0\;\"
           \"sl %%t1,#%ld,%%3\;\"
           \"ior %%3,%%0,%%0\;\"
           \"lsr %%t1,#%ld,%%d0\;\"
           \"sl %%q1,#%ld,%%3\;\"
           \"ior %%3,%%d0,%%d0\;\",
           INTVAL(operands[2]) - 16,
           32 - INTVAL(operands[2]),
           INTVAL(operands[2]) - 16,
           32 - INTVAL(operands[2]));
        if ((unsigned)f - (unsigned)buffer > 256) 
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 1:
        f += sprintf(f,
           \"lsr %%d1,#%ld,%%0\;\"
           \"sl %%t1,#%ld,%%3\;\"
           \"ior %%3,%%0,%%0\",
           INTVAL(operands[2]) - 16,
           32 - INTVAL(operands[2]));
        if ((unsigned)f - (unsigned)buffer > 256) 
          error(\"Unexpected error during assembly generation\");
        return buffer;
    }
  } else if (INTVAL(operands[2]) == 32) {
    switch (results) {
      case 4:
        f += sprintf(f,
          \"mov.d %%t1,%%0\;\"
          \"asr %%t1,#15,%%t0\;\"
          \"asr %%t1,#15,%%q0\");
        break;
      case 3:
        f += sprintf(f,
          \"mov %%t1,%%0\;\"
          \"asr %%t1,#15,%%t0\");
        break;
      case 2:
        f += sprintf(f,
          \"mov.d %%t1,%%0\");
        break;
      case 1:
        f += sprintf(f,
          \"mov.w %%t1,%%0\");
        break;
    }
    if ((unsigned)f - (unsigned)buffer > 256)
      error(\"Unexpected error during assembly generation\");
    return buffer;
  } else if (INTVAL(operands[2]) < 48) {
    switch (results) {
      case 4:
        f += sprintf(f,
           \"lsr %%t1,#%ld,%%0\;\"
           \"sl %%q1,#%ld,%%3\;\"
           \"ior %%3,%%0,%%0\;\"
           \"asr %%q1,#%ld,%%d0\;\"
           \"asr %%q1,#15,%%t0\;\"
           \"asr %%q1,#15,%%q0\",
           INTVAL(operands[2]) - 32,
           48 - INTVAL(operands[2]),
           INTVAL(operands[2]) - 32);
        if ((unsigned)f - (unsigned)buffer > 256) 
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 3:
        f += sprintf(f,
           \"lsr %%t1,#%ld,%%0\;\"
           \"sl %%q1,#%ld,%%3\;\"
           \"ior %%3,%%0,%%0\;\"
           \"asr %%q1,#%ld,%%d0\;\"
           \"asr %%q1,#15,%%t0\",
           INTVAL(operands[2]) - 32,
           48 - INTVAL(operands[2]),
           INTVAL(operands[2]) - 32);
        if ((unsigned)f - (unsigned)buffer > 256) 
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 2:
        f += sprintf(f,
           \"lsr %%t1,#%ld,%%0\;\"
           \"sl %%q1,#%ld,%%3\;\"
           \"ior %%3,%%0,%%0\;\"
           \"asr %%q1,#%ld,%%d0\",
           INTVAL(operands[2]) - 32,
           48 - INTVAL(operands[2]),
           INTVAL(operands[2]) - 32);
        if ((unsigned)f - (unsigned)buffer > 256) 
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 1:
        f += sprintf(f,
           \"lsr %%t1,#%ld,%%0\;\"
           \"sl %%q1,#%ld,%%3\;\"
           \"ior %%3,%%0,%%0\",
           INTVAL(operands[2]) - 32,
           48 - INTVAL(operands[2]));
        if ((unsigned)f - (unsigned)buffer > 256) 
          error(\"Unexpected error during assembly generation\");
        return buffer;
    }
  } else if (INTVAL(operands[2]) == 48) {
    switch (results) {
      case 4:
        f += sprintf(f,
          \"mul.su %%q1,#1,%%0\;\"
          \"asr %%q1,#15,%%t0\;\"
          \"asr %%q1,#15,%%q0\");
        break;
      case 3:
        f += sprintf(f,
          \"mul.su %%q1,#1,%%0\;\"
          \"asr %%q1,#15,%%t0\");
        break;
      case 2:
        f += sprintf(f,
          \"mul.su %%q1,#1,%%0\");
        break;
      case 1:
        f += sprintf(f,
          \"mov %%q1,%%0\");
        break;
    }
    if ((unsigned)f - (unsigned)buffer > 256)
      error(\"Unexpected error during assembly generation\");
    return buffer;
  } else if (INTVAL(operands[2]) < 64) {
    f += sprintf(f, \"asr %%q1,#%ld,%%0\", INTVAL(operands[2])-48);
    switch (results) {
      case 4: 
        f += sprintf(f,
          \"\;asr %%q1,#15,%%d0\;\"
          \"asr %%q1,#15,%%t0\;\"
          \"asr %%q1,#15,%%q0\;\");
        break;
      case 3:
        f += sprintf(f,
          \"\;asr %%q1,#15,%%d0\;\"
          \"asr %%q1,#15,%%t0\;\");
        break;
      case 2:
        f += sprintf(f,
          \"\;asr %%q1,#15,%%d0\;\");
        break;
    }
    if ((unsigned)f - (unsigned)buffer > 256) 
      error(\"Unexpected error during assembly generation\");
    return buffer;
  }
  gcc_assert(0);
  return \"nop\";
}"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ashrdi3_reg"
  [(set (match_operand:DI 0 "pic30_register_operand"             "=r")
        (ashiftrt:DI (match_operand:DI 1 "pic30_register_operand" "0")
                     (match_operand:HI 2 "pic30_register_operand" "r")))
		     (clobber (match_scratch:HI 3          "=2"))]
  ""
  "*
   {
      return 
#if (1)
      	      \".set ___BP___,0\n\"
#endif
              \".LB%=:\;\"
              \"dec %2,%2\;\"
              \"bra n,.LE%=\;\"
              \"asr %q1,%q0\;\"
              \"rrc %t1,%t0\;\"
              \"rrc %d1,%d0\;\"
              \"rrc %1,%0\;\"
              \"bra .LB%=\n\"
              \".LE%=:\";
   }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; rotate instructions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; rotate left
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;
;; QImode ;;
;;;;;;;;;;;;

(define_insn "*rotlqi3_one_DATA"
  [(set (match_operand:QI 0 "pic30_mode2_operand"           "=r<>,r<>,R,R")
        (rotate:QI 
           (match_operand:QI 1 "pic30_mode2_operand" "r,  R<>,r,R<>")
           (match_operand:QI 2 "pic30_I_operand"     "I,  I,  I,I")))]
  ""
  "rlnc.b %1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,defuse,use,use")
  ]
)

(define_insn "*rotlqi3_one_APSV"
  [(set (match_operand:QI 0 "pic30_mode2_operand"           "=r<>,r<>,R,R")
        (rotate:QI 
           (match_operand:QI 1 "pic30_mode2_APSV_operand" "r,  R<>,r,R<>")
           (match_operand:QI 2 "pic30_I_operand"     "I,  I,  I,I")))]
  ""
  "rlnc.b %1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,defuse,use,use")
  ]
)

(define_insn "*rotlqi3_sfr"
  [(set (match_operand:QI 0 "pic30_wreg_or_near_operand"   "=a,U")
        (rotate:QI (match_operand:QI 1 "pic30_near_operand" "U,0")
                   (match_operand:QI 2 "pic30_I_operand"    "I,I")))]
  ""
  "@
    rlnc.b %1,WREG
    rlnc.b %1"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,etc")
  ]
)

;;;;;;;;;;;;
;; HImode ;;
;;;;;;;;;;;;

(define_insn "*rotlhi3_one_DATA"
  [(set (match_operand:HI 0 "pic30_mode2_operand"           "=r<>,r<>,R,R")
        (rotate:HI (match_operand:HI 1 "pic30_mode2_operand" "r,  R<>,r,R<>")
                   (match_operand:HI 2 "pic30_I_operand"     "I,  I,  I,I")))]
  ""
  "rlnc %1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,defuse,use,use")
  ]
)

(define_insn "*rotlhi3_one_APSV"
  [(set (match_operand:HI 0 "pic30_mode2_operand"           "=r<>,r<>,R,R")
        (rotate:HI 
           (match_operand:HI 1 "pic30_mode2_APSV_operand" "r,  R<>,r,R<>")
           (match_operand:HI 2 "pic30_I_operand"     "I,  I,  I,I")))]
  ""
  "rlnc %1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,defuse,use,use")
  ]
)

(define_insn "*rotlhi3_sfr"
  [(set (match_operand:HI 0 "pic30_wreg_or_near_operand"   "=a,U")
        (rotate:HI (match_operand:HI 1 "pic30_near_operand" "U,0")
                   (match_operand:HI 2 "pic30_I_operand"    "I,I")))]
  ""
  "@
    rlnc %1,WREG
    rlnc %1"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,etc")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; rotate right
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;
;; QImode ;;
;;;;;;;;;;;;

(define_insn "*rotrqi3_one_DATA"
  [(set (match_operand:QI 0 "pic30_mode2_operand"             "=r<>,r<>,R,R")
        (rotatert:QI (match_operand:QI 1 "pic30_mode2_operand" "r,  R<>,r,R<>")
                   (match_operand:QI 2 "pic30_I_operand"       "I,  I,  I,I")))]
  ""
  "rrnc.b %1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,defuse,use,use")
  ]
)

(define_insn "*rotrqi3_one_APSV"
  [(set (match_operand:QI 0 "pic30_mode2_operand"             "=r<>,r<>,R,R")
        (rotatert:QI 
           (match_operand:QI 1 "pic30_mode2_APSV_operand" "r,  R<>,r,R<>")
           (match_operand:QI 2 "pic30_I_operand"       "I,  I,  I,I")))]
  ""
  "rrnc.b %1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,defuse,use,use")
  ]
)

(define_insn "*rotrqi3_sfr"
  [(set (match_operand:QI 0 "pic30_wreg_or_near_operand"     "=a,U")
        (rotatert:QI (match_operand:QI 1 "pic30_near_operand" "U,0")
                   (match_operand:QI 2 "pic30_I_operand"      "I,I")))]
  ""
  "@
    rrnc.b %1,WREG
    rrnc.b %1"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,etc")
  ]
)

;;;;;;;;;;;;
;; HImode ;;
;;;;;;;;;;;;

(define_insn "*rotrhi3_one_DATA"
  [(set (match_operand:HI 0 "pic30_mode2_operand"             "=r<>,r<>,R,R")
        (rotatert:HI (match_operand:HI 1 "pic30_mode2_operand" "r,  R<>,r,R<>")
                     (match_operand:HI 2 "pic30_I_operand"     "I,  I,  I,I")))]
  ""
  "rrnc %1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,defuse,use,use")
  ]
)

(define_insn "*rotrhi3_one"
  [(set (match_operand:HI 0 "pic30_mode2_operand"             "=r<>,r<>,R,R")
        (rotatert:HI 
           (match_operand:HI 1 "pic30_mode2_APSV_operand" "r,  R<>,r,R<>")
           (match_operand:HI 2 "pic30_I_operand"     "I,  I,  I,I")))]
  ""
  "rrnc %1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,defuse,use,use")
  ]
)

(define_insn "*rotrhi3_sfr"
  [(set (match_operand:HI 0 "pic30_wreg_or_near_operand"     "=a,U")
        (rotatert:HI (match_operand:HI 1 "pic30_near_operand" "U,0")
                   (match_operand:HI 2 "pic30_I_operand"      "I,I")))]
  ""
  "@
    rrnc %1,WREG
    rrnc %1"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,etc")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Special cases of bit-field insns which we should
;; recognize in preference to the general case.
;; These handle aligned 8-bit and 16-bit fields,
;; which can usually be done with move instructions.
;    dsPIC30: t.b.d.
;********************

;; Bit field instructions, general cases.
;; "o,d" constraint causes a nonoffsettable memref to match the "o"
;; so that its address is reloaded.

(define_insn "bfins"
  [(set (zero_extract:HI    
          (match_operand    0 "pic30_mode2_or_near_operand" "+Rr,Rr,U,U")
          (match_operand:HI 1 "immediate_operand"           " i, i, i,i")
          (match_operand:HI 2 "immediate_operand"           " i, i, i,i"))
        (match_operand:HI 3 "pic30_reg_or_lit8"             " r, i, r,???i"))
   (clobber (match_scratch:HI 4                             "=X, X, X, r"))
  ]
  "(pic30_isav4_target())"
  "*
{
  switch (which_alternative) 
  {
    case 0: return \"bfins #%2,#%1,%3,%0\";
    case 1: return \"bfins #%2,#%1,#%3,%0\";
    case 2:  { /* U, i, i, r */
      /* Check to see if it is near+offset */
      if (GET_CODE(XEXP(operands[0],0)) == CONST) {
        if(GET_CODE(XEXP(XEXP(operands[0],0),0)) == PLUS) {
          int offset;
          offset = INTVAL(XEXP(XEXP(XEXP(operands[0],0),0),1));
          if (offset & 1) {
            return \"bfins #%2+8,#%1,%3,%0-1\";
          } else {
            return \"bfins #%2,#%1,%3,%0\";
          }
        } 
      } else {
        return \"bfins #%2,#%1,%3,%0\";
      }
    }
    case 3: /* U,i,i,???i,r */
      return \"mov #%3,%4\;bfins #%2,#%1,%4,%0\";
    default:
      gcc_assert(0);
  }
}"
)

;; (define_insn "extv" ...

;; (define_insn "extzv" ...
(define_insn "bfext"
  [(set (match_operand:HI   0 "pic30_register_operand"      "=r,r")
        (zero_extract:HI  
          (match_operand    1 "pic30_mode2_or_near_operand" "Rr,U")
          (match_operand:HI 2 "immediate_operand"           " i,i")
          (match_operand:HI 3 "immediate_operand"           " i,i")))]
  "(pic30_isav4_target())"
  "*
{
  switch(which_alternative)
  {
    case 0:  return \"bfext #%3,#%2,%1,%0\";
    case 1:  {
      /* Check to see if the near operand has an offset */
      if (GET_CODE(XEXP(operands[1],0)) == CONST) {
        if(GET_CODE(XEXP(XEXP(operands[1],0),0)) == PLUS) {
          int offset;
          offset = INTVAL(XEXP(XEXP(XEXP(operands[1],0),0),1));
          if (offset & 1) {
            return \"bfext #%3+8,#%2,%1-1,%0\";
          } else {
            return \"bfext #%3,#%2,%1,%0\";
          }
        }
      } else {
        return \"bfext #%3,#%2,%1,%0\";
      }
    }
    default:
      gcc_assert(0);
  }
}"
)
(define_expand "extzv"
  [(set (match_operand:HI      0 "pic30_register_operand"      "=r")
        (zero_extract:HI  
          (match_operand    1 "pic30_mode2_or_near_operand" "RrU")
          (match_operand:HI 2 "immediate_operand"           " i")
          (match_operand:HI 3 "immediate_operand"           " i")))]
  ""
  "
  { 
    if (pic30_isav4_target() &&
        pic30_mode2_or_near_operand(operands[1],VOIDmode) &&
        GET_MODE(operands[0]) == HImode) {
      emit(
        gen_bfext(operands[0], operands[1], operands[2], operands[3])
      );
      DONE;
    } else {
      FAIL;
    }
  }"
)

;; (define_insn "insv" ...

(define_expand "insv"
  [(set (zero_extract:HI
          (match_operand    0 "pic30_mode2_or_near_operand" "+RrU")
          (match_operand:HI 1 "immediate_operand"           "i")
          (match_operand:HI 2 "immediate_operand"           "i"))
        (match_operand:HI 3 "immediate_operand"             "i"))]
  ""
  "
{ int n;
  int mode;
  if (pic30_isav4_target() && 
      pic30_mode2_or_near_operand(operands[0],VOIDmode) &&
      (INTVAL(operands[1]) > 1)) {
      emit(
        gen_bfins(operands[0],operands[1],operands[2],operands[3])
      );
      DONE;
  }

  n = 4;
  mode = GET_MODE(operands[0]);
  if (pic30_volatile_operand(operands[0], mode)) n = 1;
  if ((INTVAL(operands[1]) <= n) && (GET_CODE(operands[3]) == CONST_INT) &&
      /* pic30_reg_or_near_operand is already called, but if optimization is
         on, constant addresses are forced into a register so that 'cse can
         get a chance to see them' (in fn memory_address)... thats okay, cse
         will turn them back to constants we hope */
      (pic30_reg_or_near_operand(operands[0],VOIDmode)) &&
      ((mode == HImode) || (mode == QImode)))
  {  int mask;
     rtx mask_rtx;
     int i;
     rtx modifybit = operands[0];

     /* actually operand [3] does not necessarily fit into our bitfield...
        *SIGH* */

     for (i = 0; i < INTVAL(operands[1]); i++) {
       mask =  (1 << (INTVAL(operands[2]) +i));
       if ((INTVAL(operands[3]) & (1 << i)) == 0) {
          if (pic30_mode2_operand(operands[0],VOIDmode)) {
            mask_rtx = gen_rtx_CONST_INT(HImode, ~mask);
            emit(gen_bitclrhi(operands[0], operands[0], mask_rtx));
          } else {
            if (mode == HImode) {
              mask_rtx = gen_rtx_CONST_INT(HImode, ~mask);
              emit(gen_bitclrhi_sfr(operands[0], mask_rtx));
            } else if (mode == QImode) {
              if (mask > 0x80) {
                FAIL;
                break;
              }
              mask_rtx = gen_rtx_CONST_INT(HImode, ~mask);
              emit(gen_bitclrqi_sfr(modifybit, mask_rtx));
            }
          }
       } else {
          if (pic30_mode2_operand(operands[0],VOIDmode)) {
            mask_rtx = gen_rtx_CONST_INT(HImode, mask);
            emit(gen_bitsethi(operands[0], operands[0], mask_rtx));
          } else {
            if (mode == HImode) {
              mask_rtx = gen_rtx_CONST_INT(HImode, mask);
              emit(gen_bitsethi_sfr(operands[0], mask_rtx));
            } else {
              if (mask > 0x80) {
                FAIL;
                break;
              }
              mask_rtx = gen_rtx_CONST_INT(HImode, mask);
              emit(gen_bitsetqi_sfr(modifybit, mask_rtx));
            }
          }
       }
     }
     DONE;
  }
  else FAIL;
}"
)

;; Now recognize bit field insns that operate on registers
;; (or at least were intended to do so).
;[unnamed only]

;; Special patterns for optimizing bit-field instructions.
;**************************************

; cc status test ops n.a. on dsPIC30 ......... e.g. "sleu" on 68k:
;  [(set (match_operand:QI 0 "pic30_general_operand" "=d")
;        (leu (cc0) (const_int 0)))]
;  ""
;  "* cc_status = cc_prev_status;
;     return \"sls %0\"; ")


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Basic conditional jump instructions.
;; Every machine description must have a named pattern for each of the
;; conditional branch names "bcond"
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_insn "beq"
  [(set (pc)
        (if_then_else (eq (cc0)
                          (const_int 0))
                      (label_ref (match_operand 0 "" ""))
                      (pc)))]
  ""
  "* return pic30_conditional_branch(EQ, operands[0]);"
  [(set_attr "cc" "unchanged")])

(define_insn "bne"
  [(set (pc)
        (if_then_else (ne (cc0)
                          (const_int 0))
                      (label_ref (match_operand 0 "" ""))
                      (pc)))]
  ""
  "* return pic30_conditional_branch(NE, operands[0]);"
  [(set_attr "cc" "unchanged")])

(define_insn "bgt"
  [(set (pc)
        (if_then_else (gt (cc0)
                          (const_int 0))
                      (label_ref (match_operand 0 "" ""))
                      (pc)))]
  ""
  "* return pic30_conditional_branch(GT, operands[0]);"
  [(set_attr "cc" "unchanged")])

(define_insn "blt"
  [(set (pc)
        (if_then_else (lt (cc0)
                          (const_int 0))
                      (label_ref (match_operand 0 "" ""))
                      (pc)))]
  ""
  "* return pic30_conditional_branch(LT, operands[0]);"
  [(set_attr "cc" "unchanged")])

(define_insn "bge"
  [(set (pc)
        (if_then_else (ge (cc0)
                          (const_int 0))
                      (label_ref (match_operand 0 "" ""))
                      (pc)))]
  ""
  "* return pic30_conditional_branch(GE, operands[0]);"
  [(set_attr "cc" "unchanged")])

(define_insn "ble"
  [(set (pc)
        (if_then_else (le (cc0)
                          (const_int 0))
                      (label_ref (match_operand 0 "" ""))
                      (pc)))]
  ""
  "* return pic30_conditional_branch(LE, operands[0]);"
  [(set_attr "cc" "unchanged")])


; unsigned branches:

(define_insn "bgtu"
  [(set (pc)
        (if_then_else (gtu (cc0)
                          (const_int 0))
                      (label_ref (match_operand 0 "" ""))
                      (pc)))]
  ""
  "* return pic30_conditional_branch(GTU, operands[0]);"
  [(set_attr "cc" "unchanged")])

(define_insn "bltu"
  [(set (pc)
        (if_then_else (ltu (cc0)
                          (const_int 0))
                      (label_ref (match_operand 0 "" ""))
                      (pc)))]
  ""
  "* return pic30_conditional_branch(LTU, operands[0]);"
  [(set_attr "cc" "unchanged")])

(define_insn "bgeu"
  [(set (pc)
        (if_then_else (geu (cc0)
                          (const_int 0))
                      (label_ref (match_operand 0 "" ""))
                      (pc)))]
  ""
  "* return pic30_conditional_branch(GEU, operands[0]);"
  [(set_attr "cc" "unchanged")])

(define_insn "bleu"
  [(set (pc)
        (if_then_else (leu (cc0)
                          (const_int 0))
                      (label_ref (match_operand 0 "" ""))
                      (pc)))]
  ""
  "* return pic30_conditional_branch(LEU, operands[0]);"
  [(set_attr "cc" "unchanged")])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Every machine description must have an anonymous pattern for each of
;; the possible reverse-conditional branches.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_insn "*bccreverse"
  [(set (pc)
        (if_then_else (match_operator 1 "comparison_operator" 
			[(cc0) (const_int 0)])
                      (pc)
                      (label_ref (match_operand 0 "" ""))))]
  ""
  "*
   {
     return pic30_conditional_branch(
		reverse_condition(GET_CODE(operands[1])), operands[0]);
   }"
  [(set_attr "cc" "unchanged")])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; An instruction to jump to an address which is operand zero.
;; This pattern name is mandatory on all machines.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_insn "indirect_jump"
 [(set (pc) 
       (match_operand:HI 0 "pic30_register_operand" "r"))
 ]
 ""
 "goto %0"
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Instruction to jump to a variable address. This is a low-level capability
;; which can be used to implement a dispatch table when there is no 'casesi'
;; pattern. This pattern requires two operands: the address or offset, and a
;; label which should immediately precede the jump table. If the macro
;; CASE_VECTOR_PC_RELATIVE evaluates to a nonzero value then the first operand
;; is an offset which counts from the address of the table; otherwise, it is
;; an absolute address to jump to. In either case, the first operand has mode
;; Pmode. The 'tablejump' insn is always the last insn before the jump table
;; it uses. Its assembler code normally has no need to use the second operand,
;; but you should incorporate it in the RTL pattern so that the jump optimizer
;; will not delete the table as unreachable code.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define_insn "tablejump"
  [(set (pc) (match_operand:HI 0 "pic30_register_operand" "r"))
   (use (label_ref (match_operand 1 "" "")))]
  ""
  "bra %0")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Subroutines of "casesi".
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Operand 0 is index
;; operand 1 is the minimum bound
;; operand 2 is the maximum bound - minimum bound + 1
;; operand 3 is CODE_LABEL for the table;
;; operand 4 is the CODE_LABEL to go to if index out of range.

(define_expand "casesi"
  [(match_operand:SI 0 "pic30_general_operand" "")
   (match_operand:SI 1 "immediate_operand" "")
   (match_operand:SI 2 "immediate_operand" "")
   (match_operand 3 "" "")
   (match_operand 4 "" "")]
  ""
  "
{
  if (INTVAL(operands[2]) >= 32767) {
    error(\"Too many case statements in switch table\");
    FAIL;
  }
  if (operands[1] != const0_rtx) {
    rtx reg = gen_reg_rtx(SImode);

    operands[1] = GEN_INT(-INTVAL(operands[1]));
    operands[1] = force_reg(SImode, operands[1]);
    emit_insn(gen_addsi3(reg, operands[0], operands[1]));
    operands[0] = reg;
  }
  operands[0] = force_reg(SImode, operands[0]);
  operands[2] = force_reg(SImode, operands[2]);
  emit_insn(gen_cmpsi(operands[0], operands[2]));
  emit_jump_insn(gen_bgtu(operands[4]));
  emit_jump_insn(gen_casesi0(operands[0], operands[3]));
  DONE;
}")

(define_insn "casesi0"
  [(set (pc) (plus:SI
     (mem:SI (plus:SI (pc)
               (match_operand:SI 0 "pic30_mode2_operand" "r,R")))
     (label_ref (match_operand 1 "" ""))))
     (clobber (match_scratch:HI 2  "=X,r"))
     (clobber (match_dup 0))]
  ""
  "*
   {
     /*
     ** See if there is anything between us and the jump table
     ** If we could be sure there never was, then the 'clobber'
     ** of operand[0] could be removed.
     */
     register rtx p;
     int fDisjoint = FALSE;
     for (p = NEXT_INSN (insn); p != operands[1]; p = NEXT_INSN (p)) {
       if (INSN_P(p)) {
         fDisjoint = TRUE;
         break;
       }
     }
     if (fDisjoint) {
       if (which_alternative == 0)
         return \"add #(%1-$)/4,%0\;\"
                \"bra %0\";
       else
         return \"mov [%0], %2\;\"
                \"add #(%1-$)/4,%2\;\"
                \"bra %2\";
     } else {
       if (which_alternative == 0)
         return \"bra %0\";
       else
         return \"mov %0, %2\;\"
                \"bra %2\";
     }
   }"
  [
    (set_attr "type" "etc,use")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Unconditional jump
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define_insn "jump"
  [(set (pc)
        (label_ref (match_operand 0 "" "")))]
  ""
  "bra %0"
  [(set_attr "cc" "unchanged")])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Call subroutine, returning value in operand 0
;; (which must be a hard register).
;; Operand 1 is the function to call
;; Operand 2 is the number of bytes of arguments pushed
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define_expand "call_value"
  [(set (match_operand 0 "pic30_register_operand"        "=r,r ,r")
        (call (match_operand    1 "memory_operand"  "R,QS,m")
              (match_operand:HI 2 "pic30_general_operand" "")))]
  ;; Operand 2 not really used for dsPIC30.
  ""
  "
{
     char *security;
     int slot = 0;
     int set_psv;
     rtx sfr;
     rtx psv_page;
     struct saved_list *save_list = 0;
     tree save_variable_list;

     if ((GET_CODE(operands[1]) == MEM) &&
         (GET_CODE(XEXP(operands[1],0)) == SYMBOL_REF)) {
       if (!pic30_program_space_operand_p(XEXP(operands[1],0))) {
         error(\"Cannot call non-program symbol\");
       }
     }

     save_variable_list = pic30_get_save_variable_list();
     if (save_variable_list) {
       tree v;

       for (v = save_variable_list; v; v = TREE_CHAIN(v)) {
         struct saved_list *save_item;
         tree decl = pic30_get_save_variable_decl(v,NULL,NULL);

         save_item = (struct saved_list *)xmalloc(sizeof(struct saved_list));
         gcc_assert(save_item);
         save_item->saved_value = gen_reg_rtx(DECL_MODE(decl));
	 save_item->decl = decl;
         save_item->next = save_list;
         save_list = save_item;
         emit_move_insn(save_item->saved_value, DECL_RTL(save_item->decl));
       }
     }
 
     security = pic30_boot_secure_access(operands[1],&slot,&set_psv);
     if ((set_psv == pic30_set_nothing) && (TARGET_TRACK_PSVPAG) &&
         TARGET_CONST_IN_CODE) {
       set_psv = pic30_set_for_tracking;
     }
     if ((set_psv == pic30_set_on_call) || (set_psv == pic30_set_for_tracking)){
       psv_page = pic30_get_set_psv_value(0);

       if (psv_page == 0) {
         sfr = gen_rtx_SYMBOL_REF(HImode,\"_const_psvpage\");
         psv_page = gen_reg_rtx(HImode);
         emit(
           gen_save_const_psv(psv_page, sfr)
         );
       } 
       emit(
         gen_set_psv(psv_page)
       );
     }
     emit(
       set_psv == pic30_set_for_tracking ?
       gen_call_value_helper_apsv(operands[0], operands[1], operands[2]) :
       gen_call_value_helper(operands[0], operands[1], operands[2])
     );
     if ((set_psv) && (set_psv != pic30_set_for_tracking)) {
       if (lookup_attribute(IDENTIFIER_POINTER(pic30_identBoot[0]),
                            DECL_ATTRIBUTES(current_function_decl))) {
         sfr = gen_rtx_SYMBOL_REF(HImode,\"_bootconst_psvpage\");
       } else if (lookup_attribute(IDENTIFIER_POINTER(pic30_identSecure[0]),
                                   DECL_ATTRIBUTES(current_function_decl))) {
         sfr = gen_rtx_SYMBOL_REF(HImode,\"_secureconst_psvpage\");
       } else DONE;
       psv_page = gen_reg_rtx(HImode);
#if 1
       emit(
         gen_save_const_psv(psv_page, sfr)
       );
       emit(
         gen_set_psv(psv_page)
       );
#else
       emit(
         gen_set_const_psv(sfr)
       );
#endif
     }    
     
     if (save_variable_list) {
       struct saved_list *l;

       for (l = save_list; l; ) {
         struct saved_list *ll = l->next;
         emit_move_insn(DECL_RTL(l->decl),l->saved_value);
         free(l);
         l = ll;
       }
     }

     DONE;
}
  "
)

(define_insn "save_const_psv"
  [(set (match_operand:HI 0 "pic30_register_operand"        "=r")
        (match_operand:HI 1 "pic30_symbolic_address_operand" "q"))]
  ""
  "mov #%1,%0"
)

(define_insn "call_value_helper"
  [(set (match_operand 0 "pic30_register_operand"        "=r,r ,r")
        (call (match_operand    1 "memory_operand"  "R,QS,m")
              (match_operand:HI 2 "pic30_general_operand" "")))]
  ;; Operand 2 not really used for dsPIC30.
  "(pic30_check_for_conversion(insn))"
  "*
   static char szInsn[88];
   char *security;
   int slot = 0;
   int set_psv;
   char *this_insn = szInsn;

   pic30_clear_fn_list = 1;
   pic30_valid_call_address_operand(operands[0], Pmode);
#ifdef __C30_BETA__
   if (TARGET_ABI_CHECK) {
    this_insn += sprintf(this_insn,\"call __c30_abi_push\n\t\");
   }
#endif
   switch (which_alternative)
   {
     case 0:
       this_insn += sprintf(this_insn,\"call %s\", reg_names[REGNO(XEXP(operands[1],0))]);
       break;
     case 1:
       /*
        ** Casts of &(int x) to function ptrs, etc.
        */
       error(\"invalid function call\");
     case 2:
       security = pic30_boot_secure_access(operands[1],&slot,&set_psv);
       if (security) {
         this_insn += sprintf(this_insn, \"%s %s(%d)\",
                         pic30_near_function_p(operands[1]) ? 
                           \"rcall\" : \"call\", security,slot);
       } else 
         this_insn += sprintf(this_insn, \"%s %%1\",
                         pic30_near_function_p(operands[1]) ? 
                           \"rcall\" : \"call\");
         break;
      default:
         gcc_assert(0);
   }
#ifdef __C30_BETA__
   if (TARGET_ABI_CHECK) {
     this_insn += sprintf(this_insn,\"\n\tcall __c30_abi_pop\");
   }
#endif
   return szInsn ;
")

(define_insn "call_value_helper_apsv"
  [(set (match_operand 0 "pic30_register_operand"        "=r,r ,r")
        (call (match_operand    1 "memory_operand"  "R,QS,m")
              (match_operand:HI 2 "pic30_general_operand" "")))
   (use (reg:HI PSVPAG))
  ]
  ;; Operand 2 not really used for dsPIC30.
  "(pic30_check_for_conversion(insn))"
  "*
   static char szInsn[88];
   char *security;
   int slot = 0;
   int set_psv;
   char *this_insn = szInsn;

   pic30_clear_fn_list = 1;
   pic30_valid_call_address_operand(operands[0], Pmode);
#ifdef __C30_BETA__
   if (TARGET_ABI_CHECK) {
    this_insn += sprintf(this_insn,\"call __c30_abi_push\n\t\");
   }
#endif
   switch (which_alternative)
   {
     case 0:
       this_insn += sprintf(this_insn,\"call %s\", reg_names[REGNO(XEXP(operands[1],0))]);
       break;
     case 1:
       /*
        ** Casts of &(int x) to function ptrs, etc.
        */
       error(\"invalid function call\");
     case 2:
       security = pic30_boot_secure_access(operands[1],&slot,&set_psv);
       if (security) {
         this_insn += sprintf(this_insn, \"%s %s(%d)\",
                         pic30_near_function_p(operands[1]) ? 
                           \"rcall\" : \"call\", security,slot);
       } else 
         this_insn += sprintf(this_insn, \"%s %%1\",
                         pic30_near_function_p(operands[1]) ? 
                           \"rcall\" : \"call\");
         break;
      default:
         gcc_assert(0);
   }
#ifdef __C30_BETA__
   if (TARGET_ABI_CHECK) {
     this_insn += sprintf(this_insn,\"\n\tcall __c30_abi_pop\");
   }
#endif
   return szInsn ;
")

;; Call subroutine with no return value.
(define_expand "call_void"
  [ (call (match_operand:QI 0 "memory_operand"  "R,QS,m")
          (match_operand:HI 1 "pic30_general_operand" ""))]
  ;; Operand 1 not really used for dsPIC30.
  ""
  "
{
     char *security;
     int slot = 0;
     int set_psv;
     rtx sfr;
     rtx psv_page;
     struct saved_list *save_list = 0;
     tree save_variable_list;

     if ((GET_CODE(operands[0]) == MEM) &&
         (GET_CODE(XEXP(operands[0],0)) == SYMBOL_REF)) {
       if (!pic30_program_space_operand_p(XEXP(operands[0],0))) {
         error(\"Cannot call non-program symbol\");
       }
     }

     save_variable_list = pic30_get_save_variable_list();
     if (save_variable_list) {
       tree v;

       for (v = save_variable_list; v; v = TREE_CHAIN(v)) {
         struct saved_list *save_item;
         tree decl = pic30_get_save_variable_decl(v,NULL,NULL);

         save_item = (struct saved_list *)xmalloc(sizeof(struct saved_list));
         gcc_assert(save_item);
         save_item->saved_value = gen_reg_rtx(DECL_MODE(decl));
         save_item->decl = decl;
         save_item->next = save_list;
         save_list = save_item;
         emit_move_insn(save_item->saved_value, DECL_RTL(save_item->decl));
       }
     }

     security = pic30_boot_secure_access(operands[0],&slot,&set_psv);
     if ((set_psv == pic30_set_nothing) && (TARGET_TRACK_PSVPAG) &&
          TARGET_CONST_IN_CODE) {
       set_psv = pic30_set_for_tracking;
     }
     if ((set_psv == pic30_set_on_call) || (set_psv == pic30_set_for_tracking)){
       psv_page = pic30_get_set_psv_value(0);

       if (psv_page == 0) {
         sfr = gen_rtx_SYMBOL_REF(HImode,\"_const_psvpage\");
         psv_page = gen_reg_rtx(HImode);
         emit(
           gen_save_const_psv(psv_page, sfr)
         );
       }
       emit(
         gen_set_psv(psv_page)
       );
     }
     emit(
       set_psv == pic30_set_for_tracking ?
       gen_call_void_helper_apsv(operands[0], operands[1]) :
       gen_call_void_helper(operands[0], operands[1])
     );
     if ((set_psv) && (set_psv != pic30_set_for_tracking)) {
       if (lookup_attribute(IDENTIFIER_POINTER(pic30_identBoot[0]),
                            DECL_ATTRIBUTES(current_function_decl))) {
         sfr = gen_rtx_SYMBOL_REF(HImode,\"_bootconst_psvpage\");
       } else if (lookup_attribute(IDENTIFIER_POINTER(pic30_identSecure[0]),
                                   DECL_ATTRIBUTES(current_function_decl))) {
         sfr = gen_rtx_SYMBOL_REF(HImode,\"_secureconst_psvpage\");
       } else DONE;
       psv_page = gen_reg_rtx(HImode);
       emit(
         gen_save_const_psv(psv_page, sfr)
       );
       emit(
         gen_set_psv(psv_page)
       );
     }    

     if (save_variable_list) {
       struct saved_list *l;

       for (l = save_list; l; ) {
         struct saved_list *ll = l->next;
         emit_move_insn(DECL_RTL(l->decl),l->saved_value);
         free(l);
         l = ll;
       }
     }

     DONE;
}
  "
)

(define_insn "call_void_helper"
  [(call (match_operand:QI 0 "memory_operand" "R,QS,m")
         (match_operand:HI 1 "pic30_general_operand" ""))]
  "(pic30_check_for_conversion(insn))"
  "*
{
   static char szInsn[88];
   char *security;
   int slot = 0;
   char *this_insn = szInsn;

   pic30_clear_fn_list = 1;
   pic30_valid_call_address_operand(operands[0], Pmode);
#ifdef __C30_BETA__
   if (TARGET_ABI_CHECK) {
    this_insn += sprintf(this_insn,\"call __c30_abi_push\n\t\");
   }
#endif
   switch (which_alternative)
   {
     case 0:
       this_insn += sprintf(this_insn,\"call %s\", reg_names[REGNO(XEXP(operands[0],0))]);
       break;
     case 1:
       /*
        ** Casts of &(int x) to function ptrs, etc.
        */
       error(\"invalid function call\");
     case 2:
       security = pic30_boot_secure_access(operands[0],&slot,0);
       if (security) {
         this_insn += sprintf(this_insn, \"%s %s(%d)\",
                         pic30_near_function_p(operands[0]) ? 
                           \"rcall\" : \"call\",
                         security, slot);
       } else
         this_insn += sprintf(this_insn, \"%s %%0\",
                         pic30_near_function_p(operands[0]) ? 
                           \"rcall\" : \"call\");
         break;
     default:
       gcc_assert(0);
   }
#ifdef __C30_BETA__
   if (TARGET_ABI_CHECK) {
     this_insn += sprintf(this_insn,\"\n\tcall __c30_abi_pop\");
   }
#endif
   return szInsn ;
}")

(define_insn "call_void_helper_apsv"
  [(call (match_operand:QI 0 "memory_operand" "R,QS,m")
         (match_operand:HI 1 "pic30_general_operand" ""))
   (use (reg:HI PSVPAG))
  ]
  "(pic30_check_for_conversion(insn))"
  "*
{
   static char szInsn[88];
   char *security;
   int slot = 0;
   char *this_insn = szInsn;

   pic30_clear_fn_list = 1;
   pic30_valid_call_address_operand(operands[0], Pmode);
#ifdef __C30_BETA__
   if (TARGET_ABI_CHECK) {
    this_insn += sprintf(this_insn,\"call __c30_abi_push\n\t\");
   }
#endif
   switch (which_alternative)
   {
     case 0:
       this_insn += sprintf(this_insn,\"call %s\", reg_names[REGNO(XEXP(operands[0],0))]);
       break;
     case 1:
       /*
        ** Casts of &(int x) to function ptrs, etc.
        */
       error(\"invalid function call\");
     case 2:
       security = pic30_boot_secure_access(operands[0],&slot,0);
       if (security) {
         this_insn += sprintf(this_insn, \"%s %s(%d)\",
                         pic30_near_function_p(operands[0]) ? 
                           \"rcall\" : \"call\",
                         security, slot);
       } else
         this_insn += sprintf(this_insn, \"%s %%0\",
                         pic30_near_function_p(operands[0]) ? 
                           \"rcall\" : \"call\");
         break;
     default:
       gcc_assert(0);
   }
#ifdef __C30_BETA__
   if (TARGET_ABI_CHECK) {
     this_insn += sprintf(this_insn,\"\n\tcall __c30_abi_pop\");
   }
#endif
   return szInsn ;
}")

;; Call subroutine with no return value.
;; This handles intrinsics, such as bcopy.

(define_expand "call"
 [(call (match_operand:QI 0 "" "")
        (match_operand:HI 1 "" ""))]
 ""
 "
{
  char *security;
  int slot = 0;
  int set_psv;
  rtx sfr;
  rtx psv_page;
  struct saved_list *save_list = 0;
  tree save_variable_list;
  if (GET_CODE (operands[0]) == MEM && 
      !pic30_call_address_operand (XEXP (operands[0], 0), FN_Pmode))
    operands[0] = gen_rtx_MEM (GET_MODE (operands[0]),
			       force_reg (FN_Pmode, XEXP (operands[0], 0)));

  if ((GET_CODE(operands[0]) == MEM) && 
      (GET_CODE(XEXP(operands[0],0)) == SYMBOL_REF)) {
    if (!pic30_program_space_operand_p(XEXP(operands[0],0))) {
      error(\"Cannot call non-program symbol\");
    }
  }

  save_variable_list = pic30_get_save_variable_list();
  if (save_variable_list) {
    tree v;

    for (v = save_variable_list; v; v = TREE_CHAIN(v)) {
      struct saved_list *save_item;
      tree decl = pic30_get_save_variable_decl(v,NULL,NULL);

      save_item = (struct saved_list *)xmalloc(sizeof(struct saved_list));
      gcc_assert(save_item);
      save_item->saved_value = gen_reg_rtx(DECL_MODE(decl));
      save_item->decl = decl;
      save_item->next = save_list;
      save_list = save_item;
      emit_move_insn(save_item->saved_value, DECL_RTL(save_item->decl));
    }
  }

  security = pic30_boot_secure_access(operands[0],&slot,&set_psv);
  if ((set_psv == pic30_set_nothing) && (TARGET_TRACK_PSVPAG) &&
       TARGET_CONST_IN_CODE) {
    set_psv = pic30_set_for_tracking;
  }
  if ((set_psv == pic30_set_on_call) || (set_psv == pic30_set_for_tracking)){
    psv_page = pic30_get_set_psv_value(0);

    if (psv_page == 0) {
      sfr = gen_rtx_SYMBOL_REF(HImode,\"_const_psvpage\");
      psv_page = gen_reg_rtx(HImode);
      emit(
        gen_save_const_psv(psv_page, sfr)
      );
    }
    emit(
      gen_set_psv(psv_page)
    );
  }
  emit(
    set_psv == pic30_set_for_tracking ?
    gen_call_void_helper_apsv(operands[0], operands[1]) :
    gen_call_void_helper(operands[0], operands[1])
  );
  if ((set_psv) && (set_psv != pic30_set_for_tracking)) {
    if (lookup_attribute(IDENTIFIER_POINTER(pic30_identBoot[0]),
                         DECL_ATTRIBUTES(current_function_decl))) {
      sfr = gen_rtx_SYMBOL_REF(HImode,\"_bootconst_psvpage\");
    } else if (lookup_attribute(IDENTIFIER_POINTER(pic30_identSecure[0]),
                                DECL_ATTRIBUTES(current_function_decl))) {
      sfr = gen_rtx_SYMBOL_REF(HImode,\"_secureconst_psvpage\");
    } else DONE;
    psv_page = gen_reg_rtx(HImode);
    emit(
      gen_save_const_psv(psv_page, sfr)
    );
    emit(
      gen_set_psv(psv_page)
    );
  }   

  if (save_variable_list) {
     struct saved_list *l;

     for (l = save_list; l; ) {
       struct saved_list *ll = l->next;
       emit_move_insn(DECL_RTL(l->decl),l->saved_value);
       free(l);
       l = ll;
     }
   }

  DONE;
}")

(define_insn "*call"
  [(call (mem:QI (match_operand:QI 0 "pic30_call_address_operand" ""))
         (match_operand:HI 1 "pic30_general_operand" ""))]
  "(pic30_check_for_conversion(insn))"
  "*
  {
    static char szInsn[88];
    char *security;
    int slot = 0;
    char *insn = szInsn;

    pic30_clear_fn_list = 1;
    pic30_valid_call_address_operand(operands[0], FN_Pmode);
    security = pic30_boot_secure_access(operands[0],&slot,0);
#ifdef __C30_BETA__
    if (TARGET_ABI_CHECK) {
     insn += sprintf(insn,\"call __c30_abi_push\n\t\");
    }
#endif
    if (security) {
      insn += sprintf(insn, \"call %s(%d)\",security, slot);
    } else sprintf(szInsn,\"call %%0\");
#ifdef __C30_BETA__
    if (TARGET_ABI_CHECK) {
      insn += sprintf(insn,\"\n\tcall __c30_abi_pop\");
    }
#endif
    return szInsn;
  }"
)

;;
;; return
;;
(define_insn "return"
  [(return)]
  "pic30_null_epilogue_p(0)"
  "*
{
	pic30_set_function_return(TRUE);

	return \"return\";
}"
  [(set_attr "cc" "clobber")])

(define_insn "return_from_epilogue"
  [(return)]
  "!pic30_null_epilogue_p(0) && reload_completed"
  "*
  { extern tree current_function_decl;
    if (pic30_interrupt_function_p(current_function_decl))
    {
      return \"retfie\";
    }
    else if (pic30_noreturn_function(current_function_decl))
    {
      return \"reset\";
    }
    else
    {
      return \"return\";
    }
  }"
  [(set_attr "cc" "clobber")]
)

;;
;; link
;;
(define_insn "lnk"
 [
    (set (mem:HI (post_inc:HI (reg:HI SPREG)))
         (reg:HI FPREG))
    (set (reg:HI FPREG)
         (reg:HI SPREG))
    (set (reg:HI SPREG)
         (plus:HI (reg:HI SPREG)
                  (match_operand 0 "immediate_operand" "i")))
 ]
 "reload_completed"
 "lnk #%0"
 [
  (set_attr "cc" "change0")
  (set_attr "type" "def")
 ]
)

;;
;; unlink
;;
(define_insn "ulnk"
  [
     (set (reg:HI SPREG) 
          (reg:HI FPREG))
     (set (reg:HI FPREG)
          (mem:HI (pre_dec:HI (reg:HI SPREG))))
  ]
  "reload_completed"
  "*
  {
    if ((pic30_errata_mask & busmaster_errata) && (pic30_ecore_target())) {
      return \"mov w14,w15\;mov [--w15],w14\;bclr CORCON,#2\";
    } 
    return \"ulnk\";
  }
  "
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def")
  ]
)

  

;;
;; disi
;;
(define_insn "disi"
  [(unspec_volatile [(match_operand 0 "immediate_operand" "i")] UNSPECV_DISI)]
  ""
  "disi #%0")



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; prologue/epilogue
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_expand "prologue"
  [(const_int 1)]
  ""                           
  "
  {
     pic30_expand_prologue();
     DONE;
  }"
)

(define_expand "epilogue"
  [(const_int 1)]
  ""
  "
  {
     pic30_expand_epilogue();
     DONE;
  }"
)

(define_insn "profile_enter"
  [(unspec_volatile [(const_int 0)] UNSPECV_ENTER)]
  ""
  "call __function_level_profiling_long"
)

(define_insn "profile_exit"
  [(unspec_volatile [(const_int 0)] UNSPECV_EXIT)]
  ""
  "goto __function_level_profiling_long_zero"
)

(define_insn "profile_exit_call"
  [(unspec_volatile [(const_int 1)] UNSPECV_EXIT)]
  ""
  "call __function_level_profiling_long_zero"
)

;; UNSPEC_VOLATILE is considered to use and clobber all hard registers and
;; all of memory.  This blocks insns from being moved across this point.

(define_insn "blockage"
  [(unspec_volatile [(const_int 0)] UNSPECV_BLOCKAGE)]
  ""
  "")

(define_insn "pa"
  [(unspec_volatile [(match_operand 0 "immediate_operand" "i")] UNSPECV_PA)]
  ""
  ".set ___PA___,%0")

(define_insn "iv"
  [(unspec_volatile [(match_operand 0 "immediate_operand" "i")] UNSPECV_IV)]
  ""
  {
   static char szInsn[96];
	char szVector[32];
	int nVectorID;
			
	nVectorID = INTVAL(operands[0]);
	if (nVectorID < 0)
	{
		nVectorID = -nVectorID-1;
		sprintf(szVector,"__AltInterrupt%d",nVectorID);
	}
	else
	{
		sprintf(szVector, "__Interrupt%d", nVectorID);
	}
	sprintf(szInsn, ".global\t%s\n%s:", szVector, szVector);

	return szInsn;
  }
)
(define_insn "pp"
  [(unspec_volatile [(const_int 0)] UNSPECV_PP)]
  ""
  {
  	return pic30_interrupt_preprologue();
  }
)

;
; CAW - for RAW scheduling we could split these instructions after the
;   mov #_addr,%0
;
(define_insn "write_oscconl"
  [(set (match_operand:HI 0 "pic30_register_operand" "=&r")
        (unspec_volatile [
                     (match_operand 1 "pic30_register_operand" "r")
                     (match_operand 2 "pic30_register_operand" "r")
                     (match_operand 3 "pic30_register_operand" "r")]
           UNSPECV_WRITEOSCCONL)
   )]
  ""
  "mov #_OSCCON,%0\;mov.b %1,[%0]\;mov.b %2,[%0]\;mov.b %3,[%0]"
)

(define_insn "write_oscconh"
  [(set (match_operand:HI 0 "pic30_register_operand" "=&r")
        (unspec_volatile [
                     (match_operand 1 "pic30_register_operand" "r")
                     (match_operand 2 "pic30_register_operand" "r")
                     (match_operand 3 "pic30_register_operand" "r")]
    UNSPECV_WRITEOSCCONH)
   )]
  ""
  "mov #_OSCCON+1,%0\;mov.b %1,[%0]\;mov.b %2,[%0]\;mov.b %3,[%0]"
)

(define_insn "write_disicnt"
  [ (unspec_volatile [
      (match_operand 0 "pic30_register_operand" "r")] UNSPECV_WRITEDISICNT)
  ]
  ""
  "mov %0,_DISICNT\;mov w0,_WREG0"
)

(define_insn "write_pwmsfr"
  [ (unspec_volatile [
      (match_operand:HI 0 "pic30_near_operand"     "U,U")
      (match_operand:HI 1 "pic30_register_operand" "a,r")
      (match_operand:HI 2 "pic30_register_operand" "r,r")
      (match_operand:HI 3 "pic30_register_operand" "r,r")
      (match_operand:HI 4 "pic30_R_operand"        "R,R")
    ] UNSPECV_WRITEPWMCON)
    (clobber (match_scratch: HI  5                "=X,&r"))
  ]
  ""
  "@
   mov %3,%4\;mov %2,%4\;mov %1,%0
   mov #%0,%5\;mov %3,%4\;mov %2,%4\;mov %1,[%5]"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "use,etc")
  ]
)

;   (set (match_operand:HI 0 "pic30_register_operand" "+r")
;        (unspec_volatile [ (const_int 0) ] UNSPECV_WRITENVM))
;   (set (match_operand:HI 1 "pic30_register_operand" "+r")
;        (unspec_volatile [ (const_int 1) ] UNSPECV_WRITENVM)) ]
(define_insn "write_nvm_secure"
  [
    (unspec_volatile [ 
      (match_operand:HI 0 "pic30_register_operand" "+r") 
      (match_operand:HI 1 "pic30_register_operand" "+r") 
    ] UNSPECV_WRITENVM)
  ]
  ""
  ".set ___PA___,0\;mov %0,_NVMKEY\;nop\;mov %1,_NVMKEY\;bset _NVMCON,#15\;clr %0\;clr %1\;.set __PA___,1"
  [
    (set_attr "type" "etc")
  ]
)

(define_insn "write_nvm"
  [(set (match_operand:HI 0 "pic30_register_operand" "=r")
        (unspec_volatile [ (const_int 0) ] UNSPECV_WRITENVM))]
  ""
  ".set ___PA___,0\;mov #0x55,%0\;mov %0,_NVMKEY\;mov #0xAA,%0\;mov %0,_NVMKEY\;bset _NVMCON,#15\;nop\;nop\;.set ___PA___,1"
  [
    (set_attr "type" "etc")
  ]
)

(define_insn "write_rtcwen"
  [(set (match_operand:HI 0 "pic30_register_operand" "=&r")
        (unspec_volatile [
           (match_operand:HI 1 "pic30_register_operand" "0")
         ] UNSPECV_WRITERTCWEN))]
  ""
  ".set ___PA___,0\;mov #0x55,%0\;mov %0,_NVMKEY\;mov #0xAA,%0\;mov %0,_NVMKEY\;bset _RCFGCAL,#13\;.set ___PA___,1"
  [
    (set_attr "type" "etc")
  ]
)

(define_insn "write_wrlock"
  [(set (match_operand:HI 0 "pic30_register_operand" "=&r")
        (unspec_volatile [
           (match_operand:HI 1 "pic30_register_operand" "0")
         ] UNSPECV_WRITEWRLOCK))]
  ""
  ".set ___PA___,0\;mov #0x55,%0\;mov %0,_NVMKEY\;mov #0xAA,%0\;mov %0,_NVMKEY\;bclr _RTCCON1L,#11\;.set ___PA___,1"
  [
    (set_attr "type" "etc")
  ]
)

(define_insn "write_cryotp"
  [(set (match_operand:HI 0 "pic30_register_operand" "=&r")
        (unspec_volatile [ (const_int 0) ] UNSPECV_WRITECRTOTP))]
  ""
  ".set ___PA___,0\;mov #0x55,%0\;mov %0,_NVMKEY\;mov #0xAA,%0\;mov %0,_NVMKEY\;nop\;bset _CRYOTP,#0\;.set ___PA___,1"
  [
    (set_attr "type" "etc")
  ]
)

(define_insn "write_dataflash"
  [(set (match_operand:HI 0 "pic30_register_operand" "=r")
        (unspec_volatile [ (const_int 0) ] UNSPECV_WRITEDATAFLASH))
   (clobber 
        (match_scratch:HI 1                          "=&r"))
  ]
  ""
  ".set ___PA___,0\;mov _DFCON,%1\;bset %1,#7\;mov #0xEDB7,%0\;mov %0,_DFKEY\;mov #0x1248,%0\;mov %0,_DFKEY\;mov %1,_DFCON\;.set ___PA___,1"
)

(define_insn "write_dataflash_secure"
  [
    (unspec_volatile [ 
      (match_operand:HI 0 "pic30_register_operand" "+r") 
      (match_operand:HI 1 "pic30_register_operand" "+r") 
    ] UNSPECV_WRITEDATAFLASH)
    (clobber 
         (match_scratch:HI 2                          "=&r"))
  ]
  ""
  ".set ___PA___,0\;mov _DFCON,%2\;bset %2,#7\;mov %0,_DFKEY\;mov %1,_DFKEY\;mov %2,_DFCON\;clr %0\;clr %1\;.set ___PA___,1"
)



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; nop
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_insn "bifnop"
  [(unspec_volatile [(const_int 0)] UNSPECV_NOP)]
  ""
  "nop"
  [(set_attr "cc" "unchanged")])

(define_insn "nop"
  [(const_int 0)]
  ""
  "nop"
  [(set_attr "cc" "unchanged")])

(define_insn "pwrsav"
  [
   (unspec_volatile 
     [(match_operand:HI 0 "immediate_operand" "i")]
    UNSPECV_PWRSAV)
  ]
  ""
  "pwrsav #%0"
  [(set_attr "cc" "unchanged")]
)

(define_insn "clrwdt"
  [
   (unspec_volatile
     [(const_int 0)]
   UNSPECV_CLRWDT)
  ]
  ""
  "clrwdt"
  [(set_attr "cc" "unchanged")]
)

;
;; misc
;

(define_insn "section_begin"
  [(set (match_operand:SI 0 "pic30_register_operand" "=r")
        (unspec:SI [ 
          (match_operand 1 "immediate_operand" "i")
        ] UNSPEC_SECTION_BEGIN))]
  ""
  "*
  { static char *buffer = 0;
    static int buffer_size;
    int len;

    tree t = (tree)(INTVAL(operands[1]));
    char *section_name = TREE_STRING_POINTER(t);
    len = sizeof (\"mov #.startof.(),%0\;mov #.startof_hi.(),%d0\");
    len += strlen(section_name)*2;
    len++;
    if (buffer_size < len) {
      if (buffer) free(buffer);
      buffer = (char *)xmalloc(len+50);
      buffer_size = len+50;
    }
    sprintf(buffer, \"mov #.startof.(%s),%%0\;mov #.startof_hi.(%s),%%d0\",
            section_name, section_name);
    return buffer;
  }"
  [
    (set_attr "type" "def")
  ]
)

(define_insn "section_end"
  [(set (match_operand:SI 0 "pic30_register_operand" "=r")
        (unspec:SI [ 
          (match_operand 1 "immediate_operand" "i")
        ] UNSPEC_SECTION_END))]
  ""
  "*
  { static char *buffer = 0;
    static int buffer_size;
    int len;

    tree t = (tree)(INTVAL(operands[1]));
    char *section_name = TREE_STRING_POINTER(t);
    len = sizeof (\"mov #.endof.(),%0\;mov #.endof_hi.(),%d0\");
    len += strlen(section_name)*2;
    len++;
    if (buffer_size < len) {
      if (buffer) free(buffer);
      buffer = (char *)xmalloc(len+50);
      buffer_size = len+50;
    }
    sprintf(buffer, \"mov #.endof.(%s),%%0\;mov #.endof_hi.(%s),%%d0\",
            section_name, section_name);
    return buffer;
  }"
  [
    (set_attr "type" "def")
  ]
)

(define_insn "section_size"
  [(set (match_operand:SI 0 "pic30_register_operand" "=r")
        (unspec:SI [ 
          (match_operand 1 "immediate_operand" "i")
        ] UNSPEC_SECTION_SIZE))]
  ""
  "*
  { static char *buffer = 0;
    static int buffer_size;
    int len;

    tree t = (tree)(INTVAL(operands[1]));
    char *section_name = TREE_STRING_POINTER(t);
    len = sizeof (\"mov #.sizeof.(),%0\;mov #.sizeof_hi.(),%d0\");
    len += strlen(section_name)*2;
    len++;
    if (buffer_size < len) {
      if (buffer) free(buffer);
      buffer = (char *)xmalloc(len+50);
      buffer_size = len+50;
    }
    sprintf(buffer, \"mov #.sizeof.(%s),%%0\;mov #.sizeof_hi.(%s),%%d0\",
            section_name, section_name);
    return buffer;
  }"
  [
    (set_attr "type" "def")
  ]
)

; define [sg]et_isr_state as an expand, in so that we can generate less
;   code if we don't actually 'use' the value (apart from to re-set it)
;   if unless we say if (__builtin_get_isr_state() == n) there is no need
;   to shift the value

(define_insn "get_isr_state_helper"
  [(set (match_operand:HI 0 "pic30_register_operand" "=r")
        (unspec:HI [ (const_int 0) ] UNSPEC_GET_ISR_STATE))]
  ""
  "mov _SR,%0"
  [
    (set_attr "type" "def")
  ]
)

(define_insn "extract_gie"
  [(set (match_operand:HI 0 "pic30_register_operand" "=r")
        (unspec:HI [ (match_dup 0) ] UNSPEC_EXTRACT_GIE))]
  ""
  "bclr %0,#3\;btsc _INTCON2,#15\;bset %0,#3"
)

(define_expand "get_isr_state"
 [(set (match_operand:HI 0 "pic30_register_operand" "=r")
       (unspec:HI [(const_int 0)] UNSPEC_GET_ISR_STATE))]
 ""
 "{ rtx reg = operands[0];

    if (!pic30_register_operand(operands[0], HImode)) {
      reg = force_reg (GET_MODE(operands[0]), operands[0]);
    }
    emit_insn(
      gen_get_isr_state_helper(reg)
    );
    emit_insn(
      gen_ashrhi3(reg, reg, GEN_INT(5))
    );
    emit_insn(
      gen_andhi3(reg, reg, GEN_INT(7))
    );
    if (pic30_device_has_gie()) {
      emit_insn(
        gen_extract_gie(reg)
      );
    }
    if (reg != operands[0]) {
      emit_move_insn(operands[0], reg);
    }
    DONE;
  }")

(define_insn "set_isr_state_helper"
  [(unspec_volatile [
      (match_operand:HI 0 "pic30_register_operand" "r")
    ] UNSPECV_SET_ISR_STATE)
   (clobber (match_scratch:HI 1                    "=&r"))
   (clobber (match_scratch:HI 2                    "=&r"))]
  ""
  "mov _SR,%1\;and.b #0x1F,%1\;ior %1,%0,%1\;mov %1,_SR"
  [(set_attr "cc" "clobber")]
)

(define_insn "insert_gie"
  [(unspec_volatile [ 
      (match_operand:HI 0 "pic30_register_operand" "r")] UNSPEC_INSERT_GIE)
   (clobber (match_scratch:HI 1                    "=r"))]
  ""
  "btsc %0,#3\;bset _INTCON2,#15\;btss %0,#3\;bclr _INTCON2,#15\;nop\;nop"
)


(define_expand "set_isr_state"
 [(unspec_volatile [ 
     (match_operand:HI 0 "pic30_register_operand" "=r")] UNSPECV_SET_ISR_STATE)]
 ""
 "{ rtx reg = operands[0];
    rtx reg2 = gen_reg_rtx(HImode);

    if (!pic30_register_operand(operands[0], HImode)) {
      reg = force_reg (GET_MODE(operands[0]), operands[0]);
    }
    emit_insn(
      gen_andhi3(reg2, reg, GEN_INT(7))
    );
    emit_insn(
      gen_ashlhi3(reg2, reg2, GEN_INT(5))
    );
    emit_insn(
      gen_set_isr_state_helper(reg2)
    );
    if (pic30_device_has_gie()) {
      emit_insn(
        gen_insert_gie(reg)
      );
    }
    DONE;
  }")

(define_insn "disable_isr_gie"
  [(unspec_volatile [(const_int 0)] UNSPECV_DISABLE_ISR_GIE)]
  ""
  "*
   {
     if (pic30_device_has_gie()) {
       /* clear the GIE */
       return \"bclr _INTCON2,#15\;nop\;nop\";
     } else {
       error(\"This device has no GIE\");
       return \"; This device has no GIE\";
     }
   }"
)

(define_insn "enable_isr_gie"
  [(unspec_volatile [(const_int 0)] UNSPECV_ENABLE_ISR_GIE)]
  ""
  "*
   {
     if (pic30_device_has_gie()) {
       /* set the GIE */
       return \"bset _INTCON2,#15\;nop\;nop\";
     } else {
       error(\"This device has no GIE\");
       return \"; This device has no GIE\";
     }
   }"
)  

(define_insn "disable_isr_ipl"
  [(unspec_volatile [(const_int 0)] UNSPECV_DISABLE_ISR)
   (clobber
      (match_scratch:HI 0  "=a,r"))
   (clobber
      (match_scratch:HI 1  "=r,r"))]
  ""
  "*
   {
     if (which_alternative == 0) {
       return \"mov _DISICNT,%1\;disi #0x3FFF\;mov #0xE0,%0\;ior _SR\;mov %1,_DISICNT\;mov w0,_WREG0\";
     } else {
      return \"mov _DISICNT,%1\;disi #0x3FFF\;mov _SR,%1\;ior #0xE0,%1\;mov %1,_SR\;mov %1,_DISICNT\;mov w0,_WREG0\";
     }
   }"
)

(define_insn "enable_isr_ipl"
  [(unspec_volatile [(const_int 0)] UNSPECV_ENABLE_ISR)
   (clobber
      (match_scratch:HI 0  "=r"))
   (clobber
      (match_scratch:HI 1  "=r"))]
  ""
  "mov _DISICNT,%1\;disi #0x3FFF\;mov _SR,%0\;and.b #0x1F,%0\;mov %0,_SR\;mov %1,_DISICNT\;mov w0,_WREG0"
)

(define_expand "disable_isr"
  [(const_int 0)]
  ""
  "{
     if (pic30_device_has_gie()) {
       emit_insn(
         gen_disable_isr_gie()
       );
     } else {
       emit_insn(
         gen_disable_isr_ipl()
       );
     }
     DONE;
   }"
)

(define_expand "enable_isr"
  [(const_int 0)]
  ""
  "{
     if (pic30_device_has_gie()) {
       emit_insn(
         gen_enable_isr_gie()
       );
     } else {
       emit_insn(
         gen_enable_isr_ipl()
       );
     }
     DONE;
   }"
)

(define_insn "software_break"
  [(unspec_volatile [(const_int 0)] UNSPECV_SOFTWARE_BREAK)]
  ""
  ".pword 0xda4000"
)
 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;	Peephole
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; generate btst f, #bit


; first from load, and, compare
(define_peephole
  [(set (match_operand:HI 0 "pic30_register_operand" "")
        (match_operand:HI 1 "pic30_near_operand" ""))
   (set (match_operand:HI 2 "pic30_register_operand" "")
        (and:HI 
           (match_dup 0)
           (match_operand 3 "immediate_operand" "")))
   (set (cc0)
        (compare
          (match_dup 2)
          (const_int 0)))
  ]
  "((pic30_one_bit_set(GET_MODE(operands[0]),operands[3],1)) &&
    (find_regno_note(prev_active_insn(insn), REG_DEAD, REGNO(operands[0])) ||
     (REGNO(operands[2]) == REGNO(operands[0])) ||
     pic30_dead_or_set_p(insn,operands[0])) &&
    (find_regno_note(insn, REG_DEAD, REGNO(operands[2])) ||
     pic30_dead_or_set_p(next_active_insn(insn),operands[2])))"
  "btst %1,#%b3"
  [(set_attr "cc" "math")]
)
 

(define_peephole
  [(set (match_operand:HI 0 "pic30_register_operand" "")
        (rotate:HI
           (match_operand:HI 1 "pic30_register_operand" "")
           (const_int 1)))
   (set (match_dup 0)
        (rotatert:HI
           (match_dup 0)
           (const_int 1)))
  ]
  ""
  ""
  [(set_attr "cc" "unchanged")]
)

(define_peephole
  [(set (match_operand:HI 0 "pic30_register_operand" "")
        (rotate:HI
           (match_operand:HI 1 "pic30_register_operand" "")
           (const_int 1)))
   (set (match_operand:HI 2 "pic30_register_operand" "")
        (rotatert:HI
           (match_dup 0)
           (const_int 1)))
  ]
  "(pic30_dead_or_set_p(NEXT_INSN(insn),operands[0]) && 
    (REGNO(operands[1]) == REGNO(operands[2])))"
  ""
  [(set_attr "cc" "unchanged")]
)

(define_peephole
  [(set (match_operand:HI 0 "pic30_register_operand" "")
        (rotate:HI
           (match_operand:HI 1 "pic30_register_operand" "")
           (const_int 1)))
   (set (match_operand:HI 2 "pic30_register_operand" "")
        (rotatert:HI
           (match_dup 0)
           (const_int 1)))
  ]
  "pic30_dead_or_set_p(NEXT_INSN(insn),operands[0])"
  "mov %1,%2"
  [(set_attr "cc" "unchanged")]
)

;; sequential assignments of 0 to a register
(define_peephole
  [
   (set (match_operand:HI 0 "pic30_register_operand" "")
        (const_int 0))
   (set (match_operand:HI 1 "pic30_register_operand" "")
        (const_int 0))
  ]
  "((REGNO(operands[0]) + 1 == REGNO(operands[1])) && 
    ((REGNO(operands[0]) & 1) == 0))"
  "mul.uu %0, #0, %0"
  [(set_attr "cc" "unchanged")]
)

(define_peephole
  [
   (set (match_operand:HI 0 "pic30_register_operand" "")
        (const_int 0))
   (set (match_operand:HI 1 "pic30_register_operand" "")
        (const_int 0))
  ]
  "((REGNO(operands[1]) + 1 == REGNO(operands[0])) && 
    ((REGNO(operands[1]) & 1) == 0))"
  "mul.uu %1, #0, %1"
  [(set_attr "cc" "unchanged")]
)


;; remove redundant lnk
(define_peephole2
  [(parallel[
      (set (reg:HI SPREG)
            (match_operand 0 "immediate_operand" "i"))
      (clobber (reg:HI FPREG))
      (use (reg:HI FPREG))
      (use (reg:HI SPREG))]
  )]
  "pic30_lnk_removed(insn,1+INTVAL(operands[0]))"
  [(set (reg:HI SPREG)
        (plus:HI (reg:HI SPREG)
                 (match_dup 0)))]
  "{ operands[0] = GEN_INT(INTVAL(operands[0])+2); }"
)

(define_peephole2
  [(parallel[
     (set (reg:HI SPREG)
          (reg:HI FPREG))
     (clobber (reg:HI FPREG))]
  )]
  "pic30_lnk_removed(insn,0)"
  [(unspec_volatile [(const_int 0)] UNSPECV_NOP)]
  ""
)

;;
;; redundant copy
;;
(define_peephole2
  [
   (set (match_operand 0 "pic30_register_operand" "")
        (match_operand 1 "pic30_register_operand" ""))
   (set (match_operand 2 "pic30_register_operand" "")
        (match_operand 3 "pic30_register_operand" ""))
  ]
  "((REGNO(operands[3]) == REGNO(operands[0])) &&
    (GET_MODE(operands[3]) == GET_MODE(operands[0])) &&
    peep2_reg_dead_p(2, operands[0]))"
  [
   (set (match_dup 2)
        (match_dup 1))
  ]
  ""
)

(define_peephole2
  [
   (set (match_operand 0 "pic30_register_operand" "")
        (match_operand 1 "immediate_operand" ""))
   (set (match_operand 2 "pic30_register_operand" "")
        (match_operand 3 "pic30_register_operand" ""))
  ]
  "((REGNO(operands[3]) == REGNO(operands[0])) &&
    (GET_MODE(operands[3]) == GET_MODE(operands[0])) &&
    peep2_reg_dead_p(2, operands[0]))"
  [
   (set (match_dup 2)
        (match_dup 1))
  ]
  ""
)
   
;;
;; clean up Ureload_outQI
;;
(define_peephole2
  [
   (set (match_operand:QI 0 "pic30_register_operand" "")
        (match_operand:QI 1 "pic30_register_operand" ""))
   (parallel [
     (set
        (match_operand:QI 2 "pic30_near_operand"     "=U")
        (match_operand:QI 3 "pic30_register_operand" " r"))
     (clobber
        (match_operand:HI 4 "pic30_register_operand" "=&r"))
   ])
  ]
  "((REGNO(operands[3]) == REGNO(operands[0])) &&
    (REGNO(operands[1]) != REGNO(operands[4])) &&
    peep2_reg_dead_p(2, operands[0]))"
  [(parallel [
     (set
        (match_dup 2)
        (match_dup 1))
     (clobber
        (match_dup 4))
   ])
  ]
  ""
)

  
;;
;; 16-bit shift right SI followed by truncate to HI.
;; Simplify to most-significant subreg.
;; Unsigned shift.
;;
(define_peephole2
  [(set (match_operand:SI 0            "pic30_register_operand"    "")
        (lshiftrt:SI (match_operand:SI 1 "pic30_register_operand"  "")
                     (match_operand 2 "immediate_operand" "")))
   (set (match_operand:HI 3 "pic30_move_operand" "")
        (match_operand:HI 4 "pic30_register_operand" ""))
  ]
  "(INTVAL(operands[2]) == 16) &&
   (REGNO(operands[0]) == REGNO(operands[4])) &&
   (((REGNO(operands[0]) <= REGNO(operands[3])) && 
     (REGNO(operands[3]) < REGNO(operands[0]) + 
                    HARD_REGNO_NREGS(REGNO(operands[0]), GET_MODE (operands[0]))
     )) || peep2_reg_dead_p(2, operands[0]))"
  [(set (match_dup 3)
        (subreg:HI (match_dup 1) 2))]
  ""
  )

(define_peephole2
  [(set (match_operand:SI 0            "pic30_register_operand"    "")
        (lshiftrt:SI (match_operand:SI 1 "pic30_register_operand"  "")
                     (match_operand 2 "immediate_operand" "")))
   (set (match_operand:HI 3 "pic30_register_operand" "")
        (match_operator:HI 6 "pic30_valid_operator"
           [(match_operand:HI 4 "pic30_register_operand" "")
            (match_operand:HI 5 "" "")]))
  ]
  "(INTVAL(operands[2]) == 16) &&
   (REGNO(operands[0]) == REGNO(operands[4])) &&
   (((REGNO(operands[0]) <= REGNO(operands[3])) &&
     (REGNO(operands[3]) < REGNO(operands[0]) + 
                    HARD_REGNO_NREGS(REGNO(operands[0]), GET_MODE (operands[0]))     )) || peep2_reg_dead_p(2, operands[0]))"
  [ 
   (set (match_dup 4) (subreg:HI (match_dup 1) 2))
   (set (match_dup 3)
        (match_op_dup 6 [(match_dup 4) (match_dup 5)]))
  ]
  ""
  )

;; Ditto for signed shift.
(define_peephole2
  [(set (match_operand:SI 0            "pic30_register_operand"    "")
        (ashiftrt:SI (match_operand:SI 1 "pic30_register_operand"  "")
                     (match_operand 2 "immediate_operand" "")))
   (set (match_operand:HI 3 "pic30_move_operand" "")
        (match_operand:HI 4 "pic30_register_operand" ""))
  ]
  "(INTVAL(operands[2]) == 16) &&
   (REGNO(operands[0]) == REGNO(operands[4])) &&
   (((REGNO(operands[0]) <= REGNO(operands[3])) &&
     (REGNO(operands[3]) < REGNO(operands[0]) + 
                    HARD_REGNO_NREGS(REGNO(operands[0]), GET_MODE (operands[0]))     )) || peep2_reg_dead_p(2, operands[0]))"

  [(set (match_dup 3)
        (subreg:HI (match_dup 1) 2))]
  ""
  )

(define_peephole2
  [(set (match_operand:SI 0            "pic30_register_operand"    "")
        (ashiftrt:SI (match_operand:SI 1 "pic30_register_operand"  "")
                     (match_operand 2 "immediate_operand" "")))
   (set (match_operand:HI 3 "pic30_register_operand" "")
        (match_operator:HI 6 "pic30_valid_operator"
           [(match_operand:HI 4 "pic30_register_operand" "")
            (match_operand:HI 5 "" "")]))
  ]
  "(INTVAL(operands[2]) == 16) &&
   (REGNO(operands[0]) == REGNO(operands[4])) &&
   (((REGNO(operands[0]) <= REGNO(operands[3])) &&
     (REGNO(operands[3]) < REGNO(operands[0]) +
                    HARD_REGNO_NREGS(REGNO(operands[0]), GET_MODE (operands[0]))     )) || peep2_reg_dead_p(2, operands[0]))"
  [
   (set (match_dup 4) (subreg:HI (match_dup 1) 2))
   (set (match_dup 3)
        (match_op_dup 6 [(match_dup 4) (match_dup 5)]))
  ]
  ""
  )


;; Move [Base+Index] to [Base+Index] where Base or Index is common
(define_peephole
  [(set (match_operand:HI 0 "pic30_register_operand" "=r")
	(match_operand:HI 1 "pic30_mode3_operand" "RS<>r"))
   (set (match_operand:HI 2 "pic30_mode3_operand" "=RS<>r")
	(match_dup 0))
  ]
 "pic30_IndexEqual(operands[1], operands[2]) &&
	dead_or_set_p(insn, operands[0])"
 "mov %1,%2"
  [(set_attr "cc" "unchanged")])

(define_peephole
  [(set (match_operand:QI 0 "pic30_register_operand" "=r")
	(match_operand:QI 1 "pic30_mode3_operand" "RS<>r"))
   (set (match_operand:QI 2 "pic30_mode3_operand" "=RS<>r")
	(match_dup 0))
  ]
 "pic30_IndexEqual(operands[1], operands[2]) &&
	dead_or_set_p(insn, operands[0])"
 "mov.b %1,%2"
  [(set_attr "cc" "unchanged")])

;; add a,b,c;  mov [c], d => mov [a+b], d
(define_peephole2
  [(set (match_operand:HI 0 "pic30_register_operand" "")
        (plus:HI (match_operand:HI 1 "pic30_register_operand" "")
                 (match_operand:HI 2 "pic30_register_operand" "")))
   (set (match_operand:HI 3 "pic30_register_operand" "")
        (mem:HI (match_dup 0)))]
  "((!pic30_ecore_target()) && (peep2_reg_dead_p(2, operands[0]) || (REGNO(operands[0]) == REGNO(operands[3]))))"
  [(set (match_dup 3)
        (mem:HI (plus:HI (match_dup 1) (match_dup 2))))]
)

(define_peephole
 [(set (match_operand:HI 0 "pic30_register_operand" "=r")
       (match_dup 0))]
 ""
 "; mov %0, %0"
)

(define_peephole
 [(set (match_operand:HI 0 "pic30_register_operand" "=r")
       (match_operand:HI 1 "pic30_move_operand" "RS<>rTQ"))
  (set (match_operand:HI 2 "pic30_register_operand" "=r")
       (match_dup 0))]
 "dead_or_set_p(insn, operands[0])"
 "mov %1, %2"
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; GCC often loads a function parameter into an arbitrary register,
;; then moves that register to one appropriate for the function call.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; mov #addr,r0; mov r0,r1 becomes mov #addr,r1

(define_peephole
  [(set (match_operand:HI 0 "pic30_register_operand"        "=r")
        (match_operand:HI 1 "pic30_symbolic_address_operand" "q"))
   (set (match_operand:HI 2 "pic30_register_operand"        "=r")
        (match_dup 0))]
 "dead_or_set_p(insn, operands[0])"
  "*
{ rtx sym;

  sym = pic30_program_space_operand_p(operands[1]);
  if (sym) {
    tree fndecl = SYMBOL_REF_DECL(sym);
    tree fndecl_attrib;
    char *access=0;
    int slot = 0;

    if ((fndecl_attrib =lookup_attribute(IDENTIFIER_POINTER(pic30_identBoot[0]),
                                         DECL_ATTRIBUTES(fndecl)))) {
      access=\"boot\";
    } else if ((fndecl_attrib = lookup_attribute(
                                IDENTIFIER_POINTER(pic30_identSecure[0]),
                                DECL_ATTRIBUTES(fndecl)))) {
      access=\"secure\";
    }
    if (access) {
      if (TREE_VALUE(fndecl_attrib)) {
        if (TREE_CODE(TREE_VALUE(TREE_VALUE(fndecl_attrib))) == INTEGER_CST) {
          slot = TREE_INT_CST_LOW(TREE_VALUE(TREE_VALUE(fndecl_attrib)));
        } else access = 0;
      } else access = 0;
    }
    if (access) {
      static char buffer[25];
      sprintf(buffer,\"mov #%s(%d),%%2\", access, slot);
      return buffer;
    } else {
      return \"mov #handle(%1),%2\";
    }
  } else {
    return \"mov #%1,%2\";
  }
}"
  [(set_attr "cc" "clobber")])

;; mov.d [wn+k],r0; mov.d r0,r1 becomes mov.d [wn+k],r1

(define_peephole
  [(set (match_operand:M32BIT 0 "pic30_register_operand" "=r")
        (match_operand:M32BIT 1 "pic30_Q_operand"   "Q"))
   (set (match_operand:M32BIT 2 "pic30_register_operand" "=r")
        (match_dup 0))
  ]
 "dead_or_set_p(insn, operands[0])"
 "*
{
	int idSrc, idDst;

	idDst = REGNO(operands[2]);
	idSrc = REGNO(XEXP(XEXP(operands[1],0),0));
  if (pic30_psrd_psrd_errata(NULL,operands[1])) {
    pic30_rtx_nops++;
    if (idDst == idSrc) {
      return \"mov %Q1,%d2\;nop\;mov %1,%2\";
    } else {
      return \"mov %1,%2\;nop\;mov %Q1,%d2\";
	}
  } else {
    if (idDst == idSrc) {
		return \"mov %Q1,%d2\;mov %1,%2\";
    } else {
		return \"mov %1,%2\;mov %Q1,%d2\";
	}
  }
}"
  [(set_attr "cc" "clobber")])

;(define_peephole
;  [(set (match_operand:SI 0 "pic30_register_operand" "=r")
;        (match_operand:SI 1 "pic30_Q_operand"   "Q"))
;   (set (match_operand:SI 2 "pic30_register_operand" "=r")
;        (match_dup 0))
;  ]
; "dead_or_set_p(insn, operands[0])"
; "*
;{
;  int idSrc, idDst;
;
;  idDst = REGNO(operands[2]);
;  idSrc = REGNO(XEXP(XEXP(operands[1],0),0));
;  if (pic30_psrd_psrd_errata(NULL,operands[1])) {
;    if (idDst == idSrc) {
;    pic30_rtx_nops++;
;      return \"mov %Q1,%d2\;nop\;mov %1,%2\";
;    } else {
;     return \"mov %1,%2\;nop\;mov %Q1,%d2\";
;    }
;  } else {
;    if (idDst == idSrc) {
;      return \"mov %Q1,%d2\;mov %1,%2\";
;    } else {
;     return \"mov %1,%2\;mov %Q1,%d2\";
;    }
;  }
;}"
;  [(set_attr "cc" "clobber")])

;; mov.d a,r0; mov.d r0,r1 becomes mov.d a,r1

(define_peephole
  [(set (match_operand:M32BIT 0 "pic30_register_operand" "=r")
        (match_operand:M32BIT 1 "pic30_T_operand"   "T"))
   (set (match_operand:M32BIT 2 "pic30_register_operand" "=r")
        (match_dup 0))
  ]
 "dead_or_set_p(insn, operands[0])"
 "*
{
  if (pic30_psrd_psrd_errata(NULL,operands[1])) {
    pic30_rtx_nops++;
    return \"mov %1,%2\;nop\;mov %Q1,%d2\";
  } else {
	return \"mov %1,%2\;mov %Q1,%d2\";
  }
}"
  [(set_attr "cc" "clobber")])

;(define_peephole
;  [(set (match_operand:SI 0 "pic30_register_operand" "=r")
;        (match_operand:SI 1 "pic30_T_operand"   "T"))
;   (set (match_operand:SI 2 "pic30_register_operand" "=r")
;        (match_dup 0))
;  ]
; "dead_or_set_p(insn, operands[0])"
; "*
;{
;	return \"mov %1,%2\;mov %Q1,%d2\";
;}"
;  [(set_attr "cc" "clobber")])

;; mov.q #k,r0; mov.q r0,r1 becomes mov.q #k,r1

(define_peephole
  [(set (match_operand:DF 0 "pic30_register_operand" "=r,r")
        (match_operand:DF 1 "immediate_operand" "G,i"))
   (set (match_operand:DF 2 "pic30_register_operand" "=r,r")
        (match_dup 0))
  ]
 "dead_or_set_p(insn, operands[0])"
 "*
  {
    REAL_VALUE_TYPE r;
    long l[4] = { 0 };

    switch (which_alternative) {
      case 0:
        return \"mul.uu %2,#0,%2\;\"
               \"mul.uu %t2,#0,%t2\";
      case 1:
        REAL_VALUE_FROM_CONST_DOUBLE(r, operands[1]);
        REAL_VALUE_TO_TARGET_DOUBLE(r, l);
        if (l[0] == 0) {
          return \"mul.uu %0,#0,%2\;\"
                 \"mov #%x1,%t2\;\"
                 \"mov #%w1,%q2\";
        } else {
          return \"mov #%z1,%2\;\"
                 \"mov #%y1,%d2\;\"
                 \"mov #%x1,%t2\;\"
                 \"mov #%w1,%q2\";
        }
      default: gcc_assert(0);
    }
   }"
  [
    (set_attr "cc" "clobber")
  ]
)

;; mov.q [wn+k],r0; mov.q r0,r1 becomes mov.q [wn+k],r1

(define_peephole
  [(set (match_operand:DF 0 "pic30_register_operand" "=r")
        (match_operand:DF 1 "pic30_Q_operand"   "Q"))
   (set (match_operand:DF 2 "pic30_register_operand" "=r")
        (match_dup 0))
  ]
 "dead_or_set_p(insn, operands[0])"
 "*
{
  int idSrc, idDst;
  char temp[48];
  char save[48];
  static char szInsn[48];

  szInsn[0] = 0;
  temp[0] = 0;
  save[0] = 0;

  idDst = REGNO(operands[2]);
  idSrc = REGNO(XEXP(XEXP(operands[1],0),0));
  strcpy(temp, \"mov %1,%2\;\");
  if (idDst != idSrc)
    strcat(szInsn, temp);
  else
    strcat(save, temp);
  idDst++;
  strcpy(temp, \"mov %Q1,%d2\;\");
  if (idDst != idSrc)
    strcat(szInsn, temp);
  else
    strcat(save, temp);
  idDst++;
  strcpy(temp, \"mov %R1,%t2\;\");
  if (idDst != idSrc)
    strcat(szInsn, temp);
  else
    strcat(save, temp);
  idDst++;
  strcpy(temp, \"mov %S1,%q2\;\");
  if (idDst != idSrc)
    strcat(szInsn, temp);
  else
    strcat(save, temp);
  idDst++;
  if (save[0]) {
    save[strlen(save)-2] = 0;
    strcat(szInsn, save);
  }
  return szInsn;
}"
  [(set_attr "cc" "clobber")])

;;
;; Substitute RETLW #k,Wn for MOV #k,Wn; RETURN
;;
(define_peephole
  [(set (match_operand:QI 0 "pic30_register_operand" "=r")
        (match_operand:QI 1 "pic30_J_operand"   "J"))
   (return)
  ]
 "pic30_null_epilogue_p(1)"
 "*
{
        pic30_set_function_return(TRUE);
        if (REGNO(operands[0]) == WR0_REGNO)
        {
                return \"retlw #%1,%0\";
        }
        else
        {
                return \"mov.b #%1,%0\;return\";
        }
}"
  [(set_attr "cc" "clobber")])


(define_peephole
  [(set (match_operand:HI 0 "pic30_register_operand" "=r")
	(match_operand:HI 1 "pic30_J_operand"   "J"))
   (return)
  ]
 "pic30_null_epilogue_p(1)"
 "*
{
	pic30_set_function_return(TRUE);
	if (REGNO(operands[0]) == WR0_REGNO)
	{
		return \"retlw #%1,%0\";
	}
	else
	{
		return \"mov #%1,%0\;return\";
	}
}"
  [(set_attr "cc" "clobber")])

(define_peephole
  [(set (match_operand:SI 0 "pic30_register_operand" "=r")
	(match_operand:SI 1 "pic30_J_operand"   "J"))
   (return)
  ]
 "pic30_null_epilogue_p(1)"
 "*
{
	pic30_set_function_return(TRUE);
	if (REGNO(operands[0]) == WR0_REGNO)
	{
		return \"mov #0,%d0\;retlw #%1,%0\";
	}
	else
	{
		return \"mov #0,%d0\;mov #%1,%0\;return\";
	}
}"
  [(set_attr "cc" "clobber")])

;; Substitute bra/goto f for rcall/call f; ret

(define_peephole
  [(call (match_operand:QI 0 "memory_operand" "R,mp")
         (match_operand:HI 1 "pic30_general_operand" ""))
   (return)
  ]
  "pic30_null_epilogue_p(1) /* a */"
  "*
{
	pic30_set_function_return(TRUE);
	switch (which_alternative)
	{
	static char szInsn[48];
	case 0:
		sprintf(szInsn, \"goto %s\",
				reg_names[REGNO(XEXP(operands[0],0))]);
		return szInsn;
	case 1:
		if (pic30_near_function_p(operands[0]))
			return \"bra %0\";
		else
			return \"goto %0\";
	default:
		gcc_assert(0);
	}
}")

(define_peephole
  [(set (match_operand 0 "pic30_register_operand"         "r,r")
        (call (match_operand:QI 1 "memory_operand"  "R,mp")
              (match_operand:HI 2 "pic30_general_operand" "")))
   (return)
  ]
  "pic30_null_epilogue_p(1)"
  "*
{
	pic30_set_function_return(TRUE);
	switch (which_alternative)
	{
	static char szInsn[48];
	case 0:
		sprintf(szInsn, \"goto %s\",
				reg_names[REGNO(XEXP(operands[1],0))]);
		return szInsn;
	case 1:
		if (pic30_near_function_p(operands[1]))
			return \"bra %1\";
		else
			return \"goto %1\";
	default:
		gcc_assert(0);
	}
}")

;; Combine mov.w pairs to mov.d

(define_peephole
  [(set (match_operand:HI 0 "pic30_register_operand" "=r")
        (match_operand:HI 1 "pic30_register_operand"  "r"))
   (set (match_operand:HI 2 "pic30_register_operand" "=r")
        (match_operand:HI 3 "pic30_register_operand"  "r"))
  ]
  "pic30_registerpairs_p(operands[0],operands[2],operands[1],operands[3])"
  "*
{
	if (REGNO(operands[0]) < REGNO(operands[2]))
	{
		return \"mov.d %1,%0\";
	}
	else
	{
		return \"mov.d %3,%2\";
	}
}"
  [(set_attr "cc" "clobber")])
  
;; Combine mov.w [Wn],Wm; mov.w [Wn+2],Wm+1 to mov.d [Wn],Wm

(define_peephole
  [(set (match_operand:HI 0 "pic30_register_operand" "=r")
        (match_operand:HI 1 "pic30_R_operand"   "R"))
   (set (match_operand:HI 2 "pic30_register_operand" "=r")
        (match_operand:HI 3 "pic30_Q_operand"   "Q"))
  ]
  "(REGNO(operands[0]) == (REGNO(operands[2]) - 1)) &&
   (IS_EVEN_REG(REGNO(operands[0]))) &&
   (pic30_Q_base(operands[3]) == REGNO(operands[1])) &&
   (pic30_Q_displacement(operands[3]) == 2) &&
   (pic30_psrd_psrd_errata_movd(NULL,operands[1]) == 0)"
  "mov.d %1,%0"
  [(set_attr "cc" "clobber")])

;; Zero-extend followed by shift

(define_peephole
  [(set (match_operand:SI 0 "pic30_register_operand"                  "=r")
        (zero_extend:SI (match_operand:QI 1 "pic30_register_operand"   "r")) )
   (set (match_dup 0)
        (ashift:SI (match_dup 0)
                   (match_operand:HI 2 "pic30_imm16plus_operand" "i")))
  ]
  ""
  "*
{
	int n = INTVAL(operands[2]);
	if (n == 16)
	{
		return \"ze %1,%d0\;mov #0,%0\";
	}
	else if (n >= 24)
	{
		return \"sl %1,#%K2,%d0\;mov #0,%0\";
	}
	else
	{
		return \"ze %1,%0\;sl %0,#%K2,%d0\;mov #0,%0\";
	}
}"
  [(set_attr "cc" "clobber")])


(define_peephole2
  [(set (match_operand:HI 0 "pic30_register_operand" "")
        (match_operand:HI 1 "pic30_near_operand"  "") )
   (set (match_operand:SI 2 "pic30_wreg_operand" "")
        (mult:SI (zero_extend:SI (match_dup 0))
                 (zero_extend:SI (match_operand 3 "immediate_operand"   ""))))]
  "((INTVAL(operands[3]) == 2) && (peep2_reg_dead_p(2, operands[0]) || (REGNO(operands[0]) == REGNO(operands[2]))))"
  [(set (subreg:HI (match_dup 2) 0)
        (ashift:HI (match_dup 1)
                   (const_int 1)))]
  ""
  )

(define_peephole2
  [(set (match_operand:HI 0 "pic30_register_operand" "")
        (match_operand:HI 1 "pic30_near_operand"  "") )
   (set (match_operand:SI 2 "pic30_register_operand" "")
        (mult:SI (zero_extend:SI (match_dup 0))
                 (match_operand:SI 3 "immediate_operand"   "")))
   (set (match_operand:HI 4 "pic30_wreg_operand" "" )
        (match_operand:HI 5 "pic30_register_operand" ""))
]
  "((INTVAL(operands[3]) == 2) && (REGNO(operands[2]) == REGNO(operands[5])) &&     (peep2_reg_dead_p(3, operands[0]) || (REGNO(operands[0]) == REGNO(operands[4]))))"
  [(set (subreg:HI (match_dup 2) 0)
        (ashift:HI (match_dup 1)
                   (const_int 1)))]
  ""
  )

(define_peephole2
  [(match_scratch:HI 5 "a") 
   (set (match_operand:HI 0 "pic30_register_operand" "")
        (match_operand:HI 1 "pic30_near_operand"  ""))
   (set (match_operand:SI 2 "pic30_register_operand" "")
        (mult:SI (zero_extend:SI (match_dup 0))
                 (match_operand:SI 3 "immediate_operand"   "")))
   (set (match_operand:HI 6 "pic30_register_operand" "")
        (plus:HI (match_operand:HI 7 "pic30_register_operand" "")
                 (match_operand:HI 4 "pic30_math_operand" "")))]
  "((INTVAL(operands[3]) == 2) && (REGNO(operands[7]) == REGNO(operands[2])) &&     (peep2_reg_dead_p(3, operands[0]) ||                                              (REGNO(operands[0]) == REGNO(operands[6])) ||                                   (REGNO(operands[0]) == REGNO(operands[2]))) &&                                (peep2_reg_dead_p(3, operands[2]) ||                                              (REGNO(operands[2]) == REGNO(operands[6]))))"
  [(set (match_dup 5)
        (ashift:HI (match_dup 1)
                   (const_int 1)))
   (set (match_dup 6) 
        (plus:HI (match_dup 4) (match_dup 5)))]
  ""
  )

(define_peephole2
  [(match_scratch:HI 5 "a") 
   (set (match_operand:HI 0 "pic30_register_operand" "")
        (match_operand:HI 1 "pic30_near_operand"  ""))
   (set (match_operand:SI 2 "pic30_register_operand" "")
        (mult:SI (zero_extend:SI (match_dup 0))
                 (match_operand:SI 3 "immediate_operand"   "")))
   (set (match_operand:HI 6 "pic30_register_operand" "")
        (plus:HI (match_operand:HI 4 "pic30_math_operand" "")
                 (match_operand:HI 7 "pic30_register_operand" "")))]
  "((INTVAL(operands[3]) == 2) && (REGNO(operands[7]) == REGNO(operands[2])) &&     (peep2_reg_dead_p(3, operands[0]) ||                                              (REGNO(operands[0]) == REGNO(operands[6])) ||                                   (REGNO(operands[0]) == REGNO(operands[2]))) &&                                (peep2_reg_dead_p(3, operands[2]) ||                                              (REGNO(operands[2]) == REGNO(operands[6]))))"
  [(set (match_dup 5)
        (ashift:HI (match_dup 1)
                   (const_int 1)))
   (set (match_dup 6) 
        (plus:HI (match_dup 4) (match_dup 5)))]
  ""
  )

(define_peephole
  [(set (match_operand:SI 0 "pic30_register_operand"                "=r")
        (zero_extend:SI (match_operand:QI 1 "pic30_register_operand" "r")) )
   (set (match_dup 0)
        (ashift:SI (match_dup 0)
                   (match_operand:HI 2 "pic30_imm8_operand"    "i")))
  ]
  ""
  "*
   {
     return \"sl %1,#%2,%0\;\"
            \"mov #0,%d0\";
   }"
  [
    (set_attr "cc" "clobber")
  ]
)

;; bit set optimizations

(define_peephole
  [(set (match_operand:SI 0 "pic30_register_operand" "=r")
	(match_operand:SI 1 "pic30_R_operand"   "R"))
   (set (match_dup 0)
        (ior:SI  (match_dup 0)
                 (match_operand:SI 2 "const_int_operand"   "i")))
   (set (match_dup 0)
        (ior:SI  (match_dup 0)
                 (match_operand:SI 3 "const_int_operand"   "i")))
   (set (match_dup 1)
	(match_dup 0))
  ]
 "dead_or_set_p(insn, operands[0]) &&
  (pic30_one_bit_set(GET_MODE(operands[0]),operands[2],1)) &&
  (pic30_which_bit(INTVAL(operands[2]))<16) &&
  (pic30_one_bit_set(GET_MODE(operands[0]),operands[3],1)) &&
  (pic30_which_bit(INTVAL(operands[2]))<16)"
 "bset %1,#%b2\;bset %1,#%b3"
  [(set_attr "cc" "clobber")])

;; Improve mov.b Wd,sfr

(define_peephole
  [(set (match_operand:QI 0 "pic30_near_operand" "=U,U")
	(match_operand:QI 1 "pic30_register_operand"    "d,a"))
   (set (match_operand:QI 2 "pic30_near_operand" "=U,U")
	(match_dup 1))
   (set (match_operand:QI 3 "pic30_near_operand" "=U,U")
	(match_dup 1))
   (set (match_operand:QI 4 "pic30_near_operand" "=U,U")
	(match_dup 1))
   (set (match_operand:QI 5 "pic30_near_operand" "=U,U")
	(match_dup 1))
  ]
 "!(pic30_errata_mask & exch_errata)"
 "@
  exch w0,%1\;mov.b WREG,%0\;mov.b WREG,%2\;mov.b WREG,%3\;mov.b WREG,%4\;mov.b WREG,%5\;exch w0,%1
  mov.b WREG,%0\;mov.b WREG,%2\;mov.b WREG,%3\;mov.b WREG,%4\;mov.b WREG,%5"
  [(set_attr "cc" "unchanged")])

(define_peephole
  [(set (match_operand:QI 0 "pic30_near_operand" "=U,U")
	(match_operand:QI 1 "pic30_register_operand"    "d,a"))
   (set (match_operand:QI 2 "pic30_near_operand" "=U,U")
	(match_dup 1))
   (set (match_operand:QI 3 "pic30_near_operand" "=U,U")
	(match_dup 1))
   (set (match_operand:QI 4 "pic30_near_operand" "=U,U")
	(match_dup 1))
  ]
 "!(pic30_errata_mask & exch_errata)"
 "@
  exch w0,%1\;mov.b WREG,%0\;mov.b WREG,%2\;mov.b WREG,%3\;mov.b WREG,%4\;exch w0,%1
  mov.b WREG,%0\;mov.b WREG,%2\;mov.b WREG,%3\;mov.b WREG,%4"
  [(set_attr "cc" "unchanged")])

(define_peephole
  [(set (match_operand:QI 0 "pic30_near_operand" "=U,U")
	(match_operand:QI 1 "pic30_register_operand"    "d,a"))
   (set (match_operand:QI 2 "pic30_near_operand" "=U,U")
	(match_dup 1))
   (set (match_operand:QI 3 "pic30_near_operand" "=U,U")
	(match_dup 1))
  ]
 "!(pic30_errata_mask & exch_errata)"
 "@
  exch w0,%1\;mov.b WREG,%0\;mov.b WREG,%2\;mov.b WREG,%3\;exch w0,%1
  mov.b WREG,%0\;mov.b WREG,%2\;mov.b WREG,%3"
  [(set_attr "cc" "unchanged")])

(define_peephole
  [(set (match_operand:QI 0 "pic30_near_operand" "=U,U")
	(match_operand:QI 1 "pic30_register_operand"    "d,a"))
   (set (match_operand:QI 2 "pic30_near_operand" "=U,U")
	(match_dup 1))
  ]
 "!(pic30_errata_mask & exch_errata)"
 "@
  exch w0,%1\;mov.b WREG,%0\;mov.b WREG,%2\;exch w0,%1
  mov.b WREG,%0\;mov.b WREG,%2"
  [(set_attr "cc" "unchanged")])

;
;  mov val, reg
;  mov reg, reg2
;
;  -> mov val, reg2
;
;  don't know why we need them, seems the register allocator should do better
;

(define_peephole2
  [(set (match_operand:QI 0 "pic30_register_operand" "=r")
        (match_operand:QI 1 "immediate_operand" "i"))
   (set (match_operand:QI 2 "pic30_register_operand" "=r")
        (match_dup 0))]
  "peep2_reg_dead_p(2,operands[0])"
  [(set (match_dup 2)
        (match_dup 1))]
  ""
)

(define_peephole
  [(set (match_operand:QI 0 "pic30_register_operand" "=r")
        (match_operand:QI 1 "immediate_operand" "i"))
   (set (match_operand:QI 2 "pic30_register_operand" "=r")
        (match_dup 0))]
  "dead_or_set_p(insn,operands[0])"
  "mov.b #%1,%2"
  [(set_attr "cc" "unchanged")])

(define_peephole
  [(set (match_operand:QI 0 "pic30_register_operand" "=r")
        (match_operand:QI 1 "pic30_near_operand" "U"))
   (set (match_operand:QI 2 "pic30_register_operand" "=r")
        (match_dup 0))]
  "dead_or_set_p(insn,operands[0])"
  "mov #%1,%2\;mov.b [%2],%2"
  [(set_attr "cc" "unchanged")])

(define_peephole
  [(set (match_operand:QI 0 "pic30_register_operand" "=r")
        (match_operand:QI 1 "pic30_general_operand" "g"))
   (set (match_operand:QI 2 "pic30_register_operand" "=r")
        (match_dup 0))]
  "dead_or_set_p(insn,operands[0])"
  "mov.b %1,%2"
  [(set_attr "cc" "unchanged")])
 
(define_peephole
  [(set (match_operand:HI 0 "pic30_register_operand" "=r")
        (match_operand:HI 1 "immediate_operand" "i"))
   (set (match_operand:HI 2 "pic30_register_operand" "=r")
        (match_dup 0))]
  "dead_or_set_p(insn,operands[0])"
  "mov.w #%1,%2"
  [(set_attr "cc" "unchanged")])

(define_peephole
  [(set (match_operand:HI 0 "pic30_register_operand" "=r")
        (match_operand:HI 1 "pic30_general_operand" "g"))
   (set (match_operand:HI 2 "pic30_register_operand" "=r")
        (match_dup 0))]
  "dead_or_set_p(insn,operands[0])"
  "mov.w %1,%2"
  [(set_attr "cc" "unchanged")])

(define_peephole
  [(set (match_operand:HI 0 "register_operand" "=r")
        (match_operand:HI 1 "general_operand" "g"))
   (set (match_dup 1)
        (match_dup 0))]
  "dead_or_set_p(insn,operands[0])"
  "; move deleted"
  [(set_attr "cc" "unchanged")])

(define_peephole
  [(set (match_operand:QI 0 "pic30_register_operand" "=r")
        (match_operand:QI 1 "pic30_general_operand" "g"))
   (set (match_dup 1)
        (match_dup 0))]
  "pic30_dead_or_set_p(NEXT_INSN(insn),operands[0])"
  "; move deleted"
  [(set_attr "cc" "unchanged")])

(define_peephole
  [(set (match_operand:SI 0 "pic30_register_operand" "=r")
        (match_operand:SI 1 "pic30_general_operand" "g"))
   (set (match_dup 1)
        (match_dup 0))]
  "pic30_dead_or_set_p(NEXT_INSN(insn),operands[0])"
  "; move deleted"
  [(set_attr "cc" "unchanged")])

;
; some general const int optimizations
;

(define_peephole2
 [(set (match_operand:HI 0 "pic30_register_operand" "")
       (match_operand:HI 1 "immediate_operand" ""))
  (set (match_operand:HI 2 "pic30_near_operand" "")
       (match_dup 0))]
 "((INTVAL(operands[1]) == 255) && 
   (!pic30_volatile_operand(operands[2],HImode)) &&
   (peep2_regno_dead_p(2, REGNO(operands[0]))))"
 [(set (match_dup 2) (const_int 0))
  (set (subreg:QI (match_dup 2) 0) (const_int -1))]
 ""
)

(define_peephole2
 [(set (match_operand:HI 0 "pic30_register_operand" "")
       (match_operand:HI 1 "immediate_operand" ""))
  (set (match_operand:HI 2 "pic30_near_operand" "")
       (match_dup 0))]
 "((INTVAL(operands[1]) == -256) && 
   (!pic30_volatile_operand(operands[2],HImode)) &&
   (peep2_regno_dead_p(2, REGNO(operands[0]))))"
 [(set (match_dup 2) (const_int -1))
  (set (subreg:QI (match_dup 2) 0) (const_int 0))]
 ""
)

;
; add become subtract
;
(define_peephole2
 [(set (match_operand:HI 0 "pic30_register_operand" "")
       (match_operand:HI 1 "immediate_operand" ""))
  (set (match_operand:HI 2 "pic30_register_operand" "")
       (plus:HI (match_dup 2)
                (match_dup 0)))]
 "((INTVAL(operands[1]) <= 0) && (INTVAL(operands[1]) >= -1023) && peep2_regno_dead_p(2,REGNO(operands[0])))"
 [ (set (match_dup 2)
        (minus:HI (match_dup 2) (match_dup 1)))]
 "{ operands[1] = gen_rtx_CONST_INT(HImode,-INTVAL(operands[1])); }"
)

(define_peephole2
 [(set (match_operand:HI 0 "pic30_register_operand" "")
       (match_operand:HI 1 "immediate_operand" ""))
  (set (match_operand:HI 2 "pic30_register_operand" "")
       (plus:HI (match_operand:HI 3 "pic30_register_operand" "")
                (match_dup 0)))]
 "((INTVAL(operands[1]) <= 0) && (INTVAL(operands[1]) >= -31) && peep2_regno_dead_p(2,REGNO(operands[0])))"
 [ (set (match_dup 2)
        (minus:HI (match_dup 3) (match_dup 1)))]
 "{ operands[1] = gen_rtx_CONST_INT(HImode,-INTVAL(operands[1])); }"
)

;
; combining two HI's into an SI
;

(define_peephole2
 [(set (match_operand:SI 0 "pic30_register_operand" "")
       (zero_extend:SI (match_operand:HI 1 "pic30_register_operand" "")))
  (set (match_operand:SI 2 "pic30_register_operand" "")
       (ashift:SI (match_dup 0) (const_int 16)))
  (set (match_operand:SI 3 "pic30_register_operand" "")
       (zero_extend:SI (match_operand:HI 4 "pic30_register_operand" "")))
  (set (match_operand:SI 5 "pic30_register_operand" "")
       (ior:SI (match_dup 2)
               (match_dup 3)))]
 "((REGNO(operands[5]) != REGNO(operands[1])) && pic30_dead_or_set_p(peep2_next_insn(4), operands[2]) && pic30_dead_or_set_p(peep2_next_insn(4),operands[3]))"
 [(set (match_dup 5) (match_dup 4))
  (set (match_dup 0) (match_dup 1))]
 "{ int reg = REGNO(operands[5]);
    operands[5] = gen_rtx_REG(HImode,reg);
    operands[0] = gen_rtx_REG(HImode,reg+1); }"
)

; [(set (subreg:HI (match_dup 5) 0) (match_dup 4))
;  (set (subreg:HI (match_dup 5) 2) (match_dup 1))]

(define_peephole2
 [(set (match_operand:SI 0 "pic30_register_operand" "")
       (zero_extend:SI (match_operand:HI 1 "pic30_register_operand" "")))
  (set (match_operand:SI 2 "pic30_register_operand" "")
       (ashift:SI (match_dup 0) (const_int 16)))
  (set (match_operand:SI 3 "pic30_register_operand" "")
       (zero_extend:SI (match_operand:HI 4 "pic30_register_operand" "")))
  (set (match_operand:SI 5 "pic30_register_operand" "")
       (ior:SI (match_dup 2)
               (match_dup 3)))]
 "(((REGNO(operands[5])+1) != REGNO(operands[4])) && pic30_dead_or_set_p(peep2_next_insn(4), operands[2]) && pic30_dead_or_set_p(peep2_next_insn(4),operands[3]))"
 [(set (match_dup 5) (match_dup 1))
  (set (match_dup 0) (match_dup 4))]
 "{ int reg = REGNO(operands[5]);
    operands[5] = gen_rtx_REG(HImode,reg+1);
    operands[0] = gen_rtx_REG(HImode,reg); }"
)

(define_peephole2
 [(set (match_operand:SI 0 "pic30_register_operand" "")
       (zero_extend:SI (match_operand:HI 1 "pic30_register_operand" "")))
  (set (match_operand:SI 2 "pic30_register_operand" "")
       (ashift:SI (match_dup 0) (const_int 16)))
  (set (match_operand:SI 3 "pic30_register_operand" "")
       (zero_extend:SI (match_operand:HI 4 "pic30_register_operand" "")))
  (set (match_operand:SI 5 "pic30_register_operand" "")
       (ior:SI (match_dup 2)
               (match_dup 3)))]
 "(REGNO(operands[0])+1 != REGNO(operands[4]))"
 [
  (set (match_dup 2) (match_dup 1))
  (set (match_dup 3) (match_dup 4))
  (set (match_dup 5) (match_dup 0))
 ] 
 "{ int reg = REGNO(operands[0]);
    operands[2] = gen_rtx_REG(HImode, reg+1);
    operands[3] = gen_rtx_REG(HImode, reg);  }"
)

(define_peephole2
 [(set (match_operand:SI 0 "pic30_register_operand" "")
       (match_operand:SI 1 "pic30_move_operand" ""))
  (set (match_operand:SI 2 "pic30_register_operand" "")
       (match_dup 0))]
 "peep2_reg_dead_p(2, operands[0])"
 [(set (match_dup 2) (match_dup 1))]
)

(define_peephole2
 [(set (match_operand:SI 0 "pic30_register_operand" "")
       (match_operand:SI 1 "pic30_register_operand" ""))
  (set (match_operand:SI 2 "pic30_move_operand" "")
       (match_dup 0))]
 "peep2_reg_dead_p(2, operands[0])"
 [(set (match_dup 2) (match_dup 1))]
)

(define_peephole2
 [(set (match_operand:SI 0 "pic30_move_operand" "")
       (match_operand:SI 1 "pic30_register_operand" ""))
  (set (match_operand:SI 2 "pic30_register_operand" "")
       (match_dup 0))]
 "peep2_reg_dead_p(2, operands[1])"
 [(set (match_dup 0) (match_dup 1))
  (set (match_dup 2) (match_dup 1))]
)

; [(set (subreg:HI (match_dup 5) 2) (match_dup 1))
;  (set (subreg:HI (match_dup 5) 0) (match_dup 4))]

;; (define_peephole
;;   [(set (match_operand:SI 0 "pic30_register_operand"                "=r")
;;         (sign_extend:SI (match_operand:HI 1 "pic30_register_operand" "r")) )
;;    (set (match_operand:SF 2 "pic30_register_operand" "=r")
;;         (call (match_operand:QI 3 "memory_operand"  "m")
;;               (match_operand:HI 4 "pic30_general_operand" "g")))
;;   ]
;;   "isfloatsisf(operands[3])"
;;   "*
;; {
;; 	if (TARGET_SMALL_CODE)
;; 		return \"rcall __floathisf\";
;; 	else
;; 		return \"call __floathisf\";
;; }")

;; Fixed Point

;; Use mode iterators alot here, because they are "new" and these are new
;;   patterns (and because most of our Fract/Accum types are the same size

; Two sizs of Fract: Q15, Q31
(define_mode_iterator Q15  [QQ HQ])
(define_mode_iterator Q31  [SQ DQ TQ])

(define_mode_iterator UQ15 [UQQ UHQ])
(define_mode_iterator UQ31 [USQ UDQ UTQ])

(define_mode_iterator QUQ15 [QQ UQQ HQ UHQ])
(define_mode_iterator QUQ31 [SQ USQ DQ UDQ TQ UTQ])

; One size of Accum: ACC
(define_mode_iterator ACC   [HA SA DA TA])
(define_mode_iterator UACC  [UHA USA UDA UTA])
(define_mode_iterator AUACC [HA UHA SA USA DA UDA TA UTA])


;; *** helper patterns

; for use in the prologue to set the right initial value
(define_insn "setCORCON"
  [(set (reg:HI CORCON)
        (match_operand:HI 0 "pic30_register_operand" "r"))]
  ""
  "mov %0,_CORCON"
)

; for use in pic30_track_sfrs to adjust the corcon
;   bit 0 cannot be adjusted
;   bit n will be set or cleared based upon the value of bit 0
;(define_insn "setSAT"
;  [(set (reg:HI CORCON)
;        (unspec_volatile:HI [
;           (match_operand:HI 0 "immediate_operand" "i")
;        ] UNSPECV_SETSAT))
;  ]
;  ""
;  "*
;  {
;    if (INTVAL(operands[0]) == CORCON_SET_SATA + 1) {
;      return \"bset _CORCON,#7\";
;    } else if (INTVAL(operands[0]) == CORCON_SET_SATB + 1) {
;      return \"bset _CORCON,#6\";
;    } else if (INTVAL(operands[0]) == CORCON_SET_SATA) {
;      return \"bclr _CORCON,#7\";
;    } else if (INTVAL(operands[0]) == CORCON_SET_SATB) {
;      return \"bclr _CORCON,#6\";
;    } else return \"; no CORCON modification needed\";
;  }
;  "
;)

(define_insn "abs<mode>2"
  [(set (match_operand:Q15   0 "pic30_register_operand" "=r")
        (abs:Q15 
          (match_operand:Q15 1 "pic30_register_operand"  "0")))]
  ""
  "btsc %1,#15\;neg %1,%0"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def")
  ]
)

(define_insn "bsetCORCON"
  [(set (reg:HI CORCON)
        (ior:HI (reg:HI CORCON)
                (match_operand 0 "const_int_operand"      "i,i,i")))]
  "(pic30_one_bit_set_p(INTVAL(operands[0])&0xffff))"
  "bset _CORCON,#%b0"
)

(define_insn "bclrCORCON"
  [(set (reg:HI CORCON)
        (and:HI (reg:HI CORCON)
                (match_operand 0 "const_int_operand"      "i,i,i")))]
  "(pic30_one_bit_set_p(((~INTVAL(operands[0]))&0xffff)))"
  "bclr.b _CORCON,#%B0"
)

;; *** load/store

(define_insn "mov<mode>_rimm"
   [(set (match_operand:QUQ15 0 "pic30_register_operand" "=r")
         (match_operand:QUQ15 1 "immediate_operand" "i"))]
   ""
   "mov #%1,%0"
  [
    (set_attr "type" "def")
  ]
)

(define_insn "mov<mode>_gen"
  [
    (set 
       (match_operand:QUQ15 0 "pic30_move_operand" "=rR<>, Q,r, TU,r, !TUrR<>,w,Q,w,TU,w,r,w,   R<>")
       (match_operand:QUQ15 1 "pic30_move_operand" " rR<>, r,Q, r,TU, TUrR<>, w,w,Q,w,TU,w,rR<>,w"))
  ]
  ""
  "@
   mov %1,%0
   mov %1,%0
   mov %1,%0
   mov %1,%0
   mov %1,%0
   push %1\;pop %0
   clr %0\;add %0
   mov %m1H,%0
   lac %1,%0
   push %m1H\;pop %0
   clr %0\;push %1\;pop %m0H
   mov %m1H,%0
   lac %1,%0
   push %m1H\;pop %0"
  [
    (set_attr "type" "defuse,use,defuse,etc,def,defuse,etc,use,use,etc,etc,def,use,use")
  ]
)

(define_expand "mov<mode>"
  [(set (match_operand:QUQ15 0 "pic30_move_operand" "")
        (match_operand:QUQ15 1 "pic30_move_operand" ""))]
  ""
  "
{ int result;

  result = pic30_emit_move_sequence(operands, <MODE>mode);

  if (result > 0) DONE;
  if (immediate_operand(operands[1],VOIDmode)) {
    rtx reg = operands[0];

    if (!pic30_register_operand(operands[0],<MODE>mode)) {
      reg = gen_reg_rtx(<MODE>mode);
      emit(
        gen_mov<mode>_rimm(reg,operands[1])
      );
      emit_move_insn(operands[0], reg);
      DONE;
    }
  }
}")

;;
;; larger moves cannot use the 'k'

(define_insn "mov<mode>_rimm"
  [
    (set (match_operand:QUQ31 0 "pic30_register_operand" "=r")
         (match_operand:QUQ31 1 "immediate_operand" "i"))
  ]
  ""
  "mov #%1,%0\;mov #%y1,%d0"
  [
    (set_attr "type" "def")
  ]
)

(define_insn "mov<mode>_gen"
  [
    (set 
      (match_operand:QUQ31 0 "pic30_move_operand" "=rR<>, r,   Q, r, TU,r, TU,R, w,TU,w,r,w,R,w")
      (match_operand:QUQ31 1 "pic30_move_operand" " r,    R<>, r, Q, r,TU, R,TU, w,w,TU,w,r,w,R"))
  ]
  "(pic30_psrd_psrd_errata(operands[0],operands[1]) == 0) &&
   (pic30_psrd_psrd_errata_movd(operands[0],operands[1]) == 0)"
  "*
   {
     const char *patterns[] = {
       \"mov.d %1,%0\",
       \"mov.d %1,%0\",
       \"mov.w %1,%0\;mov.w %d1,%Q0\",
       \"mov.w %1,%0\;mov.w %Q1,%d0\",               /* =r,Q */
       \"push.d %1\;pop %0+2\;pop %0\",
       \"push %1\;push %1+2\;pop.d %0\",
       \"push %I1\;push %D1\;pop %0+2\;pop %0\",
       \"push %1\;push %1+2\;pop %P0\;pop %p0\",
       \"clr %0\;add %0\",
       \"push %m1L\;push %m1H\;pop %0+2\;pop %0\",
       \"push %1\;push %1+2\;pop %m0H\;pop %m0L\",
       \"mov %m1L,%0\;mov %m1H,%d0\",
       \"mov %1,%m0L\;mov %d1,%m0H\",
       \"push %m1H\;push %m1L\;pop %I0\;pop %D0\",
       \"push %I1\;push %D1\;pop %m0H\;pop %m0L\"
     };

     /* check for early clobber */
     int src_regno,dst_regno,mode_n_regs;
     int overlap;

     dst_regno = REGNO(operands[0]);
     mode_n_regs = pic30_class_max_nregs(W_REGS,GET_MODE(operands[0]));

     switch (which_alternative) {
       default: /* no overlap possible */
                break;
       case 3: {
         /* mem ( plus ( reg, */
         rtx inner = XEXP(operands[1],0);
         src_regno = REGNO(XEXP(inner,0));
         overlap = src_regno-dst_regno;
         switch (overlap) {
           default: /* no overlap */
             break;
           case 0:  /* src == dst */
             return \"mov.w %Q1,%d0\;mov.w %1,%0\";
             break;
         }
         break;
       }
     }
     return patterns[which_alternative];
   }"
  [
    (set_attr "type" "def,defuse,use,use,etc,def,use,use,etc,etc,etc,def,etc,use,use")
  ]
)

(define_insn "mov<mode>_psrd_psrd_movd_errata_gen"
  [
    (set 
      (match_operand:QUQ31 0 "pic30_move_operand" "=rR<>, r,&r, Q, r, TU,r, TU,R, w,TU,w,r,w,R,w")
      (match_operand:QUQ31 1 "pic30_move_operand" " r,    R,<>, r, Q, r,TU, R,TU, w,w,TU,w,r,w,R"))
  ]
  "(pic30_psrd_psrd_errata_movd(operands[0],operands[1]) == 1)"
  "*
   {
     const char *patterns[] = {
       \"mov.d %1,%0\",
       \"mov %1,%0\;mov %Q1,%d0\",                    /* =r,R */
       \"mov %1,%0\;mov %1,%d0\",
       \"mov.w %1,%0\;mov.w %d1,%Q0\",
       \"mov.w %1,%0\;mov.w %Q1,%d0\",                /* =r,Q */
       \"push.d %1\;pop %0+2\;pop %0\",
       \"push %1\;push %1+2\;pop.d %0\",
       \"push %I1\;push %D1\;pop %0+2\;pop %0\",
       \"push %1\;push %1+2\;pop %P0\;pop %p0\",
       \"clr %0\;add %0\",
       \"push %m1L\;push %m1H\;pop %0+2\;pop %0\",
       \"push %1\;push %1+2\;pop %m0H\;pop %m0L\",
       \"mov %m1L,%0\;mov %m1H,%d0\",
       \"mov %1,%m0L\;mov %d1,%m0H\",
       \"push %m1H\;push %m1L\;pop %I0\;pop %D0\",
       \"push %I1\;push %D1\;pop %m0H\;pop %m0L\"
     };

     /* check for early clobber */
     int src_regno,dst_regno,mode_n_regs;
     int overlap;

     /* mem ( reg */
     rtx inner = operands[1];

     dst_regno = REGNO(operands[0]);
     mode_n_regs = pic30_class_max_nregs(W_REGS,GET_MODE(operands[0]));


     switch (which_alternative) {
       default: /* no overlap possible */
                break;
       case 4: 
         /* mem ( plus (reg */
         inner = XEXP(operands[1],0);
       case 1: {
          /* FALLSTHROUGH */
         src_regno = REGNO(XEXP(inner,0));
         overlap = src_regno-dst_regno;
         switch (overlap) {
           default: /* no overlap */
             break;
           case 0:  /* src == dst */
             return \"mov.w %Q1,%d0\;mov.w %1,%0\";    
             break;
         }
         break;
       }
     }
     return patterns[which_alternative];
   }"
  [
    (set_attr "type" "def,defuse,defuse,use,use,etc,def,use,use,etc,etc,etc,def,etc,use,use")
  ]
)

(define_expand "mov<mode>"
  [(set (match_operand:QUQ31 0 "pic30_move_d_operand" "")
        (match_operand:QUQ31 1 "pic30_move_d_operand" ""))]
  ""
  "
{ int result = pic30_emit_move_sequence(operands, <MODE>mode);

  if (result > 0) DONE;
  
  if (immediate_operand(operands[1],VOIDmode)) {
    rtx reg = operands[0];

    if (!pic30_register_operand(operands[0],<MODE>mode)) {
      reg = gen_reg_rtx(<MODE>mode);
      emit(
        gen_mov<mode>_rimm(reg,operands[1])
      );
      emit_move_insn(operands[0], reg);
      DONE;
    }
  }

  /* we may need a clobber here */
  if (pic30_move_d_operand(operands[1],<MODE>mode)) {
    emit(
      gen_mov<mode>_gen(operands[0], operands[1])
    );
    DONE;
  }
 
}")

;; *** add/sub
;  16-bit
(define_insn "add<mode>3"
  [(set (match_operand:QUQ15 0 "pic30_register_operand" "=r")
        (plus:QUQ15
           (match_operand:QUQ15 1 "pic30_register_operand" "r")
           (match_operand:QUQ15 2 "pic30_register_operand" "r")))]
  ""
  "add %1,%2,%0"
  [
    (set_attr "cc" "math")
    (set_attr "type" "etc")
  ]
)

(define_insn "sub<mode>3"
  [(set (match_operand:QUQ15 0 "pic30_register_operand" "=r")
        (minus:QUQ15
           (match_operand:QUQ15 1 "pic30_register_operand" "r")
           (match_operand:QUQ15 2 "pic30_register_operand" "r")))]
  ""
  "sub %1,%2,%0"
  [
    (set_attr "cc" "math")
    (set_attr "type" "etc")
  ]
)

;  signed saturating
(define_insn "ssadd<mode>3"
  [(set (match_operand:QUQ15 0 "pic30_register_operand" "=&r")
        (ss_plus:QUQ15
           (match_operand:QUQ15 1 "pic30_register_operand" "r")
           (match_operand:QUQ15 2 "pic30_register_operand" "r")))]
  "pic30_fp_inline_p()"
  "add %1,%2,%0\;bra nov,.L1_%=\;mov #0x7FFF,%0\;btsc %2,#15\;com %0,%0\n.L1_%=:\;"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "etc")
  ]
)

(define_insn "sssub<mode>3"
  [(set (match_operand:QUQ15 0 "pic30_register_operand" "=&r")
        (ss_minus:QUQ15
           (match_operand:QUQ15 1 "pic30_register_operand" "r")
           (match_operand:QUQ15 2 "pic30_register_operand" "r")))]
  "pic30_fp_inline_p()"
  "sub %1,%2,%0\;bra nov,.L1_%=\;mov #0x7FFF,%0\;btss %2,#15\;com %0,%0\n.L1_%=:\;"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "etc")
  ]
)

;  unsigned saturating - our unsigned mode really is the same width as signed
(define_insn "usadd<mode>3"
  [(set (match_operand:QUQ15 0 "pic30_register_operand" "=&r")
        (us_plus:QUQ15
           (match_operand:QUQ15 1 "pic30_register_operand" "r")
           (match_operand:QUQ15 2 "pic30_register_operand" "r")))]
  ""
  "add %1,%2,%0\;btsc _SR,#2\;mov #0x7FFF,%0"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "etc")
  ]
)

(define_insn "ussub<mode>3"
  [(set (match_operand:QUQ15 0 "pic30_register_operand" "=&r")
        (us_minus:QUQ15
           (match_operand:QUQ15 1 "pic30_register_operand" "r")
           (match_operand:QUQ15 2 "pic30_register_operand" "r")))]
  ""
  "sub %1,%2,%0\;btsc _SR,#3\;clr %0"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "etc")
  ]
)

;  32-bit
(define_insn "add<mode>3"
  [(set (match_operand:QUQ31 0 "pic30_register_operand" "=r")
        (plus:QUQ31
           (match_operand:QUQ31 1 "pic30_register_operand" "r")
           (match_operand:QUQ31 2 "pic30_register_operand" "r")))]
  ""
  "add %1,%2,%0\;addc %d1,%d2,%d0"
  [
    (set_attr "cc" "math")
    (set_attr "type" "etc")
  ]
)

(define_insn "sub<mode>3"
  [(set (match_operand:QUQ31 0 "pic30_register_operand" "=r")
        (minus:QUQ31
           (match_operand:QUQ31 1 "pic30_register_operand" "r")
           (match_operand:QUQ31 2 "pic30_register_operand" "r")))]
  ""
  "sub %1,%2,%0\;subb %d1,%d2,%d0"
  [
    (set_attr "cc" "math")
    (set_attr "type" "etc")
  ]
)

;  signed saturating
(define_insn "ssadd<mode>3"
  [(set (match_operand:QUQ31 0 "pic30_register_operand" "=&r")
        (ss_plus:QUQ31
           (match_operand:QUQ31 1 "pic30_register_operand" "r")
           (match_operand:QUQ31 2 "pic30_register_operand" "r")))]
  "pic30_fp_inline_p()"
  "*
   return \"add %1,%2,%0\;\"
          \"addc %d1,%d2,%d0\;\"
          \"bra nov,.L1_%=\;\"
          \"setm %0\;\"
          \"mov #0x7FFF,%d0\;\"
          \"btst.c %d2,#15\;\"
          \"bra nc,.L1_%=\;\"
          \"com %d0,%d0\;\"
          \"com %0,%0\n\"
          \".L1_%=:\";
  "
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "etc")
  ]
)

(define_insn "sssub<mode>3"
  [(set (match_operand:QUQ31 0 "pic30_register_operand" "=&r")
        (ss_minus:QUQ31
           (match_operand:QUQ31 1 "pic30_register_operand" "r")
           (match_operand:QUQ31 2 "pic30_register_operand" "r")))]
  "pic30_fp_inline_p()"
  "*
   return \"sub %1,%2,%0\;\"
          \"subb %d1,%d2,%d0\;\"
          \"bra nov,.L1_%=\;\"
          \"setm %0\;\"
          \"mov #0x7FFF,%d0\;\"
          \"btst.c %d2,#15\;\"
          \"bra c,.L1_%=\;\"
          \"com %d0,%d0\;\"
          \"com %0,%0\n\"
          \".L1_%=:\";
  "
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "etc")
  ]
)

;  unsigned saturating - our unsigned mode really is the same width as signed
(define_insn "usadd<mode>3"
  [(set (match_operand:QUQ31 0 "pic30_register_operand" "=&r")
        (us_plus:QUQ31
           (match_operand:QUQ31 1 "pic30_register_operand" "r")
           (match_operand:QUQ31 2 "pic30_register_operand" "r")))]
  "pic30_fp_inline_p()"
  "*
   return \"add %1,%2,%0\;\"
          \"addc %d1,%d2,%d0\;\"
          \"bra nov,.L1_%=\;\"
          \"setm %0\;\"
          \"mov #0x7FFF,%d0\n\"
          \".L1_%=:\";
  "
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "etc")
  ]
)

(define_insn "ussub<mode>3"
  [(set (match_operand:QUQ31 0 "pic30_register_operand" "=&r")
        (us_minus:QUQ31
           (match_operand:QUQ31 1 "pic30_register_operand" "r")
           (match_operand:QUQ31 2 "pic30_register_operand" "r")))]
  "pic30_fp_inline_p()"
  "*
   return \"sub %1,%2,%0\;\"
          \"subb %d1,%d2,%d0\;\"
          \"btsc _SR,#3\;\"
          \"mul.uu %0,#0,%0\";
  "
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "etc")
  ]
)

;; *** multiply
;  16-bit

/*
 * do not know if this will be successful
 */
(define_insn "mul<mode>3_helper_trunc_dsp_A"
  [(set (match_operand:QUQ15 0 "pic30_move_operand"       "=r")
        (mult:QUQ15 
          (match_operand:QUQ15 1 "pic30_register_operand" " z")
          (match_operand:QUQ15 2 "pic30_register_operand" " z")))
   (clobber (reg:SQ A_REGNO))
   (use (reg:HI CORCON))
  ]
  "((pic30_fp_round_p() == pic30_truncation) || 
    (pic30_fp_round_p() == pic30_fastest))"
  "mpy %1,%2,A\;sac A,#0,%0"
)

(define_insn "mul<mode>3_helper_trunc_dsp_B"
  [(set (match_operand:QUQ15 0 "pic30_move_operand"       "=r")
        (mult:QUQ15 
          (match_operand:QUQ15 1 "pic30_register_operand" " z")
          (match_operand:QUQ15 2 "pic30_register_operand" " z")))
   (clobber (reg:SQ B_REGNO))
   (use (reg:HI CORCON))
  ]
  "((pic30_fp_round_p() == pic30_truncation) || 
    (pic30_fp_round_p() == pic30_fastest))"
  "mpy %1,%2,B\;sac B,#0,%0"
)

(define_insn "mul<mode>3_helper_rnd_dsp_A"
  [(set (match_operand:QUQ15 0 "pic30_move_operand"       "=r")
        (mult:QUQ15
          (match_operand:QUQ15 1 "pic30_register_operand" " z")
          (match_operand:QUQ15 2 "pic30_register_operand" " z")))
   (clobber (reg:SQ A_REGNO))
   (use (reg:HI CORCON))
  ]
  "((pic30_fp_round_p() == pic30_convergent) ||
    (pic30_fp_round_p() == pic30_conventional))"
  "mpy %1,%2,A\;sac.r A,#0,%0"
)

(define_insn "mul<mode>3_helper_rnd_dsp_B"
  [(set (match_operand:QUQ15 0 "pic30_move_operand"       "=r")
        (mult:QUQ15
          (match_operand:QUQ15 1 "pic30_register_operand" " z")
          (match_operand:QUQ15 2 "pic30_register_operand" " z")))
   (clobber (reg:SQ B_REGNO))
   (use (reg:HI CORCON))
  ]
  "((pic30_fp_round_p() == pic30_convergent) ||
    (pic30_fp_round_p() == pic30_conventional))"
  "mpy %1,%2,B\;sac.r B,#0,%0"
)
/* If it is, we should remove the middle alternative here */

(define_insn "mul<mode>3_helper"
  [(set (match_operand:QUQ15 0 "pic30_move_operand"       "=rR<>,r,QST")
        (mult:QUQ15 
          (match_operand:QUQ15 1 "pic30_register_operand" " r,z,r")
          (match_operand:QUQ15 2 "pic30_register_operand" " r,z,r")))
   (clobber (match_scratch:SQ  3                         "=&r,&w,&r"))
  ]
  ""
  "*
   { 
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       static const char *patterns[] = {
         \"mul.ss %1,%2,%3\;sl %3,%3\;rlc %d3,%0\",
         \"mpy %1,%2,%3\;sac %3,#0,%0\",
         \"mul.ss %1,%2,%3\;sl %3,%3\;rlc %d3,%d3\;mov %d3,%0\"
       };

       return patterns[which_alternative];
     } else if (pic30_fp_round_p() == pic30_conventional) {
       static const char *patterns[] = {
         \"mul.ss %1,%2,%3\;\"
             \"sl %3,%3\;\"
             \"rlc %d3,%d3\;\"
             \"sl %3,[w15]\;\"
             \"addc %d3,#0,%0\",

         \"mpy %1,%2,%3\;\"
             \"sac.r %3,#0,%0\",

         \"mul.ss %1,%2,%3\;\"
             \"sl %3,%3\;\"
             \"rlc %d3,%d3\;\"
             \"sl %3,[w15]\;\"
             \"addc %d3,#0,%d3\;\"
             \"mov %d3,%0\"
       };

       return patterns[which_alternative];
     } else if (pic30_fp_round_p() == pic30_convergent) {
       /* convergent rounding, doing it without branches appears to be
        * simpler. And quicker, especially on EP parts;
        *
        * For rounding, we do the add and if the remainer is 0 we mask of the
        * low bit.  Ie:
        *  res rem
        *  xx1 100 will round to xx1+1
        *  xx0 100 will round to xx0+1 (xx1) then mask back to (xx0) 
        *
        * Listen very carefully, I shall say this only wance
        */
       static const char *patterns[] = {
         \"mul.ss %1,%2,%3\;\"     /* multipy */
           \"sl %3,%3\;\"          /* shift 32-bit result left to reposition */
           \"rlc %d3,%d3\;\"       /*   binary point */
           \"sl %3,%3\;\"          /* round shift remainder up, like convgnt */
           \"bra nc,.L1_%=\;\"     /* if no carry, finish */
           \"btsc _SR,#1\;\"       /* if round word == 0 */
           \"btst.c %d3,#0\;\"     /* mov low result bit to C */
                                   /*  1 + 1 = 0 (even) */
           \"addc %d3,#0,%d3\n\"
           \".L1_%=:\;\"
           \"mov %d3,%0\",

         \"mpy %1,%2,%0\;\"        /* ensure CORCONbits.US == 0? */
           \"sac.r %3,#0,%0\",

         \"mul.ss %1,%2,%3\;\"
           \"sl %3,%3\;\"
           \"rlc %d3,%d3\;\"
           \"sl %3,%3\;\"          /* round */
           \"bra nc,.L1_%=\;\"     /* if no carry, finish */
           \"btsc _SR,#1\;\"       /* if round word == 0 */
           \"btst.c %d3,#0\;\"     /* mov low result bit to C */
           \"addc %d3,#0,%d3\;\"
           \".L1_%=:\;\"
           \"mov %d3,%0\" 
       };

       return patterns[which_alternative];
     } else return \"Cannot generate pattern\";
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "mul<mode>3"
  [(set (match_operand:QUQ15 0 "pic30_move_operand" "=rRQST<>")
        (mult:QUQ15 
          (match_operand:QUQ15 1 "pic30_register_operand" "=r")
          (match_operand:QUQ15 2 "pic30_register_operand" "=r")))]
  ""
  "
  {  rtx ra,rb;

     /* for no fp inline big patterns; lets fail and call the routine */
     if (!pic30_fp_inline_p() && (pic30_fp_round_p() != pic30_truncation) &&
         (pic30_fp_round_p() != pic30_fastest))
       FAIL;
 
     /* set round mode and saturation mode 
      *   the optimizer should discard the things we don't use - ie
      *   an accumulator is not used or the saturation is already correct
      */
     ra = operands[1];
     rb = operands[2];
     if (!pic30_register_operand(ra,<MODE>mode)) 
       ra = force_reg(<MODE>mode, ra);
     if (!pic30_register_operand(rb,<MODE>mode)) 
       rb = force_reg(<MODE>mode, rb);
     emit(
       gen_mul<mode>3_helper(operands[0],ra,rb)
     );
     DONE;
  }"
)

/*
 * do not know if this will be successful
 */
(define_insn "ssmul<mode>3_helper_trunc_dsp_A"
  [(set (match_operand:QUQ15 0 "pic30_move_operand"       "=r")
        (ss_mult:QUQ15
          (match_operand:QUQ15 1 "pic30_register_operand" " z")
          (match_operand:QUQ15 2 "pic30_register_operand" " z")))
   (clobber (reg:SQ A_REGNO))
   (use (reg:HI CORCON))
  ]
  "((pic30_fp_round_p() == pic30_truncation) ||
    (pic30_fp_round_p() == pic30_fastest))"
  "mpy %1,%2,A\;sac A,#0,%0"
)

(define_insn "ssmul<mode>3_helper_trunc_dsp_B"
  [(set (match_operand:QUQ15 0 "pic30_move_operand"       "=r")
        (ss_mult:QUQ15
          (match_operand:QUQ15 1 "pic30_register_operand" " z")
          (match_operand:QUQ15 2 "pic30_register_operand" " z")))
   (clobber (reg:SQ B_REGNO))
   (use (reg:HI CORCON))
  ]
  "((pic30_fp_round_p() == pic30_truncation) ||
    (pic30_fp_round_p() == pic30_fastest))"
  "mpy %1,%2,B\;sac B,#0,%0"
)

(define_insn "ssmul<mode>3_helper_rnd_dsp_A"
  [(set (match_operand:QUQ15 0 "pic30_move_operand"       "=r")
        (ss_mult:QUQ15
          (match_operand:QUQ15 1 "pic30_register_operand" " z")
          (match_operand:QUQ15 2 "pic30_register_operand" " z")))
   (clobber (reg:SQ A_REGNO))
   (use (reg:HI CORCON))
  ]
  "((pic30_fp_round_p() == pic30_convergent) ||
    (pic30_fp_round_p() == pic30_conventional))"
  "mpy %1,%2,A\;sac.r A,#0,%0"
)

(define_insn "ssmul<mode>3_helper_rnd_dsp_B"
  [(set (match_operand:QUQ15 0 "pic30_move_operand"       "=r")
        (ss_mult:QUQ15
          (match_operand:QUQ15 1 "pic30_register_operand" " z")
          (match_operand:QUQ15 2 "pic30_register_operand" " z")))
   (clobber (reg:SQ B_REGNO))
   (use (reg:HI CORCON))
  ]
  "((pic30_fp_round_p() == pic30_convergent) ||
    (pic30_fp_round_p() == pic30_conventional))"
  "mpy %1,%2,B\;sac.r B,#0,%0"
)
/* If it is, we should remove the middle alternative here */

(define_insn "ssmul<mode>3_helper"
  [(set (match_operand:QUQ15 0 "pic30_move_operand" "=&r,r,RQST<>")
        (ss_mult:QUQ15 
          (match_operand:QUQ15 1 "pic30_register_operand" " r,z,r")
          (match_operand:QUQ15 2 "pic30_register_operand" " r,z,r")))
   (clobber (match_scratch:SQ  3                         "=&r,w,&r"))
  ]
  ""
  "*
   { 
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       static const char *patterns[] = {
         \"mul.ss %1,%2,%3\;\"
           \"sl %3,%3\;\"
           \"rlc %d3,%0\;\"
           \"xor %1,%2,%3\;\"
           \"bra n,.L1_%=\;\"
           \"btsc %0,#15\;\"
           \"com %0,%0\n\"
           \".L1_%=:\",

         \"mpy %1,%2,%3\;sac %3,#0,%0\",  /* ensure CORCONbits.US == 0? */

         \"mul.ss %1,%2,%3\;\"
           \"sl %3,%3\;\"
           \"rlc %d3,%d3\;\"
           \"xor %1,%2,%3\;\"
           \"bra n,.L1_%=\;\"
           \"btsc %d3,#15\;\"
           \"com %d3,%d3\n\"
           \".L1_%=:\;\"
           \"mov %d3,%0\"
       };

       return patterns[which_alternative];
     } else if (pic30_fp_round_p() == pic30_conventional) {
       static const char *patterns[] = {
         \"mul.ss %1,%2,%3\;\"
           \"sl %3,%3\;\"
           \"rlc %d3,%d3\;\"
           \"sl %3,[w15]\;\"
           \"addc %d3,#0,%0\;\"
           \"xor %1,%2,%3\;\"
           \"bra n,.L1_%=\;\"
           \"btsc %0,#15\;\"
           \"com %0,%0\n\"
           \".L1_%=:\",

         \"mpy %1,%2,%0\;sac.r %3,#0,%0\",  /* ensure CORCONbits.US == 0? */

         \"mul.ss %1,%2,%3\;\"
           \"sl %3,%3\;\"
           \"rlc %d3,%d3\;\"
           \"sl %3,[w15]\;\"
           \"addc %d3,#0,%d3\;\"
           \"xor %1,%2,%3\;\"
           \"bra n,.L1_%=\;\"
           \"btsc %d3,#15\;\"
           \"com %d3,%d3\n\"
           \".L1_%=:\;\"
           \"mov %d3,%0\"
       };

       return patterns[which_alternative];
     } else if (pic30_fp_round_p() == pic30_convergent) {
       static const char *patterns[] = {
         \"mul.ss %1,%2,%3\;\"                    /* multiply */
           \"sl %3,%3\;\"                         /* fix binary point */
           \"rlc %d3,%0\;\"
           \"sl %3,%3\;\"                         /* move round into carry */
           \"bra nc,.L1_%=\;\"                    /* if no carry, finish */
           \"btsc _SR,#1\;\"                      /* if round word == 0 */
           \"btst.c %0,#0\;\"                     /* mov low result bit to C */
                                                  /*  1 + 1 = 0 (even) */
           \"addc %0,#0,%0\n\"                    /* add carry */
           \".L1_%=:\;\"
           \"xor %1,%2,%3\;\"
           \"bra n,.L2_%=\;\"
           \"btsc %0,#15\;\"
           \"com %0,%0\n\"
           \".L2_%=:\",

         \"mpy %1,%2,%0\;sac.r %3,#0,%0\",  /* ensure CORCONbits.US == 0? */

         \"mul.ss %1,%2,%3\;\"
           \"sl %3,%3\;\"
           \"rlc %d3,%d3\;\"
           \"sl %3,%3\;\"                         /* round */
           \"bra nc,.L1_%=\;\"                    /* if no carry, finish */
           \"btsc _SR,#1\;\"                      /* if round word == 0 */
           \"btst.c %d3,#0\;\"                    /* mov low result bit to C */
                                                  /*  1 + 1 = 0 (even) */
           \"addc %d3,#0,%d3\n\"
           \".L1_%=:\;\"
           \"xor %1,%2,%3\;\"
           \"bra n,.L2_%=\;\"
           \"btsc %d3,#15\;\"
           \"com %d3,%d3\n\"
           \".L2_%=:\;\"
           \"mov %d3,%0\"
       };

       return patterns[which_alternative];
     } else return \"Cannot generate pattern\";
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "ssmul<mode>3"
  [(set (match_operand:QUQ15 0 "pic30_move_operand" "=rRQST<>")
        (ss_mult:QUQ15 
          (match_operand:QUQ15 1 "pic30_register_operand" "=r")
          (match_operand:QUQ15 2 "pic30_register_operand" "=r")))]
  ""
  "
  {  rtx ra,rb;

     /* for no fp inline big patterns; lets fail and call the routine */
     if (!pic30_fp_inline_p() && (pic30_fp_round_p() != pic30_truncation) &&
         (pic30_fp_round_p() != pic30_fastest))
       FAIL;

     /* set round mode and saturation mode
      *   the optimizer should discard the things we don't use - ie
      *   an accumulator is not used or the saturation is already correct
      */
     ra = operands[1];
     rb = operands[2];
     if (!pic30_register_operand(ra,<MODE>mode)) 
       ra = force_reg(<MODE>mode, ra);
     if (!pic30_register_operand(rb,<MODE>mode)) 
       rb = force_reg(<MODE>mode, rb);
     emit(
       gen_ssmul<mode>3_helper(operands[0],ra,rb)
     );
     DONE;
  }"
)

(define_expand "usmul<mode>3"
  [(set (match_operand:QUQ15 0 "pic30_move_operand" "=rRQST<>")
        (us_mult:QUQ15
          (match_operand:QUQ15 1 "pic30_register_operand" "=r")
          (match_operand:QUQ15 2 "pic30_register_operand" "=r")))]
  ""
  "
  {  rtx ra,rb;

     /* for no fp inline big patterns; lets fail and call the routine */
     if (!pic30_fp_inline_p() && (pic30_fp_round_p() != pic30_truncation) &&
         (pic30_fp_round_p() != pic30_fastest))
       FAIL;

     /* set round mode and saturation mode
      *   the optimizer should discard the things we don't use - ie
      *   an accumulator is not used or the saturation is already correct
      */

     /* unsigned multiply on this device cannot over-flow
        so we don't need to do saturation - translate it to the unsaturating
        signed multiply */
     ra = operands[1];
     rb = operands[2];
     if (!pic30_register_operand(ra,<MODE>mode))
       ra = force_reg(<MODE>mode, ra);
     if (!pic30_register_operand(rb,<MODE>mode))
       rb = force_reg(<MODE>mode, rb);
     emit(
       gen_mul<mode>3_helper(operands[0],ra,rb)
     );
     DONE;
  }"
)

;; *** multiply
;  32-bit
; handled by helper routines in libfx

;; *** divide
;  16-bit

(define_insn "udiv<mode>3_helper"
  [(set (match_operand:UQ15 0 "pic30_register_operand"    "=a,?b,??&e")
        (udiv:UQ15 
          (match_operand:UQ15 1 "pic30_register_operand"   "r, r,  r")
          (match_operand:UQ15 2 "pic30_ereg_operand"       "e, e,  e")))
   (clobber (reg:HI RCOUNT))
  ]
  ""
  "*
  {
     rtx w0 = gen_rtx_REG(HImode, WR0_REGNO);
     rtx w1 = gen_rtx_REG(HImode, WR1_REGNO);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       switch (which_alternative) {
         case 0:  /*
                ** wm/wn -> w0
                */
                  if (pic30_dead_or_set_p(insn, w1)) {
                    return \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\";
                  } else {
                      return \"mov w1,[w15++]\;\"
                             \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                             \"divf %1,%2\;\"
                             \"mov [--w15],w1\";
                }
         case 1:  /*
                  ** wm/wn -> w1
                  */
                  if (pic30_dead_or_set_p(insn, w0)) {
                    return \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"mov w0,%0\";
                  } else {
                    return \"mov w0,[w15++]\;\"
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"mov w0,%0\;\"
                           \"mov [--w15],w0\";
                  }
         case 2:  /*
                  ** wm/wn -> we
                  */
                  if (pic30_dead_or_set_p(insn, w0) &&
                      pic30_dead_or_set_p(insn, w1)) {
                    return \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"mov w0,%0\";
                  } else {
                    return \"mov.d w0,[w15++]\;\"
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"mov w0,%0\;\"
                           \"mov.d [--w15],w0\";
                  }
         default: gcc_assert(0);
       }
     } else if (pic30_fp_round_p() == pic30_conventional) {
       switch (which_alternative) {
         case 0:  /*
                ** wm/wn -> w0
                */
                  if (pic30_dead_or_set_p(insn, w1)) {
                                                     /* all follow sim. flow */
                    return 
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"sl w1,w1\;\"
                           \"cp w1,%2\;\"            /* compare 2*remainder */
                           \"addc %0,#0,%0\";        /* inc if carry */
                  } else {
                      return \"mov w1,[w15++]\;\"
                             \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                             \"divf %1,%2\;\"
                             \"sl w1,w1\;\"
                             \"cp w1,%2\;\"
                             \"addc %0,#0,%0\;\"
                             \"mov [--w15],w1\";
                }
         case 1:  /*
                  ** wm/wn -> w1
                  */
                  if (pic30_dead_or_set_p(insn, w0)) {
                    return 
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"sl w1,w1\;\"
                           \"mov w0,%0\;\"
                           \"cp w1,%2\;\"
                           \"addc %0,#0,%0\;\";
                  } else {
                    return \"mov w0,[w15++]\;\"
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"sl w1,w1\;\"
                           \"mov w0,%0\;\"
                           \"cp w1,%2\;\"
                           \"addc %0,#0,%0\;\"
                           \"mov [--w15],w0\";
                  }
         case 2:  /*
                  ** wm/wn -> we
                  */
                  if (pic30_dead_or_set_p(insn, w0) &&
                      pic30_dead_or_set_p(insn, w1)) {
                    return 
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"sl w1,w1\;\"
                           \"cp w1,%2\;\"
                           \"mov w0,%0\;\"
                           \"addc %0,#0,%0\";
                  } else {
                    return \"mov.d w0,[w15++]\;\"
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"sl w1,w1\;\"
                           \"mov w0,%0\;\"
                           \"cp w1,%2\;\"
                           \"addc %0,#0,%0\;\" 
                           \"mov.d [--w15],w0\";
                  }
         default: gcc_assert(0);
       }
     } else if (pic30_fp_round_p() == pic30_convergent) {
       switch (which_alternative) {
         case 0:  /*
                  ** wm/wn -> w0
                  */
                  if (pic30_dead_or_set_p(insn, w1)) {
                                                     /* convergent follows this
                                                        form */
                    return 
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"sl w1,w1\;\"
                           \"cp w1,%2\;\"            /* cp divisor w/ 2*rem */
                           \"btsc _SR,#1\;\"         /* if zero ... */
                           \"btst.c w0,#0\;\"        /*   copy low bit to c */
                                                     /*   ie if low bit == 0 */
                                                     /*      don't add */
                           \"addc.w w0,#0,%0\";      /* add carry */
                  } else {
                      return \"mov w1,[w15++]\;\"
                             \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                             \"divf %1,%2\;\"
                             \"sl w1,w1\;\"
                             \"cp w1,%2\;\"
                             \"btsc _SR,#1\;\"
                             \"btst.c w0,#0\;\"
                             \"addc.w w0,#0,%0\;\" 
                             \"mov [--w15],w1\";
                  }
         case 1:  /*
                  ** wm/wn -> w1
                  */
                  if (pic30_dead_or_set_p(insn, w0)) {
                    return 
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"sl w1,w1\;\"
                           \"cp w1,%2\;\"
                           \"btsc _SR,#1\;\"
                           \"btst.c w0,#0\;\"
                           \"addc.w w0,#0,%0\";
                  } else {
                    return \"mov w0,[w15++]\;\"
                           \"sl %2,[w15++]\;\"
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"sl w1,w1\;\"
                           \"cp w1,[--w15]\;\"
                           \"btsc _SR,#1\;\"
                           \"btst.c w0,#0\;\"
                           \"addc.w w0,#0,%0\;\" 
                           \"mov [--w15],w0\";
                  }
         case 2 : /*
                  ** wm/wn -> we
                  */
                  if (pic30_dead_or_set_p(insn, w0) &&
                      pic30_dead_or_set_p(insn, w1)) {
                    return \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"sl w1,w1\;\"
                           \"cp w1,%2\;\"
                           \"btsc _SR,#1\;\"
                           \"btst.c w0,#0\;\"
                           \"addc.w w0,#0,%0\";
                  } else {
                    return \"mov.d w0,[w15++]\;\"
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"sl w1,w1\;\"
                           \"cp w1,%2\;\"
                           \"btsc _SR,#1\;\"
                           \"btst.c w0,#0\;\"
                           \"addc.w w0,#0,%0\;\" 
                           \"mov.d [--w15],w0\";
                  }
         default: gcc_assert(0);
       }
     }
     gcc_assert(0);
     return \"nop\";
  } 
  "
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def")
  ]
)

; check for == and return 0x8000 in all cases (if sign is positive then 
;   its an valid invalid answer)

(define_insn "div<mode>3_helper"
  [(set (match_operand:QUQ15   0 "pic30_register_operand"  "=a,?b,??&e")
        (div:QUQ15 
          (match_operand:QUQ15 1 "pic30_register_operand"   "r, r,  r")
          (match_operand:QUQ15 2 "pic30_ereg_operand"       "e, e,  e")))
   (match_operand:HI           3 "pic30_register_operand"   "e, e,  e")
   (clobber (match_scratch:HI  4                          "=&e,&e, &e"))
   (clobber (reg:HI RCOUNT))
  ]
  ""
  "*
  {
     rtx w0 = gen_rtx_REG(HImode, WR0_REGNO);
     rtx w1 = gen_rtx_REG(HImode, WR1_REGNO);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       switch (which_alternative) {
         case 0:  /*
                ** wm/wn -> w0
                */
                  if (pic30_dead_or_set_p(insn, w1)) {
                    return \"sub %1,%2,[w15]\;\"
                           \"mov #0x8000,%0\;\"
                           \"bra z,.LE%=\;\"
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"com w0,%4\;\"              /* complement in case
                                                            of negate */
                           \"ff1r w1,w1\;\"             /* C = w1 == 0 */
                           \"btsc %3,#15\;\"            /* if negative, neg */
                           \"addc %4,#0,%0\n\"
                           \".LE%=:\";
                  } else {
                    return \"sub %1,%2,[w15]\;\"
                           \"mov #0x8000,%0\;\"
                           \"bra z,.LE%=\;\"
                           \"mov w1,[w15++]\;\"
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"com w0,%4\;\"              /* complement in case
                                                            of negate */
                           \"ff1r w1,w1\;\"             /* C = w1 == 0 */
                           \"btsc %3,#15\;\"          /* if negative, neg */
                           \"addc %4,#0,%0\;\"
                           \"mov [--w15],w1\n\"
                           \".LE%=:\";
                }
         case 1:  /*
                  ** wm/wn -> w1
                  */
                  if (pic30_dead_or_set_p(insn, w0)) {
                    return \"sub %1,%2,[w15]\;\"
                           \"mov #0x8000,%0\;\"
                           \"bra z,.LE%=\;\"
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"com w0,%4\;\"              /* complement in case
                                                            of negate */
                           \"ff1r w1,w1\;\"             /* C = w1 == 0 */
                           \"btsc %3,#15\;\"            /* if negative, neg */
                           \"addc %4,#0,w0\;\"
                           \"mov w0,%0\n\"
                           \".LE%=:\";
                  } else {
                    return \"sub %1,%2,[w15]\;\"
                           \"mov #0x8000,%0\;\"
                           \"bra z,.LE%=\;\"
                           \"mov w0,[w15++]\;\"
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"com w0,%4\;\"              /* complement in case
                                                            of negate */
                           \"ff1r w1,w1\;\"             /* C = w1 == 0 */
                           \"btsc %3,#15\;\"            /* if negative, neg */
                           \"addc %4,#0,w0\;\"
                           \"mov w0,%0\;\"
                           \"mov [--w15],w0\n\"
                           \".LE%=:\";
                  }
         case 2 : /*
                  ** wm/wn -> we
                  */
                  if (pic30_dead_or_set_p(insn, w0) &&
                      pic30_dead_or_set_p(insn, w1)) {
                    return \"sub %1,%2,[w15]\;\"
                           \"mov #0x8000,%0\;\"
                           \"bra z,.LE%=\;\"
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"com w0,%4\;\"              /* complement in case
                                                            of negate */
                           \"ff1r w1,w1\;\"             /* C = w1 == 0 */
                           \"btsc %3,#15\;\"            /* if negative, neg */
                           \"addc %4,#0,w0\;\"
                           \"mov w0,%0\n\"
                           \".LE%=\";
                  } else {
                    return \"sub %1,%2,[w15]\;\"
                           \"mov #0x8000,%0\;\"
                           \"bra z,.LE%=\;\"
                           \"mov.d w0,[w15++]\;\"
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"com w0,%4\;\"              /* complement in case
                                                            of negate */
                           \"ff1r w1,w1\;\"             /* C = w1 == 0 */
                           \"btsc %3,#15\;\"            /* if negative, neg */
                           \"addc %4,#0,w0\;\"
                           \"mov w0,%0\;\"
                           \"mov.d [--w15],w0\n\"
                           \".LE%=:\";
                  }
         default: gcc_assert(0);
       }
     } else if (pic30_fp_round_p() == pic30_conventional) {
       switch (which_alternative) {
         case 0:  /*
                ** wm/wn -> w0
                */
                  if (pic30_dead_or_set_p(insn, w1)) {
                                                     /* all follow . flow */
                    return \"sub %1,%2,[w15]\;\"
                           \"mov #0x8000,%0\;\"
                           \"bra z,.LE%=\;\"
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"sl w1,%4\;\"
                           \"sub %4,%2,%4\;\"        /* compare 2*remainder */
                           \"btss _SR,#0\;\"         /* carry set, use new val*/
                           \"mov %4,w1\;\" 
                           \"rlc w0,w0\;\"           /* put R in low bit */
                           \"ff1r w1,%4\;\"          /* C = w1 == 0 */
                           \"com w0,%4\;\"           /* complement in case
                                                        of negate */
                           \"btsc %3,#15\;\"         /* if negative, neg */
                           \"addc %4,#0,w0\;\"
                           \"rlc %3,[w15]\;\"        /* get sign in carry */
                           \"rrc w0,w0\;\"           /* div by 2 again */
                           \"addc w0,#0,%0\n\"       /* add in round */
                           \".LE%=:\";
                  } else {
                    return \"sub %1,%2,[w15]\;\"
                           \"mov #0x8000,%0\;\"
                           \"bra z,.LE%=\;\"
                           \"mov w1,[w15++]\;\"
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"sl w1,%4\;\"
                           \"sub %4,%2,%4\;\"        /* compare 2*remainder */
                           \"btss _SR,#0\;\"         /* carry set, use new val*/
                           \"mov %4,w1\;\"
                           \"rlc w0,w0\;\"           /* put R in low bit */
                           \"ff1r w1,%4\;\"          /* C = w1 == 0 */
                           \"com w0,%4\;\"           /* complement in case
                                                        of negate */
                           \"btsc %3,#15\;\"         /* if negative, neg */
                           \"addc %4,#0,w0\;\"
                           \"rlc %3,[w15]\;\"        /* get sign in carry */
                           \"rrc w0,w0\;\"           /* div by 2 again */
                           \"addc w0,#0,%0\;\"       /* add in round */
                           \"mov [--w15],w1\n\"
                           \".LE%=:\";
                }
         case 1:  /*
                  ** wm/wn -> w1
                  */
                  if (pic30_dead_or_set_p(insn, w0)) {
                    return \"sub %1,%2,[w15]\;\"
                           \"mov #0x8000,%0\;\"
                           \"bra z,.LE%=\;\"
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"ff1r w1,%4\;\"          /* C = w1 == 0 */
                           \"sl w1,%4\;\"
                           \"sub %4,%2,%4\;\"        /* compare 2*remainder */
                           \"btss _SR,#0\;\"         /* carry set, use new val*/
                           \"mov %4,w1\;\"
                           \"rlc w0,w0\;\"           /* put R in low bit */
                           \"com w0,%4\;\"           /* complement in case
                                                        of negate */
                           \"btsc %3,#15\;\"         /* if negative, neg */
                           \"addc %4,#0,w0\;\"
                           \"rlc %3,[w15]\;\"        /* get sign in carry */
                           \"rrc w0,w0\;\"           /* div by 2 again */
                           \"addc w0,#0,%0\n\"       /* add in round */
                           \".LE%=:\";
                  } else {
                    return \"sub %1,%2,[w15]\;\"
                           \"mov #0x8000,%0\;\"
                           \"bra z,.LE%=\;\"
                           \"mov w0,[w15++]\;\"
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"sl w1,%4\;\"
                           \"sub %4,%2,%4\;\"        /* compare 2*remainder */
                           \"btss _SR,#0\;\"         /* carry set, use new val*/
                           \"mov %4,w1\;\"
                           \"rlc w0,w0\;\"           /* put R in low bit */
                           \"ff1r w1,%4\;\"          /* C = w1 == 0 */
                           \"com w0,%4\;\"           /* complement in case
                                                        of negate */
                           \"btsc %3,#15\;\"         /* if negative, neg */
                           \"addc %4,#0,w0\;\"
                           \"rlc %3,[w15]\;\"        /* get sign in carry */
                           \"rrc w0,w0\;\"           /* div by 2 again */
                           \"addc w0,#0,%0\;\"       /* add in round */
                           \"mov [--w15],w0\n\"
                           \".LE%=:\";
                  }
         case 2:  /*
                  ** wm/wn -> we
                  */
                  if (pic30_dead_or_set_p(insn, w0) &&
                      pic30_dead_or_set_p(insn, w1)) {
                    return \"sub %1,%2,[w15]\;\"
                           \"mov #0x8000,%0\;\"
                           \"bra z,.LE%=\;\"
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"sl w1,%4\;\"
                           \"sub %4,%2,%4\;\"        /* compare 2*remainder */
                           \"btss _SR,#0\;\"         /* carry set, use new val*/
                           \"mov %4,w1\;\"
                           \"rlc w0,w0\;\"           /* put R in low bit */
                           \"ff1r w1,%4\;\"          /* C = w1 == 0 */
                           \"com w0,%4\;\"           /* complement in case
                                                        of negate */
                           \"btsc %3,#15\;\"         /* if negative, neg */
                           \"addc %4,#0,w0\;\"
                           \"rlc %3,[w15]\;\"        /* get sign in carry */
                           \"rrc w0,w0\;\"           /* div by 2 again */
                           \"addc w0,#0,%0\n\"       /* add in round */
                           \".LE%=:\";
                  } else {
                    return \"sub %1,%2,[w15]\;\"
                           \"mov #0x8000,%0\;\"
                           \"bra z,.LE%=\;\"
                           \"mov.d w0,[w15++]\;\"
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"sl w1,%4\;\"
                           \"sub %4,%2,%4\;\"        /* compare 2*remainder */
                           \"btss _SR,#0\;\"         /* carry set, use new val*/
                           \"mov %4,w1\;\"
                           \"rlc w0,w0\;\"           /* put R in low bit */
                           \"ff1r w1,%4\;\"          /* C = w1 == 0 */
                           \"com w0,%4\;\"           /* complement in case
                                                        of negate */
                           \"btsc %3,#15\;\"         /* if negative, neg */
                           \"addc %4,#0,w0\;\"
                           \"rlc %3,[w15]\;\"        /* get sign in carry */
                           \"rrc w0,w0\;\"           /* div by 2 again */
                           \"addc w0,#0,%0\;\"       /* add in round */
                           \"mov.d [--w15],w0\n\"
                           \".LE%=:\";
                  }
         default: gcc_assert(0);
       }
     } else if (pic30_fp_round_p() == pic30_convergent) {
       switch (which_alternative) {
         case 0:  /*
                  ** wm/wn -> w0
                  */
                  if (pic30_dead_or_set_p(insn, w1)) {
                                                     /* convergent follows this
                                                        form */
                    return \"sub %1,%2,[w15]\;\"
                           \"mov #0x8000,%0\;\"
                           \"bra z,.LE%=\;\"
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"sl w1,%4\;\"
                           \"sub %4,%2,%4\;\"        /* compare 2*remainder */
                           \"btss _SR,#0\;\"         /* carry set, use new val*/
                           \"mov %4,w1\;\"
                           \"btsc _SR,#1\;\"
                           \"btst.c w0,#0\;\"        /*   copy low bit to c */
                                                     /*   ie if low bit == 0 */
                                                     /*      don't add */
                           \"rlc w0,w0\;\"           /* put R in low bit */

                           \"ff1r w1,%4\;\"          /* C = w1 == 0 */
                           \"com w0,%4\;\"           /* complement in case
                                                        of negate */
                           \"btsc %3,#15\;\"         /* if negative, neg */
                           \"addc %4,#0,w0\;\"
                           \"rlc %3,[w15]\;\"        /* get sign in carry */
                           \"rrc w0,w0\;\"           /* div by 2 again */
                           \"addc.w w0,#0,%0\n\"     /* add carry */
                           \".LE%=:\";
                  } else {
                    return \"sub %1,%2,[w15]\;\"
                           \"mov #0x8000,%0\;\"
                           \"bra z,.LE%=\;\"
                           \"mov w1,[w15++]\;\"
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"ff1r w1,%4\;\"          /* C = w1 == 0 */
                           \"sl w1,%4\;\"
                           \"sub %4,%2,%4\;\"        /* compare 2*remainder */
                           \"btss _SR,#0\;\"         /* carry set, use new val*/
                           \"mov %4,w1\;\"
                           \"btsc _SR,#1\;\"
                           \"btst.c w0,#0\;\"        /*   copy low bit to c */
                                                     /*   ie if low bit == 0 */
                                                     /*      don't add */
                           \"rlc w0,w0\;\"           /* put R in low bit */
                           \"com w0,%4\;\"           /* complement in case
                                                        of negate */
                           \"btsc %3,#15\;\"         /* if negative, neg */
                           \"addc %4,#0,w0\;\"
                           \"rlc %3,[w15]\;\"        /* get sign in carry */
                           \"rrc w0,w0\;\"           /* div by 2 again */
                           \"addc.w w0,#0,%0\;\"     /* add carry */
                           \"mov [--w15],w1\n\"
                           \".LE%=:\";
                  }
         case 1:  /*
                  ** wm/wn -> w1
                  */
                  if (pic30_dead_or_set_p(insn, w0)) {
                    return \"sub %1,%2,[w15]\;\"
                           \"mov #0x8000,%0\;\"
                           \"bra z,.LE%=\;\"
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"sl w1,%4\;\"
                           \"sub %4,%2,%4\;\"        /* compare 2*remainder */
                           \"btss _SR,#0\;\"         /* carry set, use new val*/
                           \"mov %4,w1\;\"
                           \"btsc _SR,#1\;\"
                           \"btst.c w0,#0\;\"        /*   copy low bit to c */
                                                     /*   ie if low bit == 0 */
                                                     /*      don't add */
                           \"rlc w0,w0\;\"           /* put R in low bit */

                           \"ff1r w1,%4\;\"          /* C = w1 == 0 */
                           \"com w0,%4\;\"           /* complement in case
                                                        of negate */
                           \"btsc %3,#15\;\"         /* if negative, neg */
                           \"addc %4,#0,w0\;\"
                           \"sl w1,w1\;\"
                           \"rlc %3,[w15]\;\"        /* get sign in carry */
                           \"rrc w0,w0\;\"           /* div by 2 again */
                           \"addc.w w0,#0,%0\n\"     /* add carry */
                           \".LE%=:\";
                  } else {
                    return \"sub %1,%2,[w15]\;\"
                           \"mov #0x8000,%0\;\"
                           \"bra z,.LE%=\;\"
                           \"mov w0,[w15++]\;\"
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"sl w1,%4\;\"
                           \"sub %4,%2,%4\;\"        /* compare 2*remainder */
                           \"btss _SR,#0\;\"         /* carry set, use new val*/
                           \"mov %4,w1\;\"
                           \"btsc _SR,#1\;\"
                           \"btst.c w0,#0\;\"        /*   copy low bit to c */
                                                     /*   ie if low bit == 0 */
                                                     /*      don't add */
                           \"rlc w0,w0\;\"           /* put R in low bit */

                           \"ff1r w1,%4\;\"          /* C = w1 == 0 */
                           \"com w0,%4\;\"           /* complement in case
                                                        of negate */
                           \"btsc %3,#15\;\"         /* if negative, neg */
                           \"addc %4,#0,w0\;\"
                           \"rlc %3,[w15]\;\"        /* get sign in carry */
                           \"rrc w0,w0\;\"           /* div by 2 again */
                           \"addc.w w0,#0,%0\;\"     /* add carry */
                           \"mov [--w15],w0\n\"
                           \".LE%=:\";
                  }
         case 2:  /*
                  ** wm/wn -> we
                  */
                  if (pic30_dead_or_set_p(insn, w0) &&
                      pic30_dead_or_set_p(insn, w1)) {
                    return \"sub %1,%2,[w15]\;\"
                           \"mov #0x8000,%0\;\"
                           \"bra z,.LE%=\;\"
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"sl w1,%4\;\"
                           \"sub %4,%2,%4\;\"        /* compare 2*remainder */
                           \"btss _SR,#0\;\"         /* carry set, use new val*/
                           \"mov %4,w1\;\"
                           \"btsc _SR,#1\;\"
                           \"btst.c w0,#0\;\"        /*   copy low bit to c */
                                                     /*   ie if low bit == 0 */
                                                     /*      don't add */
                           \"rlc w0,w0\;\"           /* put R in low bit */

                           \"ff1r w1,%4\;\"          /* C = w1 == 0 */
                           \"com w0,%4\;\"           /* complement in case
                                                        of negate */
                           \"btsc %3,#15\;\"         /* if negative, neg */
                           \"addc %4,#0,w0\;\"
                           \"rlc %3,[w15]\;\"        /* get sign in carry */
                           \"rrc w0,w0\;\"           /* div by 2 again */
                           \"addc.w w0,#0,%0\n\"     /* add carry */
                           \".LE%=:\";
                  } else {
                    return \"sub %1,%2,[w15]\;\"
                           \"mov #0x8000,%0\;\"
                           \"bra z,.LE%=\;\"
                           \"mov.d w0,[w15++]\;\"
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"sl w1,%4\;\"
                           \"sub %4,%2,%4\;\"        /* compare 2*remainder */
                           \"btss _SR,#0\;\"         /* carry set, use new val*/
                           \"mov %4,w1\;\"
                           \"btsc _SR,#1\;\"
                           \"btst.c w0,#0\;\"        /*   copy low bit to c */
                                                     /*   ie if low bit == 0 */
                                                     /*      don't add */
                           \"rlc w0,w0\;\"           /* put R in low bit */

                           \"ff1r w1,%4\;\"          /* C = w1 == 0 */
                           \"com w0,%4\;\"           /* complement in case
                                                        of negate */
                           \"btsc %3,#15\;\"         /* if negative, neg */
                           \"addc %4,#0,w0\;\"
                           \"sl w1,w1\;\"
                           \"rlc %3,[w15]\;\"        /* get sign in carry */
                           \"rrc w0,w0\;\"           /* div by 2 again */
                           \"addc.w w0,#0,%0\;\"     /* add carry */
                           \"mov.d [--w15],w0\n\"
                           \".LE%=:\";
                  }
         default: gcc_assert(0);
       }
     }
     gcc_assert(0);
     return \"nop\";
  } 
  "
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def")
  ]
)

(define_insn "usatdiv<mode>3_helper"
  [(set (match_operand:UQ15 0 "pic30_register_operand"    "=a,?b,??&e")
        (us_div:UQ15 
          (match_operand:UQ15 1 "pic30_register_operand"   "r, r,  r")
          (match_operand:UQ15 2 "pic30_ereg_operand"       "e, e,  e")))
   (clobber (reg:HI RCOUNT))
  ]
  ""
  "*
  {
     rtx w0 = gen_rtx_REG(HImode, WR0_REGNO);
     rtx w1 = gen_rtx_REG(HImode, WR1_REGNO);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       switch (which_alternative) {
         case 0:  /*
                ** wm/wn -> w0
                */
                  if (pic30_dead_or_set_p(insn, w1)) {
                    return \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"btsc _SR,#2\;\"
                           \"mov #0x7FFF,%0\";
                  } else {
                      return \"mov w1,[w15++]\;\"
                             \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                             \"divf %1,%2\;\"
                             \"mov [--w15],w1\;\"
                             \"btsc _SR,#2\;\"
                             \"mov #0x7FFF,%0\";
                }
         case 1:  /*
                  ** wm/wn -> w1
                  */
                  if (pic30_dead_or_set_p(insn, w0)) {
                    return \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"mov w0,%0\;\"
                           \"btsc _SR,#2\;\"
                           \"mov #0x7FFF,%0\";
                  } else {
                    return \"mov w0,[w15++]\;\"
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"mov w0,%0\;\"
                           \"mov [--w15],w0\;\"
                           \"btsc _SR,#2\;\"
                           \"mov #0x7FFF,%0\";
                  } 
         case 2:  /*
                  ** wm/wn -> we
                  */
                  if (pic30_dead_or_set_p(insn, w0) &&
                      pic30_dead_or_set_p(insn, w1)) {
                    return \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"mov w0,%0\;\"
                           \"btsc _SR,#2\;\"
                           \"mov #0x7FFF,%0\";
                  } else {
                    return \"mov.d w0,[w15++]\;\"
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"mov w0,%0\;\"
                           \"mov.d [--w15],w0\;\"
                           \"btsc _SR,#2\;\"
                           \"mov #0x7FFF,%0\";
                  }
         default: gcc_assert(0);
       }
     } else if (pic30_fp_round_p() == pic30_conventional) {
       switch (which_alternative) {
         case 0:  /*
                ** wm/wn -> w0
                */
                  if (pic30_dead_or_set_p(insn, w1)) {
                                                     /* all follow sim. flow */
                    return 
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"bra ov,.OV%=\;\"
                           \"sl w1,w1\;\"
                           \"cp w1,%2\;\"            /* compare 2*remainder */
                           \"addc %0,#0,%0\n\"           /* inc if carry */
                           \".OV%=:\;\"
                           \"btsc _SR,#2\;\"
                           \"mov #0x7FFF,%0\";
                  } else {
                      return \"mov w1,[w15++]\;\"
                             \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                             \"divf %1,%2\;\"
                             \"bra ov,.OV%=\;\"
                             \"sl w1,w1\;\"
                             \"cp w1,%2\;\"
                             \"addc %0,#0,%0\n\"
                             \".OV%=:\;\"
                             \"mov [--w15],w1\;\"
                             \"btsc _SR,#2\;\"
                             \"mov #0x7FFF,%0\";
                }
         case 1:  /*
                  ** wm/wn -> w1
                  */
                  if (pic30_dead_or_set_p(insn, w0)) {
                    return 
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"bra ov,.OV%=\;\"
                           \"sl w1,w1\;\"
                           \"mov w0,%0\;\"
                           \"cp w1,%2\;\"
                           \"addc %0,#0,%0\n\"
                           \".OV%=:\;\"
                           \"btsc _SR,#2\;\"
                           \"mov #0x7FFF,%0\";
                  } else {
                    return \"mov w0,[w15++]\;\"
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"bra ov,.OV%=\;\"
                           \"sl w1,w1\;\"
                           \"mov w0,%0\;\"
                           \"cp w1,%2\;\"
                           \"addc %0,#0,%0\n\"
                           \".OV%=:\;\"
                           \"mov [--w15],w0\;\"
                           \"btsc _SR,#2\;\"
                           \"mov #0x7FFF,%0\";
                  }
         case 2:  /*
                  ** wm/wn -> we
                  */
                  if (pic30_dead_or_set_p(insn, w0) &&
                      pic30_dead_or_set_p(insn, w1)) {
                    return 
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"bra ov,.OV%=\;\"
                           \"sl w1,w1\;\"
                           \"mov w0,%0\;\"
                           \"cp w1,%2\;\"
                           \"addc %0,#0,%0\n\"
                           \".OV%=:\;\"
                           \"btsc _SR,#2\;\"
                           \"mov #0x7FFF,%0\";
                  } else {
                    return \"mov.d w0,[w15++]\;\"
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"bra ov,.OV%=\;\"
                           \"sl w1,w1\;\"
                           \"mov w0,%0\;\"
                           \"cp w1,%2\;\"
                           \"addc %0,#0,%0\n\" 
                           \".OV%=:\;\"
                           \"mov.d [--w15],w0\;\"
                           \"btsc _SR,#2\;\"
                           \"mov #0x7FFF,%0\";
                  }
         default: gcc_assert(0);
       }
     } else if (pic30_fp_round_p() == pic30_convergent) {
       switch (which_alternative) {
         case 0:  /*
                  ** wm/wn -> w0
                  */
                  if (pic30_dead_or_set_p(insn, w1)) {
                                                     /* convergent follows this
                                                        form */
                    return 
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"bra ov,.OV%=\;\"
                           \"sl w1,w1\;\"
                           \"cp w1,%2\;\"            /* cp divisor w/ 2*rem */
                           \"btsc _SR,#1\;\"         /* if zero ... */
                           \"btst.c w0,#0\;\"        /*   copy low bit to c */
                                                     /*   ie if low bit == 0 */
                                                     /*      don't add */
                           \"addc.w w0,#0,%0\n\"     /* add carry */
                           \".OV%=:\;\"
                           \"btsc _SR,#2\;\"
                           \"mov #0x7FFF,%0\";
                  } else {
                      return \"mov w1,[w15++]\;\"
                             \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                             \"divf %1,%2\;\"
                             \"bra ov,.OV%=\;\"
                             \"sl w1,w1\;\"
                             \"cp w1,%2\;\"
                             \"btsc _SR,#1\;\"
                             \"btst.c w0,#0\;\"
                             \"addc.w w0,#0,%0\n\" 
                             \".OV%=:\;\"
                             \"mov [--w15],w1\;\"
                             \"btsc _SR,#2\;\"
                             \"mov #0x7FFF,%0\";
                  }
         case 1:  /*
                  ** wm/wn -> w1
                  */
                  if (pic30_dead_or_set_p(insn, w0)) {
                    return 
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"bra ov,.OV%=\;\"
                           \"sl w1,w1\;\"
                           \"cp w1,%2\;\"
                           \"btsc _SR,#1\;\"
                           \"btst.c w0,#0\;\"
                           \"addc.w w0,#0,%0\n\"
                           \".OV%=:\;\"
                           \"btsc _SR,#2\;\"
                           \"mov #0x7FFF,%0\";
                  } else {
                    return \"mov w0,[w15++]\;\"
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"bra ov,.OV%=\;\"
                           \"sl w1,w1\;\"
                           \"cp w1,%2\;\"
                           \"btsc _SR,#1\;\"
                           \"btst.c w0,#0\;\"
                           \"addc.w w0,#0,%0\n\" 
                           \".OV%=:\;\"
                           \"mov [--w15],w0\;\"
                           \"btsc _SR,#2\;\"
                           \"mov #0x7FFF,%0\";
                  }
         case 2:  /*
                  ** wm/wn -> we
                  */
                  if (pic30_dead_or_set_p(insn, w0) &&
                      pic30_dead_or_set_p(insn, w1)) {
                    return \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"bra ov,.OV%=\;\"
                           \"sl w1,w1\;\"
                           \"cp w1,%2\;\"
                           \"btsc _SR,#1\;\"
                           \"btst.c w0,#0\;\"
                           \"addc.w w0,#0,%0\n\"
                           \".OV%=:\;\"
                           \"btsc _SR,#2\;\"
                           \"mov #0x7FFF,%0\";
                  } else {
                    return \"mov.d w0,[w15++]\;\"
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"bra ov,.OV%=\;\"
                           \"sl w1,w1\;\"
                           \"cp w1,%2\;\"
                           \"btsc _SR,#1\;\"
                           \"btst.c w0,#0\;\"
                           \"addc.w w0,#0,%0\n\" 
                           \".OV%=:\;\"
                           \"mov.d [--w15],w0\;\"
                           \"btsc _SR,#2\;\"
                           \"mov #0x7FFF,%0\";
                  }
         default: gcc_assert(0);
       }
     }
     gcc_assert(0);
     return \"nop\";
  } 
  "
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def")
  ]
)

(define_insn "ssatdiv<mode>3_helper"
  [(set (match_operand:Q15    0 "pic30_register_operand"  "=a,?b,??&e")
        (ss_div:Q15 
          (match_operand:Q15  1 "pic30_register_operand"   "r, r,  r")
          (match_operand:Q15  2 "pic30_ereg_operand"       "e, e,  e")))
   (match_operand:HI          3 "pic30_register_operand"   "e, e,  e")
   (clobber (match_scratch:HI 4                          "=&e,&e, &e"))
   (clobber (reg:HI RCOUNT))
  ]
  ""
  "*
  {
     rtx w0 = gen_rtx_REG(HImode, WR0_REGNO);
     rtx w1 = gen_rtx_REG(HImode, WR1_REGNO);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       switch (which_alternative) {
         case 0:  /*
                ** wm/wn -> w0
                */
                  if (pic30_dead_or_set_p(insn, w1)) {
                    return \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"bra nov,.NOV%=\;\"
                           \"mov #0x7FFF,%0\;\"
                           \"setm w1\n\"                /* force C == 0 */
                           \".NOV%=:\;\"
                           \"ff1r w1,%4\;\"             /* C = w1 == 0 */
                           \"com w0,%4\;\"              /* complement in case
                                                            of negate */
                           \"btsc %3,#15\;\"            /* if negative, neg */
                           \"addc %4,#0,w0\";
                  } else {
                      return \"mov w1,[w15++]\;\"
                             \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                             \"divf %1,%2\;\"
                             \"bra nov,.NOV%=\;\"
                             \"mov #0x7FFF,%0\;\"
                             \"setm w1\n\"              /* force C == 0 */
                             \".NOV%=:\;\"
                             \"ff1r w1,%4\;\"           /* C = w1 == 0 */
                             \"com w0,%4\;\"            /* complement in case
                                                            of negate */
                             \"btsc %3,#15\;\"          /* if negative, neg */
                             \"addc %4,#0,w0\;\"
                             \"mov [--w15],w1\";
                }
         case 1:  /*
                  ** wm/wn -> w1
                  */
                  if (pic30_dead_or_set_p(insn, w0)) {
                    return \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"bra nov,.NOV%=\;\"
                           \"mov #0x7FFF,%0\;\"
                           \"setm w1\n\"                /* force C == 0 */
                           \".NOV%=:\;\"
                           \"ff1r w1,%4\;\"             /* C = w1 == 0 */
                           \"com w0,%4\;\"              /* complement in case
                                                            of negate */
                           \"btsc %3,#15\;\"            /* if negative, neg */
                           \"addc %4,#0,w0\;\"
                           \"mov  w0,%0\";

                  } else {
                    return \"mov w0,[w15++]\;\"
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"bra nov,.NOV%=\;\"
                           \"mov #0x7FFF,%0\;\"
                           \"setm w1\n\"                /* force C == 0 */
                           \".NOV%=:\;\"
                           \"ff1r w1,%4\;\"             /* C = w1 == 0 */
                           \"com w0,%4\;\"              /* complement in case
                                                            of negate */
                           \"btsc %3,#15\;\"            /* if negative, neg */
                           \"addc %4,#0,w0\;\"
                           \"mov w0,%0\;\"
                           \"mov [--w15],w0\";
                  } 
         case 2:  /*
                  ** wm/wn -> we
                  */
                  if (pic30_dead_or_set_p(insn, w0) &&
                      pic30_dead_or_set_p(insn, w1)) {
                    return \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"bra nov,.NOV%=\;\"
                           \"mov #0x7FFF,%0\"
                           \"setm w1\n\"                /* force C == 0 */
                           \".NOV%=:\;\"
                           \"ff1r w1,%4\;\"             /* C = w1 == 0 */
                           \"com w0,%4\;\"              /* complement in case
                                                            of negate */
                           \"btsc %3,#15\;\"            /* if negative, neg */
                           \"addc %4,#0,w0\;\"
                           \"mov w0,%0\";
                  } else {
                    return \"mov.d w0,[w15++]\;\"
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"bra nov,.NOV%=\;\"
                           \"mov #0x7FFF,%0\;\"
                           \"setm w1\n\"                /* force C == 0 */
                           \".NOV%=:\;\"
                           \"ff1r w1,%4\;\"             /* C = w1 == 0 */
                           \"com w0,%4\;\"              /* complement in case
                                                            of negate */
                           \"btsc %3,#15\;\"            /* if negative, neg */
                           \"addc %4,#0,w0\;\"
                           \"mov w0,%0\;\"
                           \"mov.d [--w15],w0\";
                  }
         default: gcc_assert(0);
       }
     } else if (pic30_fp_round_p() == pic30_conventional) {
       switch (which_alternative) {
         case 0:  /*
                ** wm/wn -> w0
                */
                  if (pic30_dead_or_set_p(insn, w1)) {
                                                     /* all follow sim. flow */
                    return 
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"bra ov,.OV%=\;\"
                           \"sl w1,%4\;\"
                           \"sub %4,%2,%4\;\"        /* compare 2*remainder */
                           \"btss _SR,#0\;\"         /* carry set, use new val*/
                           \"mov %4,w1\;\"
                           \"rlc w0,w0\;\"           /* put R in low bit */

                           \"ff1r w1,%4\;\"          /* C = w1 == 0 */
                           \"com w0,%4\;\"           /* complement in case
                                                        of negate */
                           \"btsc %3,#15\;\"         /* if negative, neg */
                           \"addc %4,#0,w0\;\"
                           \"rlc %3,[w15]\;\"        /* get sign in carry */
                           \"rrc w0,w0\;\"           /* div by 2 again */
                           \"addc w0,#0,%0\;\"       /* add in round */
                           \"bra nov,.NOV%=\n\"
                           \".OV%=:\;\"
                           \"mov #0x7FFF,%0\;\"
                           \"btsc %3,#15\;\"
                           \"com %0,%0\n\"
                           \".NOV%=:\";
                  } else {
                      return \"mov w1,[w15++]\;\"
                             \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                             \"divf %1,%2\;\"
                             \"bra ov,.OV%=\;\"
                             \"sl w1,%4\;\"
                             \"sub %4,%2,%4\;\"      /* compare 2*remainder */
                             \"btss _SR,#0\;\"       /* carry set, use new val*/
                             \"mov %4,w1\;\"
                             \"rlc w0,w0\;\"         /* put R in low bit */
                             \"ff1r w1,%4\;\"        /* C = w1 == 0 */ 
                             \"com w0,%4\;\"         /* complement in case
                                                        of negate */
                             \"btsc %3,#15\;\"       /* if negative, neg */ 
                             \"addc %4,#0,w0\;\"
                             \"rlc %3,[w15]\;\"        /* get sign in carry */
                             \"rrc w0,w0\;\"           /* div by 2 again */
                             \"addc w0,#0,%0\;\"       /* add in round */
                             \"bra nov,.NOV%=\n\"
                             \".OV%=:\;\"
                             \"mov #0x7FFF,%0\;\"
                             \"btsc %3,#15\;\"
                             \"com %0,%0\n\"
                             \".NOV%=:\;\"
                             \"mov [--w15],w1\";
                }
         case 1:  /*
                  ** wm/wn -> w1
                  */
                  if (pic30_dead_or_set_p(insn, w0)) {
                    return 
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"bra ov,.OV%=\;\"
                           \"sl w1,%4\;\"
                           \"sub %4,%2,%4\;\"        /* compare 2*remainder */
                           \"btss _SR,#0\;\"         /* carry set, use new val*/
                           \"mov %4,w1\;\"
                           \"rlc w0,w0\;\"           /* put R in low bit */
                           \"ff1r w1,%4\;\"          /* C = w1 == 0 */ 
                           \"com w0,%4\;\"           /* complement in case
                                                        of negate */
                           \"btsc %3,#15\;\"         /* if negative, neg */ 
                           \"addc %4,#0,w0\;\"
                           \"rlc %3,[w15]\;\"        /* get sign in carry */
                           \"rrc w0,w0\;\"           /* div by 2 again */
                           \"addc w0,#0,%0\;\"       /* add in round */
                           \"bra nov,.NOV%=\n\"
                           \".OV%=:\;\"
                           \"mov #0x7FFF,%0\;\"
                           \"btsc %3,#15\;\"
                           \"com %0,%0\n\"
                           \".NOV%=:\";
                  } else {
                    return \"mov w0,[w15++]\;\"
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"bra ov,.OV%=\;\"
                           \"sl w1,%4\;\"
                           \"sub %4,%2,%4\;\"        /* compare 2*remainder */
                           \"btss _SR,#0\;\"         /* carry set, use new val*/
                           \"mov %4,w1\;\"
                           \"rlc w0,w0\;\"           /* put R in low bit */
                           \"ff1r w1,%4\;\"          /* C = w1 == 0 */ 
                           \"com w0,%4\;\"           /* complement in case
                                                        of negate */
                           \"btsc %3,#15\;\"         /* if negative, neg */ 
                           \"addc %4,#0,w0\;\"
                           \"rlc %3,[w15]\;\"        /* get sign in carry */
                           \"rrc w0,w0\;\"           /* div by 2 again */
                           \"addc w0,#0,%0\;\"       /* add in round */
                           \"bra nov,.NOV%=\n\"
                           \".OV%=:\;\"
                           \"mov #0x7FFF,%0\;\"
                           \"btsc %3,#15\;\"
                           \"com %0,%0\n\"
                           \".NOV%=:\;\"
                           \"mov [--w15],w0\";
                  }
         case 2:  /*
                  ** wm/wn -> we
                  */
                  if (pic30_dead_or_set_p(insn, w0) &&
                      pic30_dead_or_set_p(insn, w1)) {
                    return 
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"bra ov,.OV%=\;\"
                           \"sl w1,%4\;\"
                           \"sub %4,%2,%4\;\"        /* compare 2*remainder */
                           \"btss _SR,#0\;\"         /* carry set, use new val*/
                           \"mov %4,w1\;\"
                           \"rlc w0,w0\;\"           /* put R in low bit */
                           \"ff1r w1,%4\;\"          /* C = w1 == 0 */ 
                           \"com w0,%4\;\"           /* complement in case
                                                        of negate */
                           \"btsc %3,#15\;\"         /* if negative, neg */ 
                           \"addc %4,#0,w0\;\"
                           \"rlc %3,[w15]\;\"        /* get sign in carry */
                           \"rrc w0,w0\;\"           /* div by 2 again */
                           \"addc w0,#0,%0\;\"       /* add in round */
                           \"bra nov,.NOV%=\n\"
                           \".OV%=:\;\"
                           \"mov #0x7FFF,%0\;\"
                           \"btsc %3,#15\;\"
                           \"com %0,%0\n\"
                           \".NOV%=:\";
                  } else {
                    return \"mov.d w0,[w15++]\;\"
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"bra ov,.OV%=\;\"
                           \"sl w1,%4\;\"
                           \"sub %4,%2,%4\;\"        /* compare 2*remainder */
                           \"btss _SR,#0\;\"         /* carry set, use new val*/
                           \"mov %4,w1\;\"
                           \"rlc w0,w0\;\"           /* put R in low bit */
                           \"ff1r w1,%4\;\"          /* C = w1 == 0 */ 
                           \"com w0,%4\;\"           /* complement in case
                                                        of negate */
                           \"btsc %3,#15\;\"         /* if negative, neg */ 
                           \"addc %4,#0,w0\;\"
                           \"rlc %3,[w15]\;\"        /* get sign in carry */
                           \"rrc w0,w0\;\"           /* div by 2 again */
                           \"addc w0,#0,%0\;\"       /* add in round */
                           \"bra nov,.NOV%=\n\"
                           \".OV%=:\;\"
                           \"mov #0x7FFF,%0\;\"
                           \"btsc %3,#15\;\"
                           \"com %0,%0\n\"
                           \".NOV%=:\;\"
                           \"mov.d [--w15],w0\";
                  }
         default: gcc_assert(0);
       }
     } else if (pic30_fp_round_p() == pic30_convergent) {
       switch (which_alternative) {
         case 0:  /*
                  ** wm/wn -> w0
                  */
                  if (pic30_dead_or_set_p(insn, w1)) {
                                                     /* convergent follows this
                                                        form */
                    return 
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"bra ov,.OV%=\;\"
                           \"sl w1,%4\;\"
                           \"sub %4,%2,%4\;\"        /* compare 2*remainder */
                           \"btss _SR,#0\;\"         /* carry set, use new val*/
                           \"mov %4,w1\;\"
                           \"btsc _SR,#1\;\"
                           \"btst.c w0,#0\;\"        /*   copy low bit to c */
                                                     /*   ie if low bit == 0 */
                                                     /*      don't add */
                           \"rlc w0,w0\;\"           /* put R in low bit */
                           \"ff1r w1,%4\;\"          /* C = w1 == 0 */ 
                           \"com w0,%4\;\"           /* complement in case
                                                        of negate */
                           \"btsc %3,#15\;\"         /* if negative, neg */ 
                           \"addc %4,#0,w0\;\"
                           \"rlc %3,[w15]\;\"        /* get sign in carry */
                           \"rrc w0,w0\;\"           /* div by 2 again */
                           \"addc.w w0,#0,%0\;\"     /* add carry */
                           \"bra nov,.NOV%=\n\"
                           \".OV%=:\;\"
                           \"mov #0x7FFF,%0\;\"
                           \"btsc %3,#15\;\"
                           \"com %0,%0\n\"
                           \".NOV%=:\";
                  } else {
                      return \"mov w1,[w15++]\;\"
                             \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                             \"divf %1,%2\;\"
                             \"bra ov,.OV%=\;\"
                             \"sl w1,%4\;\"
                             \"sub %4,%2,%4\;\"      /* compare 2*remainder */
                             \"btss _SR,#0\;\"       /* carry set, use new val*/
                             \"mov %4,w1\;\"
                             \"btsc _SR,#1\;\"
                             \"btst.c w0,#0\;\"      /*   copy low bit to c */
                                                     /*   ie if low bit == 0 */
                                                     /*      don't add */
                             \"rlc w0,w0\;\"         /* put R in low bit */
                             \"ff1r w1,%4\;\"        /* C = w1 == 0 */ 
                             \"com w0,%4\;\"         /* complement in case
                                                        of negate */
                             \"btsc %3,#15\;\"       /* if negative, neg */ 
                             \"addc %4,#0,w0\;\"
                             \"rlc %3,[w15]\;\"      /* get sign in carry */
                             \"rrc w0,w0\;\"         /* div by 2 again */
                             \"addc.w w0,#0,%0\;\" 
                             \"bra nov,.NOV%=\n\"
                             \".OV%=:\;\"
                             \"mov #0x7FFF,%0\;\"
                             \"btsc %3,#15\;\"
                             \"com %0,%0\n\"
                             \".NOV%=:\;\"
                             \"mov [--w15],w1\";
                  }
         case 1:  /*
                  ** wm/wn -> w1
                  */
                  if (pic30_dead_or_set_p(insn, w0)) {
                    return 
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"bra ov,.OV%=\;\"
                           \"sl w1,%4\;\"
                           \"sub %4,%2,%4\;\"        /* compare 2*remainder */
                           \"btss _SR,#0\;\"         /* carry set, use new val*/
                           \"mov %4,w1\;\"
                           \"btsc _SR,#1\;\"
                           \"btst.c w0,#0\;\"        /*   copy low bit to c */
                                                     /*   ie if low bit == 0 */
                                                     /*      don't add */
                           \"rlc w0,w0\;\"           /* put R in low bit */
                           \"ff1r w1,%4\;\"          /* C = w1 == 0 */ 
                           \"com w0,%4\;\"           /* complement in case
                                                        of negate */
                           \"btsc %3,#15\;\"         /* if negative, neg */ 
                           \"addc %4,#0,w0\;\"
                           \"rlc %3,[w15]\;\"        /* get sign in carry */
                           \"rrc w0,w0\;\"           /* div by 2 again */
                           \"addc.w w0,#0,%0\;\"
                           \"bra nov,.NOV%=\n\"
                           \".OV%=:\;\"
                           \"mov #0x7FFF,%0\;\"
                           \"btsc %3,#15\;\"
                           \"com %0,%0\n\"
                           \".NOV%=:\";
                  } else {
                    return \"mov w0,[w15++]\;\"
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"bra ov,.OV%=\;\"
                           \"sl w1,%4\;\"
                           \"sub %4,%2,%4\;\"        /* compare 2*remainder */
                           \"btss _SR,#0\;\"         /* carry set, use new val*/
                           \"mov %4,w1\;\"
                           \"btsc _SR,#1\;\"
                           \"btst.c w0,#0\;\"        /*   copy low bit to c */
                                                     /*   ie if low bit == 0 */
                                                     /*      don't add */
                           \"rlc w0,w0\;\"           /* put R in low bit */
                           \"ff1r w1,%4\;\"          /* C = w1 == 0 */ 
                           \"com w0,%4\;\"           /* complement in case
                                                        of negate */
                           \"btsc %3,#15\;\"         /* if negative, neg */ 
                           \"addc %4,#0,w0\;\"
                           \"rlc %3,[w15]\;\"        /* get sign in carry */
                           \"rrc w0,w0\;\"           /* div by 2 again */
                           \"addc.w w0,#0,%0\;\" 
                           \"bra nov,.NOV%=\n\"
                           \".OV%=:\;\"
                           \"mov #0x7FFF,%0\;\"
                           \"btsc %3,#15\;\"
                           \"com %0,%0\n\"
                           \".NOV%=:\;\"
                           \"mov [--w15],w0\";
                  }
         case 2:  /*
                  ** wm/wn -> we
                  */
                  if (pic30_dead_or_set_p(insn, w0) &&
                      pic30_dead_or_set_p(insn, w1)) {
                    return \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"bra ov,.OV%=\;\"
                           \"sl w1,%4\;\"
                           \"sub %4,%2,%4\;\"        /* compare 2*remainder */
                           \"btss _SR,#0\;\"         /* carry set, use new val*/
                           \"mov %4,w1\;\"
                           \"btsc _SR,#1\;\"
                           \"btst.c w0,#0\;\"        /*   copy low bit to c */
                                                     /*   ie if low bit == 0 */
                                                     /*      don't add */
                           \"rlc w0,w0\;\"           /* put R in low bit */
                           \"ff1r w1,%4\;\"          /* C = w1 == 0 */ 
                           \"com w0,%4\;\"           /* complement in case
                                                        of negate */
                           \"btsc %3,#15\;\"         /* if negative, neg */ 
                           \"addc %4,#0,w0\;\"
                           \"rlc %3,[w15]\;\"        /* get sign in carry */
                           \"rrc w0,w0\;\"           /* div by 2 again */
                           \"addc.w w0,#0,%0\;\"
                           \"bra nov,.NOV%=\n\"
                           \".OV%=:\;\"
                           \"mov #0x7FFF,%0\;\"
                           \"btsc %3,#15\;\"
                           \"com %0,%0\n\"
                           \".NOV%=:\";
                  } else {
                    return \"mov.d w0,[w15++]\;\"
                           \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                           \"divf %1,%2\;\"
                           \"sl w1,%4\;\"
                           \"sub %4,%2,%4\;\"        /* compare 2*remainder */
                           \"btss _SR,#0\;\"         /* carry set, use new val*/
                           \"mov %4,w1\;\"
                           \"btsc _SR,#1\;\"
                           \"btst.c w0,#0\;\"        /*   copy low bit to c */
                                                     /*   ie if low bit == 0 */
                                                     /*      don't add */
                           \"rlc w0,w0\;\"           /* put R in low bit */
                           \"bra ov,.OV%=\;\"
                           \"ff1r w1,%4\;\"          /* C = w1 == 0 */ 
                           \"com w0,%4\;\"           /* complement in case
                                                        of negate */
                           \"btsc %3,#15\;\"         /* if negative, neg */ 
                           \"addc %4,#0,w0\;\"
                           \"rlc %3,[w15]\;\"        /* get sign in carry */
                           \"rrc w0,w0\;\"           /* div by 2 again */
                           \"addc.w w0,#0,%0\;\" 
                           \"bra nov,.NOV%=\n\"
                           \".OV%=:\;\"
                           \"mov #0x7FFF,%0\;\"
                           \"btsc %3,#15\;\"
                           \"com %0,%0\n\"
                           \".NOV%=:\;\"
                           \"mov.d [--w15],w0\";
                  }
         default: gcc_assert(0);
       }
     }
     gcc_assert(0);
     return \"nop\";
  } 
  "
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def")
  ]
)

(define_expand "udiv<mode>3"
  [(set (match_operand:UQ15 0 "pic30_register_operand"    "=a,?b,??e")
        (udiv:UQ15
          (match_operand:UQ15 1 "pic30_register_operand"   "r, r,  r")
          (match_operand:UQ15 2 "pic30_ereg_operand"       "e, e,  e")))]
  ""
  "
  {  rtx ra,rb;

     /* divf is not valid on 24F targets */
     if (!pic30_dsp_target()) FAIL;
     ra = operands[1];
     rb = operands[2];
     if (!pic30_register_operand(ra,<MODE>mode))
       ra = force_reg(<MODE>mode, ra);
     if (!pic30_register_operand(rb,<MODE>mode))
       rb = force_reg(<MODE>mode, rb);
     emit(
       gen_udiv<mode>3_helper(operands[0],ra,rb)
     );
     DONE;
  }"
)

(define_expand "div<mode>3"
  [(set (match_operand:Q15 0 "pic30_register_operand"    "=a,?b,??e")
        (div:Q15
          (match_operand:Q15 1 "pic30_register_operand"   "r, r,  r")
          (match_operand:Q15 2 "pic30_ereg_operand"       "e, e,  e")))]
  ""
  "
  {  rtx ra,rb;
     rtx ura,urb;
     rtx sign, hi1,hi2;

     /* divf is not valid on 24F targets */
     if (!pic30_dsp_target()) FAIL;
     ra = operands[1];
     rb = operands[2];
     if (!pic30_register_operand(ra,<MODE>mode))
       ra = force_reg(<MODE>mode, ra);
     if (!pic30_register_operand(rb,<MODE>mode))
       rb = force_reg(<MODE>mode, rb);
     sign = gen_reg_rtx(HImode);
     hi1 = gen_rtx_SUBREG(HImode, ra, 0);
     hi2 = gen_rtx_SUBREG(HImode, rb, 0);
     emit(
       gen_xorhi3(sign,hi1,hi2)
     );
     ura = gen_reg_rtx(<MODE>mode);
     urb = gen_reg_rtx(<MODE>mode);
     emit(
       gen_abs<mode>2(ura,ra)
     );
     emit(
       gen_abs<mode>2(urb,rb)
     );
     emit(
       gen_div<mode>3_helper(operands[0],ura,urb,sign)
     );
     DONE;
  }"
)

(define_insn "sssaturate<mode>"
  [(set (match_operand:QUQ15    0 "pic30_register_operand" "=&r")
        (unspec:QUQ15 [
           (match_operand:QUQ15 1 "pic30_register_operand" "0")
           (match_operand:HI    2 "pic30_register_operand" "r")
         ] UNSPEC_SATURATE)
   ) 
   (clobber (match_scratch:HI 3                        "=&r"))
  ]
  ""
  "*
   return \"xor %1,%2,%3\;\"    /* test result sign with expected */
          \"btss %3,#15\;\"
          \"bra .SAT%=\;\"        /* if they are the same we are done */
          \"mov #0x8000,%0\;\"  /* otherwise saturate to the expected sign */
          \".SAT%=:\";
  "
)

(define_expand "usdiv<mode>3"
  [(set (match_operand:UQ15 0 "pic30_register_operand"    "=a,?b,??e")
        (us_div:UQ15
          (match_operand:UQ15 1 "pic30_register_operand"   "r, r,  r")
          (match_operand:UQ15 2 "pic30_ereg_operand"       "e, e,  e")))]
  ""
  "
  {  rtx ra,rb;

     /* divf is not valid on 24F targets */
     if (!pic30_dsp_target()) FAIL;
     ra = operands[1];
     rb = operands[2];
     if (!pic30_register_operand(ra,<MODE>mode))
       ra = force_reg(<MODE>mode, ra);
     if (!pic30_register_operand(rb,<MODE>mode))
       rb = force_reg(<MODE>mode, rb);
     emit(
       gen_usatdiv<mode>3_helper(operands[0],ra,rb)
     );
     DONE;
  }"
)

(define_expand "ssdiv<mode>3"
  [(set (match_operand:Q15    0 "pic30_register_operand"  "=a,?b,??e")
        (ss_div:Q15
          (match_operand:Q15  1 "pic30_register_operand"   "r, r,  r")
          (match_operand:Q15  2 "pic30_ereg_operand"       "e, e,  e")))
   (clobber (match_scratch:HI 3                           "=r, r,  r"))
  ]
  ""
  "
  {  rtx ra,rb;
     rtx ura,urb;
     rtx sign,hi1,hi2;

     /* divf is not valid on 24F targets */
     if (!pic30_dsp_target()) FAIL;
     ra = operands[1];
     rb = operands[2];
     if (!pic30_register_operand(ra,<MODE>mode))
       ra = force_reg(<MODE>mode, ra);
     if (!pic30_register_operand(rb,<MODE>mode))
       rb = force_reg(<MODE>mode, rb);
     hi1 = gen_rtx_SUBREG(HImode, ra, 0);
     hi2 = gen_rtx_SUBREG(HImode, rb, 0);
     sign = gen_reg_rtx(HImode);
     emit(
       gen_xorhi3(sign,hi1, hi2)
     );
     ura = gen_reg_rtx(<MODE>mode);
     urb = gen_reg_rtx(<MODE>mode);
     emit(
       gen_abs<mode>2(ura,ra)
     );
     emit(
       gen_abs<mode>2(urb,rb)
     );
     emit(
       gen_ssatdiv<mode>3_helper(operands[0],ura,urb,sign)
     );
     DONE;
  }"
)

;; *** multiply
;  32-bit
; handled by helper routines in libfx

;; *** conversions
; 16-bit

;  [sat]fract[uns]mn2
;
;    These patterns handle modes m,n where m,n are any combination of
;      fixed-point, floating-point, [un]signed integer
;  
;    One of the modes is fixed.
;

; integer (IMODE) modes
;  from Q15

(define_insn "fract<mode>qi2_helper"
  [(set (match_operand:QI    0 "pic30_register_operand"  "=&r")
        (fract_convert:QI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %1,#15,%0\"; 
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %1,#14,%0\;btss %0,#0\;clr.b %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fract<mode>qi2_convergent"
  [(set (match_operand:QI      0 "pic30_register_operand" "=&r")
        (fract_convert:QI
          (match_operand:QUQ15   1 "pic30_register_operand"   "r")))
   (clobber (match_scratch:QUQ15 2                           "=r"))
  ]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr.b %0\;\"
              \"sl %1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"    /*   always rounds to even 0 */
              \"clr.b %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fract<mode>qi2"
  [(set (match_operand:QI    0 "pic30_register_operand" "=r")
        (fract_convert:QI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  ""
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,QImode)) {
      r0 = gen_reg_rtx(QImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_fract<mode>qi2_convergent(r0,r1)
      );
    } else {
      emit(
        gen_fract<mode>qi2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fract<mode>hi2_helper"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=&r")
        (fract_convert:HI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %1,#15,%0\"; 
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %1,#14,%0\;btss %0,#0\;clr %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fract<mode>hi2_convergent"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=&r")
        (fract_convert:HI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ15 2                         "=r"))
  ]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr %0\;\"
              \"sl %1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"    /*   always rounds to even 0 */
              \"clr %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fract<mode>hi2"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=r")
        (fract_convert:HI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  ""
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,HImode)) {
      r0 = gen_reg_rtx(HImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_fract<mode>hi2_convergent(r0,r1)
      );
    } else {
      emit(
        gen_fract<mode>hi2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fract<mode>si2_helper"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=&r")
        (fract_convert:SI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %1,#15,%d0\;asr %1,#15,%0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %1,#14,%0\;btss %0,#0\;clr %0\;asr %0,#15,%d0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fract<mode>si2_convergent"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=&r")
        (fract_convert:SI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ15 2                         "=r"))
  ]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %1,#14,%0\;\" /* as conventional */
              \"btss %0,#0\;\"
              \"clr  %0\;\"
              \"asr %0,#15,%d0\;\"
              \"sl %1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"    /*   always rounds to even 0 */
              \"mul.uu %0,#0,%0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fract<mode>si2"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=r")
        (fract_convert:SI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  ""
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,SImode)) {
      r0 = gen_reg_rtx(SImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_fract<mode>si2_convergent(r0,r1)
      );
    } else {
      emit(
        gen_fract<mode>si2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fract<mode>di2_helper"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=&r")
        (fract_convert:DI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %1,#15,%q0\;asr %1,#15,%t0\;mul.su %t0,#1,%0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %1,#14,%0\;\"
              \"btss %0,#0\;\"
              \"clr %0\;\"
              \"asr %0,#15,%d0\;\"
              \"mul.su %d0,#1,%t0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fract<mode>di2_convergent"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=&r")
        (fract_convert:DI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ15 2                         "=r"))
  ]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr  %0\;\"
              \"asr %0,#15,%d0\;\"
              \"sl %1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"    /*   always rounds to even 0 */
              \"mul.uu %0,#0,%0\;\"
              \"mul.su %d0,#1,%t0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fract<mode>di2"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=r")
        (fract_convert:DI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  ""
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && 
        ((pic30_fp_round_p() == pic30_convergent) ||
         (pic30_fp_round_p() == pic30_conventional)))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,DImode)) {
      r0 = gen_reg_rtx(DImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_fract<mode>di2_convergent(r0,r1)
      );
    } else {
      emit(
        gen_fract<mode>di2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

; from Q31

(define_insn "fract<mode>qi2_helper"
  [(set (match_operand:QI    0 "pic30_register_operand"  "=&r")
        (fract_convert:QI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %d1,#15,%0\"; 
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %d1,#14,%0\;btss %0,#0\;clr.b %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fract<mode>qi2_convergent"
  [(set (match_operand:QI    0 "pic30_register_operand"  "=&r")
        (fract_convert:QI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ31 2                         "=&r"))
  ]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %d1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr.b %0\;\"
              \"sl %d1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"     /*   always rounds to even 0 */
              \"cp0 %1\;\"  
              \"btsc _SR,#1\;\"
              \"clr %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fract<mode>qi2"
  [(set (match_operand:QI    0 "pic30_register_operand"  "=r")
        (fract_convert:QI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  ""
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,QImode)) {
      r0 = gen_reg_rtx(QImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_fract<mode>qi2_convergent(r0,r1)
      );
    } else {
      emit(
        gen_fract<mode>qi2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fract<mode>hi2_helper"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=&r")
        (fract_convert:HI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %d1,#15,%0\"; 
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %d1,#14,%0\;btss %0,#0\;clr %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fract<mode>hi2_convergent"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=&r")
        (fract_convert:HI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ31 2                         "=&r"))
  ]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %d1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr %0\;\"
              \"sl %d1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"     /*   always rounds to even 0 */
              \"cp0 %1\;\"  
              \"btsc _SR,#1\;\"
              \"clr %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fract<mode>hi2"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=r")
        (fract_convert:HI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  ""
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,HImode)) {
      r0 = gen_reg_rtx(HImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_fract<mode>hi2_convergent(r0,r1)
      );
    } else {
      emit(
        gen_fract<mode>hi2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fract<mode>si2_helper"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=&r")
        (fract_convert:SI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %d1,#15,%d0\;asr %d1,#15,%0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %d1,#14,%0\;\"
              \"btss %0,#0\;\"
              \"clr %0\;\"
              \"asr %0,#15,%d0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fract<mode>si2_convergent"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=&r")
        (fract_convert:SI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ31 2                         "=&r"))
  ]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %d1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr  %0\;\"
              \"asr %0,#15,%d0\;\"
              \"sl %d1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"     /*   always rounds to even 0 */
              \"cp0 %1\;\"
              \"btsc _SR,#1\;\"
              \"mul.uu %0,#0,%0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fract<mode>si2"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=r")
        (fract_convert:SI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  ""
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,SImode)) {
      r0 = gen_reg_rtx(SImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_fract<mode>si2_convergent(r0,r1)
      );
    } else {
      emit(
        gen_fract<mode>si2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fract<mode>di2_helper"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=&r")
        (fract_convert:DI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %d1,#15,%q0\;asr %d1,#15,%t0\;mul.su %t0,#1,%0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %d1,#14,%0\;\"
              \"btss %0,#0\;\"
              \"clr %0\;\"
              \"asr %0,#15,%d0\;\"
              \"mul.su %d0,#1,%t0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fract<mode>di2_convergent"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=&r")
        (fract_convert:DI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ31 2                         "=&r"))
  ]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %d1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr  %0\;\"
              \"asr %0,#15,%d0\;\"
              \"sl %d1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"     /*   always rounds to even 0 */
              \"cp0 %1\;\"
              \"btsc _SR,#1\;\"
              \"mul.uu %0,#0,%0\;\"
              \"mul.su %d0,#1,%t0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fract<mode>di2"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=r")
        (fract_convert:DI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  ""
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && 
         ((pic30_fp_round_p() == pic30_convergent) ||
          (pic30_fp_round_p() == pic30_convergent)))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,DImode)) {
      r0 = gen_reg_rtx(DImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_fract<mode>di2_convergent(r0,r1)
      );
    } else {
      emit(
        gen_fract<mode>di2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

; from ACC

(define_insn "fract<mode>qi2_helper"
  [(set (match_operand:QI    0 "pic30_register_operand"   "=&r,r")
        (fract_convert:QI
          (match_operand:ACC 1 "pic30_accum_or_reg_operand" "r,w")))
  ]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits; remember with 9.31 the lowest order  */
       /*  integer bit is in the 15th bit of 2nd word */
       if (which_alternative == 0)
         return \"sl %d1,[w15]\;\"
                \"rlc %t1,%0\";
       else 
         return \"mov %m1U,%0\;\"
                \"sl %0,%0\;\"
                \"btsc %m1H,#15\;\"
                \"inc %0,%0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       if (which_alternative == 0)
         return \"sl %d1,[w15]\;\"
                \"rlc %t1,%0\;\"
                \"btst.c %d1,#14\;\"
                \"addc.b %0,#0,%0\";
       else 
         return \"mov %m1U,%0\;\"
                \"sl %0,%0\;\"
                \"btsc %m1H,#15\;\"
                \"inc %0,%0\;\"
                \"btsc %m1H,#14\;\"
                \"inc %0,%0\;\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fract<mode>qi2_convergent"
  [(set (match_operand:QI     0 "pic30_register_operand" "=&r")
        (fract_convert:QI
          (match_operand:ACC  1 "pic30_register_operand"   "r")))
   (clobber (match_scratch:HI 2                           "=&r"))
  ]
  ""
  "*
   return \"sl %d1,%2\;\"
          \"rlc.b %t1,%0\;\"
          \"sl %2,%2\;\"
          \"ior %2,%1,[w15]\;\"
          \"btsc _SR,#0\;\"   /* carry clear? */
          \"bset _SR,#0\;\"
          \"btsc _SR,#1\;\"
          \"btst.c %0,#0\;\"
          \"addc.b %0,#0,%0\";

  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fract<mode>qi2"
  [(set (match_operand:QI    0 "pic30_register_operand"    "=r")
        (fract_convert:QI
          (match_operand:ACC 1 "pic30_accum_or_reg_operand" "rw")))]
  ""
  "
  { rtx r0,r1;

    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,QImode)) {
      r0 = gen_reg_rtx(QImode);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      if (!pic30_accum_or_reg_operand(r1,<MODE>mode)) {
        r1 = force_reg(<MODE>mode, r1);
      }
      emit(
        gen_fract<mode>qi2_convergent(r0,r1)
      );
    } else {
      if (!pic30_register_operand(r1,VOIDmode)) {
        r1 = force_reg(<MODE>mode, r1);
      }
      emit(
        gen_fract<mode>qi2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fract<mode>hi2_helper"
  [(set (match_operand:HI    0 "pic30_register_operand"   "=&r,r")
        (fract_convert:HI
          (match_operand:ACC 1 "pic30_accum_or_reg_operand" "r,w")))
  ]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits; remember with 9.31 the lowest order  */
       /*  integer bit is in the 15th bit of 2nd word */
       if (which_alternative == 0)
         return \"se %t1,%0\;\"
                \"sl %d1,[w15]\;\"
                \"rlc %0,%0\;\";
       else 
         return \"mov %m1U,%0\;\"
                \"se %0,%0\;\"
                \"sl %0,%0\;\"
                \"btsc %m1H,#15\;\"
                \"inc %0,%0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       if (which_alternative == 0)
         return \"se %t1,%0\;\"
                \"sl %d1,[w15]\;\"
                \"rlc %0,%0\;\"
                \"btst.c %d1,#14\;\"
                \"addc %0,#0,%0\";
       else 
         return \"mov %m1U,%0\;\"
                \"se %0,%0\;\"
                \"sl %0,%0\;\"
                \"btsc %m1H,#15\;\"
                \"inc %0,%0\;\"
                \"btsc %m1H,#14\;\"
                \"inc %0,%0\;\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fract<mode>hi2_convergent"
  [(set (match_operand:HI     0 "pic30_register_operand" "=&r")
        (fract_convert:HI
          (match_operand:ACC  1 "pic30_register_operand"   "r")))
   (clobber (match_scratch:HI 2                           "=&r"))
  ]
  ""
  "*
   return \"se %t1,%0\;\"
          \"sl %d1,%2\;\"
          \"rlc %0,%0\;\"
          \"sl %2,%2\;\"
          \"ior %2,%1,[w15]\;\"
          \"btsc _SR,#0\;\"   /* carry clear? */
          \"bset _SR,#0\;\"
          \"btsc _SR,#1\;\"
          \"btst.c %0,#0\;\"
          \"addc %0,#0,%0\";
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fract<mode>hi2"
  [(set (match_operand:HI    0 "pic30_register_operand"    "=r")
        (fract_convert:HI
          (match_operand:ACC 1 "pic30_accum_or_reg_operand" "rw")))]
  ""
  "
  { rtx r0,r1;

    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,HImode)) {
      r0 = gen_reg_rtx(HImode);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      if (!pic30_accum_or_reg_operand(r1,<MODE>mode)) {
        r1 = force_reg(<MODE>mode, r1);
      }
      emit(
        gen_fract<mode>hi2_convergent(r0,r1)
      );
    } else {
      if (!pic30_register_operand(r1,VOIDmode)) {
        r1 = force_reg(<MODE>mode, r1);
      }
      emit(
        gen_fract<mode>hi2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fract<mode>qi2_helper"
  [(set (match_operand:QI     0 "pic30_register_operand"   "=&r,r")
        (fract_convert:QI
          (match_operand:UACC 1 "pic30_accum_or_reg_operand" "r,w")))
  ]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits; remember with 9.31 the lowest order  */
       /*  integer bit is in the 15th bit of 2nd word */
       if (which_alternative == 0)
         return \"sl %d1,[w15]\;\"
                \"rlc %t1,%0\";
       else 
         return \"mov %m1U,%0\;\"
                \"sl %0,%0\;\"
                \"btsc %m1H,#15\;\"
                \"inc %0,%0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       if (which_alternative == 0)
         return \"sl %d1,[w15]\;\"
                \"rlc %t1,%0\;\"
                \"btst.c %d1,#14\;\"
                \"addc.b %0,#0,%0\";
       else 
         return \"mov %m1U,%0\;\"
                \"sl %0,%0\;\"
                \"btsc %m1H,#15\;\"
                \"inc %0,%0\;\"
                \"btsc %m1H,#14\;\"
                \"inc %0,%0\;\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fract<mode>qi2_convergent"
  [(set (match_operand:QI      0 "pic30_register_operand" "=&r")
        (fract_convert:QI
          (match_operand:UACC  1 "pic30_register_operand"   "r")))
   (clobber (match_scratch:HI 2                           "=&r"))
  ]
  ""
  "sl %d1,%2\;rlc %t1,%0\;sl %2,%2\;ior %2,%1,[w15]\;btst.c %d1,#14\;btsc _SR,#1\;bclr _SR,#0\;addc %0,#0,%0"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fract<mode>qi2"
  [(set (match_operand:QI     0 "pic30_register_operand"    "=r")
        (fract_convert:QI
          (match_operand:UACC 1 "pic30_accum_or_reg_operand" "rw")))]
  ""
  "
  { rtx r0,r1;

    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,QImode)) {
      r0 = gen_reg_rtx(QImode);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      if (!pic30_accum_or_reg_operand(r1,<MODE>mode)) {
        r1 = force_reg(<MODE>mode, r1);
      }
      emit(
        gen_fract<mode>qi2_convergent(r0,r1)
      );
    } else {
      if (!pic30_register_operand(r1,VOIDmode)) {
        r1 = force_reg(<MODE>mode, r1);
      }
      emit(
        gen_fract<mode>qi2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fract<mode>hi2_helper"
  [(set (match_operand:HI     0 "pic30_register_operand"   "=&r,r")
        (fract_convert:HI
          (match_operand:UACC 1 "pic30_accum_or_reg_operand" "r,w")))
  ]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits; remember with 9.31 the lowest order  */
       /*  integer bit is in the 15th bit of 2nd word */
       if (which_alternative == 0)
         return \"ze %t1,%0\;\"
                \"sl %d1,[w15]\;\"
                \"rlc %t1,%0\";
       else 
         return \"mov %m1U,%0\;\"
                \"ze %0,%0\;\"
                \"sl %0,%0\;\"
                \"btsc %m1H,#15\;\"
                \"inc %0,%0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       if (which_alternative == 0)
         return \"ze %t0,%0\;\"
                \"sl %d1,[w15]\;\"
                \"rlc %0,%0\;\"
                \"btst.c %d1,#14\;\"
                \"addc %0,#0,%0\";
       else 
         return \"mov %m1U,%0\;\"
                \"ze %0,%0\;\"
                \"sl %0,%0\;\"
                \"btsc %m1H,#15\;\"
                \"inc %0,%0\;\"
                \"btsc %m1H,#14\;\"
                \"inc %0,%0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fract<mode>hi2_convergent"
  [(set (match_operand:HI      0 "pic30_register_operand" "=&r")
        (fract_convert:HI
          (match_operand:UACC  1 "pic30_register_operand"   "r")))
   (clobber (match_scratch:HI  2                           "=&r"))
  ]
  ""
  "*
   return \"ze %t1,%0\;\"
          \"sl %d1,%2\;\"
          \"rlc %0,%0\;\"
          \"sl %2,%2\;\"
          \"ior %2,%1,[w15]\;\"
          \"btsc _SR,#0\;\"   /* carry clear? */
          \"bset _SR,#0\;\"
          \"btsc _SR,#1\;\"
          \"btst.c %0,#0\;\"
          \"addc %0,#0,%0\";
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fract<mode>hi2"
  [(set (match_operand:HI     0 "pic30_register_operand"    "=r")
        (fract_convert:HI
          (match_operand:UACC 1 "pic30_accum_or_reg_operand" "rw")))]
  ""
  "
  { rtx r0,r1;

    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,HImode)) {
      r0 = gen_reg_rtx(HImode);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      if (!pic30_accum_or_reg_operand(r1,<MODE>mode)) {
        r1 = force_reg(<MODE>mode, r1);
      }
      emit(
        gen_fract<mode>hi2_convergent(r0,r1)
      );
    } else {
      if (!pic30_register_operand(r1,VOIDmode)) {
        r1 = force_reg(<MODE>mode, r1);
      }
      emit(
        gen_fract<mode>hi2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

; To SI and DI done by function only

; to Q15

(define_insn "fractqi<mode>2"
  [(set (match_operand:Q15  0 "pic30_register_operand"  "=&r")
        (fract_convert:Q15
          (match_operand:QI 1 "pic30_register_operand"  "r")))]
  "pic30_fp_inline_p()"
  "*
   {  
      return 
             \"cp0.b %1\;\"        /* compare input with 0 */
             \"mov #0x8000,%0\;\"  /* assume -1 */
             \"btsc _SR,#0\;\"     /* positive => 0 or .99 */
             \"mov #0x7FFF,%0\;\"  /*   load .99... */
             \"btsc _SR,#1\;\"     /* if zero */
             \"clr %0\";           /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fracthi<mode>2"
  [(set (match_operand:Q15  0 "pic30_register_operand"  "=&r")
        (fract_convert:Q15
          (match_operand:HI 1 "pic30_register_operand"  "r")))]
  "pic30_fp_inline_p()"
  "*
   {
      return 
             \"cp0  %1\;\"         /* compare input with 0 */
             \"mov #0x8000,%0\;\"  /* assume -1 */
             \"btsc _SR,#0\;\"     /* positive => 0 or .99 */
             \"mov #0x7FFF,%0\;\"  /*   load .99... */
             \"btsc _SR,#1\;\"     /* if zero */
             \"clr %0\";           /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractsi<mode>2"
  [(set (match_operand:Q15  0 "pic30_register_operand"  "=&r")
        (fract_convert:Q15
          (match_operand:SI 1 "pic30_register_operand"  "r")))]
  "pic30_fp_inline_p()"
  "*
   {  
      return 
             \"sub %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subb %d1,#0,[w15]\;\" /* compare input with 0 */
             \"mov #0x8000,%0\;\"    /* assume -1 */
             \"btsc _SR,#0\;\"       /* positive => 0 or .99 */
             \"mov #0x7FFF,%0\;\"    /*   load .99... */
             \"btsc _SR,#1\;\"       /* if zero */
             \"clr %0\";             /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractdi<mode>2"
  [(set (match_operand:Q15  0 "pic30_register_operand"  "=&r")
        (fract_convert:Q15
          (match_operand:DI 1 "pic30_register_operand"  "r")))]
  "pic30_fp_inline_p()"
  "*
   {  
      return 
             \"sub %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subb %d1,#0,[w15]\;\" /* compare input with 0 */
             \"subb %t1,#0,[w15]\;\" /* compare input with 0 */
             \"subb %q1,#0,[w15]\;\" /* compare input with 0 */
             \"mov #0x8000,%0\;\"    /* assume -1 */
             \"btsc _SR,#0\;\"       /* positive => 0 or .99 */
             \"mov #0x7FFF,%0\;\"    /*   load .99... */
             \"btsc _SR,#1\;\"       /* if zero */
             \"clr %0\";             /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractqi<mode>2"
  [(set (match_operand:UQ15  0 "pic30_register_operand"  "=&r")
        (fract_convert:UQ15
          (match_operand:QI  1 "pic30_register_operand"  "r")))]
  ""
  "*
   {  
      return 
             \"cp0.b %1\;\"        /* compare input with 0 */
             \"mov #0x7FFF,%0\;\"  /* assume ~1 */
             \"btsc _SR,#1\;\"     /* if zero */
             \"clr %0\";           /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fracthi<mode>2"
  [(set (match_operand:UQ15  0 "pic30_register_operand"  "=&r")
        (fract_convert:UQ15
          (match_operand:HI  1 "pic30_register_operand"  "r")))]
  ""
  "*
   {
      return 
             \"cp0.b %1\;\"        /* compare input with 0 */
             \"mov #0x7FFF,%0\;\"  /* assume ~1 */
             \"btsc _SR,#1\;\"     /* if zero */
             \"clr %0\";           /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractsi<mode>2"
  [(set (match_operand:UQ15  0 "pic30_register_operand"  "=&r")
        (fract_convert:UQ15
          (match_operand:SI  1 "pic30_register_operand"  "r")))]
  ""
  "*
   {  
      return 
             \"sub %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subb %d1,#0,[w15]\;\" /* compare input with 0 */
             \"mov #0x7FFF,%0\;\"    /* assume ~1 */
             \"btsc _SR,#1\;\"       /* if zero */
             \"clr %0\";             /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractdi<mode>2"
  [(set (match_operand:UQ15  0 "pic30_register_operand"  "=&r")
        (fract_convert:UQ15
          (match_operand:DI  1 "pic30_register_operand"  "r")))]
  ""
  "*
   {  
      return 
             \"sub %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subb %d1,#0,[w15]\;\" /* compare input with 0 */
             \"subb %t1,#0,[w15]\;\" /* compare input with 0 */
             \"subb %q1,#0,[w15]\;\" /* compare input with 0 */
             \"mov #0x7FFF,%0\;\"    /*   load .99... */
             \"btsc _SR,#1\;\"       /* if zero */
             \"clr %0\";             /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

; to Q31

(define_insn "fractqi<mode>2"
  [(set (match_operand:Q31  0 "pic30_register_operand"  "=&r")
        (fract_convert:Q31
          (match_operand:QI 1 "pic30_register_operand"  "r")))]
  "pic30_fp_inline_p()"
  "*
   {  
      return 
             \"cp0.b %1\;\"         /* compare input with 0 */
             \"mov #0x8000,%d0\;\"  /* assume -1 */
             \"btsc _SR,#0\;\"      /* positive => 0 or .99 */
             \"mov #0x7FFF,%d0\;\"  /*   load .99... */
             \"btsc _SR,#1\;\"      /* if zero */
             \"clr %d0\;\"          /*   load zero */
             \"sl  %d0,%0\;\"       /* form low word by propagating non sign */
             \"asr %0,#15,%0\";     /*   bits into low word */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fracthi<mode>2"
  [(set (match_operand:Q31  0 "pic30_register_operand"  "=&r")
        (fract_convert:Q31
          (match_operand:HI 1 "pic30_register_operand"  "r")))]
  "pic30_fp_inline_p()"
  "*
   {
      return 
             \"cp0.b %1\;\"         /* compare input with 0 */
             \"mov #0x8000,%d0\;\"  /* assume -1 */
             \"btsc _SR,#0\;\"      /* positive => 0 or .99 */
             \"mov #0x7FFF,%d0\;\"  /*   load .99... */
             \"btsc _SR,#1\;\"      /* if zero */
             \"clr %d0\;\"          /*   load zero */
             \"sl  %d0,%0\;\"       /* form low word by propagating non sign */
             \"asr %0,#15,%0\";     /*   bits into low word */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractsi<mode>2"
  [(set (match_operand:Q31  0 "pic30_register_operand"  "=&r")
        (fract_convert:Q31
          (match_operand:SI 1 "pic30_register_operand"  "r")))]
  "pic30_fp_inline_p()"
  "*
   {  
      return 
             \"sub %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subb %d1,#0,[w15]\;\" /* compare input with 0 */
             \"mov #0x8000,%d0\;\"   /* assume -1 */
             \"btsc _SR,#0\;\"       /* positive => 0 or .99 */
             \"mov #0x7FFF,%d0\;\"   /*   load .99... */
             \"btsc _SR,#1\;\"       /* if zero */
             \"clr %d0\;\"           /*   load zero */
             \"sl  %d0,%0\;\"        /* form low word by propagating non sign */
             \"asr %0,#15,%0\";      /*   bits into low word */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractdi<mode>2"
  [(set (match_operand:Q31  0 "pic30_register_operand"  "=&r")
        (fract_convert:Q31
          (match_operand:DI 1 "pic30_register_operand"  "r")))]
  "pic30_fp_inline_p()"
  "*
   {  
      return 
             \"sub %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subb %d1,#0,[w15]\;\" /* compare input with 0 */
             \"subb %t1,#0,[w15]\;\" /* compare input with 0 */
             \"subb %q1,#0,[w15]\;\" /* compare input with 0 */
             \"mov #0x8000,%d0\;\"   /* assume -1 */
             \"btsc _SR,#0\;\"       /* positive => 0 or .99 */
             \"mov #0x7FFF,%d0\;\"   /*   load .99... */
             \"btsc _SR,#1\;\"       /* if zero */
             \"clr %d0\;\"           /*   load zero */
             \"sl  %d0,%0\;\"        /* form low word by propagating non sign */
             \"asr %0,#15,%0\";      /*   bits into low word */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractqi<mode>2"
  [(set (match_operand:UQ31  0 "pic30_register_operand"  "=&r")
        (fract_convert:UQ31
          (match_operand:QI  1 "pic30_register_operand"  "r")))]
  ""
  "*
   {  
      return 
             \"cp0.b %1\;\"         /* compare input with 0 */
             \"mov #0x7FFF,%d0\;\"  /*   load .99... */
             \"setm %0\;\"
             \"btsc _SR,#1\;\"      /* if zero */
             \"mul.uu %0,#0,%0\";   /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fracthi<mode>2"
  [(set (match_operand:UQ31  0 "pic30_register_operand"  "=&r")
        (fract_convert:UQ31
          (match_operand:HI  1 "pic30_register_operand"  "r")))]
  ""
  "*
   {
      return 
             \"cp0.b %1\;\"         /* compare input with 0 */
             \"mov #0x7FFF,%d0\;\"  /*   load .99... */
             \"setm %0\;\"
             \"btsc _SR,#1\;\"      /* if zero */
             \"mul.uu %0,#0,%0\";   /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractsi<mode>2"
  [(set (match_operand:UQ31  0 "pic30_register_operand"  "=&r")
        (fract_convert:UQ31
          (match_operand:SI  1 "pic30_register_operand"  "r")))]
  ""
  "*
   {  
      return 
             \"sub %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subb %d1,#0,[w15]\;\" /* compare input with 0 */
             \"mov #0x7FFF,%d0\;\"   /*   load .99... */
             \"setm %0\;\"
             \"btsc _SR,#1\;\"       /* if zero */
             \"mul.uu %0,#0,%0\";    /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractdi<mode>2"
  [(set (match_operand:UQ31  0 "pic30_register_operand"  "=&r")
        (fract_convert:UQ31
          (match_operand:DI  1 "pic30_register_operand"  "r")))]
  ""
  "*
   {  
      return 
             \"sub %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subb %d1,#0,[w15]\;\" /* compare input with 0 */
             \"subb %t1,#0,[w15]\;\" /* compare input with 0 */
             \"subb %q1,#0,[w15]\;\" /* compare input with 0 */
             \"mov #0x7FFF,%d0\;\"   /*   load .99... */
             \"setm %0\;\"
             \"btsc _SR,#1\;\"       /* if zero */
             \"mul.uu %0,#0,%0\";    /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

; to ACC

(define_insn "fractqi<mode>2"
  [(set (match_operand:ACC  0 "pic30_register_operand"  "=&r")
        (fract_convert:ACC
          (match_operand:QI 1 "pic30_register_operand"    "r")))]
  "pic30_fp_inline_p()"
  "*
   {  
      return 
             \"mul.uu %0,#0,%0\;\"  /* clear low bits */
             \"mov.b %1,%t0\;\"     /* copy integer portion into upper byte */
             \"asr.b %t0,%t0\;\"    /* shift it into position */
             \"rrc %d0,%d0\";
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fracthi<mode>2"
  [(set (match_operand:ACC  0 "pic30_register_operand"  "=&r")
        (fract_convert:ACC
          (match_operand:HI 1 "pic30_register_operand"  "r")))]
  "pic30_fp_inline_p()"
  "*
   {
      return 
             \"mul.uu %0,#0,%0\;\"  /* clear low bits */
             \"mov %1,%t0\;\"       /* copy low integer portion to upper byte */
             \"asr.b %t0,%t0\;\"    /* shift it into position */
             \"rrc %d0,%d0\";
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractsi<mode>2"
  [(set (match_operand:ACC  0 "pic30_register_operand"  "=&r")
        (fract_convert:ACC
          (match_operand:SI 1 "pic30_register_operand"  "r")))]
  "pic30_fp_inline_p()"
  "*
   {  
      return 
             \"mul.uu %0,#0,%0\;\"  /* clear low bits */
             \"mov %1,%t0\;\"       /* copy low integer portion to upper byte */
             \"asr.b %t0,%t0\;\"    /* shift it into position */
             \"rrc %d0,%d0\";
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractdi<mode>2"
  [(set (match_operand:ACC  0 "pic30_register_operand"  "=&r")
        (fract_convert:ACC
          (match_operand:DI 1 "pic30_register_operand"  "r")))]
  "pic30_fp_inline_p()"
  "*
   {  
      return 
             \"mul.uu %0,#0,%0\;\"  /* clear low bits */
             \"mov %1,%t0\;\"       /* copy low integer portion to upper byte */
             \"asr.b %t0,%t0\;\"    /* shift it into position */
             \"rrc %d0,%d0\";
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractqi<mode>2"
  [(set (match_operand:UACC  0 "pic30_register_operand"  "=&r")
        (fract_convert:UACC
          (match_operand:QI  1 "pic30_register_operand"  "r")))]
  ""
  "*
   {  
      return 
             \"mul.uu %0,#0,%0\;\"  /* clear low bits */
             \"mov.b %1,%t0\;\"     /* copy integer portion into upper byte */
             \"asr.b %t0,%t0\;\"    /* shift it into position */
             \"rrc %d0,%d0\";
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fracthi<mode>2"
  [(set (match_operand:UACC  0 "pic30_register_operand"  "=&r")
        (fract_convert:UACC
          (match_operand:HI  1 "pic30_register_operand"  "r")))]
  ""
  "*
   {
      return 
             \"mul.uu %0,#0,%0\;\"  /* clear low bits */
             \"mov %1,%t0\;\"       /* copy low integer portion to upper byte */
             \"asr.b %t0,%t0\;\"    /* shift it into position */
             \"rrc %d0,%d0\";
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractsi<mode>2"
  [(set (match_operand:UACC  0 "pic30_register_operand"  "=&r")
        (fract_convert:UACC
          (match_operand:SI  1 "pic30_register_operand"  "r")))]
  ""
  "*
   {  
      return 
             \"mul.uu %0,#0,%0\;\"  /* clear low bits */
             \"mov %1,%t0\;\"       /* copy low integer portion to upper byte */
             \"asr.b %t0,%t0\;\"    /* shift it into position */
             \"rrc %d0,%d0\";
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractdi<mode>2"
  [(set (match_operand:UACC  0 "pic30_register_operand"  "=&r")
        (fract_convert:UACC
          (match_operand:DI  1 "pic30_register_operand"  "r")))]
  ""
  "*
   {  
      return 
             \"mul.uu %0,#0,%0\;\"  /* clear low bits */
             \"mov %1,%t0\;\"       /* copy low integer portion to upper byte */
             \"asr.b %t0,%t0\;\"    /* shift it into position */
             \"rrc %d0,%d0\";
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

; unsigned integer (IMODE) modes
;  from Q15

(define_insn "fractuns<mode>qi2_helper"
  [(set (match_operand:QI    0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:QI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       return \"asr %1,#15,%0\"; 
     } else if (pic30_fp_round_p() == pic30_conventional) {
       return \"asr %1,#14,%0\;btss %0,#0\;clr.b %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractuns<mode>qi2_convergent"
  [(set (match_operand:QI      0 "pic30_register_operand" "=&r")
        (unsigned_fract_convert:QI
          (match_operand:QUQ15   1 "pic30_register_operand"   "r")))
   (clobber (match_scratch:QUQ15 2                           "=r"))
  ]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr.b %0\;\"
              \"sl %1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"    /*   always rounds to even 0 */
              \"clr.b %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fractuns<mode>qi2"
  [(set (match_operand:QI    0 "pic30_register_operand" "=r")
        (unsigned_fract_convert:QI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  ""
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,QImode)) {
      r0 = gen_reg_rtx(QImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_fractuns<mode>qi2_convergent(r0,r1)
      );
    } else {
      emit(
        gen_fractuns<mode>qi2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fractuns<mode>hi2_helper"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:HI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %1,#15,%0\"; 
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %1,#14,%0\;btss %0,#0\;clr %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractuns<mode>hi2_convergent"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:HI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ15 2                         "=r"))
  ]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr %0\;\"
              \"sl %1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"    /*   always rounds to even 0 */
              \"clr %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fractuns<mode>hi2"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=r")
        (unsigned_fract_convert:HI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  ""
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,HImode)) {
      r0 = gen_reg_rtx(HImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_fractuns<mode>hi2_convergent(r0,r1)
      );
    } else {
      emit(
        gen_fractuns<mode>hi2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fractuns<mode>si2_helper"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:SI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %1,#15,%d0\;asr %1,#15,%0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %1,#14,%0\;btss %0,#0\;clr %0\;asr %0,#15,%d0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractuns<mode>si2_convergent"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:SI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ15 2                         "=r"))
  ]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %1,#14,%0\;\" /* as conventional */
              \"btss %0,#0\;\"
              \"clr  %0\;\"
              \"asr %0,#15,%d0\;\"
              \"sl %1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"    /*   always rounds to even 0 */
              \"mul.uu %0,#0,%0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fractuns<mode>si2"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=r")
        (unsigned_fract_convert:SI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  ""
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,SImode)) {
      r0 = gen_reg_rtx(SImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_fractuns<mode>si2_convergent(r0,r1)
      );
    } else {
      emit(
        gen_fractuns<mode>si2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fractuns<mode>di2_helper"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:DI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %1,#15,%q0\;asr %1,#15,%t0\;mul.su %t0,#1,%0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %1,#14,%0\;\"
              \"btss %0,#0\;\"
              \"clr %0\;\"
              \"asr %0,#15,%d0\;\"
              \"mul.su %d0,#1,%t0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractuns<mode>di2_convergent"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:DI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ15 2                         "=r"))
  ]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr  %0\;\"
              \"asr %0,#15,%d0\;\"
              \"sl %1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"    /*   always rounds to even 0 */
              \"mul.uu %0,#0,%0\;\"
              \"mul.su %d0,#1,%t0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fractuns<mode>di2"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=r")
        (unsigned_fract_convert:DI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  ""
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && 
        ((pic30_fp_round_p() == pic30_convergent) ||
         (pic30_fp_round_p() == pic30_conventional)))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,DImode)) {
      r0 = gen_reg_rtx(DImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_fractuns<mode>di2_convergent(r0,r1)
      );
    } else {
      emit(
        gen_fractuns<mode>di2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

; from Q31

(define_insn "fractuns<mode>qi2_helper"
  [(set (match_operand:QI    0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:QI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %d1,#15,%0\"; 
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %d1,#14,%0\;btss %0,#0\;clr.b %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractuns<mode>qi2_convergent"
  [(set (match_operand:QI    0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:QI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ31 2                         "=&r"))
  ]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %d1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr.b %0\;\"
              \"sl %d1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"     /*   always rounds to even 0 */
              \"cp0 %1\;\"  
              \"btsc _SR,#1\;\"
              \"clr %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fractuns<mode>qi2"
  [(set (match_operand:QI    0 "pic30_register_operand"  "=r")
        (unsigned_fract_convert:QI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  ""
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,QImode)) {
      r0 = gen_reg_rtx(QImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_fractuns<mode>qi2_convergent(r0,r1)
      );
    } else {
      emit(
        gen_fractuns<mode>qi2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fractuns<mode>hi2_helper"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:HI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %d1,#15,%0\"; 
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %d1,#14,%0\;btss %0,#0\;clr %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractuns<mode>hi2_convergent"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:HI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ31 2                         "=&r"))
  ]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %d1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr %0\;\"
              \"sl %d1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"     /*   always rounds to even 0 */
              \"cp0 %1\;\"  
              \"btsc _SR,#1\;\"
              \"clr %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fractuns<mode>hi2"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=r")
        (unsigned_fract_convert:HI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  ""
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,HImode)) {
      r0 = gen_reg_rtx(HImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_fractuns<mode>hi2_convergent(r0,r1)
      );
    } else {
      emit(
        gen_fractuns<mode>hi2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fractuns<mode>si2_helper"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:SI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %d1,#15,%d0\;asr %d1,#15,%0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %d1,#14,%0\;\"
              \"btss %0,#0\;\"
              \"clr %0\;\"
              \"asr %0,#15,%d0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractuns<mode>si2_convergent"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:SI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ31 2                         "=&r"))
  ]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %d1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr  %0\;\"
              \"asr %0,#15,%d0\;\"
              \"sl %d1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"     /*   always rounds to even 0 */
              \"cp0 %1\;\"
              \"btsc _SR,#1\;\"
              \"mul.uu %0,#0,%0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fractuns<mode>si2"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=r")
        (unsigned_fract_convert:SI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  ""
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,SImode)) {
      r0 = gen_reg_rtx(SImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_fractuns<mode>si2_convergent(r0,r1)
      );
    } else {
      emit(
        gen_fractuns<mode>si2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fractuns<mode>di2_helper"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:DI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %d1,#15,%q0\;asr %d1,#15,%t0\;mul.su %t0,#1,%0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %d1,#14,%0\;\"
              \"btss %0,#0\;\"
              \"clr %0\;\"
              \"asr %0,#15,%d0\;\"
              \"mul.su %d0,#1,%t0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractuns<mode>di2_convergent"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:DI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ31 2                         "=&r"))
  ]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %d1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr  %0\;\"
              \"asr %0,#15,%d0\;\"
              \"sl %d1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"     /*   always rounds to even 0 */
              \"cp0 %1\;\"
              \"btsc _SR,#1\;\"
              \"mul.uu %0,#0,%0\;\"
              \"mul.su %d0,#1,%t0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fractuns<mode>di2"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=r")
        (unsigned_fract_convert:DI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  ""
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && 
         ((pic30_fp_round_p() == pic30_convergent) ||
          (pic30_fp_round_p() == pic30_convergent)))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,DImode)) {
      r0 = gen_reg_rtx(DImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_fractuns<mode>di2_convergent(r0,r1)
      );
    } else {
      emit(
        gen_fractuns<mode>di2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

; from ACC

(define_insn "fractuns<mode>qi2_helper"
  [(set (match_operand:QI    0 "pic30_register_operand"   "=&r,r")
        (unsigned_fract_convert:QI
          (match_operand:ACC 1 "pic30_accum_or_reg_operand" "r,w")))
  ]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits; remember with 9.31 the lowest order  */
       /*  integer bit is in the 15th bit of 2nd word */
       if (which_alternative == 0)
         return \"sl %d1,[w15]\;\"
                \"rlc %t1,%0\";
       else 
         return \"mov %m1U,%0\;\"
                \"sl %0,%0\;\"
                \"btsc %m1H\;\"
                \"inc %0,%0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       if (which_alternative == 0)
         return \"sl %d1,[w15]\;\"
                \"rlc %t1,%0\;\"
                \"btst.c %d1,#14\;\"
                \"addc.b %0,#0,%0\";
       else 
         return \"mov %m1U,%0\;\"
                \"sl %0,%0\;\"
                \"btsc %m1H,#15\;\"
                \"inc %0,%0\;\"
                \"btsc %m1H,#14\;\"
                \"inc %0,%0\;\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractuns<mode>qi2_convergent"
  [(set (match_operand:QI     0 "pic30_register_operand" "=&r")
        (unsigned_fract_convert:QI
          (match_operand:ACC  1 "pic30_register_operand"   "r")))
   (clobber (match_scratch:HI 2                           "=&r"))
  ]
  ""
  "*
   return \"sl %d1,%2\;\"
          \"rlc.b %t1,%0\;\"
          \"sl %2,%2\;\"
          \"ior %2,%1,[w15]\;\"
          \"btsc _SR,#0\;\"   /* carry clear? */
          \"bset _SR,#0\;\"
          \"btsc _SR,#1\;\"
          \"btst.c %0,#0\;\"
          \"addc.b %0,#0,%0\";
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fractuns<mode>qi2"
  [(set (match_operand:QI    0 "pic30_register_operand"    "=r")
        (unsigned_fract_convert:QI
          (match_operand:ACC 1 "pic30_accum_or_reg_operand" "rw")))]
  ""
  "
  { rtx r0,r1;

    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,QImode)) {
      r0 = gen_reg_rtx(QImode);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      if (!pic30_accum_or_reg_operand(r1,<MODE>mode)) {
        r1 = force_reg(<MODE>mode, r1);
      }
      emit(
        gen_fractuns<mode>qi2_convergent(r0,r1)
      );
    } else {
      if (!pic30_register_operand(r1,VOIDmode)) {
        r1 = force_reg(<MODE>mode, r1);
      }
      emit(
        gen_fractuns<mode>qi2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fractuns<mode>hi2_helper"
  [(set (match_operand:HI    0 "pic30_register_operand"   "=&r,r")
        (unsigned_fract_convert:HI
          (match_operand:ACC 1 "pic30_accum_or_reg_operand" "r,w")))
  ]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits; remember with 9.31 the lowest order  */
       /*  integer bit is in the 15th bit of 2nd word */
       if (which_alternative == 0)
         return \"ze %t1,%0\;\"
                \"sl %d1,[w15]\;\"
                \"rlc %0,%0\";
       else 
         return \"mov %m1U,%0\;\"
                \"ze %0,%0\;\"
                \"sl %0,%0\;\"
                \"btsc %m1H\;\"
                \"inc %0,%0\;\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       if (which_alternative == 0)
         return \"ze %t1,%0\;\"
                \"sl %d1,[w15]\;\"
                \"rlc %0,%0\;\"
                \"btst.c %d1,#14\;\"
                \"addc %0,#0,%0\";
       else 
         return \"mov %m1U,%0\;\"
                \"ze %0,%0\;\"
                \"sl %0,%0\;\"
                \"btsc %m1H,#15\;\"
                \"inc %0,%0\;\"
                \"btsc %m1H,#14\;\"
                \"inc %0,%0\;\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractuns<mode>hi2_convergent"
  [(set (match_operand:HI     0 "pic30_register_operand" "=&r")
        (unsigned_fract_convert:HI
          (match_operand:ACC  1 "pic30_register_operand"   "r")))
   (clobber (match_scratch:HI 2                           "=&r"))
  ]
  ""
  "*
   return \"ze %t1,%0\;\"
          \"sl %d1,%2\;\"
          \"rlc %0,%0\;\"
          \"sl %2,%2\;\"
          \"ior %2,%1,[w15]\;\"
          \"btsc _SR,#0\;\"   /* carry clear? */
          \"bset _SR,#0\;\"
          \"btsc _SR,#1\;\"
          \"btst.c %0,#0\;\"
          \"addc %0,#0,%0\";
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fractuns<mode>hi2"
  [(set (match_operand:HI    0 "pic30_register_operand"    "=r")
        (unsigned_fract_convert:HI
          (match_operand:ACC 1 "pic30_accum_or_reg_operand" "rw")))]
  ""
  "
  { rtx r0,r1;

    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,HImode)) {
      r0 = gen_reg_rtx(HImode);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      if (!pic30_accum_or_reg_operand(r1,<MODE>mode)) {
        r1 = force_reg(<MODE>mode, r1);
      }
      emit(
        gen_fractuns<mode>hi2_convergent(r0,r1)
      );
    } else {
      if (!pic30_register_operand(r1,VOIDmode)) {
        r1 = force_reg(<MODE>mode, r1);
      }
      emit(
        gen_fractuns<mode>hi2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fractuns<mode>qi2_helper"
  [(set (match_operand:QI     0 "pic30_register_operand"   "=&r,r")
        (unsigned_fract_convert:QI
          (match_operand:UACC 1 "pic30_accum_or_reg_operand" "r,w")))
  ]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits; remember with 9.31 the lowest order  */
       /*  integer bit is in the 15th bit of 2nd word */
       if (which_alternative == 0)
         return \"sl %d1,[w15]\;\"
                \"rlc %t1,%0\";
       else 
         return \"mov %m1U,%0\;\"
                \"sl %0,%0\;\"
                \"btsc %m1H\;\"
                \"inc %0,%0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       if (which_alternative == 0)
         return \"sl %d1,[w15]\;\"
                \"rlc %t1,%0\;\"
                \"btst.c %d1,#14\;\"
                \"addc.b %0,#0,%0\";
       else 
         return \"mov %m1U,%0\;\"
                \"sl %0,%0\;\"
                \"btsc %m1H,#15\;\"
                \"inc %0,%0\;\"
                \"btsc %m1H,#14\;\"
                \"inc %0,%0\;\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractuns<mode>qi2_convergent"
  [(set (match_operand:QI      0 "pic30_register_operand" "=&r")
        (unsigned_fract_convert:QI
          (match_operand:UACC  1 "pic30_register_operand"   "r")))
   (clobber (match_scratch:HI 2                           "=&r"))
  ]
  ""
  "sl %d1,%2\;rlc %t1,%0\;sl %2,%2\;ior %2,%1,[w15]\;btst.c %d1,#14\;btsc _SR,#1\;bclr _SR,#0\;addc %0,#0,%0"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fractuns<mode>qi2"
  [(set (match_operand:QI     0 "pic30_register_operand"    "=r")
        (unsigned_fract_convert:QI
          (match_operand:UACC 1 "pic30_accum_or_reg_operand" "rw")))]
  ""
  "
  { rtx r0,r1;

    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,QImode)) {
      r0 = gen_reg_rtx(QImode);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      if (!pic30_accum_or_reg_operand(r1,<MODE>mode)) {
        r1 = force_reg(<MODE>mode, r1);
      }
      emit(
        gen_fractuns<mode>qi2_convergent(r0,r1)
      );
    } else {
      if (!pic30_register_operand(r1,VOIDmode)) {
        r1 = force_reg(<MODE>mode, r1);
      }
      emit(
        gen_fractuns<mode>qi2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fractuns<mode>hi2_helper"
  [(set (match_operand:HI     0 "pic30_register_operand"   "=&r,r")
        (unsigned_fract_convert:HI
          (match_operand:UACC 1 "pic30_accum_or_reg_operand" "r,w")))
  ]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits; remember with 9.31 the lowest order  */
       /*  integer bit is in the 15th bit of 2nd word */
       if (which_alternative == 0)
         return \"ze %t1,%0\;\"
                \"sl %d1,[w15]\;\"
                \"rlc %0,%0\;\";
       else 
         return \"mov %m1U,%0\;\"
                \"ze %0,%0\;\"
                \"sl %0,%0\;\"
                \"btsc %m1H\;\"
                \"inc %0,%0\;\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       if (which_alternative == 0)
         return \"ze %t1,%0\;\"
                \"sl %d1,[w15]\;\"
                \"rlc %0,%0\;\"
                \"btst.c %d1,#14\;\"
                \"addc %0,#0,%0\";
       else 
         return \"mov %m1U,%0\;\"
                \"ze %0,%0\;\"
                \"sl %0,%0\;\"
                \"btsc %m1H,#15\;\"
                \"inc %0,%0\;\"
                \"btsc %m1H,#14\;\"
                \"inc %0,%0\;\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractuns<mode>hi2_convergent"
  [(set (match_operand:HI      0 "pic30_register_operand" "=&r")
        (unsigned_fract_convert:HI
          (match_operand:UACC  1 "pic30_register_operand"   "r")))
   (clobber (match_scratch:HI  2                           "=&r"))
  ]
  ""
  "*
   return \"ze %t1,%0\;\"
          \"sl %d1,%2\;\"
          \"rlc %0,%0\;\"
          \"sl %2,%2\;\"
          \"ior %2,%1,[w15]\;\"
          \"btsc _SR,#0\;\"   /* carry clear? */
          \"bset _SR,#0\;\"
          \"btsc _SR,#1\;\"
          \"btst.c %0,#0\;\"
          \"addc %0,#0,%0\";
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fractuns<mode>hi2"
  [(set (match_operand:HI     0 "pic30_register_operand"    "=r")
        (unsigned_fract_convert:HI
          (match_operand:UACC 1 "pic30_accum_or_reg_operand" "rw")))]
  ""
  "
  { rtx r0,r1;

    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,HImode)) {
      r0 = gen_reg_rtx(HImode);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      if (!pic30_accum_or_reg_operand(r1,<MODE>mode)) {
        r1 = force_reg(<MODE>mode, r1);
      }
      emit(
        gen_fractuns<mode>hi2_convergent(r0,r1)
      );
    } else {
      if (!pic30_register_operand(r1,VOIDmode)) {
        r1 = force_reg(<MODE>mode, r1);
      }
      emit(
        gen_fractuns<mode>hi2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

; To SI and DI done by function only

; to Q15

(define_insn "fractunsqi<mode>2"
  [(set (match_operand:Q15  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:Q15
          (match_operand:QI 1 "pic30_register_operand"  "r")))]
  "pic30_fp_inline_p()"
  "*
   {  
      return 
             \"cp0.b %1\;\"        /* compare input with 0 */
             \"mov #0x8000,%0\;\"  /* assume -1 */
             \"btsc _SR,#0\;\"     /* positive => 0 or .99 */
             \"mov #0x7FFF,%0\;\"  /*   load .99... */
             \"btsc _SR,#1\;\"     /* if zero */
             \"clr %0\";           /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractunshi<mode>2"
  [(set (match_operand:Q15  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:Q15
          (match_operand:HI 1 "pic30_register_operand"  "r")))]
  "pic30_fp_inline_p()"
  "*
   {
      return 
             \"cp0  %1\;\"         /* compare input with 0 */
             \"mov #0x8000,%0\;\"  /* assume -1 */
             \"btsc _SR,#0\;\"     /* positive => 0 or .99 */
             \"mov #0x7FFF,%0\;\"  /*   load .99... */
             \"btsc _SR,#1\;\"     /* if zero */
             \"clr %0\";           /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractunssi<mode>2"
  [(set (match_operand:Q15  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:Q15
          (match_operand:SI 1 "pic30_register_operand"  "r")))]
  "pic30_fp_inline_p()"
  "*
   {  
      return 
             \"sub %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subb %d1,#0,[w15]\;\" /* compare input with 0 */
             \"mov #0x8000,%0\;\"    /* assume -1 */
             \"btsc _SR,#0\;\"       /* positive => 0 or .99 */
             \"mov #0x7FFF,%0\;\"    /*   load .99... */
             \"btsc _SR,#1\;\"       /* if zero */
             \"clr %0\";             /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractunsdi<mode>2"
  [(set (match_operand:Q15  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:Q15
          (match_operand:DI 1 "pic30_register_operand"  "r")))]
  "pic30_fp_inline_p()"
  "*
   {  
      return 
             \"sub %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subb %d1,#0,[w15]\;\" /* compare input with 0 */
             \"subb %t1,#0,[w15]\;\" /* compare input with 0 */
             \"subb %q1,#0,[w15]\;\" /* compare input with 0 */
             \"mov #0x8000,%0\;\"    /* assume -1 */
             \"btsc _SR,#0\;\"       /* positive => 0 or .99 */
             \"mov #0x7FFF,%0\;\"    /*   load .99... */
             \"btsc _SR,#1\;\"       /* if zero */
             \"clr %0\";             /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractunsqi<mode>2"
  [(set (match_operand:UQ15  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:UQ15
          (match_operand:QI  1 "pic30_register_operand"  "r")))]
  ""
  "*
   {  
      return 
             \"cp0.b %1\;\"        /* compare input with 0 */
             \"mov #0x7FFF,%0\;\"  /* assume ~1 */
             \"btsc _SR,#1\;\"     /* if zero */
             \"clr %0\";           /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractunshi<mode>2"
  [(set (match_operand:UQ15  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:UQ15
          (match_operand:HI  1 "pic30_register_operand"  "r")))]
  ""
  "*
   {
      return 
             \"cp0.b %1\;\"        /* compare input with 0 */
             \"mov #0x7FFF,%0\;\"  /* assume ~1 */
             \"btsc _SR,#1\;\"     /* if zero */
             \"clr %0\";           /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractunssi<mode>2"
  [(set (match_operand:UQ15  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:UQ15
          (match_operand:SI  1 "pic30_register_operand"  "r")))]
  ""
  "*
   {  
      return 
             \"sub %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subb %d1,#0,[w15]\;\" /* compare input with 0 */
             \"mov #0x7FFF,%0\;\"    /* assume ~1 */
             \"btsc _SR,#1\;\"       /* if zero */
             \"clr %0\";             /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractunsdi<mode>2"
  [(set (match_operand:UQ15  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:UQ15
          (match_operand:DI  1 "pic30_register_operand"  "r")))]
  ""
  "*
   {  
      return 
             \"sub %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subb %d1,#0,[w15]\;\" /* compare input with 0 */
             \"subb %t1,#0,[w15]\;\" /* compare input with 0 */
             \"subb %q1,#0,[w15]\;\" /* compare input with 0 */
             \"mov #0x7FFF,%0\;\"    /*   load .99... */
             \"btsc _SR,#1\;\"       /* if zero */
             \"clr %0\";             /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

; to Q31

(define_insn "fractunsqi<mode>2"
  [(set (match_operand:Q31  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:Q31
          (match_operand:QI 1 "pic30_register_operand"  "r")))]
  "pic30_fp_inline_p()"
  "*
   {  
      return 
             \"cp0.b %1\;\"         /* compare input with 0 */
             \"mov #0x8000,%d0\;\"  /* assume -1 */
             \"btsc _SR,#0\;\"      /* positive => 0 or .99 */
             \"mov #0x7FFF,%d0\;\"  /*   load .99... */
             \"btsc _SR,#1\;\"      /* if zero */
             \"clr %d0\;\"          /*   load zero */
             \"sl  %d0,%0\;\"       /* form low word by propagating non sign */
             \"asr %0,#15,%0\";     /*   bits into low word */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractunshi<mode>2"
  [(set (match_operand:Q31  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:Q31
          (match_operand:HI 1 "pic30_register_operand"  "r")))]
  "pic30_fp_inline_p()"
  "*
   {
      return 
             \"cp0.b %1\;\"         /* compare input with 0 */
             \"mov #0x8000,%d0\;\"  /* assume -1 */
             \"btsc _SR,#0\;\"      /* positive => 0 or .99 */
             \"mov #0x7FFF,%d0\;\"  /*   load .99... */
             \"btsc _SR,#1\;\"      /* if zero */
             \"clr %d0\;\"          /*   load zero */
             \"sl  %d0,%0\;\"       /* form low word by propagating non sign */
             \"asr %0,#15,%0\";     /*   bits into low word */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractunssi<mode>2"
  [(set (match_operand:Q31  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:Q31
          (match_operand:SI 1 "pic30_register_operand"  "r")))]
  "pic30_fp_inline_p()"
  "*
   {  
      return 
             \"sub %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subb %d1,#0,[w15]\;\" /* compare input with 0 */
             \"mov #0x8000,%d0\;\"   /* assume -1 */
             \"btsc _SR,#0\;\"       /* positive => 0 or .99 */
             \"mov #0x7FFF,%d0\;\"   /*   load .99... */
             \"btsc _SR,#1\;\"       /* if zero */
             \"clr %d0\;\"           /*   load zero */
             \"sl  %d0,%0\;\"        /* form low word by propagating non sign */
             \"asr %0,#15,%0\";      /*   bits into low word */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractunsdi<mode>2"
  [(set (match_operand:Q31  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:Q31
          (match_operand:DI 1 "pic30_register_operand"  "r")))]
  "pic30_fp_inline_p()"
  "*
   {  
      return 
             \"sub %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subb %d1,#0,[w15]\;\" /* compare input with 0 */
             \"subb %t1,#0,[w15]\;\" /* compare input with 0 */
             \"subb %q1,#0,[w15]\;\" /* compare input with 0 */
             \"mov #0x8000,%d0\;\"   /* assume -1 */
             \"btsc _SR,#0\;\"       /* positive => 0 or .99 */
             \"mov #0x7FFF,%d0\;\"   /*   load .99... */
             \"btsc _SR,#1\;\"       /* if zero */
             \"clr %d0\;\"           /*   load zero */
             \"sl  %d0,%0\;\"        /* form low word by propagating non sign */
             \"asr %0,#15,%0\";      /*   bits into low word */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractunsqi<mode>2"
  [(set (match_operand:UQ31  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:UQ31
          (match_operand:QI  1 "pic30_register_operand"  "r")))]
  ""
  "*
   {  
      return 
             \"cp0.b %1\;\"         /* compare input with 0 */
             \"mov #0x7FFF,%d0\;\"  /*   load .99... */
             \"setm %0\;\"
             \"btsc _SR,#1\;\"      /* if zero */
             \"mul.uu %0,#0,%0\";   /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractunshi<mode>2"
  [(set (match_operand:UQ31  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:UQ31
          (match_operand:HI  1 "pic30_register_operand"  "r")))]
  ""
  "*
   {
      return 
             \"cp0.b %1\;\"         /* compare input with 0 */
             \"mov #0x7FFF,%d0\;\"  /*   load .99... */
             \"setm %0\;\"
             \"btsc _SR,#1\;\"      /* if zero */
             \"mul.uu %0,#0,%0\";   /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractunssi<mode>2"
  [(set (match_operand:UQ31  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:UQ31
          (match_operand:SI  1 "pic30_register_operand"  "r")))]
  ""
  "*
   {  
      return 
             \"sub %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subb %d1,#0,[w15]\;\" /* compare input with 0 */
             \"mov #0x7FFF,%d0\;\"   /*   load .99... */
             \"setm %0\;\"
             \"btsc _SR,#1\;\"       /* if zero */
             \"mul.uu %0,#0,%0\";    /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractunsdi<mode>2"
  [(set (match_operand:UQ31  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:UQ31
          (match_operand:DI  1 "pic30_register_operand"  "r")))]
  ""
  "*
   {  
      return 
             \"sub %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subb %d1,#0,[w15]\;\" /* compare input with 0 */
             \"subb %t1,#0,[w15]\;\" /* compare input with 0 */
             \"subb %q1,#0,[w15]\;\" /* compare input with 0 */
             \"mov #0x7FFF,%d0\;\"   /*   load .99... */
             \"setm %0\;\"
             \"btsc _SR,#1\;\"       /* if zero */
             \"mul.uu %0,#0,%0\";    /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

; to ACC

(define_insn "fractunsqi<mode>2"
  [(set (match_operand:ACC  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:ACC
          (match_operand:QI 1 "pic30_register_operand"    "r")))]
  "pic30_fp_inline_p()"
  "*
   {  
      return 
             \"mul.uu %0,#0,%0\;\"  /* clear low bits */
             \"mov.b %1,%t0\;\"     /* copy integer portion into upper byte */
             \"asr.b %t0,%t0\;\"    /* shift it into position */
             \"rrc %d0,%d0\";
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractunshi<mode>2"
  [(set (match_operand:ACC  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:ACC
          (match_operand:HI 1 "pic30_register_operand"  "r")))]
  "pic30_fp_inline_p()"
  "*
   {
      return 
             \"mul.uu %0,#0,%0\;\"  /* clear low bits */
             \"mov %1,%t0\;\"       /* copy low integer portion to upper byte */
             \"asr.b %t0,%t0\;\"    /* shift it into position */
             \"rrc %d0,%d0\";
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractunssi<mode>2"
  [(set (match_operand:ACC  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:ACC
          (match_operand:SI 1 "pic30_register_operand"  "r")))]
  "pic30_fp_inline_p()"
  "*
   {  
      return 
             \"mul.uu %0,#0,%0\;\"  /* clear low bits */
             \"mov %1,%t0\;\"       /* copy low integer portion to upper byte */
             \"asr.b %t0,%t0\;\"    /* shift it into position */
             \"rrc %d0,%d0\";
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractunsdi<mode>2"
  [(set (match_operand:ACC  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:ACC
          (match_operand:DI 1 "pic30_register_operand"  "r")))]
  "pic30_fp_inline_p()"
  "*
   {  
      return 
             \"mul.uu %0,#0,%0\;\"  /* clear low bits */
             \"mov %1,%t0\;\"       /* copy low integer portion to upper byte */
             \"asr.b %t0,%t0\;\"    /* shift it into position */
             \"rrc %d0,%d0\";
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractunsqi<mode>2"
  [(set (match_operand:UACC  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:UACC
          (match_operand:QI  1 "pic30_register_operand"  "r")))]
  ""
  "*
   {  
      return 
             \"mul.uu %0,#0,%0\;\"  /* clear low bits */
             \"mov.b %1,%t0\;\"     /* copy integer portion into upper byte */
             \"asr.b %t0,%t0\;\"    /* shift it into position */
             \"rrc %d0,%d0\";
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractunshi<mode>2"
  [(set (match_operand:UACC  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:UACC
          (match_operand:HI  1 "pic30_register_operand"  "r")))]
  ""
  "*
   {
      return 
             \"mul.uu %0,#0,%0\;\"  /* clear low bits */
             \"mov %1,%t0\;\"       /* copy low integer portion to upper byte */
             \"asr.b %t0,%t0\;\"    /* shift it into position */
             \"rrc %d0,%d0\";
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractunssi<mode>2"
  [(set (match_operand:UACC  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:UACC
          (match_operand:SI  1 "pic30_register_operand"  "r")))]
  ""
  "*
   {  
      return 
             \"mul.uu %0,#0,%0\;\"  /* clear low bits */
             \"mov %1,%t0\;\"       /* copy low integer portion to upper byte */
             \"asr.b %t0,%t0\;\"    /* shift it into position */
             \"rrc %d0,%d0\";
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractunsdi<mode>2"
  [(set (match_operand:UACC  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:UACC
          (match_operand:DI  1 "pic30_register_operand"  "r")))]
  ""
  "*
   {  
      return 
             \"mul.uu %0,#0,%0\;\"  /* clear low bits */
             \"mov %1,%t0\;\"       /* copy low integer portion to upper byte */
             \"asr.b %t0,%t0\;\"    /* shift it into position */
             \"rrc %d0,%d0\";
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)


;; conversions back and forth to floating point or double will be done by
;;  out of line functions only

; conversions to and from fractional types
;; awkward - we can only move through one iterator, these are all 
;;   coppies of each other with a different source mode

(define_insn "fractsq<mode>2_helper"
  [(set (match_operand:QUQ15  0 "pic30_register_operand" "=&r")
        (fract_convert:QUQ15
          (match_operand:SQ 1 "pic30_register_operand" "r")))]
  ""
  "*
  {
    if ((pic30_fp_round_p() == pic30_truncation) ||
        (pic30_fp_round_p() == pic30_fastest)) {
      return \"mov %d1,%0\";
    } else if (pic30_fp_round_p() == pic30_conventional) {
      return \"sl %1,[w15]\;\"
             \"addc %d1,#0,%0\";
    } else {
       error(\"Invalid fixed-point rounding mode specified\");
    }
     gcc_assert(0);
     return \"nop\";
  }
  "
  [
    (set_attr "cc" "math")
  ]
)

(define_insn "fractsq<mode>2_convergent"
  [(set (match_operand:QUQ15  0 "pic30_register_operand" "=&r")
        (fract_convert:QUQ15
          (match_operand:SQ   1 "pic30_register_operand" "r")))
   (clobber (match_scratch:HI 2                          "=&r"))
  ]
  ""
  "*
  {
    if (pic30_fp_round_p() == pic30_convergent) {
      return \"setm %2\;\"
             \"sl %1,[w15]\;\"          /* get top bit into carry */
             \"btsc _SR,#1\;\"          /* if the result is 0 */
             \"mov #0xFFFE,%2\;\"       /*   mask off low bit */
             \"addc %d1,#0,%0\;\"       /* add in 'overflow' */
             \"and %0,%2,%0\";          /* maybe mask off low bit */
    } else {
       error(\"Invalid fixed-point rounding mode specified\");
    }
     gcc_assert(0);
     return \"nop\";
  }
  "
  [
    (set_attr "cc" "math")
  ]
)

(define_expand "fractsq<mode>2"
  [(set (match_operand:QUQ15 0 "pic30_register_operand"  "=r")
        (fract_convert:QUQ15
          (match_operand:SQ  1 "pic30_register_operand"  "r")))]
  ""
  "
  { rtx r0,r1;

    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,SImode)) {
      r0 = gen_reg_rtx(<MODE>mode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_fractsq<mode>2_convergent(r0,r1)
      );
    } else {
      emit(
        gen_fractsq<mode>2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fractusq<mode>2_helper"
  [(set (match_operand:QUQ15 0 "pic30_register_operand" "=&r")
        (fract_convert:QUQ15
          (match_operand:USQ 1 "pic30_register_operand" "r")))]
  ""
  "*
  {
    if ((pic30_fp_round_p() == pic30_truncation) ||
        (pic30_fp_round_p() == pic30_fastest)) {
      return \"mov %d1,%0\";
    } else if (pic30_fp_round_p() == pic30_conventional) {
      return \"sl %1,[w15]\;\"
             \"addc %d1,#0,%0\";
    } else {
       error(\"Invalid fixed-point rounding mode specified\");
    }
     gcc_assert(0);
     return \"nop\";
  }
  "
  [
    (set_attr "cc" "math")
  ]
)

(define_insn "fractusq<mode>2_convergent"
  [(set (match_operand:QUQ15  0 "pic30_register_operand" "=&r")
        (fract_convert:QUQ15
          (match_operand:USQ  1 "pic30_register_operand" "r")))
   (clobber (match_scratch:HI 2                          "=&r"))
  ]
  ""
  "*
  {
    if (pic30_fp_round_p() == pic30_convergent) {
      return \"setm %2\;\"
             \"sl %1,[w15]\;\"          /* get top bit into carry */
             \"btsc _SR,#1\;\"          /* if the result is 0 */
             \"mov #0xFFFE,%2\;\"       /*   mask off low bit */
             \"addc %d1,#0,%0\;\"       /* add in 'overflow' */
             \"and %0,%2,%0\";          /* maybe mask off low bit */
    } else {
       error(\"Invalid fixed-point rounding mode specified\");
    }
     gcc_assert(0);
     return \"nop\";
  }
  "
  [
    (set_attr "cc" "math")
  ]
)

(define_expand "fractusq<mode>2"
  [(set (match_operand:QUQ15 0 "pic30_register_operand"  "=r")
        (fract_convert:QUQ15
          (match_operand:USQ 1 "pic30_register_operand"  "r")))]
  ""
  "
  { rtx r0,r1;

    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,SImode)) {
      r0 = gen_reg_rtx(<MODE>mode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_fractusq<mode>2_convergent(r0,r1)
      );
    } else {
      emit(
        gen_fractusq<mode>2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fracttq<mode>2_helper"
  [(set (match_operand:QUQ15 0 "pic30_register_operand" "=&r")
        (fract_convert:QUQ15
          (match_operand:TQ  1 "pic30_register_operand" "r")))]
  ""
  "*
  {
    if ((pic30_fp_round_p() == pic30_truncation) ||
        (pic30_fp_round_p() == pic30_fastest)) {
      return \"mov %d1,%0\";
    } else if (pic30_fp_round_p() == pic30_conventional) {
      return \"sl %1,[w15]\;\"
             \"addc %d1,#0,%0\";
    } else {
       error(\"Invalid fixed-point rounding mode specified\");
    }
     gcc_assert(0);
     return \"nop\";
  }
  "
  [
    (set_attr "cc" "math")
  ]
)

(define_insn "fracttq<mode>2_convergent"
  [(set (match_operand:QUQ15  0 "pic30_register_operand" "=&r")
        (fract_convert:QUQ15
          (match_operand:TQ  1 "pic30_register_operand" "r")))
   (clobber (match_scratch:HI 2                          "=&r"))
  ]
  ""
  "*
  {
    if (pic30_fp_round_p() == pic30_convergent) {
      return \"setm %2\;\"
             \"sl %1,[w15]\;\"          /* get top bit into carry */
             \"btsc _SR,#1\;\"          /* if the result is 0 */
             \"mov #0xFFFE,%2\;\"       /*   mask off low bit */
             \"addc %d1,#0,%0\;\"       /* add in 'overflow' */
             \"and %0,%2,%0\";          /* maybe mask off low bit */
    } else {
       error(\"Invalid fixed-point rounding mode specified\");
    }
     gcc_assert(0);
     return \"nop\";
  }
  "
  [
    (set_attr "cc" "math")
  ]
)

(define_expand "fracttq<mode>2"
  [(set (match_operand:QUQ15 0 "pic30_register_operand"  "=r")
        (fract_convert:QUQ15
          (match_operand:TQ 1 "pic30_register_operand"  "r")))]
  ""
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,SImode)) {
      r0 = gen_reg_rtx(<MODE>mode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_fracttq<mode>2_convergent(r0,r1)
      );
    } else {
      emit(
        gen_fracttq<mode>2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fractutq<mode>2_helper"
  [(set (match_operand:QUQ15 0 "pic30_register_operand" "=&r")
        (fract_convert:QUQ15
          (match_operand:UTQ 1 "pic30_register_operand" "r")))]
  ""
  "*
  {
    if ((pic30_fp_round_p() == pic30_truncation) ||
        (pic30_fp_round_p() == pic30_fastest)) {
      return \"mov %d1,%0\";
    } else if (pic30_fp_round_p() == pic30_conventional) {
      return \"sl %1,[w15]\;\"
             \"addc %d1,#0,%0\";
    } else {
       error(\"Invalid fixed-point rounding mode specified\");
    }
     gcc_assert(0);
     return \"nop\";
  }
  "
  [
    (set_attr "cc" "math")
  ]
)

(define_insn "fractutq<mode>2_convergent"
  [(set (match_operand:QUQ15  0 "pic30_register_operand" "=&r")
        (fract_convert:QUQ15
          (match_operand:UTQ  1 "pic30_register_operand" "r")))
   (clobber (match_scratch:HI 2                          "=&r"))
  ]
  ""
  "*
  {
    if (pic30_fp_round_p() == pic30_convergent) {
      return \"setm %2\;\"
             \"sl %1,[w15]\;\"          /* get top bit into carry */
             \"btsc _SR,#1\;\"          /* if the result is 0 */
             \"mov #0xFFFE,%2\;\"       /*   mask off low bit */
             \"addc %d1,#0,%0\;\"       /* add in 'overflow' */
             \"and %0,%2,%0\";          /* maybe mask off low bit */
    } else {
       error(\"Invalid fixed-point rounding mode specified\");
    }
     gcc_assert(0);
     return \"nop\";
  }
  "
  [
    (set_attr "cc" "math")
  ]
)

(define_expand "fractutq<mode>2"
  [(set (match_operand:QUQ15 0 "pic30_register_operand"  "=r")
        (fract_convert:QUQ15
          (match_operand:UTQ 1 "pic30_register_operand"  "r")))]
  ""
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,SImode)) {
      r0 = gen_reg_rtx(<MODE>mode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_fracttq<mode>2_convergent(r0,r1)
      );
    } else {
      emit(
        gen_fracttq<mode>2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fractdq<mode>2_helper"
  [(set (match_operand:QUQ15 0 "pic30_register_operand" "=&r")
        (fract_convert:QUQ15
          (match_operand:DQ  1 "pic30_register_operand" "r")))]
  ""
  "*
  {
    if ((pic30_fp_round_p() == pic30_truncation) ||
        (pic30_fp_round_p() == pic30_fastest)) {
      return \"mov %d1,%0\";
    } else if (pic30_fp_round_p() == pic30_conventional) {
      return \"sl %1,[w15]\;\"
             \"addc %d1,#0,%0\";
    } else {
       error(\"Invalid fixed-point rounding mode specified\");
    }
     gcc_assert(0);
     return \"nop\";
  }
  "
  [
    (set_attr "cc" "math")
  ]
)

(define_insn "fractdq<mode>2_convergent"
  [(set (match_operand:QUQ15  0 "pic30_register_operand" "=&r")
        (fract_convert:QUQ15
          (match_operand:DQ   1 "pic30_register_operand" "r")))
   (clobber (match_scratch:HI 2                          "=&r"))
  ]
  ""
  "*
  {
    if (pic30_fp_round_p() == pic30_convergent) {
      return \"setm %2\;\"
             \"sl %1,[w15]\;\"          /* get top bit into carry */
             \"btsc _SR,#1\;\"          /* if the result is 0 */
             \"mov #0xFFFE,%2\;\"       /*   mask off low bit */
             \"addc %d1,#0,%0\;\"       /* add in 'overflow' */
             \"and %0,%2,%0\";          /* maybe mask off low bit */
    } else {
       error(\"Invalid fixed-point rounding mode specified\");
    }
     gcc_assert(0);
     return \"nop\";
  }
  "
)

(define_expand "fractdq<mode>2"
  [(set (match_operand:QUQ15 0 "pic30_register_operand"  "=r")
        (fract_convert:QUQ15
          (match_operand:DQ  1 "pic30_register_operand"  "r")))]
  ""
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,SImode)) {
      r0 = gen_reg_rtx(<MODE>mode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_fractdq<mode>2_convergent(r0,r1)
      );
    } else {
      emit(
        gen_fractdq<mode>2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fractudq<mode>2_helper"
  [(set (match_operand:QUQ15 0 "pic30_register_operand" "=&r")
        (fract_convert:QUQ15
          (match_operand:UDQ 1 "pic30_register_operand" "r")))]
  ""
  "*
  {
    if ((pic30_fp_round_p() == pic30_truncation) ||
        (pic30_fp_round_p() == pic30_fastest)) {
      return \"mov %d1,%0\";
    } else if (pic30_fp_round_p() == pic30_conventional) {
      return \"sl %1,[w15]\;\"
             \"addc %d1,#0,%0\";
    } else {
       error(\"Invalid fixed-point rounding mode specified\");
    }
     gcc_assert(0);
     return \"nop\";
  }
  "
  [
    (set_attr "cc" "math")
  ]
)

(define_insn "fractudq<mode>2_convergent"
  [(set (match_operand:QUQ15  0 "pic30_register_operand" "=&r")
        (fract_convert:QUQ15
          (match_operand:UDQ  1 "pic30_register_operand" "r")))
   (clobber (match_scratch:HI 2                          "=&r"))
  ]
  ""
  "*
  {
    if (pic30_fp_round_p() == pic30_convergent) {
      return \"setm %2\;\"
             \"sl %1,[w15]\;\"          /* get top bit into carry */
             \"btsc _SR,#1\;\"          /* if the result is 0 */
             \"mov #0xFFFE,%2\;\"       /*   mask off low bit */
             \"addc %d1,#0,%0\;\"       /* add in 'overflow' */
             \"and %0,%2,%0\";          /* maybe mask off low bit */
    } else {
       error(\"Invalid fixed-point rounding mode specified\");
    }
     gcc_assert(0);
     return \"nop\";
  }
  "
  [
    (set_attr "cc" "math")
  ]
)

(define_expand "fractudq<mode>2"
  [(set (match_operand:QUQ15 0 "pic30_register_operand"  "=r")
        (fract_convert:QUQ15
          (match_operand:UDQ 1 "pic30_register_operand"   "r")))]
  ""
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,SImode)) {
      r0 = gen_reg_rtx(<MODE>mode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_fractudq<mode>2_convergent(r0,r1)
      );
    } else {
      emit(
        gen_fractudq<mode>2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fractqq<mode>2"
  [(set (match_operand:QUQ31 0 "pic30_register_operand" "=r")
        (fract_convert:QUQ31
          (match_operand:QQ  1 "pic30_register_operand"  "r")))]
  ""
  "mov %1,%d0\;clr %0"
  [
    (set_attr "cc" "change0")
  ]
)

(define_insn "fractuqq<mode>2"
  [(set (match_operand:QUQ31 0 "pic30_register_operand" "=r")
        (fract_convert:QUQ31
          (match_operand:UQQ 1 "pic30_register_operand"  "r")))]
  ""
  "mov %1,%d0\;clr %0"
  [
    (set_attr "cc" "change0")
  ]
)

(define_insn "fracthq<mode>2"
  [(set (match_operand:QUQ31 0 "pic30_register_operand" "=r")
        (fract_convert:QUQ31
          (match_operand:HQ 1 "pic30_register_operand"   "r")))]
  ""
  "mov %1,%d0\;clr %0"
  [
    (set_attr "cc" "change0")
  ]
)

(define_insn "fractuhq<mode>2"
  [(set (match_operand:QUQ31 0 "pic30_register_operand" "=r")
        (fract_convert:QUQ31
          (match_operand:UHQ 1 "pic30_register_operand"  "r")))]
  ""
  "mov %1,%d0\;clr %0"
  [
    (set_attr "cc" "change0")
  ]
)

; conversions between signed/unsigned 'self'

(define_insn "fractqquqq2"
  [(set (match_operand:UQQ  0 "general_operand" "=g")
       (unsigned_fract_convert:UQQ
         (match_operand:QQ 1 "general_operand" "0")))]
  ""
  "; nop"
)

(define_insn "fractuqqqq2"
  [(set (match_operand:QQ    0 "general_operand" "=g")
       (fract_convert:QQ
         (match_operand:UQQ 1 "general_operand" "0")))]
  ""
  "; nop"
)

(define_insn "fracthquhq2"
  [(set (match_operand:UHQ  0 "general_operand" "=g")
       (unsigned_fract_convert:UHQ
         (match_operand:HQ 1 "general_operand" "0")))]
  ""
  "; nop"
)

(define_insn "fractuhqhq2"
  [(set (match_operand:HQ    0 "general_operand" "=g")
       (fract_convert:HQ
         (match_operand:UHQ 1 "general_operand" "0")))]
  ""
  "; nop"
)

(define_insn "fractsqusq2"
  [(set (match_operand:USQ  0 "general_operand" "=g")
       (unsigned_fract_convert:USQ
         (match_operand:SQ 1 "general_operand" "0")))]
  ""
  "; nop"
)

(define_insn "fractusqsq2"
  [(set (match_operand:SQ    0 "general_operand" "=g")
       (fract_convert:SQ
         (match_operand:USQ 1 "general_operand" "0")))]
  ""
  "; nop"
)

(define_insn "fractdqudq2"
  [(set (match_operand:UDQ  0 "general_operand" "=g")
       (unsigned_fract_convert:UDQ
         (match_operand:DQ 1 "general_operand" "0")))]
  ""
  "; nop"
)

(define_insn "fractudqdq2"
  [(set (match_operand:DQ    0 "general_operand" "=g")
       (fract_convert:DQ
         (match_operand:UDQ 1 "general_operand" "0")))]
  ""
  "; nop"
)

(define_insn "fracttqutq2"
  [(set (match_operand:UTQ  0 "general_operand" "=g")
       (unsigned_fract_convert:UTQ
         (match_operand:TQ 1 "general_operand" "0")))]
  ""
  "; nop"
)

(define_insn "fractutqtq2"
  [(set (match_operand:TQ    0 "general_operand" "=g")
       (fract_convert:TQ
         (match_operand:UTQ 1 "general_operand" "0")))]
  ""
  "; nop"
)

(define_insn "fracthauha2"
  [(set (match_operand:UHA  0 "general_operand" "=g")
       (unsigned_fract_convert:UHA
         (match_operand:HA 1 "general_operand" "0")))]
  ""
  "; nop"
)

(define_insn "fractuhaha2"
  [(set (match_operand:HA    0 "general_operand" "=g")
       (fract_convert:HA
         (match_operand:UHA 1 "general_operand" "0")))]
  ""
  "; nop"
)

(define_insn "fractsausa2"
  [(set (match_operand:USA  0 "general_operand" "=g")
       (unsigned_fract_convert:USA
         (match_operand:SA 1 "general_operand" "0")))]
  ""
  "; nop"
)

(define_insn "fractusasa2"
  [(set (match_operand:SA    0 "general_operand" "=g")
       (fract_convert:SA
         (match_operand:USA 1 "general_operand" "0")))]
  ""
  "; nop"
)

(define_insn "fractdauda2"
  [(set (match_operand:UDA  0 "general_operand" "=g")
       (unsigned_fract_convert:UDA
         (match_operand:DA 1 "general_operand" "0")))]
  ""
  "; nop"
)

(define_insn "fractudada2"
  [(set (match_operand:DA    0 "general_operand" "=g")
       (fract_convert:DA
         (match_operand:UDA 1 "general_operand" "0")))]
  ""
  "; nop"
)

(define_insn "fracttauta2"
  [(set (match_operand:UTA  0 "general_operand" "=g")
       (unsigned_fract_convert:UTA
         (match_operand:TA 1 "general_operand" "0")))]
  ""
  "; nop"
)

(define_insn "fractutata2"
  [(set (match_operand:TA    0 "general_operand" "=g")
       (fract_convert:TA
         (match_operand:UTA 1 "general_operand" "0")))]
  ""
  "; nop"
)

; saturating conversions
;   not all conversions saturate (but we seem to need them all)
;   many of these are copies of the "non-saturating" versions

(define_insn "satfract<mode>qi2_helper"
  [(set (match_operand:QI    0 "pic30_register_operand"  "=&r")
        (sat_fract:QI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       return \"asr %1,#15,%0\"; 
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %1,#14,%0\;btss %0,#0\;clr.b %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfract<mode>qi2_convergent"
  [(set (match_operand:QI    0 "pic30_register_operand"  "=&r")
        (sat_fract:QI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ15 2                         "=r"))
  ]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr.b %0\;\"
              \"sl %1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"    /*   always rounds to even 0 */
              \"clr.b %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "satfract<mode>qi2"
  [(set (match_operand:QI    0 "pic30_register_operand"  "=r")
        (sat_fract:QI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  ""
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,QImode)) {
      r0 = gen_reg_rtx(QImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_satfract<mode>qi2_convergent(r0,r1)
      );
    } else {
      emit(
        gen_satfract<mode>qi2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "satfract<mode>hi2_helper"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=&r")
        (sat_fract:HI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %1,#15,%0\"; 
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %1,#14,%0\;btss %0,#0\;clr %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfract<mode>hi2_convergent"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=&r")
        (sat_fract:HI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ15 2                         "=r"))
  ]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr %0\;\"
              \"sl %1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"    /*   always rounds to even 0 */
              \"clr %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "satfract<mode>hi2"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=r")
        (sat_fract:HI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  ""
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,HImode)) {
      r0 = gen_reg_rtx(HImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_satfract<mode>hi2_convergent(r0,r1)
      );
    } else {
      emit(
        gen_satfract<mode>hi2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "satfract<mode>si2_helper"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=&r")
        (sat_fract:SI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %1,#15,%d0\;asr %1,#15,%0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %1,#14,%0\;\"
              \"btss %0,#0\;\"
              \"clr %0\;\"
              \"asr %0,#15,%d0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfract<mode>si2_convergent"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=&r")
        (sat_fract:SI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ15 2                         "=r"))
  ]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %1,#14,%0\;\" /* as conventional */
              \"btss %0,#0\;\"
              \"clr  %0\;\"
              \"asr %0,#15,%d0\;\"
              \"sl %1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"    /*   always rounds to even 0 */
              \"mul.uu %0,#0,%0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "satfract<mode>si2"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=r")
        (sat_fract:SI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  ""
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,SImode)) {
      r0 = gen_reg_rtx(SImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_satfract<mode>si2_convergent(r0,r1)
      );
    } else {
      emit(
        gen_satfract<mode>si2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "satfract<mode>di2_helper"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=&r")
        (sat_fract:DI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %1,#15,%q0\;asr %1,#15,%t0\;mul.su %t0,#1,%0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %1,#14,%0\;\"
              \"btss %0,#0\;\"
              \"clr %0\;\"
              \"asr %0,#15,%d0\;\"
              \"mul.su %d0,#1,%t0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfract<mode>di2_convergent"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=&r")
        (sat_fract:DI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ15 2                         "=r"))
  ]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr  %0\;\"
              \"asr %0,#15,%d0\;\"
              \"sl %1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"    /*   always rounds to even 0 */
              \"mul.uu %0,#0,%0\;\"
              \"mul.su %d0,#1,%t0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "satfract<mode>di2"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=r")
        (sat_fract:DI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  ""
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && 
        ((pic30_fp_round_p() == pic30_convergent) ||
         (pic30_fp_round_p() == pic30_conventional)))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,DImode)) {
      r0 = gen_reg_rtx(DImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_satfract<mode>di2_convergent(r0,r1)
      );
    } else {
      emit(
        gen_satfract<mode>di2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

; from Q31

(define_insn "satfract<mode>qi2_helper"
  [(set (match_operand:QI    0 "pic30_register_operand"  "=&r")
        (sat_fract:QI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %d1,#15,%0\"; 
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %d1,#14,%0\;btss %0,#0\;clr.b %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfract<mode>qi2_convergent"
  [(set (match_operand:QI    0 "pic30_register_operand"  "=&r")
        (sat_fract:QI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ31 2                         "=&r"))
  ]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %d1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr.b %0\;\"
              \"sl %d1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"     /*   always rounds to even 0 */
              \"cp0 %1\;\"  
              \"btsc _SR,#1\;\"
              \"clr %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "satfract<mode>qi2"
  [(set (match_operand:QI    0 "pic30_register_operand"  "=r")
        (sat_fract:QI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  ""
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,QImode)) {
      r0 = gen_reg_rtx(QImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_satfract<mode>qi2_convergent(r0,r1)
      );
    } else {
      emit(
        gen_satfract<mode>qi2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "satfract<mode>hi2_helper"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=&r")
        (sat_fract:HI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %d1,#15,%0\"; 
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %d1,#14,%0\;btss %0,#0\;clr %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfract<mode>hi2_convergent"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=&r")
        (sat_fract:HI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ31 2                         "=&r"))
  ]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %d1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr %0\;\"
              \"sl %d1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"     /*   always rounds to even 0 */
              \"cp0 %1\;\"  
              \"btsc _SR,#1\;\"
              \"clr %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "satfract<mode>hi2"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=r")
        (sat_fract:HI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  ""
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,HImode)) {
      r0 = gen_reg_rtx(HImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_satfract<mode>hi2_convergent(r0,r1)
      );
    } else {
      emit(
        gen_satfract<mode>hi2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "satfract<mode>si2_helper"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=&r")
        (sat_fract:SI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %d1,#15,%d0\;asr %d1,#15,%0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %d1,#14,%0\;\"
              \"btss %0,#0\;\"
              \"clr %0\;\"
              \"asr %0,#15,%d0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfract<mode>si2_convergent"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=&r")
        (sat_fract:SI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ31 2                         "=&r"))
  ]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %d1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr  %0\;\"
              \"asr %0,#15,%d0\;\"
              \"sl %d1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"     /*   always rounds to even 0 */
              \"cp0 %1\;\"
              \"btsc _SR,#1\;\"
              \"mul.uu %0,#0,%0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "satfract<mode>si2"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=r")
        (sat_fract:SI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  ""
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,SImode)) {
      r0 = gen_reg_rtx(SImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_satfract<mode>si2_convergent(r0,r1)
      );
    } else {
      emit(
        gen_satfract<mode>si2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "satfract<mode>di2_helper"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=&r")
        (sat_fract:DI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %d1,#15,%q0\;asr %d1,#15,%t0\;mul.su %t0,#1,%0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %d1,#14,%0\;\"
              \"btss %0,#0\;\"
              \"clr %0\;\"
              \"asr %0,#15,%d0\;\"
              \"mul.su %d0,#1,%t0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfract<mode>di2_convergent"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=&r")
        (sat_fract:DI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ31 2                         "=&r"))
  ]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %d1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr  %0\;\"
              \"asr %0,#15,%d0\;\"
              \"sl %d1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"     /*   always rounds to even 0 */
              \"cp0 %1\;\"
              \"btsc _SR,#1\;\"
              \"mul.uu %0,#0,%0\;\"
              \"mul.su %d0,#1,%t0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "satfract<mode>di2"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=r")
        (sat_fract:DI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  ""
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && 
         ((pic30_fp_round_p() == pic30_convergent) ||
          (pic30_fp_round_p() == pic30_convergent)))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,DImode)) {
      r0 = gen_reg_rtx(DImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_satfract<mode>di2_convergent(r0,r1)
      );
    } else {
      emit(
        gen_satfract<mode>di2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

; to Q15

(define_insn "satfractqi<mode>2"
  [(set (match_operand:QUQ15  0 "pic30_register_operand"  "=r")
        (sat_fract:QUQ15
          (match_operand:QI 1 "pic30_register_operand"  "r")))]
  "pic30_fp_inline_p()"
  "*
   {  
      return \"cp0.b %1\;\"        /* compare input with 0 */
             \"mov  #0x8000,%0\;\" /* assume -1 */
             \"btsc _SR,#0\;\"     /* positive => 0 or .99 */
             \"mov #0x7FFF,%0\;\"  /*   load .99... */
             \"btsc _SR,#1\;\"     /* if zero */
             \"clr %0\";           /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfracthi<mode>2"
  [(set (match_operand:QUQ15  0 "pic30_register_operand"  "=r")
        (sat_fract:QUQ15
          (match_operand:HI 1 "pic30_register_operand"  "r")))]
  "pic30_fp_inline_p()"
  "*
   {
      return \"cp0  %1\;\"         /* compare input with 0 */
             \"mov  #0x8000,%0\;\" /* assume -1 */
             \"btsc _SR,#0\;\"     /* positive => 0 or .99 */
             \"mov #0x7FFF,%0\;\"  /*   load .99... */
             \"btsc _SR,#1\;\"     /* if zero */
             \"clr %0\";           /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractsi<mode>2"
  [(set (match_operand:QUQ15  0 "pic30_register_operand"  "=r")
        (sat_fract:QUQ15
          (match_operand:SI 1 "pic30_register_operand"  "r")))]
  "pic30_fp_inline_p()"
  "*
   {  
      return \"subr %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subbr %d1,#0,[w15]\;\" /* compare input with 0 */
             \"mov  #0x8000,%0\;\"    /* assume -1 */
             \"btsc _SR,#0\;\"        /* positive => 0 or .99 */
             \"mov #0x7FFF,%0\;\"     /*   load .99... */
             \"btsc _SR,#1\;\"        /* if zero */
             \"clr %0\";              /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractdi<mode>2"
  [(set (match_operand:QUQ15  0 "pic30_register_operand"  "=r")
        (sat_fract:QUQ15
          (match_operand:DI 1 "pic30_register_operand"  "r")))]
  "pic30_fp_inline_p()"
  "*
   {  
      return \"subr %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subbr %d1,#0,[w15]\;\" /* compare input with 0 */
             \"subbr %t1,#0,[w15]\;\" /* compare input with 0 */
             \"subbr %q1,#0,[w15]\;\" /* compare input with 0 */
             \"mov  #0x8000,%0\;\"    /* assume -1 */
             \"btsc _SR,#0\;\"        /* positive => 0 or .99 */
             \"mov #0x7FFF,%0\;\"     /*   load .99... */
             \"btsc _SR,#1\;\"        /* if zero */
             \"clr %0\";              /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

; to Q31

(define_insn "satfractqi<mode>2"
  [(set (match_operand:QUQ31  0 "pic30_register_operand"  "=r")
        (sat_fract:QUQ31
          (match_operand:QI 1 "pic30_register_operand"  "r")))]
  "pic30_fp_inline_p()"
  "*
   {  
      return 
             \"cp0.b %1\;\"         /* compare input with 0 */
             \"mov #0x8000,%d0\;\"  /* assume -1 */
             \"btsc _SR,#0\;\"      /* positive => 0 or .99 */
             \"mov #0x7FFF,%d0\;\"  /*   load .99... */
             \"btsc _SR,#1\;\"      /* if zero */
             \"clr %d0\;\"          /*   load zero */
             \"sl  %d0,%0\;\"       /* form low word by propagating non sign */
             \"asr %0,#15,%0\";     /*   bits into low word */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfracthi<mode>2"
  [(set (match_operand:QUQ31  0 "pic30_register_operand"  "=r")
        (sat_fract:QUQ31
          (match_operand:HI 1 "pic30_register_operand"  "r")))]
  "pic30_fp_inline_p()"
  "*
   {
      return 
             \"cp0.b %1\;\"         /* compare input with 0 */
             \"mov #0x8000,%d0\;\"  /* assume -1 */
             \"btsc _SR,#0\;\"      /* positive => 0 or .99 */
             \"mov #0x7FFF,%d0\;\"  /*   load .99... */
             \"btsc _SR,#1\;\"      /* if zero */
             \"clr %d0\;\"          /*   load zero */
             \"sl  %d0,%0\;\"       /* form low word by propagating non sign */
             \"asr %0,#15,%0\";     /*   bits into low word */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractsi<mode>2"
  [(set (match_operand:QUQ31  0 "pic30_register_operand"  "=r")
        (sat_fract:QUQ31
          (match_operand:SI 1 "pic30_register_operand"  "r")))]
  "pic30_fp_inline_p()"
  "*
   {  
      return 
             \"sub %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subb %d1,#0,[w15]\;\" /* compare input with 0 */
             \"mov #0x8000,%d0\;\"   /* assume -1 */
             \"btsc _SR,#0\;\"       /* positive => 0 or .99 */
             \"mov #0x7FFF,%d0\;\"   /*   load .99... */
             \"btsc _SR,#1\;\"       /* if zero */
             \"clr %d0\;\"           /*   load zero */
             \"sl  %d0,%0\;\"        /* form low word by propagating non sign */
             \"asr %0,#15,%0\";      /*   bits into low word */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractdi<mode>2"
  [(set (match_operand:QUQ31  0 "pic30_register_operand"  "=r")
        (sat_fract:QUQ31
          (match_operand:DI 1 "pic30_register_operand"  "r")))]
  "pic30_fp_inline_p()"
  "*
   {  
      return 
             \"sub %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subb %d1,#0,[w15]\;\" /* compare input with 0 */
             \"subb %t1,#0,[w15]\;\" /* compare input with 0 */
             \"subb %q1,#0,[w15]\;\" /* compare input with 0 */
             \"mov #0x8000,%d0\;\"   /* assume -1 */
             \"btsc _SR,#0\;\"       /* positive => 0 or .99 */
             \"mov #0x7FFF,%d0\;\"   /*   load .99... */
             \"btsc _SR,#1\;\"       /* if zero */
             \"clr %d0\;\"           /*   load zero */
             \"sl  %d0,%0\;\"        /* form low word by propagating non sign */
             \"asr %0,#15,%0\";      /*   bits into low word */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

; to ACC

; cannot saturate
(define_insn "satfractqi<mode>2"
  [(set (match_operand:AUACC 0 "pic30_register_operand"  "=&r")
        (sat_fract:AUACC
          (match_operand:QI  1 "pic30_register_operand"    "r")))]
  ""
  "*
   {
      return
             \"mul.uu %0,#0,%0\;\"  /* clear low bits */
             \"mov.b %1,%t0\;\"     /* copy integer portion into upper byte */
             \"asr.b %t0,%t0\;\"    /* shift it into position */
             \"rrc %d0,%d0\";
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractunsqi<mode>2"
  [(set (match_operand:AUACC 0 "pic30_register_operand"  "=&r")
        (unsigned_sat_fract:AUACC
          (match_operand:QI  1 "pic30_register_operand"    "r")))]
  ""
  "*
  {
      return
             \"mul.uu %0,#0,%0\;\"  /* clear low bits */
             \"mov.b %1,%t0\;\"     /* copy integer portion into upper byte */
             \"asr.b %t0,%t0\;\"    /* shift it into position */
             \"rrc %d0,%d0\";
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

; the rest are function only

; unsigned

(define_insn "satfractuns<mode>qi2_helper"
  [(set (match_operand:QI    0 "pic30_register_operand"  "=&r")
        (unsigned_sat_fract:QI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       return \"asr %1,#15,%0\"; 
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %1,#14,%0\;btss %0,#0\;clr.b %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractuns<mode>qi2_convergent"
  [(set (match_operand:QI    0 "pic30_register_operand"  "=&r")
        (unsigned_sat_fract:QI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ15 2                         "=r"))
  ]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr.b %0\;\"
              \"sl %1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"    /*   always rounds to even 0 */
              \"clr.b %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "satfractuns<mode>qi2"
  [(set (match_operand:QI    0 "pic30_register_operand"  "=r")
        (unsigned_sat_fract:QI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  ""
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,QImode)) {
      r0 = gen_reg_rtx(QImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_satfract<mode>qi2_convergent(r0,r1)
      );
    } else {
      emit(
        gen_satfract<mode>qi2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "satfractuns<mode>hi2_helper"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=&r")
        (unsigned_sat_fract:HI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %1,#15,%0\"; 
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %1,#14,%0\;btss %0,#0\;clr %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractuns<mode>hi2_convergent"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=&r")
        (unsigned_sat_fract:HI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ15 2                         "=r"))
  ]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr %0\;\"
              \"sl %1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"    /*   always rounds to even 0 */
              \"clr %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "satfractuns<mode>hi2"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=r")
        (unsigned_sat_fract:HI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  ""
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,HImode)) {
      r0 = gen_reg_rtx(HImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_satfract<mode>hi2_convergent(r0,r1)
      );
    } else {
      emit(
        gen_satfract<mode>hi2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "satfractuns<mode>si2_helper"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=&r")
        (unsigned_sat_fract:SI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %1,#15,%d0\;asr %1,#15,%0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %1,#14,%0\;\"
              \"btss %0,#0\;\"
              \"clr %0\;\"
              \"asr %0,#15,%d0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractuns<mode>si2_convergent"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=&r")
        (unsigned_sat_fract:SI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ15 2                         "=r"))
  ]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %1,#14,%0\;\" /* as conventional */
              \"btss %0,#0\;\"
              \"clr  %0\;\"
              \"asr %0,#15,%d0\;\"
              \"sl %1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"    /*   always rounds to even 0 */
              \"mul.uu %0,#0,%0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "satfractuns<mode>si2"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=r")
        (unsigned_sat_fract:SI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  ""
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,SImode)) {
      r0 = gen_reg_rtx(SImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_satfract<mode>si2_convergent(r0,r1)
      );
    } else {
      emit(
        gen_satfract<mode>si2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "satfractuns<mode>di2_helper"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=&r")
        (unsigned_sat_fract:DI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %1,#15,%q0\;asr %1,#15,%t0\;mul.su %t0,#1,%0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %1,#14,%0\;\"
              \"btss %0,#0\;\"
              \"clr %0\;\"
              \"asr %0,#15,%d0\;\"
              \"mul.su %d0,#1,%t0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractuns<mode>di2_convergent"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=&r")
        (unsigned_sat_fract:DI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ15 2                         "=r"))
  ]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr  %0\;\"
              \"asr %0,#15,%d0\;\"
              \"sl %1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"    /*   always rounds to even 0 */
              \"mul.uu %0,#0,%0\;\"
              \"mul.su %d0,#1,%t0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "satfractuns<mode>di2"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=r")
        (unsigned_sat_fract:DI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  ""
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && 
        ((pic30_fp_round_p() == pic30_convergent) ||
         (pic30_fp_round_p() == pic30_conventional)))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,DImode)) {
      r0 = gen_reg_rtx(DImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_satfract<mode>di2_convergent(r0,r1)
      );
    } else {
      emit(
        gen_satfract<mode>di2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

; from Q31

(define_insn "satfractuns<mode>qi2_helper"
  [(set (match_operand:QI    0 "pic30_register_operand"  "=&r")
        (unsigned_sat_fract:QI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %d1,#15,%0\"; 
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %d1,#14,%0\;btss %0,#0\;clr.b %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractuns<mode>qi2_convergent"
  [(set (match_operand:QI    0 "pic30_register_operand"  "=&r")
        (unsigned_sat_fract:QI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ31 2                         "=&r"))
  ]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %d1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr.b %0\;\"
              \"sl %d1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"     /*   always rounds to even 0 */
              \"cp0 %1\;\"  
              \"btsc _SR,#1\;\"
              \"clr %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "satfractuns<mode>qi2"
  [(set (match_operand:QI    0 "pic30_register_operand"  "=r")
        (unsigned_sat_fract:QI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  ""
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,QImode)) {
      r0 = gen_reg_rtx(QImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_satfract<mode>qi2_convergent(r0,r1)
      );
    } else {
      emit(
        gen_satfract<mode>qi2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "satfractuns<mode>hi2_helper"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=&r")
        (unsigned_sat_fract:HI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %d1,#15,%0\"; 
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %d1,#14,%0\;btss %0,#0\;clr %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractuns<mode>hi2_convergent"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=&r")
        (unsigned_sat_fract:HI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ31 2                         "=&r"))
  ]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %d1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr %0\;\"
              \"sl %d1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"     /*   always rounds to even 0 */
              \"cp0 %1\;\"  
              \"btsc _SR,#1\;\"
              \"clr %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "satfractuns<mode>hi2"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=r")
        (unsigned_sat_fract:HI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  ""
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,HImode)) {
      r0 = gen_reg_rtx(HImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_satfract<mode>hi2_convergent(r0,r1)
      );
    } else {
      emit(
        gen_satfract<mode>hi2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "satfractuns<mode>si2_helper"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=&r")
        (unsigned_sat_fract:SI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %d1,#15,%d0\;asr %d1,#15,%0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %d1,#14,%0\;\"
              \"btss %0,#0\;\"
              \"clr %0\;\"
              \"asr %0,#15,%d0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractuns<mode>si2_convergent"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=&r")
        (unsigned_sat_fract:SI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ31 2                         "=&r"))
  ]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %d1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr  %0\;\"
              \"asr %0,#15,%d0\;\"
              \"sl %d1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"     /*   always rounds to even 0 */
              \"cp0 %1\;\"
              \"btsc _SR,#1\;\"
              \"mul.uu %0,#0,%0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "satfractuns<mode>si2"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=r")
        (unsigned_sat_fract:SI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  ""
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,SImode)) {
      r0 = gen_reg_rtx(SImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_satfract<mode>si2_convergent(r0,r1)
      );
    } else {
      emit(
        gen_satfract<mode>si2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "satfractuns<mode>di2_helper"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=&r")
        (unsigned_sat_fract:DI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %d1,#15,%q0\;asr %d1,#15,%t0\;mul.su %t0,#1,%0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %d1,#14,%0\;\"
              \"btss %0,#0\;\"
              \"clr %0\;\"
              \"asr %0,#15,%d0\;\"
              \"mul.su %d0,#1,%t0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractuns<mode>di2_convergent"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=&r")
        (unsigned_sat_fract:DI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ31 2                         "=&r"))
  ]
  ""
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %d1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr  %0\;\"
              \"asr %0,#15,%d0\;\"
              \"sl %d1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"     /*   always rounds to even 0 */
              \"cp0 %1\;\"
              \"btsc _SR,#1\;\"
              \"mul.uu %0,#0,%0\;\"
              \"mul.su %d0,#1,%t0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "satfractuns<mode>di2"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=r")
        (unsigned_sat_fract:DI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  ""
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && 
         ((pic30_fp_round_p() == pic30_convergent) ||
          (pic30_fp_round_p() == pic30_convergent)))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,DImode)) {
      r0 = gen_reg_rtx(DImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_satfract<mode>di2_convergent(r0,r1)
      );
    } else {
      emit(
        gen_satfract<mode>di2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

; to Q15

(define_insn "satfractunsqi<mode>2"
  [(set (match_operand:QUQ15  0 "pic30_register_operand"  "=r")
        (unsigned_sat_fract:QUQ15
          (match_operand:QI 1 "pic30_register_operand"  "r")))]
  "pic30_fp_inline_p()"
  "*
   {  
      return \"cp0.b %1\;\"        /* compare input with 0 */
             \"mov  #0x8000,%0\;\" /* assume -1 */
             \"btsc _SR,#0\;\"     /* positive => 0 or .99 */
             \"mov #0x7FFF,%0\;\"  /*   load .99... */
             \"btsc _SR,#1\;\"     /* if zero */
             \"clr %0\";           /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractunshi<mode>2"
  [(set (match_operand:QUQ15  0 "pic30_register_operand"  "=r")
        (unsigned_sat_fract:QUQ15
          (match_operand:HI 1 "pic30_register_operand"  "r")))]
  "pic30_fp_inline_p()"
  "*
   {
      return \"cp0  %1\;\"         /* compare input with 0 */
             \"mov  #0x8000,%0\;\" /* assume -1 */
             \"btsc _SR,#0\;\"     /* positive => 0 or .99 */
             \"mov #0x7FFF,%0\;\"  /*   load .99... */
             \"btsc _SR,#1\;\"     /* if zero */
             \"clr %0\";           /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractunssi<mode>2"
  [(set (match_operand:QUQ15  0 "pic30_register_operand"  "=r")
        (unsigned_sat_fract:QUQ15
          (match_operand:SI 1 "pic30_register_operand"  "r")))]
  "pic30_fp_inline_p()"
  "*
   {  
      return \"subr %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subbr %d1,#0,[w15]\;\" /* compare input with 0 */
             \"mov  #0x8000,%0\;\"    /* assume -1 */
             \"btsc _SR,#0\;\"        /* positive => 0 or .99 */
             \"mov #0x7FFF,%0\;\"     /*   load .99... */
             \"btsc _SR,#1\;\"        /* if zero */
             \"clr %0\";              /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractunsdi<mode>2"
  [(set (match_operand:QUQ15  0 "pic30_register_operand"  "=r")
        (unsigned_sat_fract:QUQ15
          (match_operand:DI 1 "pic30_register_operand"  "r")))]
  "pic30_fp_inline_p()"
  "*
   {  
      return \"subr %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subbr %d1,#0,[w15]\;\" /* compare input with 0 */
             \"subbr %t1,#0,[w15]\;\" /* compare input with 0 */
             \"subbr %q1,#0,[w15]\;\" /* compare input with 0 */
             \"mov  #0x8000,%0\;\"    /* assume -1 */
             \"btsc _SR,#0\;\"        /* positive => 0 or .99 */
             \"mov #0x7FFF,%0\;\"     /*   load .99... */
             \"btsc _SR,#1\;\"        /* if zero */
             \"clr %0\";              /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

; to Q31

(define_insn "satfractunsqi<mode>2"
  [(set (match_operand:QUQ31  0 "pic30_register_operand"  "=r")
        (unsigned_sat_fract:QUQ31
          (match_operand:QI 1 "pic30_register_operand"  "r")))]
  "pic30_fp_inline_p()"
  "*
   {  
      return 
             \"cp0.b %1\;\"         /* compare input with 0 */
             \"mov #0x8000,%d0\;\"  /* assume -1 */
             \"btsc _SR,#0\;\"      /* positive => 0 or .99 */
             \"mov #0x7FFF,%d0\;\"  /*   load .99... */
             \"btsc _SR,#1\;\"      /* if zero */
             \"clr %d0\;\"          /*   load zero */
             \"sl  %d0,%0\;\"       /* form low word by propagating non sign */
             \"asr %0,#15,%0\";     /*   bits into low word */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractunshi<mode>2"
  [(set (match_operand:QUQ31  0 "pic30_register_operand"  "=r")
        (unsigned_sat_fract:QUQ31
          (match_operand:HI 1 "pic30_register_operand"  "r")))]
  "pic30_fp_inline_p()"
  "*
   {
      return 
             \"cp0.b %1\;\"         /* compare input with 0 */
             \"mov #0x8000,%d0\;\"  /* assume -1 */
             \"btsc _SR,#0\;\"      /* positive => 0 or .99 */
             \"mov #0x7FFF,%d0\;\"  /*   load .99... */
             \"btsc _SR,#1\;\"      /* if zero */
             \"clr %d0\;\"          /*   load zero */
             \"sl  %d0,%0\;\"       /* form low word by propagating non sign */
             \"asr %0,#15,%0\";     /*   bits into low word */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractunssi<mode>2"
  [(set (match_operand:QUQ31  0 "pic30_register_operand"  "=r")
        (unsigned_sat_fract:QUQ31
          (match_operand:SI 1 "pic30_register_operand"  "r")))]
  "pic30_fp_inline_p()"
  "*
   {  
      return 
             \"sub %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subb %d1,#0,[w15]\;\" /* compare input with 0 */
             \"mov #0x8000,%d0\;\"   /* assume -1 */
             \"btsc _SR,#0\;\"       /* positive => 0 or .99 */
             \"mov #0x7FFF,%d0\;\"   /*   load .99... */
             \"btsc _SR,#1\;\"       /* if zero */
             \"clr %d0\;\"           /*   load zero */
             \"sl  %d0,%0\;\"        /* form low word by propagating non sign */
             \"asr %0,#15,%0\";      /*   bits into low word */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractunsdi<mode>2"
  [(set (match_operand:QUQ31  0 "pic30_register_operand"  "=r")
        (unsigned_sat_fract:QUQ31
          (match_operand:DI 1 "pic30_register_operand"  "r")))]
  "pic30_fp_inline_p()"
  "*
   {  
      return 
             \"sub %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subb %d1,#0,[w15]\;\" /* compare input with 0 */
             \"subb %t1,#0,[w15]\;\" /* compare input with 0 */
             \"subb %q1,#0,[w15]\;\" /* compare input with 0 */
             \"mov #0x8000,%d0\;\"   /* assume -1 */
             \"btsc _SR,#0\;\"       /* positive => 0 or .99 */
             \"mov #0x7FFF,%d0\;\"   /*   load .99... */
             \"btsc _SR,#1\;\"       /* if zero */
             \"clr %d0\;\"           /*   load zero */
             \"sl  %d0,%0\;\"        /* form low word by propagating non sign */
             \"asr %0,#15,%0\";      /*   bits into low word */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)


;; conversions back and forth to floating point or double will be done by
;;  out of line functions only

;; conversions to and from fractional types
;;   some of these can actually cause saturation

(define_insn "satfractsq<mode>2_helper"
  [(set (match_operand:QUQ15 0 "pic30_register_operand" "=&r")
        (sat_fract:QUQ15
          (match_operand:SQ  1 "pic30_register_operand" "r")))]
  ""
  "*
  {
    if ((pic30_fp_round_p() == pic30_truncation) ||
        (pic30_fp_round_p() == pic30_fastest)) {
      return \"mov %d1,%0\";
    } else if (pic30_fp_round_p() == pic30_conventional) {
      return \"sl %1,[w15]\;\"       /* shift overflow bit to carry */
             \"addc %d1,#0,%0\;\"    /* add */
             \"bra nov,.L1_%=\;\"    /* no overflow? finished */
             \"mov #0x7FFF,%0\;\"    /* return ~1 */
             \"btsc %d1,#15\;\"
             \"com %0,%0\n\"         /* or -1 */
             \".L1_%=:\";
    } else {
       error(\"Invalid fixed-point rounding mode specified\");
    }
     gcc_assert(0);
     return \"nop\";
  }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractsq<mode>2_convergent"
  [(set (match_operand:QUQ15  0 "pic30_register_operand" "=&r")
        (sat_fract:QUQ15
          (match_operand:SQ   1 "pic30_register_operand" "r")))
   (clobber (match_scratch:HI 2                          "=&r"))
  ]
  ""
  "*
  {
    if (pic30_fp_round_p() == pic30_convergent) {
      return \"setm %2\;\"
             \"sl %1,[w15]\;\"          /* get top bit into carry */
             \"btsc _SR,#1\;\"          /* if the result is 0 */
             \"mov #0xFFFE,%2\;\"       /*   mask off low bit */
             \"addc %d1,#0,%0\;\"       /* add in 'overflow' */
             \"bra nov,.L1_%=\;\"       /* nov ? continue */
             \"mov #0x7FFF,%0\;\"       /* return ~1 */
             \"btsc %d1,#15\;\"
             \"com %0,%0\;\"            /* or -1 */
             \"setm %2\;\"              /* prevent mask */
             \".L1_%=:\;\"
             \"and %0,%2,%0\";          /* maybe mask off low bit */
    } else {
       error(\"Invalid fixed-point rounding mode specified\");
    }
     gcc_assert(0);
     return \"nop\";
  }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "satfractsq<mode>2"
  [(set (match_operand:QUQ15 0 "pic30_register_operand"  "=r")
        (sat_fract:QUQ15
          (match_operand:SQ  1 "pic30_register_operand"  "r")))]
  ""
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && 
         ((pic30_fp_round_p() == pic30_convergent) ||
          (pic30_fp_round_p() == pic30_conventional)))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,SImode)) {
      r0 = gen_reg_rtx(<MODE>mode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_satfractsq<mode>2_convergent(r0,r1)
      );
    } else {
      emit(
        gen_satfractsq<mode>2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "satfractusq<mode>2_helper"
  [(set (match_operand:QUQ15 0 "pic30_register_operand" "=&r")
        (sat_fract:QUQ15
          (match_operand:USQ 1 "pic30_register_operand" "r")))]
  ""
  "*
  {
    if ((pic30_fp_round_p() == pic30_truncation) ||
        (pic30_fp_round_p() == pic30_fastest)) {
      return \"mov %d1,%0\";
    } else if (pic30_fp_round_p() == pic30_conventional) {
      return \"sl %1,[w15]\;\"       /* shift overflow bit to carry */
             \"addc %d1,#0,%0\;\"    /* add */
             \"bra nov,.L1_%=\;\"    /* no overflow? finished */
             \"mov #0x7FFF,%0\;\"    /* return ~1 */
             \"btsc %d1,#15\;\"      
             \"com %0,%0\n\"         /* or -1 */
             \".L1_%=:\";
    } else {
       error(\"Invalid fixed-point rounding mode specified\");
    }
     gcc_assert(0);
     return \"nop\";
  }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractusq<mode>2_convergent"
  [(set (match_operand:QUQ15  0 "pic30_register_operand" "=&r")
        (sat_fract:QUQ15
          (match_operand:USQ  1 "pic30_register_operand" "r")))
   (clobber (match_scratch:HI 2                          "=&r"))
  ]
  ""
  "*
  {
    if (pic30_fp_round_p() == pic30_convergent) {
      return \"setm %2\;\"
             \"sl %1,[w15]\;\"          /* get top bit into carry */
             \"btsc _SR,#1\;\"          /* if the result is 0 */
             \"mov #0xFFFE,%2\;\"       /*   mask off low bit */
             \"addc %d1,#0,%0\;\"       /* add in 'overflow' */
             \"bra nov,.L1_%=\;\"       /* nov ? continue */
             \"mov #0x7FFF,%0\;\"       /* return ~1 */
             \"btsc %d1,#15\;\" 
             \"com %0,%0\;\"            /* or -1 */
             \"setm %2\n\"              /* prevent mask */
             \".L1_%=:\;\"
             \"and %0,%2,%0\";          /* maybe mask off low bit */
    } else { 
       error(\"Invalid fixed-point rounding mode specified\");
    }  
     gcc_assert(0);
     return \"nop\";
  } 
  "
  [
    (set_attr "cc" "clobber")
  ]
) 

(define_expand "satfractusq<mode>2"
  [(set (match_operand:QUQ15 0 "pic30_register_operand"  "=r")
        (sat_fract:QUQ15
          (match_operand:USQ 1 "pic30_register_operand"  "r")))]
  ""      
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && 
         ((pic30_fp_round_p() == pic30_convergent) ||
          (pic30_fp_round_p() == pic30_conventional)))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,SImode)) {
      r0 = gen_reg_rtx(<MODE>mode);
    } 
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    } 
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_satfractusq<mode>2_convergent(r0,r1)
      );
    } else {
      emit(
        gen_satfractusq<mode>2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "satfractdq<mode>2_helper"
  [(set (match_operand:QUQ15 0 "pic30_register_operand" "=&r")
        (sat_fract:QUQ15
          (match_operand:DQ  1 "pic30_register_operand" "r")))]
  ""
  "*
  {
    if ((pic30_fp_round_p() == pic30_truncation) ||
        (pic30_fp_round_p() == pic30_fastest)) {
      return \"mov %d1,%0\";
    } else if (pic30_fp_round_p() == pic30_conventional) {
      return \"sl %1,[w15]\;\"       /* shift overflow bit to carry */
             \"addc %d1,#0,%0\;\"    /* add */
             \"bra nov,.L1_%=\;\"    /* no overflow? finished */
             \"mov #0x7FFF,%0\;\"    /* return ~1 */
             \"btsc %d1,#15\;\"      
             \"com %0,%0\n\"         /* or -1 */
             \".L1_%=:\";
    } else {
       error(\"Invalid fixed-point rounding mode specified\");
    }
     gcc_assert(0);
     return \"nop\";
  }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractdq<mode>2_convergent"
  [(set (match_operand:QUQ15  0 "pic30_register_operand" "=&r")
        (sat_fract:QUQ15
          (match_operand:DQ   1 "pic30_register_operand" "r")))
   (clobber (match_scratch:HI 2                          "=&r"))
  ]
  ""
  "*
  {
    if (pic30_fp_round_p() == pic30_convergent) {
      return \"setm %2\;\"
             \"sl %1,[w15]\;\"          /* get top bit into carry */
             \"btsc _SR,#1\;\"          /* if the result is 0 */
             \"mov #0xFFFE,%2\;\"       /*   mask off low bit */
             \"addc %d1,#0,%0\;\"       /* add in 'overflow' */
             \"bra nov,.L1_%=\;\"       /* nov ? continue */
             \"mov #0x7FFF,%0\;\"       /* return ~1 */
             \"btsc %d1,#15\;\" 
             \"com %0,%0\;\"            /* or -1 */
             \"setm %2\n\"              /* prevent mask */
             \".L1_%=:\;\"
             \"and %0,%2,%0\";          /* maybe mask off low bit */
    } else { 
       error(\"Invalid fixed-point rounding mode specified\");
    }  
     gcc_assert(0);
     return \"nop\";
  } 
  "
  [
    (set_attr "cc" "clobber")
  ]
) 

(define_expand "satfractdq<mode>2"
  [(set (match_operand:QUQ15 0 "pic30_register_operand"  "=r")
        (sat_fract:QUQ15
          (match_operand:DQ  1 "pic30_register_operand"  "r")))]
  ""      
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && 
         ((pic30_fp_round_p() == pic30_convergent) ||
          (pic30_fp_round_p() == pic30_conventional)))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,SImode)) {
      r0 = gen_reg_rtx(<MODE>mode);
    } 
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    } 
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_satfractdq<mode>2_convergent(r0,r1)
      );
    } else {
      emit(
        gen_satfractdq<mode>2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)
(define_insn "satfractudq<mode>2_helper"
  [(set (match_operand:QUQ15 0 "pic30_register_operand" "=&r")
        (sat_fract:QUQ15
          (match_operand:UDQ 1 "pic30_register_operand" "r")))]
  ""
  "*
  {
    if ((pic30_fp_round_p() == pic30_truncation) ||
        (pic30_fp_round_p() == pic30_fastest)) {
      return \"mov %d1,%0\";
    } else if (pic30_fp_round_p() == pic30_conventional) {
      return \"sl %1,[w15]\;\"       /* shift overflow bit to carry */
             \"addc %d1,#0,%0\;\"    /* add */
             \"bra nov,.L1_%=\;\"    /* no overflow? finished */
             \"mov #0x7FFF,%0\;\"    /* return ~1 */
             \"btsc %d1,#15\;\"      
             \"com %0,%0\n\"         /* or -1 */
             \".L1_%=:\";
    } else {
       error(\"Invalid fixed-point rounding mode specified\");
    }
     gcc_assert(0);
     return \"nop\";
  }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractudq<mode>2_convergent"
  [(set (match_operand:QUQ15  0 "pic30_register_operand" "=&r")
        (sat_fract:QUQ15
          (match_operand:UDQ   1 "pic30_register_operand" "r")))
   (clobber (match_scratch:HI 2                          "=&r"))
  ]
  ""
  "*
  {
    if (pic30_fp_round_p() == pic30_convergent) {
      return \"setm %2\;\"
             \"sl %1,[w15]\;\"          /* get top bit into carry */
             \"btsc _SR,#1\;\"          /* if the result is 0 */
             \"mov #0xFFFE,%2\;\"       /*   mask off low bit */
             \"addc %d1,#0,%0\;\"       /* add in 'overflow' */
             \"bra nov,.L1_%=\;\"       /* nov ? continue */
             \"mov #0x7FFF,%0\;\"       /* return ~1 */
             \"btsc %d1,#15\;\" 
             \"com %0,%0\;\"            /* or -1 */
             \"setm %2\n\"              /* prevent mask */
             \".L1_%=:\;\"
             \"and %0,%2,%0\";          /* maybe mask off low bit */
    } else { 
       error(\"Invalid fixed-point rounding mode specified\");
    }  
     gcc_assert(0);
     return \"nop\";
  } 
  "
  [
    (set_attr "cc" "clobber")
  ]
) 

(define_expand "satfractudq<mode>2"
  [(set (match_operand:QUQ15 0 "pic30_register_operand"  "=r")
        (sat_fract:QUQ15
          (match_operand:UDQ 1 "pic30_register_operand"  "r")))]
  ""      
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && 
         ((pic30_fp_round_p() == pic30_convergent) ||
          (pic30_fp_round_p() == pic30_conventional)))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,SImode)) {
      r0 = gen_reg_rtx(<MODE>mode);
    } 
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    } 
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_satfractudq<mode>2_convergent(r0,r1)
      );
    } else {
      emit(
        gen_satfractudq<mode>2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "satfracttq<mode>2_helper"
  [(set (match_operand:QUQ15 0 "pic30_register_operand" "=&r")
        (sat_fract:QUQ15
          (match_operand:TQ  1 "pic30_register_operand" "r")))]
  ""
  "*
  {
    if ((pic30_fp_round_p() == pic30_truncation) ||
        (pic30_fp_round_p() == pic30_fastest)) {
      return \"mov %d1,%0\";
    } else if (pic30_fp_round_p() == pic30_conventional) {
      return \"sl %1,[w15]\;\"       /* shift overflow bit to carry */
             \"addc %d1,#0,%0\;\"    /* add */
             \"bra nov,.L1_%=\;\"    /* no overflow? finished */
             \"mov #0x7FFF,%0\;\"    /* return ~1 */
             \"btsc %d1,#15\;\"      
             \"com %0,%0\n\"         /* or -1 */
             \".L1_%=:\";
    } else {
       error(\"Invalid fixed-point rounding mode specified\");
    }
     gcc_assert(0);
     return \"nop\";
  }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfracttq<mode>2_convergent"
  [(set (match_operand:QUQ15  0 "pic30_register_operand" "=&r")
        (sat_fract:QUQ15
          (match_operand:TQ   1 "pic30_register_operand" "r")))
   (clobber (match_scratch:HI 2                          "=&r"))
  ]
  ""
  "*
  {
    if (pic30_fp_round_p() == pic30_convergent) {
      return \"setm %2\;\"
             \"sl %1,[w15]\;\"          /* get top bit into carry */
             \"btsc _SR,#1\;\"          /* if the result is 0 */
             \"mov #0xFFFE,%2\;\"       /*   mask off low bit */
             \"addc %d1,#0,%0\;\"       /* add in 'overflow' */
             \"bra nov,.L1_%=\;\"       /* nov ? continue */
             \"mov #0x7FFF,%0\;\"       /* return ~1 */
             \"btsc %d1,#15\;\" 
             \"com %0,%0\;\"            /* or -1 */
             \"setm %2\n\"              /* prevent mask */
             \".L1_%=:\;\"
             \"and %0,%2,%0\";          /* maybe mask off low bit */
    } else { 
       error(\"Invalid fixed-point rounding mode specified\");
    }  
     gcc_assert(0);
     return \"nop\";
  } 
  "
  [
    (set_attr "cc" "clobber")
  ]
) 

(define_expand "satfracttq<mode>2"
  [(set (match_operand:QUQ15 0 "pic30_register_operand"  "=r")
        (sat_fract:QUQ15
          (match_operand:TQ  1 "pic30_register_operand"  "r")))]
  ""      
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && 
         ((pic30_fp_round_p() == pic30_convergent) ||
          (pic30_fp_round_p() == pic30_conventional)))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,SImode)) {
      r0 = gen_reg_rtx(<MODE>mode);
    } 
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    } 
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_satfracttq<mode>2_convergent(r0,r1)
      );
    } else {
      emit(
        gen_satfracttq<mode>2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "satfractutq<mode>2_helper"
  [(set (match_operand:QUQ15 0 "pic30_register_operand" "=&r")
        (sat_fract:QUQ15
          (match_operand:UTQ 1 "pic30_register_operand" "r")))]
  ""
  "*
  {
    if ((pic30_fp_round_p() == pic30_truncation) ||
        (pic30_fp_round_p() == pic30_fastest)) {
      return \"mov %d1,%0\";
    } else if (pic30_fp_round_p() == pic30_conventional) {
      return \"sl %1,[w15]\;\"       /* shift overflow bit to carry */
             \"addc %d1,#0,%0\;\"    /* add */
             \"bra nov,.L1_%=\;\"    /* no overflow? finished */
             \"mov #0x7FFF,%0\;\"    /* return ~1 */
             \"btsc %d1,#15\;\"      
             \"com %0,%0\n\"         /* or -1 */
             \".L1_%=:\";
    } else {
       error(\"Invalid fixed-point rounding mode specified\");
    }
     gcc_assert(0);
     return \"nop\";
  }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractutq<mode>2_convergent"
  [(set (match_operand:QUQ15  0 "pic30_register_operand" "=&r")
        (sat_fract:QUQ15
          (match_operand:UTQ  1 "pic30_register_operand" "r")))
   (clobber (match_scratch:HI 2                          "=&r"))
  ]
  ""
  "*
  {
    if (pic30_fp_round_p() == pic30_convergent) {
      return \"setm %2\;\"
             \"sl %1,[w15]\;\"          /* get top bit into carry */
             \"btsc _SR,#1\;\"          /* if the result is 0 */
             \"mov #0xFFFE,%2\;\"       /*   mask off low bit */
             \"addc %d1,#0,%0\;\"       /* add in 'overflow' */
             \"bra nov,.L1_%=\;\"       /* nov ? continue */
             \"mov #0x7FFF,%0\;\"       /* return ~1 */
             \"btsc %d1,#15\;\" 
             \"com %0,%0\;\"            /* or -1 */
             \"setm %2\n\"              /* prevent mask */
             \".L1_%=:\;\"
             \"and %0,%2,%0\";          /* maybe mask off low bit */
    } else { 
       error(\"Invalid fixed-point rounding mode specified\");
    }  
     gcc_assert(0);
     return \"nop\";
  } 
  "
  [
    (set_attr "cc" "clobber")
  ]
) 

(define_expand "satfractutq<mode>2"
  [(set (match_operand:QUQ15 0 "pic30_register_operand"  "=r")
        (sat_fract:QUQ15
          (match_operand:UTQ 1 "pic30_register_operand"  "r")))]
  ""      
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && 
         ((pic30_fp_round_p() == pic30_convergent) ||
          (pic30_fp_round_p() == pic30_conventional)))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,SImode)) {
      r0 = gen_reg_rtx(<MODE>mode);
    } 
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    } 
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_satfractutq<mode>2_convergent(r0,r1)
      );
    } else {
      emit(
        gen_satfractutq<mode>2_helper(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "satfractqq<mode>2"
  [(set (match_operand:QUQ31 0 "pic30_register_operand" "=r")
        (sat_fract:QUQ31
          (match_operand:QQ  1 "pic30_register_operand" "r")))]
  ""
  "mov %1,%d0\;clr %0"
  [
    (set_attr "cc" "change0")
  ]
)

(define_insn "satfractuqq<mode>2"
  [(set (match_operand:QUQ31 0 "pic30_register_operand" "=r")
        (sat_fract:QUQ31
          (match_operand:UQQ 1 "pic30_register_operand" "r")))]
  ""
  "mov %1,%d0\;clr %0"
  [
    (set_attr "cc" "change0")
  ]
)

(define_insn "satfracthq<mode>2"
  [(set (match_operand:QUQ31 0 "pic30_register_operand" "=r")
        (sat_fract:QUQ31
          (match_operand:HQ  1 "pic30_register_operand" "r")))]
  ""
  "mov %1,%d0\;clr %0"
  [
    (set_attr "cc" "change0")
  ]
)

(define_insn "satfractuhq<mode>2"
  [(set (match_operand:QUQ31 0 "pic30_register_operand" "=r")
        (sat_fract:QUQ31
          (match_operand:UHQ 1 "pic30_register_operand" "r")))]
  ""
  "mov %1,%d0\;clr %0"
  [
    (set_attr "cc" "change0")
  ]
)

;; conversions between different fractional modes of the same size
;;   these are nops but must exist

(define_insn "satfract<mode>sq2"
  [(set (match_operand:SQ      0 "pic30_register_operand" "=r,r")
        (sat_fract:SQ
          (match_operand:QUQ31 1 "pic30_register_operand" "r,0")))]
  ""
  "@
   mov.d %1,%0
   ; nop"
  [
    (set_attr "cc" "change0,unchanged")
  ]
)

(define_insn "satfract<mode>dq2"
  [(set (match_operand:DQ      0 "pic30_register_operand" "=r,r")
        (sat_fract:DQ
          (match_operand:QUQ31 1 "pic30_register_operand" "r,0")))]
  ""
  "@
   mov.d %1,%0
   ; nop"
  [
    (set_attr "cc" "change0,unchanged")
  ]
)

(define_insn "satfract<mode>tq2"
  [(set (match_operand:TQ      0 "pic30_register_operand" "=r,r")
        (sat_fract:TQ
          (match_operand:QUQ31 1 "pic30_register_operand" "r,0")))]
  ""
  "@
   mov.d %1,%0
   ; nop"
  [
    (set_attr "cc" "change0,unchanged")
  ]
)

(define_insn "satfract<mode>qq2"
  [(set (match_operand:QQ      0 "pic30_register_operand" "=r,r")
        (sat_fract:QQ
          (match_operand:QUQ15 1 "pic30_register_operand" "r,0")))]
  ""
  "@
   mov %1,%0
   ; nop"
  [
    (set_attr "cc" "change0,unchanged")
  ]
)

(define_insn "satfract<mode>hq2"
  [(set (match_operand:HQ      0 "pic30_register_operand" "=r,r")
        (sat_fract:HQ
          (match_operand:QUQ15 1 "pic30_register_operand" "r,0")))]
  ""
  "@
   mov %1,%0
   ; nop"
  [
    (set_attr "cc" "change0,unchanged")
  ]
)

; missing conversions between signed/unsigned 'self'

(define_insn "satfractqquqq2"
  [(set (match_operand:UQQ  0 "general_operand" "=g")
       (unsigned_sat_fract:UQQ
         (match_operand:QQ 1 "general_operand" "0")))]
  ""
  "; nop"
)

(define_insn "satfracthquhq2"
  [(set (match_operand:UHQ  0 "general_operand" "=g")
       (unsigned_sat_fract:UHQ
         (match_operand:HQ 1 "general_operand" "0")))]
  ""
  "; nop"
)

(define_insn "satfractsqusq2"
  [(set (match_operand:USQ  0 "general_operand" "=g")
       (unsigned_sat_fract:USQ
         (match_operand:SQ 1 "general_operand" "0")))]
  ""
  "; nop"
)

(define_insn "satfractdqudq2"
  [(set (match_operand:UDQ  0 "general_operand" "=g")
       (unsigned_sat_fract:UDQ
         (match_operand:DQ 1 "general_operand" "0")))]
  ""
  "; nop"
)

(define_insn "satfracttqutq2"
  [(set (match_operand:UTQ  0 "general_operand" "=g")
       (unsigned_sat_fract:UTQ
         (match_operand:TQ 1 "general_operand" "0")))]
  ""
  "; nop"
)

(define_insn "satfracthauha2"
  [(set (match_operand:UHA  0 "general_operand" "=g")
       (unsigned_sat_fract:UHA
         (match_operand:HA 1 "general_operand" "0")))]
  ""
  "; nop"
)

(define_insn "satfractuhaha2"
  [(set (match_operand:HA    0 "general_operand" "=g")
       (sat_fract:HA
         (match_operand:UHA 1 "general_operand" "0")))]
  ""
  "; nop"
)

(define_insn "satfractsausa2"
  [(set (match_operand:USA  0 "general_operand" "=g")
       (unsigned_sat_fract:USA
         (match_operand:SA 1 "general_operand" "0")))]
  ""
  "; nop"
)

(define_insn "satfractusasa2"
  [(set (match_operand:SA    0 "general_operand" "=g")
       (sat_fract:SA
         (match_operand:USA 1 "general_operand" "0")))]
  ""
  "; nop"
)

(define_insn "satfractdauda2"
  [(set (match_operand:UDA  0 "general_operand" "=g")
       (unsigned_sat_fract:UDA
         (match_operand:DA 1 "general_operand" "0")))]
  ""
  "; nop"
)

(define_insn "satfractudada2"
  [(set (match_operand:DA    0 "general_operand" "=g")
       (sat_fract:DA
         (match_operand:UDA 1 "general_operand" "0")))]
  ""
  "; nop"
)

(define_insn "satfracttauta2"
  [(set (match_operand:UTA  0 "general_operand" "=g")
       (unsigned_sat_fract:UTA
         (match_operand:TA 1 "general_operand" "0")))]
  ""
  "; nop"
)

(define_insn "satfractutata2"
  [(set (match_operand:TA    0 "general_operand" "=g")
       (sat_fract:TA
         (match_operand:UTA 1 "general_operand" "0")))]
  ""
  "; nop"
)

;; negate

(define_insn "neg<mode>2"
  [(set (match_operand:QUQ15   0 "pic30_mode2_operand" "=rR<>")
        (neg:QUQ15
          (match_operand:QUQ15 1 "pic30_mode2_operand" " rR<>")))]
  ""
  "neg %1,%0"
  [
    (set_attr "cc" "math")
  ]
)

(define_insn "ssneg<mode>2"
  [(set (match_operand:QUQ15   0 "pic30_register_operand" "=&r")
        (ss_neg:QUQ15
          (match_operand:QUQ15 1 "pic30_register_operand" " r")))]
  "pic30_fp_inline_p()"
  "*
   return \"neg %1,%0\;\"
          \"bra nov,.L1_%=\;\"
          \"mov #0x7FFF,%0\;\"
          \"btss %1,#15\;\"
          \"com %0,%0\n\"
          \".L1_%=:\;\";
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "usneg<mode>2"
  [(set (match_operand:Q15   0 "pic30_register_operand" "=&r")
        (us_neg:Q15
          (match_operand:Q15 1 "pic30_register_operand" " r")))]
  ""
  "neg %1,%0;\;btsc _SR,#2\;mov #0x7FFF,%0\;btsc _SR,#3\;clr %0"
  [
    (set_attr "cc" "clobber")
  ]
)

; cannot negate with unigned saturation a positive value
(define_insn "usneg<mode>2"
  [(set (match_operand:UQ15   0 "pic30_register_operand" "=&r")
        (us_neg:UQ15
          (match_operand:UQ15 1 "pic30_register_operand" " r")))]
  ""
  "clr %0"
  [
    (set_attr "cc" "clobber")
  ]
)


(define_insn "neg<mode>2"
  [(set (match_operand:QUQ31   0 "pic30_mode2_operand" "=r<>,R")
        (neg:QUQ31
          (match_operand:QUQ31 1 "pic30_register_operand" " r,r")))]
  ""
  "@
   subr %1,#0,%0\;subbr %d1,#0,%d0
   subr %1,#0,%I0\;subbr %d1,#0,%D0"
  [
    (set_attr "cc" "math")
  ]
)

(define_insn "ssneg<mode>2"
  [(set (match_operand:QUQ31   0 "pic30_register_operand" "=&r")
        (ss_neg:QUQ31
          (match_operand:QUQ31 1 "pic30_register_operand" " r")))]
  "pic30_fp_inline_p()"
  "*
   return \"subr %1,#0,%0\;\"
          \"subbr %d1,#0,%d0\;\"
          \"bra nov,.L1_%=\;\"
          \"setm %0\;\"
          \"mov #0x7FFF,%d0\;\"
          \"btst.c %d1,#15\;\"
          \"bra c,.L1_%=\;\"
          \"com %d0,%d0\;\"
          \"com %0,%0\n\"
          \".L1_%=:\;\";
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "usneg<mode>2"
  [(set (match_operand:Q31   0 "pic30_register_operand" "=r")
        (us_neg:Q31
          (match_operand:Q31 1 "pic30_register_operand" " r")))]
  "pic30_fp_inline_p()"
  "*
   return \"subr %1,#0,%0\;\"
          \"subbr %d1,#0,%d0\;\"
          \"bra nov,.L1_%=\;\"
          \"setm %0\;\"
          \"mov #0x7FFF,%d0\n\"
          \".L1_%=:\;\"
          \"btsc _SR,#3\;\"
          \"mul.uu %0,#0,%0\";
  "
  [
    (set_attr "cc" "clobber")
  ]
)

; cannot negate with unigned saturation a positive value
(define_insn "usneg<mode>2"
  [(set (match_operand:UQ31   0 "pic30_register_operand" "=&r")
        (us_neg:UQ31
          (match_operand:UQ31 1 "pic30_register_operand" " r")))]
  ""
  "mul.uu %0,#0,%0"
  [
    (set_attr "cc" "clobber")
  ]
)

;; shift

(define_insn "ashl<mode>3"
  [(set (match_operand:QUQ15   0 "pic30_register_operand"       "=r")
        (ashift:QUQ15 
          (match_operand:QUQ15 1 "pic30_register_operand"       "r")
          (match_operand:HI    2 "pic30_register_operand"       "r")))
  ]
  ""
  "sl %1,%2,%0"
  [ 
   (set_attr "cc" "math")
  ]
)

(define_insn "ssashl<mode>3"
  [(set (match_operand:Q15   0 "pic30_register_operand"     "=&r")
        (ss_ashift:Q15
          (match_operand:Q15 1 "pic30_register_operand"       "r")
          (match_operand:HI  2 "pic30_register_operand"       "r")))
   (clobber (match_scratch:HI 3                              "=&r"))
  ]
  ""
  "*
   return \"mov #0x8000,%3\;\"        /* create mask for bits */
          \"asr %3,%2,%3\;\"          /*   that drop off */
          \"sl  %1,%2,%0\;\"          /* shift */
          \"and %3,%1,%3\;\"          /* mask input and mask */
          \"bra z,.L1_%=\;\"          /* non-zero means bits drop off */
          \"mov #0x7FFF,%0\;\"        /* Saturate to ~.99 */
          \"btsc %1,#15\;\"
          \"com %0,%0\n\"             /* or -1 */
          \".L1_%=:\";
  "
  [
   (set_attr "cc" "clobber")
  ]
)

(define_insn "ssashl<mode>3"
  [(set (match_operand:UQ15   0 "pic30_register_operand"     "=&r")
        (ss_ashift:UQ15
          (match_operand:UQ15 1 "pic30_register_operand"       "r")
          (match_operand:HI   2 "pic30_register_operand"       "r")))
   (clobber (match_scratch:HI 3                              "=&r"))
  ]
  ""
  "*
   return \"mov #0x8000,%3\;\"        /* create mask for bits */
          \"asr %3,%2,%3\;\"          /*   that drop off */
          \"sl  %1,%2,%0\;\"          /* shift */
          \"and %3,%1,%3\;\"          /* mask input and mask */
          \"btss _SR,#1\;\"           /* non-zero means bits drop off */
          \"mov #0x7FFF,%0\;\";
  "
  [
   (set_attr "cc" "clobber")
  ]
)

(define_insn "usashl<mode>3"
  [(set (match_operand:QUQ15   0 "pic30_register_operand"     "=&r")
        (us_ashift:QUQ15
          (match_operand:QUQ15 1 "pic30_register_operand"       "r")
          (match_operand:HI    2 "pic30_register_operand"       "r")))
   (clobber (match_scratch:HI 3                               "=&r"))
  ]
  ""
  "*
   return \"mov #0x8000,%3\;\"        /* create mask for bits */
          \"asr %3,%2,%3\;\"          /*   that drop off */
          \"sl  %1,%2,%0\;\"          /* shift */
          \"and %3,%1,%3\;\"          /* mask input and mask */
          \"btss _SR,#1\;\"           /* non-zero means bits drop off */
          \"mov #0x7FFF,%0\";
  "
  [
   (set_attr "cc" "clobber")
  ]
)

; 32-bit shift left

(define_insn "ashl<mode>3_imm1"
  [(set (match_operand:QUQ31   0 "pic30_register_operand" "=r")
        (ashift:QUQ31 
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")
          (match_operand:HI    2 "pic30_I_operand"         "I")))]
  ""
  "add %1,%1,%0\;addc %d1,%d1,%d0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ssashl<mode>3_imm1"
  [(set (match_operand:Q31   0 "pic30_register_operand" "=&r")
        (ss_ashift:Q31 
          (match_operand:Q31 1 "pic30_register_operand"   "r")
          (match_operand:HI  2 "pic30_I_operand"          "I")))]
  "pic30_fp_inline_p()"
  "*
   return \"add %1,%1,%0\;\"          /* shift */
          \"addc %d1,%d1,%d0\;\"
          \"bra nov,.L1_%=\;\"        /* but if the sign changes ... */
          \"mov #0x7FFF,%d0\;\"       /* Saturate to ~.99 */
          \"btsc %d1,#15\;\"
          \"com %d0,%d0\;\"           /* or -1 */
          \"sl  %d0,%0\;\"            /* form low word by propagating nonsign */
          \"asr %0,#15,%0\n\"         /*   bits into low word */
          \".L1_%=:\;\";
  "
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ssashl<mode>3_imm1"
  [(set (match_operand:UQ31   0 "pic30_register_operand" "=&r")
        (ss_ashift:UQ31
          (match_operand:UQ31 1 "pic30_register_operand"   "r")
          (match_operand:HI   2 "pic30_I_operand"          "I")))]
  "pic30_fp_inline_p()"
  "*
   return \"add %1,%1,%0\;\"          /* shift */
          \"addc %d1,%d1,%d0\;\"
          \"bra nov,.L1_%=\;\"        /* but if the sign changes ... */
          \"mov #0x7FFF,%d0\;\"       /* Saturate to ~.99 */
          \"setm %0\";                /*   bits into low word */
  "
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "usashl<mode>3_imm1"
  [(set (match_operand:QUQ31   0 "pic30_register_operand" "=&r")
        (us_ashift:QUQ31
          (match_operand:QUQ31 1 "pic30_register_operand"   "r")
          (match_operand:HI    2 "pic30_I_operand"          "I")))]
  "pic30_fp_inline_p()"
  "*
   return \"add %1,%1,%0\;\"          /* shift */
          \"addc %d1,%d1,%d0\;\"
          \"bra nov,.L1_%=\;\"        /* but if the sign changes ... */
          \"mov #0x7FFF,%d0\;\"       /* Saturate to ~.99 */
          \"setm %0\;\"               /*   bits into low word */
          \".L1_%=:\";
          
  "
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ashl<mode>3_imm8"
  [(set (match_operand:QUQ31   0 "pic30_register_operand" "=&r")
        (ashift:QUQ31 
          (match_operand:QUQ31 1 "pic30_register_operand"   "r")
          (match_operand:HI    2 "pic30_imm8_operand"       "i")))
   (clobber (match_dup 1))
  ]
  ""
  "*
  {
    int idDst = REGNO(operands[0]);
    int idSrc = REGNO(operands[1]);
    if (idDst == idSrc) {
      return \"sl %d1,#%2,%d0\;\"
             \"swap %1\;\"
             \"mov.b %0,%d0\;\"
             \"clr.b %0\";
    } else {
      return \"sl %d1,#%2,%0\;\"
             \"lsr %1,#%k2,%d0\;\"
             \"ior %0,%d0,%d0\;\"
             \"sl %1,#%2,%0\";
    }
  }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ssashl<mode>3_imm8"
  [(set (match_operand:Q31   0 "pic30_register_operand" "=&r")
        (ss_ashift:Q31
          (match_operand:Q31 1 "pic30_register_operand"   "r")
          (match_operand:HI  2 "pic30_imm8_operand"       "i")))
   (clobber (match_dup 1))
  ]
  ""
  "*
  {
    int idDst = REGNO(operands[0]);
    int idSrc = REGNO(operands[1]);
    if (idDst == idSrc) {
      return 
             \"asr %d1,#(16-9),%0\;\"    /* test the bits that drop off */
             \"asr %d1,#15,%d0\;\"       /* or move into sign */
             \"xor %d0,%0,%0\;\"         /* match the original sign */
             \"bra z,.L1_%=\;\"          /* normal shift if zero */
             \"mov #0x7FFF,%d0\;\"       /* assume ~.99 if ... */
             \"btsc %d1,#15\;\"
             \"com %d0,%d0\;\"
             \"sl  %d0,%0\;\"
             \"asr %0,#15,%0\;\"
             \"bra .L2_%=\n\"
	     \".L1_%=:\;\"               /* safe to shift ... */
	     \"sl %d1,#%2,%d0\;\"
             \"swap %1\;\"
             \"mov.b %0,%d0\;\"
             \"clr.b %0\n\"
             \".L2_%=:\;\";
    } else {
      return 
             \"asr %d1,#(16-9),%0\;\"    /* test the bits that drop off */
             \"asr %d1,#15,%d0\;\"       /* or move into sign */
             \"xor %d0,%0,%0\;\"         /* match the original sign */
             \"bra z,.L1_%=\;\"          /* normal shift if zero */
             \"mov #0x7FFF,%d0\;\"       /* assume ~.99 if ... */
             \"btsc %d1,#15\;\"
             \"com %d0,%d0\;\"
             \"sl  %d0,%0\;\"
             \"asr %0,#15,%0\;\"
             \"bra .L2_%=\n\"
             \".L1_%=:\;\"               /* safe to shift ... */
             \"sl %d1,#%2,%0\;\"
             \"lsr %1,#%k2,%d0\;\"
             \"ior %0,%d0,%d0\;\"
             \"sl %1,#%2,%0\n\"
             \".L2_%=:\;\";
    }
  }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ssashl<mode>3_imm8"
  [(set (match_operand:UQ31   0 "pic30_register_operand" "=&r")
        (ss_ashift:UQ31
          (match_operand:UQ31 1 "pic30_register_operand"   "r")
          (match_operand:HI   2 "pic30_imm8_operand"       "i")))
   (clobber (match_dup 1))
  ]
  ""
  "*
  {
    int idDst = REGNO(operands[0]);
    int idSrc = REGNO(operands[1]);
    if (idDst == idSrc) {
      return
             \"mov #0xFF10, %0\;\"       /* test the bits that drop off */
             \"and %d1,%0,%0\;\"         /* or move into sign for zero */
             \"bra z,.L1_%=\;\"          /* normal shift if zero */
             \"mov #0x7FFF,%d0\;\"       /* return ~.99  */
             \"setm %0\;\"
             \"bra .L2_%=\n\"
             \".L1_%=:\;\"               /* safe to shift ... */
             \"sl %d1,#%2,%d0\;\"        
             \"swap %1\;\"
             \"mov.b %0,%d0\;\"
             \"clr.b %0\n\"
             \".L2_%=:\;\";
    } else { 
      return 
             \"mov #0xFF10, %0\;\"       /* test the bits that drop off */
             \"and %d1,%0,%0\;\"         /* or move into sign for zero */
             \"bra z,.L1_%=\;\"          /* normal shift if zero */
             \"mov #0x7FFF,%d0\;\"       /* return ~.99 ... */
             \"setm %d0\;\"
             \"bra .L2_%=\n\"
             \".L1_%=:\;\"               /* safe to shift ... */
             \"sl %d1,#%2,%0\;\"
             \"lsr %1,#%k2,%d0\;\"
             \"ior %0,%d0,%d0\;\"
             \"sl %1,#%2,%0\n\"
             \".L2_%=:\;\";
    }
  }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "usashl<mode>3_imm8"
  [(set (match_operand:QUQ31   0 "pic30_register_operand" "=&r")
        (us_ashift:QUQ31
          (match_operand:QUQ31 1 "pic30_register_operand"   "r")
          (match_operand:HI    2 "pic30_imm8_operand"       "i")))
   (clobber (match_dup 1))
  ]       
  ""
  "*
  {
    int idDst = REGNO(operands[0]);
    int idSrc = REGNO(operands[1]);
    if (idDst == idSrc) {
      return
             \"mov #0xFF10, %0\;\"       /* test the bits that drop off */
             \"and %d1,%0,%0\;\"         /* or move into sign for zero */
             \"bra z,.L1_%=\;\"          /* normal shift if zero */
             \"mov #0x7FFF,%d0\;\"       /* return ~.99  */
             \"setm %0\;\"
             \"bra .L2_%=\n\"
             \".L1_%=:\;\"               /* safe to shift ... */
             \"sl %d1,#%2,%d0\;\"
             \"swap %1\;\"
             \"mov.b %0,%d0\;\"
             \"clr.b %0\n\"
             \".L2_%=:\;\";
    } else {
      return  
             \"mov #0xFF10, %0\;\"       /* test the bits that drop off */
             \"and %d1,%0,%0\;\"         /* or move into sign for zero */
             \"bra z,.L1_%=\;\"          /* normal shift if zero */
             \"mov #0x7FFF,%d0\;\"       /* return ~.99 ... */
             \"setm %d0\;\"
             \"bra .L2_%=\n\"
             \".L1_%=:\;\"               /* safe to shift ... */
             \"sl %d1,#%2,%0\;\"
             \"lsr %1,#%k2,%d0\;\"
             \"ior %0,%d0,%d0\;\"
             \"sl %1,#%2,%0\n\"
             \".L2_%=:\;\";
    }
  }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ashl<mode>3_imm16plus"
  [(set (match_operand:QUQ31   0 "pic30_register_operand"  "=r")
        (ashift:QUQ31 
          (match_operand:QUQ31 1 "pic30_register_operand"   "r")
          (match_operand:HI    2 "pic30_imm16plus_operand"  "i")))]
  ""
  "sl %1,#%K2,%d0\;mov #0,%0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ssashl<mode>3_imm16plus"
  [(set (match_operand:Q31   0 "pic30_register_operand"  "=&r")
        (ss_ashift:Q31
          (match_operand:Q31 1 "pic30_register_operand"    "r")
          (match_operand:HI  2 "pic30_imm16plus_operand"   "i")))]
  ""
  "*
   return 
          \"asr %d1,#15,%d0\;\"       /* for signed we care about 1s */
          \"asr %1,#(16-%K2),%0\;\"   /* for unsigned we care about 0s */
          \"xor %0,%d0,[w15]\;\"      /* shifting bits out? */
          \"btsc _SR,#1\;\"           /*  yes? don't compare the high word */
          \"cp %d0,%d1\;\"
          \"bra z,.L1_%=\;\"          /* if not losing bits, shift as normal */
          \"mov #0x7FFF,%d0\;\"       /* assume ~.9999 */
          \"btsc %d1,#15\;\"          /* if negatvie */
          \"com %d0,%d0\;\"           /* make -1 */
          \"sl %d0,%0\;\"             /* propagate non sign bits */
          \"asr %0,#15,%0\;\"
          \"bra .L2_%=\n\"
          \".L1_%=:\;\"               /* shift as normal */
          \"sl %1,#%K2,%d0\;\" 
          \"mov #0,%0\n\"
          \".L2_%=:\;\";
  "
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ssashl<mode>3_imm16plus"
  [(set (match_operand:UQ31   0 "pic30_register_operand"  "=&r")
        (ss_ashift:UQ31
          (match_operand:UQ31 1 "pic30_register_operand"    "r")
          (match_operand:HI   2 "pic30_imm16plus_operand"   "i")))]
  ""
  "*
   return
          \"asr %1,#(16-%K2),%0\;\"   /* for unsigned we care about 0s */
          \"btsc _SR,#1\;\"           /*  yes? don't compare the high word */
          \"cp0 %d1\;\"
          \"bra z,.L1_%=\;\"          /* if not losing bits, shift as normal */
          \"mov #0x7FFF,%d0\;\"       /* make ~.9999 */
          \"setm %d0\;\"
          \"bra .L2_%=\n\"
          \".L1_%=:\;\"               /* shift as normal */
          \"sl %1,#%K2,%d0\;\" 
          \"mov #0,%0\n\"
          \".L2_%=:\;\";
  " 
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "usashl<mode>3_imm16plus"
  [(set (match_operand:QUQ31   0 "pic30_register_operand"  "=&r")
        (us_ashift:QUQ31
          (match_operand:QUQ31 1 "pic30_register_operand"    "r")
          (match_operand:HI    2 "pic30_imm16plus_operand"   "i")))]
  ""
  "*
   return
          \"asr %1,#(16-%K2),%0\;\"   /* for unsigned we care about 0s */
          \"btsc _SR,#1\;\"           /*  yes? don't compare the high word */
          \"cp0 %d1\;\"
          \"bra z,.L1_%=\;\"          /* if not losing bits, shift as normal */
          \"mov #0x7FFF,%d0\;\"       /* make ~.9999 */
          \"setm %d0\;\"
          \"bra .L2_%=\n\"
          \".L1_%=:\;\"               /* shift as normal */
          \"sl %1,#%K2,%d0\;\"
          \"mov #0,%0\n\"
          \".L2_%=:\;\";
  "
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ashl<mode>3_imm2to15"
  [(set (match_operand:QUQ31   0 "pic30_register_operand" "=r,&r")
        (ashift:QUQ31 
          (match_operand:QUQ31 1 "pic30_register_operand"  "r, r")
          (match_operand:HI    2 "pic30_imm2to15_operand"  "i, i")))
   (clobber (match_scratch:HI 3                          "=&r, X"))]
  ""
  "*
  { int idDst, idSrc;

    switch (which_alternative) {
      case 0:
        /*
        ** Take care that the source and dest don't overlap
        */
        idDst = REGNO(operands[0]);
        idSrc = REGNO(operands[1]);
        if (idDst >= idSrc) {
          return \"sl %d1,#%2,%3\;\"
                 \"lsr %1,#%k2,%d0\;\"
                 \"ior %3,%d0,%d0\;\"
                 \"sl %1,#%2,%0\";
        } else {
          return \"sl %1,#%2,%0\;\"
                 \"sl %d1,#%2,%3\;\"
                 \"lsr %1,#%k2,%d0\;\"
                 \"ior %3,%d0,%d0\";
        }
      case 2:
        /*
        ** The dest and source don't overlap
        ** so use dest lsw as a temporary
        */
        return \"sl %d1,#%2,%0\;\"
               \"lsr %1,#%k2,%d0\;\"
               \"ior %0,%d0,%d0\;\"
               \"sl %1,#%2,%0\";
      default: gcc_assert(0);
    }
    return \"nop\";
  }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ssashl<mode>3_imm2to15"
  [(set (match_operand:Q31    0 "pic30_register_operand" "=r,&r")
        (ss_ashift:Q31 
          (match_operand:Q31  1 "pic30_register_operand"  "r, r")
          (match_operand:HI   2 "pic30_imm2to15_operand"  "i, i")))
   (clobber (match_scratch:HI 3                         "=&r, X"))]
  ""
  "*
  { int idDst, idSrc;

    switch (which_alternative) {
      case 0:
        /* 
        ** Take care that the source and dest don't overlap
        */
        idDst = REGNO(operands[0]);
        idSrc = REGNO(operands[1]);
        if (idDst >= idSrc) {
          return 
                 \"asr %d1,#15,%d0\;\"       /* for signed we care about 1s */
                 \"asr %d1,#(15-%2),%0\;\"   /* for unsigned we care about 0s */
                 \"xor %0,%d0,%d0\;\"        /* shifting bits out? */
                 \"bra z,.L1_%=\;\"          /* if not, shift as normal */
                 \"mov #0x7FFF,%d0\;\"       /* assume ~.9999 */
                 \"btsc %d1,#15\;\"          /* if negatvie */
                 \"com %d0,%d0\;\"           /* make -1 */
                 \"sl %d0,%0\;\"             /* propagate non sign bits */
                 \"asr %0,#15,%0\;\"
                 \"bra .L2_%=\n\"
                 \".L1_%=:\;\"               /* shift as normal */
                 \"sl %d1,#%2,%3\;\"
                 \"lsr %1,#%k2,%d0\;\"
                 \"ior %3,%d0,%d0\;\"
                 \"sl %1,#%2,%0\n\"
                 \".L2_%=:\;\";
        } else {
          return
                 \"asr %d1,#15,%d0\;\"       /* for signed we care about 1s */
                 \"asr %d1,#(15-%2),%0\;\"   /* for unsigned we care about 0s */
                 \"xor %0,%d0,%d0\;\"        /* shifting bits out? */
                 \"bra z,.L1_%=\;\"          /* if not, shift as normal */
                 \"mov #0x7FFF,%d0\;\"       /* assume ~.9999 */
                 \"btsc %d1,#15\;\"          /* if negatvie */
                 \"com %d0,%d0\;\"           /* make -1 */
                 \"sl %d0,%0\;\"             /* propagate non sign bits */
                 \"asr %0,#15,%0\;\"
                 \"bra .L2_%=\n\"
                 \".L1_%=:\;\"               /* shift as normal */
                 \"sl %1,#%2,%0\;\"
                 \"sl %d1,#%2,%3\;\"
                 \"lsr %1,#%k2,%d0\;\"
                 \"ior %3,%d0,%d0\n\"
                 \".L2_%=:\;\";
        }
      case 2:
        /*
        ** The dest and source don't overlap
        ** so use dest lsw as a temporary
        */
        return
               \"asr %d1,#15,%d0\;\"         /* for signed we care about 1s */
               \"asr %d1,#(15-%2),%0\;\"     /* for unsigned we care about 0s */
               \"xor %0,%d0,%d0\;\"          /* shifting bits out? */
               \"bra z,.L1_%=\;\"            /* if not, shift as normal */
               \"mov #0x7FFF,%d0\;\"         /* assume ~.9999 */
               \"btsc %d1,#15\;\"            /* if negatvie */
               \"com %d0,%d0\;\"             /* make -1 */
               \"sl %d0,%0\;\"               /* propagate non sign bits */
               \"asr %0,#15,%0\;\"
               \"bra .L2_%=\n\"
               \".L1_%=:\;\"                 /* shift as normal */
               \"sl %d1,#%2,%0\;\"
               \"lsr %1,#%k2,%d0\;\"
               \"ior %0,%d0,%d0\;\"
               \"sl %1,#%2,%0\n\"
               \".L2_%=:\;\";

      default: gcc_assert(0);
    }
    return \"nop\";
  }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ssashl<mode>3_imm2to15"
  [(set (match_operand:UQ31   0 "pic30_register_operand" "=r,&r")
        (ss_ashift:UQ31
          (match_operand:UQ31 1 "pic30_register_operand"  "r, r")
          (match_operand:HI   2 "pic30_imm2to15_operand"  "i, i")))
   (clobber (match_scratch:HI 3                         "=&r, X"))]
  ""
  "*
  { int idDst, idSrc;

    switch (which_alternative) {
      case 0:
        /*
        ** Take care that the source and dest don't overlap
        */
        idDst = REGNO(operands[0]);
        idSrc = REGNO(operands[1]);
        if (idDst >= idSrc) {
          return
                 \"asr %d1,#(15-%2),%0\;\"   /* for unsigned we care about 0s */
                 \"bra z,.L1_%=\;\"          /* if not, shift as normal */
                 \"mov #0x7FFF,%d0\;\"       /* return ~.9999 */
                 \"setm %0\;\"
                 \"bra .L2_%=\n\"
                 \".L1_%=:\;\"               /* shift as normal */
                 \"sl %d1,#%2,%3\;\"
                 \"lsr %1,#%k2,%d0\;\"
                 \"ior %3,%d0,%d0\;\"
                 \"sl %1,#%2,%0\n\"
                 \".L2_%=:\;\";
        } else {
          return
                 \"asr %d1,#(15-%2),%0\;\"   /* for unsigned we care about 0s */
                 \"bra z,.L1_%=\;\"          /* if not, shift as normal */
                 \"mov #0x7FFF,%d0\;\"       /* return ~.9999 */
                 \"setm %0\;\"
                 \"bra .L2_%=\n\"
                 \".L1_%=:\;\"               /* shift as normal */
                 \"sl %1,#%2,%0\;\"
                 \"sl %d1,#%2,%3\;\"
                 \"lsr %1,#%k2,%d0\;\"
                 \"ior %3,%d0,%d0\n\"
                 \".L2_%=:\;\";
        }
      case 2:
        /*
        ** The dest and source don't overlap
        ** so use dest lsw as a temporary
        */
        return 
               \"asr %d1,#(15-%2),%0\;\"     /* for unsigned we care about 0s */
               \"bra z,.L1_%=\;\"            /* if not, shift as normal */
               \"mov #0x7FFF,%d0\;\"         /* return ~.9999 */
               \"setm %0\;\"
               \"bra .L2_%=\n\"
               \".L1_%=:\;\"                 /* shift as normal */
               \"sl %d1,#%2,%0\;\"
               \"lsr %1,#%k2,%d0\;\"
               \"ior %0,%d0,%d0\;\"
               \"sl %1,#%2,%0\n\"
               \".L2_%=:\;\";
      default: gcc_assert(0);
    }
    return \"nop\";
  }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "usashl<mode>3_imm2to15"
  [(set (match_operand:QUQ31   0 "pic30_register_operand" "=r,&r")
        (us_ashift:QUQ31
          (match_operand:QUQ31 1 "pic30_register_operand"  "r, r")
          (match_operand:HI    2 "pic30_imm2to15_operand"  "i, i")))
   (clobber (match_scratch:HI  3                         "=&r, X"))]
  ""
  "*
  { int idDst, idSrc;

    switch (which_alternative) {
      case 0:
        /*
        ** Take care that the source and dest don't overlap
        */
        idDst = REGNO(operands[0]);
        idSrc = REGNO(operands[1]);
        if (idDst >= idSrc) {
          return
                 \"asr %d1,#(15-%2),%0\;\"   /* for unsigned we care about 0s */
                 \"bra z,.L1_%=\;\"          /* if not, shift as normal */
                 \"mov #0x7FFF,%d0\;\"       /* return ~.9999 */
                 \"setm %0\;\"
                 \"bra .L2_%=\n\"
                 \".L1_%=:\;\"               /* shift as normal */
                 \"sl %d1,#%2,%3\;\"
                 \"lsr %1,#%k2,%d0\;\"
                 \"ior %3,%d0,%d0\;\"
                 \"sl %1,#%2,%0\n\"
                 \".L2_%=:\;\";
        } else {
          return
                 \"asr %d1,#(15-%2),%0\;\"   /* for unsigned we care about 0s */
                 \"bra z,.L1_%=\;\"          /* if not, shift as normal */
                 \"mov #0x7FFF,%d0\;\"       /* return ~.9999 */
                 \"setm %0\;\"
                 \"bra .L2_%=\n\"
                 \".L1_%=:\;\"               /* shift as normal */
                 \"sl %1,#%2,%0\;\"
                 \"sl %d1,#%2,%3\;\"
                 \"lsr %1,#%k2,%d0\;\"
                 \"ior %3,%d0,%d0\n\"
                 \".L2_%=:\;\";
        }
      case 2:
        /*
        ** The dest and source don't overlap
        ** so use dest lsw as a temporary
        */
        return
               \"asr %d1,#(15-%2),%0\;\"     /* for unsigned we care about 0s */
               \"bra z,.L1_%=\;\"            /* if not, shift as normal */
               \"mov #0x7FFF,%d0\;\"         /* return ~.9999 */
               \"setm %0\;\"
               \"bra .L2_%=\n\"
               \".L1_%=:\;\"                 /* shift as normal */
               \"sl %d1,#%2,%0\;\"
               \"lsr %1,#%k2,%d0\;\"
               \"ior %0,%d0,%d0\;\"
               \"sl %1,#%2,%0\n\"
               \".L2_%=:\;\";
      gcc_assert(0);
    }
    return \"nop\";
  }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ashl<mode>3_reg"
  [(set (match_operand:QUQ31   0 "pic30_register_operand" "=r")
        (ashift:QUQ31 
          (match_operand:QUQ31 1 "pic30_register_operand" " 0")
          (match_operand:HI    2 "pic30_register_operand" " r")))
   (clobber (match_scratch:HI  3                          "=2"))
  ]
  ""
  "*
  {
    return
           \".set ___BP___,0\n\"
           \".LB%=:\;\"
           \"dec %2,%2\;\"
           \"bra n,.LE%=\;\"
           \"add %1,%1,%0\;\"
           \"addc %d1,%d1,%d0\;\"
           \"bra .LB%=\n\"
           \".LE%=:\";
  }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ssashl<mode>3_reg"
  [(set (match_operand:Q31    0 "pic30_register_operand" "=&r")
        (ss_ashift:Q31
          (match_operand:Q31  1 "pic30_register_operand" " r")
          (match_operand:HI   2 "pic30_register_operand" " r")))
   (clobber (match_scratch:HI 3                          "=2"))
  ]
  ""
  "*
  {
    return
           \".set ___BP___,0\n\"
           \"mov.d %1,%0\;\"
           \".LB%=:\;\"
           \"dec %2,%2\;\"
           \"bra n,.LE%=\;\"
           \"add %0,%0,%0\;\"
           \"addc %d0,%d0,%d0\;\"
           \"bra nov,.LB%=\;\"        /* if we drop a bit into the sign */
           \"mov #0x7FFF,%d0\;\"      /* assume ~.9999 */
           \"btsc %d1,#15\;\"
           \"com %d0,%d0\;\"
           \"sl %d0,%0\;\"
           \"asr %0,#15,%0\n\"
           \".LE%=:\";
  }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ssashl<mode>3_reg"
  [(set (match_operand:UQ31   0 "pic30_register_operand" "=r")
        (ss_ashift:UQ31
          (match_operand:UQ31 1 "pic30_register_operand" " 0")
          (match_operand:HI   2 "pic30_register_operand" " r")))
   (clobber (match_scratch:HI 3                          "=2"))
  ]
  ""
  "*
  {
    return
           \".set ___BP___,0\n\"
           \".LB%=:\;\"
           \"dec %2,%2\;\"
           \"bra n,.LE%=\;\"
           \"add %1,%1,%0\;\"
           \"addc %d1,%d1,%d0\;\"
           \"bra nov,.LB%=\;\"        /* if we drop a bit into the sign */
           \"mov #0x7FFF,%d0\;\"      /* return ~.9999 */
           \"setm %0\;\"
           \".LE%=:\";
  }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "usashl<mode>3_reg"
  [(set (match_operand:QUQ31   0 "pic30_register_operand" "=r")
        (us_ashift:QUQ31
          (match_operand:QUQ31 1 "pic30_register_operand" " 0")
          (match_operand:HI    2 "pic30_register_operand" " r")))
   (clobber (match_scratch:HI  3                          "=2"))
  ]
  ""
  "*
  {
    return
           \".set ___BP___,0\n\"
           \".LB%=:\;\"
           \"dec %2,%2\;\"
           \"bra n,.LE%=\;\"
           \"add %1,%1,%0\;\"
           \"addc %d1,%d1,%d0\;\"
           \"bra nov,.LB%=\;\"        /* if we drop a bit into the sign */
           \"mov #0x7FFF,%d0\;\"      /* return ~.9999 */
           \"setm %0\;\"
           \".LE%=:\";
  }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_expand "ashl<mode>3"
  [(set (match_operand:QUQ31   0 "pic30_register_operand" "")
        (ashift:QUQ31 
          (match_operand:QUQ31 1 "pic30_register_operand" "")
          (match_operand:HI    2 "pic30_reg_or_imm_operand" "")))]
  ""
  "
  {
    if (GET_CODE(operands[2]) == CONST_INT) {
      switch (INTVAL(operands[2])) {
        case 0:
          emit_insn(
            gen_mov<mode>(operands[0], operands[1])
          );
          break;
        case 1:
          emit_insn(
            gen_ashl<mode>3_imm1(operands[0], operands[1], operands[2])
          );
          break;
        case 8:
          emit_insn(
            gen_ashl<mode>3_imm8(operands[0], operands[1], operands[2])
          );
          break;
        case 2 ... 7:
        case 9 ... 15:
          emit_insn(
            gen_ashl<mode>3_imm2to15(operands[0], operands[1], operands[2])
          );
          break;
        case 16:
          emit_insn(
            gen_ashl<mode>3_imm16plus(operands[0], operands[1], operands[2])
          );
          break;
        case 17 ... 31:
          emit_insn(
            gen_ashl<mode>3_imm16plus(operands[0], operands[1], operands[2])
          );
          break;
        default:
          emit_insn(
            gen_mov<mode>(operands[0], const0_rtx)
          ); 
          break;
      }
    } else {
      emit_insn(
        gen_ashl<mode>3_reg(operands[0],operands[1],operands[2])
      );
    }
    DONE;
}")

(define_expand "ssashl<mode>3"
  [(set (match_operand:QUQ31   0 "pic30_register_operand" "")
        (ss_ashift:QUQ31 
          (match_operand:QUQ31 1 "pic30_register_operand" "")
          (match_operand:HI    2 "pic30_reg_or_imm_operand" "")))]
  ""
  "
  {
    if (!pic30_fp_inline_p()) FAIL;
    if (GET_CODE(operands[2]) == CONST_INT) {
      switch (INTVAL(operands[2])) {
        case 0:
          emit_insn(
            gen_mov<mode>(operands[0], operands[1])
          );
          break;
        case 1:
          emit_insn(
            gen_ssashl<mode>3_imm1(operands[0], operands[1], operands[2])
          );
          break;
        case 8:
          emit_insn(
            gen_ssashl<mode>3_imm8(operands[0], operands[1], operands[2])
          );
          break;
        case 2 ... 7:
        case 9 ... 15:
          emit_insn(
            gen_ssashl<mode>3_imm2to15(operands[0], operands[1], operands[2])
          );
          break;
        case 16:
          emit_insn(
            gen_ssashl<mode>3_imm16plus(operands[0], operands[1], operands[2])
          );
          break;
        case 17 ... 31:
          emit_insn(
            gen_ssashl<mode>3_imm16plus(operands[0], operands[1], operands[2])
          );
          break;
        default:
          emit_insn(
            gen_mov<mode>(operands[0], const0_rtx)
          ); 
          break;
      }
    } else {
      emit_insn(
        gen_ssashl<mode>3_reg(operands[0],operands[1],operands[2])
      );
    }
    DONE;
}")

(define_expand "usashl<mode>3"
  [(set (match_operand:QUQ31   0 "pic30_register_operand" "")
        (us_ashift:QUQ31 
          (match_operand:QUQ31 1 "pic30_register_operand" "")
          (match_operand:HI    2 "pic30_reg_or_imm_operand" "")))]
  ""
  "
  {
    if (!pic30_fp_inline_p()) FAIL;
    if (GET_CODE(operands[2]) == CONST_INT) {
      switch (INTVAL(operands[2])) {
        case 0:
          emit_insn(
            gen_mov<mode>(operands[0], operands[1])
          );
          break;
        case 1:
          emit_insn(
            gen_usashl<mode>3_imm1(operands[0], operands[1], operands[2])
          );
          break;
        case 8:
          emit_insn(
            gen_usashl<mode>3_imm8(operands[0], operands[1], operands[2])
          );
          break;
        case 2 ... 7:
        case 9 ... 15:
          emit_insn(
            gen_usashl<mode>3_imm2to15(operands[0], operands[1], operands[2])
          );
          break;
        case 16:
          emit_insn(
            gen_usashl<mode>3_imm16plus(operands[0], operands[1], operands[2])
          );
          break;
        case 17 ... 31:
          emit_insn(
            gen_usashl<mode>3_imm16plus(operands[0], operands[1], operands[2])
          );
          break;
        default:
          emit_insn(
            gen_mov<mode>(operands[0], const0_rtx)
          ); 
          break;
      }
    } else {
      emit_insn(
        gen_usashl<mode>3_reg(operands[0],operands[1],operands[2])
      );
    }
    DONE;
}")

(define_insn "ashr<mode>3_helper"
  [(set (match_operand:QUQ15   0 "pic30_register_operand"  "=&r,&r,&r")
        (ashiftrt:QUQ15 
          (match_operand:QUQ15 1 "pic30_register_operand"   "r,r,r")
          (match_operand:HI    2 "pic30_reg_or_imm_operand" "K,i,r")))]
  ""
  "*
  {
    if ((pic30_fp_round_p() == pic30_truncation) ||
        (pic30_fp_round_p() == pic30_fastest)) {
      switch (which_alternative) {
        case 0: 
          return \"asr %1,#%2,%0\";
        case 1:
          if (INTVAL(operands[2]) < 0)
            return \"sl %1,#%J2%%16,%0\";
          else
            return \"asr %1,#%2%%16,%0\";
        case 2: 
            return \"asr %1,%2,%0\";
        default: gcc_assert(0);
      }
    } else if (pic30_fp_round_p() == pic30_conventional) 
    switch (which_alternative) {
      case 0:  
        if (INTVAL(operands[2]) == 1) {
          return 
                 \"asr %1,%0\;\"
                 \"addc %0,#0,%0\";
        } else {
          return \"asr %1,#%L2,%0\;\"      /* shift one less than we need */
                 \"asr %0,%0\;\"           /*   so that we can shift once */
                 \"addc %0,#0,%0\";        /*   to capture and add carry */
        }
      case 1:
        if (INTVAL(operands[2]) < 0)
          return \"cannot generate instruction\"; 
        else
          return \"asr %1,#(%2%%16)-1,%0\;\" /* shift one less than we need */
                 \"asr %0,%0\;\"             /*   so that we can shift once */
                 \"addc %0,#0,%0\";          /*   to capture and add carry */
      case 2: 
	  return \"cp0 %2\;\"
                 \"mov %1,%0\;\"
                 \"bra z,.LE%=\;\"
                 \"dec %2,%0\;\"             /* shift one less than we need */
                 \"asr %1,%0,%0\;\"
                 \"asr %0,%0\;\"             /*   so that we can shift once */
                 \"addc %0,#0,%0\n\"         /*   to capture and add carry */
                 \".LE%=:\";
      default: gcc_assert(0);
    }
    else 
      error(\"Invalid fixed-point rounding mode specified\");
    return \"cannot generate instruction\";
  }"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
  ]
)

(define_insn "ashr<mode>3_convergent"
  [(set (match_operand:QUQ15   0 "pic30_register_operand"  "=r,r,r")
        (ashiftrt:QUQ15
          (match_operand:QUQ15 1 "pic30_register_operand"   "r,r,r")
          (match_operand:HI    2 "pic30_reg_or_imm_operand" "K,i,r")))
   (clobber (match_scratch:HI  3                          "=&r,&r,&r"))
  ]
  ""
  "*
  {
    if (pic30_fp_round_p() == pic30_convergent)
    switch (which_alternative) {
      case 0:  
        if (INTVAL(operands[2]) == 1) {
          return 
                 \"asr %1,%0\;\"
                 \"btsc %0,#0\;\"          /* do not add carry if low bit == 0*/
                 \"addc %0,#0,%0\";
        } else {
          return 
                 \"sl %1,%K2,%3\;\"        /* shift up bits that drop off */
                 \"asr %1,#%2,%0\;\"       /* shift down the bits we need */
                 \"sl %3,%3\;\"            /* shift top overfaow into carry */
                 \"bra nc,.L1_%=\;\"       /* if no carry, finish */
                 \"addc %0,#0,%0\;\"       /* add overflow from carry */
                 \"cp0 %3\;\"              /* test rest of the overflow */
                 \"mov #0xFFFE,%3\;\"      /* create mask off low bit */
                 \"btsc _SR,#1\;\"         /* if the rest of overflow is 0 */
                 \"and %0,%3,%0\n\"        /*   mask off low bit */
                 \".L1_%=:\";
        }
      case 1:
        if (INTVAL(operands[2]) < 0)
          return \"cannot generate instruction\"; 
        else
          return \"sl %1,#16-(%2%%16),%3\;\" /* shift up bits that drop off */
                 \"asr %1,#(%2%%16),%0\;\"   /* shift down bits we need */
                 \"sl %3,%3\;\"              /* shift top overflow into carry */
                 \"bra nc,.L1_%=\;\"         /* if no carry, finish */
                 \"addc %0,#0,%0\;\"         /* add carry */
                 \"cp0 %3\;\"                /* test rest of the overflow */
                 \"mov #0xFFFE,%3\;\"        /* create mask clear low bit */
                 \"btsc _SR,#1\;\"           /* if the rest of overflow is 0 */
                 \"and %0,%3,%0\n\"          /*   mask off low bit */
                 \".L1_%=:\";
      case 2: 
          return \"subr %2,#16,%3\;\"
                 \"sl %1,%3,%3\;\"           /* shift up bits that drop off */
                 \"asr %1,%2,%0\;\"          /* shift down bits we need */
                 \"sl %3,%3\;\"              /* shift top overflow into carry */
                 \"bra nc,.L1_%=\;\"         /* if no carry, finish */
                 \"addc %0,#0,%0\;\"         /* add carry */
                 \"cp0 %3\;\"                /* test rest of the overflow */
                 \"mov #0xFFFE,%3\;\"        /* create mask clear low bit */
                 \"btsc _SR,#1\;\"           /* if the rest of overflow is 0 */
                 \"and %0,%3,%0\n\"          /*   mask off low bit */
                 \".L1_%=:\";
      default:  gcc_assert(0);
    } else
      error(\"Invalid fixed-point round mode specified\n\");
    return \"cannot generate instruction\";

  }"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
  ]
)

(define_expand "ashr<mode>3"
  [(set (match_operand:QUQ15   0 "pic30_register_operand"   "")
        (ashiftrt:QUQ15
          (match_operand:QUQ15 1 "pic30_register_operand"   "")
          (match_operand:HI    2 "pic30_reg_or_imm_operand" "")))]
  ""
  "
  { rtx r0,r1,r2;

    r0 = operands[0];
    r1 = operands[1];
    r2 = operands[2];
    if (!pic30_register_operand(r0,<MODE>mode)) {
      r0 = gen_reg_rtx(<MODE>mode);
    }
    if (!pic30_register_operand(r1,<MODE>mode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (!pic30_reg_or_imm_operand(r2,<MODE>mode)) {
      r2 = force_reg(HImode, r2);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_ashr<mode>3_convergent(r0,r1,r2)
      );
    } else {
      emit(
        gen_ashr<mode>3_helper(r0,r1,r2)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }"
)

(define_expand "ashr<mode>3"
  [(set (match_operand:QUQ31   0 "pic30_register_operand"   "")
        (ashiftrt:QUQ31 
          (match_operand:QUQ31 1 "pic30_register_operand"   "")
          (match_operand:HI    2 "pic30_reg_or_imm_operand" "")))]
  ""
  "
  {
    if ((pic30_fp_round_p() == pic30_conventional) ||
        (pic30_fp_round_p() == pic30_convergent)) 
      FAIL;
    if (GET_CODE(operands[2]) == CONST_INT) {
      switch (INTVAL(operands[2])) {
        case 0:
          emit_insn(
            gen_mov<mode>(operands[0], operands[1])
          );
          break;
        case 1:
          emit_insn(
            gen_ashr<mode>3_imm1(operands[0], operands[1], operands[2])
          );
          break;
        case 2 ... 15:
          emit_insn(
            gen_ashr<mode>3_imm2to15(operands[0], operands[1], operands[2])
          );
          break;
        case 16:
          emit_insn(
            gen_ashr<mode>3_imm16plus(operands[0], operands[1], operands[2])
          );
          break;
        case 17 ... 31:
          if (pic30_fp_round_p() == pic30_convergent) {
            emit_insn(
              gen_ashr<mode>3_imm16plus_convergent(operands[0], operands[1], 
                                                   operands[2])
            );
          } else {
            emit_insn(
              gen_ashr<mode>3_imm16plus(operands[0], operands[1], operands[2])
            );
          }
          break;
        default:
          emit_insn(
            gen_mov<mode>(operands[0], const0_rtx)
          );
          break;
      }
    } else {
#if 0
      if (pic30_fp_round_p() == pic30_convergent) {
        emit_insn(
          gen_ashr<mode>3_reg_convergent(operands[0],operands[1],operands[2])
        );
      } else
#endif
      {
        emit_insn(
          gen_ashr<mode>3_reg(operands[0],operands[1],operands[2])
        );
      }
    }
    DONE;
  }"
)

(define_insn "ashr<mode>3_imm1"
  [(set (match_operand:QUQ31   0 "pic30_register_operand" "=r")
        (ashiftrt:QUQ31 
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")
          (match_operand:HI    2 "pic30_I_operand"         "I")))]
  ""
  "*
   if ((pic30_fp_round_p() == pic30_truncation) ||
       (pic30_fp_round_p() == pic30_fastest)) {
     return \"asr %d1,%d0\;rrc %1,%0\";
   } else if (pic30_fp_round_p() == pic30_conventional) {
     return 
            \"asr %d1,%d0\;\"       /* shift right ... */
            \"rrc %1,%0\;\"
            \"addc %0,#0,%0\;\"     /* add in drop overflow bit */
            \"addc %d0,#0,%d0\;\";
   } else if (pic30_fp_round_p() == pic30_convergent) {
     return 
            \"asr %d1,%d0\;\"       /* shift right ... */
            \"rrc %1,%0\;\"
            \"btsc %0,#0\;\"        /* if bit 0 is 0 */
            \"bclr _SR,#0\;\"       /*   clear overflow bit */
            \"addc %0,#0,%0\;\"     /* add in drop overflow bit */
            \"addc %d0,#0,%d0\;\";
   }
   error(\"Invalid fixed-point round mode specified\n\");
   return \"cannot generate instruction\";
  "
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ashr<mode>3_imm2to15"
  [(set (match_operand:QUQ31   0 "pic30_register_operand" "=r")
        (ashiftrt:QUQ31 
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")
          (match_operand:HI    2 "pic30_imm2to15_operand"  "i")))
   (clobber (match_scratch:HI  3                         "=&r"))]
  ""
  "*
  {
    if ((pic30_fp_round_p() == pic30_truncation) ||
        (pic30_fp_round_p() == pic30_fastest)) {
      /*
      ** Take care that the source and dest don't overlap
      */
      if (REGNO(operands[0]) <= REGNO(operands[1])) {
        return \"sl %d1,#%k2,%3\;\"
               \"lsr %1,#%2,%0\;\"
               \"ior %3,%0,%0\;\"
               \"asr %d1,#%2,%d0\";
      } else {
        return \"asr %d1,#%2,%d0\;\"
               \"sl %d1,#%k2,%3\;\"
               \"lsr %1,#%2,%0\;\"
               \"ior %3,%0,%0\";
      }
    } else if (pic30_fp_round_p() == pic30_conventional) {
      if (REGNO(operands[0]) <= REGNO(operands[1])) {
        /* reorder a bit to preserve C for overflow */
        return \"sl %d1,#%k2,%3\;\"    /* shift up low bits of high word to t */
               \"asr %d1,#%2,%d0\;\"   /* shift down high bits of high word
                                          making the high part of result */
               \"lsr %1,#%L2,%0\;\"    /* shift down low bits of low word,
                                          1 less (clearing upper bits) */
               \"lsr %0,%0\;\"         /* final shift, capturing overflow in C*/
               \"ior %3,%0,%0\;\"      /* or in high bits of low word from t */
               \"addc %0,#0,%0\;\"     /* add in overflow */
               \"addc %d0,#0,%d0\;\";
      } else {
        return \"asr %d1,#%2,%d0\;\"   /* shift down high bits of high word
                                          making the high part of result */
               \"sl %d1,#%k2,%3\;\"    /* shift up low bits of high word to t */
               \"lsr %1,#%L2,%0\;\"    /* shift down low bits of low word,
                                          1 less (clearing upper bits) */
               \"lsr %0,%0\;\"         /* final shift, capturing overflow in C*/
               \"ior %3,%0,%0\;\"      /* or in high bits of low word from t */
               \"addc %0,#0,%0\;\"     /* add in overflow */
               \"addc %d0,#0,%d0\;\";
      }
    } else if (pic30_fp_round_p() == pic30_convergent) {
      if (REGNO(operands[0]) <= REGNO(operands[1])) {
        /* reorder a bit to preserve C for overflow */
        return \"sl %d1,#%k2,%3\;\"    /* shift up low bits of high word to t */
               \"asr %d1,#%2,%d0\;\"   /* shift down high bits of high word
                                          making the high part of result */
               \"sl  %1,#%K2,%0\;\"    /* shift up low bits (that drop) */
               \"sl  %0,%0\;\"         /* shift topmost into carry */
               \"btsc _SR,#1\;\"       /* if zero clear carry */
               \"bclr _SR,#0\;\"
               \"lsr %1,#%2,%0\;\"     /* shift down low bits of low word */
               \"ior %3,%0,%0\;\"      /* or in high bits of low word from t */
               \"addc %0,#0,%0\;\"     /* maybe add in overflow */
               \"addc %d0,#0,%d0\;\";
      } else {
        return \"asr %d1,#%2,%d0\;\"   /* shift down high bits of high word
                                          making the high part of result */
               \"sl %d1,#%k2,%3\;\"    /* shift up low bits of high word to t */
               \"sl  %0,%0\;\"         /* shift topmost into carry */
               \"btsc _SR,#1\;\"       /* if zero clear carry */
               \"bclr _SR,#0\;\"
               \"lsr %1,#%2,%0\;\"     /* shift down low bits of low word */
               \"ior %3,%0,%0\;\"      /* or in high bits of low word from t */
               \"addc %0,#0,%0\;\"     /* add in overflow */
               \"addc %d0,#0,%d0\;\";
      }
    } else
      error(\"Invalid fixed-point round mode specified\n\");
    return \"cannot generate instruction\";
  }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ashr<mode>3_imm16plus"
  [(set (match_operand:QUQ31   0 "pic30_register_operand" "=&r")
        (ashiftrt:QUQ31 
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")
          (match_operand:HI    2 "pic30_imm16plus_operand" "i")))]
  ""
  "*
   {
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       return \"asr %d1,#%K2,%0\;asr %0,#15,%d0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       if (INTVAL(operands[2]) == 16) {
         return 
                \"mov %d1,%0\;\"         /* copy high word to low result */
                \"asr %0,#15,%d0\;\"     /* shift down sign to high result */
                \"btst.c %1,#15\;\"      /* copy overflow bit to carry */
                \"addc %0,#0,%0\;\"      /* add in overflow bit */
                \"addc %d0,#0,%d0\";
       } else {
         return 
                \"asr %d1,#%K2,%0\;\"    /* copy high word to low result */
                \"asr %0,#15,%d0\;\"     /* shift down sign to high result */
                \"btst.c %d1,#(%K2)-1\;\"/* copy overflow bit to carry */
                \"addc %0,#0,%0\;\"      /* add in overflow bit */
                \"addc %d0,#0,%d0\";
       }
     } else
       error(\"Invalid fixed-point round mode specified\n\");
     return \"cannot generate instruction\";
   }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ashr<mode>3_imm16plus_convergent"
  [(set (match_operand:QUQ31   0 "pic30_register_operand" "=&r")
        (ashiftrt:QUQ31 
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")
          (match_operand:HI    2 "pic30_imm16plus_operand" "i")))
   (clobber (match_scratch:HI  3                          "=r"))
  ]
  ""
  "*
   {
     if (pic30_fp_round_p() == pic30_convergent) {
       if (INTVAL(operands[2]) == 16) {
         return 
                \"mov %d1,%0\;\"         /* copy high word to low result */
                \"asr %0,#15,%d0\;\"     /* shift down sign to high result */
                \"sl %1,%3\;\"           /* shift up dropped off bits */
                \"btsc _SR,#1\;\"        /* if zero clear carry */
                \"bclr _SR,#0\;\"
                \"addc %0,#0,%0\;\"      /* add in overflow bit */
                \"addc %d0,#0,%d0\";
       } else {
         return 
                \"asr %d1,#%K2,%0\;\"    /* copy high word to low result */
                \"asr %0,#15,%d0\;\"     /* shift down sign to high result */
                \"sl %d1,#%K2,%3\;\"     /* shift up dropped off bits */
                \"btsc _SR,#1\;\"        /* if zero clear carry */
                \"bclr _SR,#0\;\"
                \"addc %0,#0,%0\;\"      /* add in overflow bit */
                \"addc %d0,#0,%d0\";
       }
     } else
       error(\"Invalid fixed-point round mode specified\n\");
     return \"cannot generate instruction\";
   }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ashr<mode>3_reg"
  [(set (match_operand:QUQ31   0 "pic30_register_operand" "=r")
        (ashiftrt:QUQ31 
          (match_operand:QUQ31 1 "pic30_register_operand"  "0")
          (match_operand:HI    2 "pic30_register_operand"  "r")))
   (clobber (match_scratch:HI  3                          "=2"))
   (clobber (match_scratch:HI  4                          "=&r"))
  ]
  ""
  "*
  {
    if ((pic30_fp_round_p() == pic30_truncation) ||
        (pic30_fp_round_p() == pic30_fastest)) {
      return \".set ___BP___,0\n\"
             \".LB%=:\;\"
             \"dec %2,%2\;\"
             \"bra n,.LE%=\;\"
             \"asr %d1,%d0\;\"
             \"rrc %1,%0\;\"
             \"bra .LB%=\n\"
             \".LE%=:\";
    } else if (pic30_fp_round_p() == pic30_conventional) {
      return \".set ___BP___,0\n\"
             \"cp0 %2\;\"
             \"bra z,.LE%=\;\"
             \".LB%=:\;\"
             \"dec %2,%2\;\"
             \"bra z,.LF%=\;\"
             \"asr %d1,%d0\;\"
             \"rrc %1,%0\;\"
             \"bra .LB%=\n\"
             \".LF%=:\;\"
             \"asr %d1,%d0\;\"
             \"rrc %1,%0\;\"
             \"addc %0,#0,%0\;\"    
             \"addc %d0,#0,%d0\n\"
             \".LE%=:\;\";
    } else if (pic30_fp_round_p() == pic30_convergent) {
      /* I would have liked to have this as a separate pattern; but
         it conflicts with ashr<mode>3_reg even though this would have had
         one more clobber - now they have the same */
      return 
             \"clr %4\;\"              /* clear overflow holder */
             \".set ___BP___,0\n\"
             \".LB%=:\;\"
             \"dec %2,%2\;\"
             \"bra n,.LE%=\;\"
             \"asr %d1,%d0\;\"
             \"rrc %1,%0\;\"
             \"rrc %4,%4\;\"           /* store overflow bits */
             \"bra .LB%=\n\"
             \".LE%=:\;\"
             \"sl %4,%4\"              /* check overflow */
             \"btsc _SR,#1\;\"         /* if zero clear carry */
             \"bclr _SR,#0\;\"
             \"addc %0,#0,%0\;\"
             \"addc %d0,#0,%d0\";
      
    } else
      error(\"Invalid fixed-point round mode specified\n\");
    return \"cannot generate instruction\";
  }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

; logical shift right

(define_insn "lshr<mode>3_helper"
  [(set (match_operand:QUQ15   0 "pic30_register_operand"  "=r,r,&r")
        (lshiftrt:QUQ15 
          (match_operand:QUQ15 1 "pic30_register_operand"   "r,r, r")
          (match_operand:HI    2 "pic30_reg_or_imm_operand" "K,i, r")))
  ]
  ""
  "*
  {
    if ((pic30_fp_round_p() == pic30_truncation) ||
        (pic30_fp_round_p() == pic30_fastest)) {
      switch (which_alternative) {
        case 0: 
          return \"lsr %1,#%2,%0\";
        case 1:
          if (INTVAL(operands[2]) < 0)
            return \"sl %1,#%J2%%16,%0\";
          else
            return \"lsr %1,#%2%%16,%0\";
        case 2: 
            return \"lsr %1,%2,%0\";
        default: gcc_assert(0);
      }
    } else if (pic30_fp_round_p() == pic30_conventional) 
    switch (which_alternative) {
      case 0:  
        if (INTVAL(operands[2]) == 1) {
          return 
                 \"lsr %1,%0\;\"
                 \"addc %0,#0,%0\";
        } else {
          return \"lsr %1,#%L2,%0\;\"      /* shift one less than we need */
                 \"lsr %1,%0\;\"           /*   so that we can shift once */
                 \"addc %0,#0,%0\";        /*   to capture and add carry */
        }
      case 1:
        if (INTVAL(operands[2]) < 0)
          return \"cannot generate instruction\"; 
        else
          return \"lsr %1,#(%2%%16)-1,%0\;\" /* shift one less than we need */
                 \"lsr %1,%0\;\"             /*   so that we can shift once */
                 \"addc %0,#0,%0\";          /*   to capture and add carry */
      case 2: 
	  return \"cp0 %2\;\"
                 \"mov %1,%0\;\"
                 \"bra z,.LE%=\;\"
                 \"dec %2,%0\;\"             /* shift one less than we need */
                 \"lsr %1,%0,%0\;\"
                 \"lsr %0,%0\;\"             /*   so that we can shift once */
                 \"addc %0,#0,%0\n\"         /*   to capture and add carry */
                 \".LE%=:\";
      default: gcc_assert(0);
    }
    else 
      error(\"Invalid fixed-point rounding mode specified\");
    return \"cannot generate instruction\";
  }"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
  ]
)

(define_insn "lshr<mode>3_convergent"
  [(set (match_operand:QUQ15   0 "pic30_register_operand"  "=r,r,r")
        (lshiftrt:QUQ15
          (match_operand:QUQ15 1 "pic30_register_operand"   "r,r,r")
          (match_operand:HI    2 "pic30_reg_or_imm_operand" "K,i,r")))
   (clobber (match_scratch:HI  3                          "=&r,&r,&r"))
  ]
  ""
  "*
  {
    if (pic30_fp_round_p() == pic30_convergent)
    switch (which_alternative) {
      case 0:  
        if (INTVAL(operands[2]) == 1) {
          return 
                 \"lsr %1,%0\;\"
                 \"btsc %0,#0\;\"          /* do not add carry if low bit == 0*/
                 \"addc %0,#0,%0\";
        } else {
          return 
                 \"sl %1,%K2,%3\;\"        /* shift up bits that drop off */
                 \"lsr %1,#%2,%0\;\"       /* shift down the bits we need */
                 \"sl %3,%3\;\"            /* shift top overflow into carry */
                 \"addc %0,#0,%0\;\"       /* add overflow from carry */
                 \"cp0 %3\;\"              /* test rest of the overflow */
                 \"mov #0xFFFE,%3\;\"      /* create mask off low bit */
                 \"btsc _SR,#1\;\"         /* if the rest of overflow is 0 */
                 \"and %0,%3,%0\n\"        /*   mask off low bit */
                 \".L1_%=:\";

        }
      case 1:
        if (INTVAL(operands[2]) < 0)
          return \"cannot generate instruction\"; 
        else
          return \"sl %1,#16-(%2%%16),%3\;\" /* shift up bits that drop off */
                 \"lsr %1,#(%2%%16),%0\;\"   /* shift down bits we need */
                 \"sl %3,%3\;\"              /* shift top overflow into carry */
                 \"bra nc,.L1_%=\;\"         /* if no carry, finish */
                 \"addc %0,#0,%0\;\"         /* add carry */
                 \"cp0 %3\;\"                /* test rest of the overflow */
                 \"mov #0xFFFE,%3\;\"        /* create mask clear low bit */
                 \"btsc _SR,#1\;\"           /* if the rest of overflow is 0 */
                 \"and %0,%3,%0\n\"          /*   mask off low bit */
                 \".L1_%=:\";

      case 2: 
          return \"subr %2,#16,%3\;\"
                 \"sl %1,%3,%3\;\"           /* shift up bits that drop off */
                 \"lsr %1,%2,%0\;\"          /* shift down bits we need */
                 \"sl %3,%3\;\"              /* shift top overflow into carry */
                 \"bra nc,.L1_%=\;\"         /* if no carry, finish */
                 \"addc %0,#0,%0\;\"         /* add carry */
                 \"cp0 %3\;\"                /* test rest of the overflow */
                 \"mov #0xFFFE,%3\;\"        /* create mask clear low bit */
                 \"btsc _SR,#1\;\"           /* if the rest of overflow is 0 */
                 \"and %0,%3,%0\n\"          /*   mask off low bit */
                 \".L1_%=:\";
       default: gcc_assert(0);
    } else
      error(\"Invalid fixed-point round mode specified\n\");
    return \"cannot generate instruction\";

  }"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
  ]
)

(define_expand "lshr<mode>3"
  [(set (match_operand:QUQ15   0 "pic30_register_operand"   "")
        (lshiftrt:QUQ15
          (match_operand:QUQ15 1 "pic30_register_operand"   "")
          (match_operand:HI    2 "pic30_reg_or_imm_operand" "")))]
  ""
  "
  { rtx r0,r1,r2;

    r0 = operands[0];
    r1 = operands[1];
    r2 = operands[2];
    if (!pic30_register_operand(r0,<MODE>mode)) {
      r0 = gen_reg_rtx(<MODE>mode);
    }
    if (!pic30_register_operand(r1,<MODE>mode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (!pic30_reg_or_imm_operand(r2,<MODE>mode)) {
      r2 = force_reg(HImode, r2);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_lshr<mode>3_convergent(r0,r1,r2)
      );
    } else {
      emit(
        gen_lshr<mode>3_helper(r0,r1,r2)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }"
)

(define_expand "lshr<mode>3"
  [(set (match_operand:QUQ31   0 "pic30_register_operand"   "")
        (lshiftrt:QUQ31 
          (match_operand:QUQ31 1 "pic30_register_operand"   "")
          (match_operand:HI    2 "pic30_reg_or_imm_operand" "")))]
  ""
  "
  {
    if ((pic30_fp_round_p() == pic30_conventional) ||
        (pic30_fp_round_p() == pic30_convergent)) 
      FAIL;
    if (GET_CODE(operands[2]) == CONST_INT) {
      switch (INTVAL(operands[2])) {
        case 0:
          emit_insn(
            gen_mov<mode>(operands[0], operands[1])
          );
          break;
        case 1:
          emit_insn(
            gen_lshr<mode>3_imm1(operands[0], operands[1], operands[2])
          );
          break;
        case 2 ... 15:
          emit_insn(
            gen_lshr<mode>3_imm2to15(operands[0], operands[1], operands[2])
          );
          break;
        case 16:
          emit_insn(
            gen_lshr<mode>3_imm16plus(operands[0], operands[1], operands[2])
          );
          break;
        case 17 ... 31:
          if (pic30_fp_round_p() == pic30_convergent) {
            emit_insn(
              gen_lshr<mode>3_imm16plus_convergent(operands[0], operands[1], 
                                                   operands[2])
            );
          } else {
            emit_insn(
              gen_lshr<mode>3_imm16plus(operands[0], operands[1], operands[2])
            );
          }
          break;
        default:
          emit_insn(
            gen_mov<mode>(operands[0], const0_rtx)
          );
          break;
      }
    } else {
#if 0
      if (pic30_fp_round_p() == pic30_convergent) {
        emit_insn(
          gen_lshr<mode>3_reg_convergent(operands[0],operands[1],operands[2])
        );
      } else
#endif
      {
        emit_insn(
          gen_lshr<mode>3_reg(operands[0],operands[1],operands[2])
        );
      }
    }
    DONE;
  }"
)

(define_insn "lshr<mode>3_imm1"
  [(set (match_operand:QUQ31   0 "pic30_register_operand" "=r")
        (lshiftrt:QUQ31 
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")
          (match_operand:HI    2 "pic30_I_operand"         "I")))]
  ""
  "*
   if ((pic30_fp_round_p() == pic30_truncation) ||
       (pic30_fp_round_p() == pic30_fastest)) {
     return \"asr %d1,%d0\;rrc %1,%0\";
   } else if (pic30_fp_round_p() == pic30_conventional) {
     return 
            \"lsr %d1,%d0\;\"       /* shift right ... */
            \"rrc %1,%0\;\"
            \"addc %0,#0,%0\;\"     /* add in drop overflow bit */
            \"addc %d0,#0,%d0\;\";
   } else if (pic30_fp_round_p() == pic30_convergent) {
     return 
            \"lsr %d1,%d0\;\"       /* shift right ... */
            \"rrc %1,%0\;\"
            \"btsc %0,#0\;\"        /* if bit 0 is 0 */
            \"bclr _SR,#0\;\"       /*   clear overflow bit */
            \"addc %0,#0,%0\;\"     /* add in drop overflow bit */
            \"addc %d0,#0,%d0\;\";
   }
   error(\"Invalid fixed-point rounding mode specified\");
   return \"nop\";
  "
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "lshr<mode>3_imm2to15"
  [(set (match_operand:QUQ31   0 "pic30_register_operand" "=r")
        (lshiftrt:QUQ31 
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")
          (match_operand:HI    2 "pic30_imm2to15_operand"  "i")))
   (clobber (match_scratch:HI  3                         "=&r"))]
  ""
  "*
  {
    if ((pic30_fp_round_p() == pic30_truncation) ||
        (pic30_fp_round_p() == pic30_fastest)) {
      /*
      ** Take care that the source and dest don't overlap
      */
      if (REGNO(operands[0]) <= REGNO(operands[1])) {
        return \"sl %d1,#%k2,%3\;\"
               \"lsr %1,#%2,%0\;\"
               \"ior %3,%0,%0\;\"
               \"lsr %d1,#%2,%d0\";
      } else {
        return \"lsr %d1,#%2,%d0\;\"
               \"sl %d1,#%k2,%3\;\"
               \"lsr %1,#%2,%0\;\"
               \"ior %3,%0,%0\";
      }
    } else if (pic30_fp_round_p() == pic30_conventional) {
      if (REGNO(operands[0]) <= REGNO(operands[1])) {
        /* reorder a bit to preserve C for overflow */
        return \"sl %d1,#%k2,%3\;\"    /* shift up low bits of high word to t */
               \"lsr %d1,#%2,%d0\;\"   /* shift down high bits of high word
                                          making the high part of result */
               \"lsr %1,#%L2,%0\;\"    /* shift down low bits of low word,
                                          1 less (clearing upper bits) */
               \"lsr %0,%0\;\"         /* final shift, capturing overflow in C*/
               \"ior %3,%0,%0\;\"      /* or in high bits of low word from t */
               \"addc %0,#0,%0\;\"     /* add in overflow */
               \"addc %d0,#0,%d0\;\";
      } else {
        return \"lsr %d1,#%2,%d0\;\"   /* shift down high bits of high word
                                          making the high part of result */
               \"sl %d1,#%k2,%3\;\"    /* shift up low bits of high word to t */
               \"lsr %1,#%L2,%0\;\"    /* shift down low bits of low word,
                                          1 less (clearing upper bits) */
               \"lsr %0,%0\;\"         /* final shift, capturing overflow in C*/
               \"ior %3,%0,%0\;\"      /* or in high bits of low word from t */
               \"addc %0,#0,%0\;\"     /* add in overflow */
               \"addc %d0,#0,%d0\;\";
      }
    } else if (pic30_fp_round_p() == pic30_convergent) {
      if (REGNO(operands[0]) <= REGNO(operands[1])) {
        /* reorder a bit to preserve C for overflow */
        return \"sl %d1,#%k2,%3\;\"    /* shift up low bits of high word to t */
               \"lsr %d1,#%2,%d0\;\"   /* shift down high bits of high word
                                          making the high part of result */
               \"sl  %1,#%K2,%0\;\"    /* shift up low bits (that drop) */
               \"sl  %0,%0\;\"         /* shift topmost into carry */
               \"btsc _SR,#1\;\"       /* if zero clear carry */
               \"bclr _SR,#0\;\"
               \"lsr %1,#%2,%0\;\"     /* shift down low bits of low word */
               \"ior %3,%0,%0\;\"      /* or in high bits of low word from t */
               \"addc %0,#0,%0\;\"     /* maybe add in overflow */
               \"addc %d0,#0,%d0\;\";
      } else {
        return \"lsr %d1,#%2,%d0\;\"   /* shift down high bits of high word
                                          making the high part of result */
               \"sl %d1,#%k2,%3\;\"    /* shift up low bits of high word to t */
               \"sl  %0,%0\;\"         /* shift topmost into carry */
               \"btsc _SR,#1\;\"       /* if zero clear carry */
               \"bclr _SR,#0\;\"
               \"lsr %1,#%2,%0\;\"     /* shift down low bits of low word */
               \"ior %3,%0,%0\;\"      /* or in high bits of low word from t */
               \"addc %0,#0,%0\;\"     /* add in overflow */
               \"addc %d0,#0,%d0\;\";
      }
    } else
      error(\"Invalid fixed-point round mode specified\n\");
    return \"cannot generate instruction\";
  }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "lshr<mode>3_imm16plus"
  [(set (match_operand:QUQ31   0 "pic30_register_operand" "=&r")
        (lshiftrt:QUQ31 
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")
          (match_operand:HI    2 "pic30_imm16plus_operand" "i")))]
  ""
  "*
   {
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       return \"asr %d1,#%K2,%0\;asr %0,#15,%d0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       if (INTVAL(operands[2]) == 16) {
         return 
                \"mov %d1,%0\;\"         /* copy high word to low result */
                \"lsr %0,#15,%d0\;\"     /* shift down sign to high result */
                \"btst.c %1,#15\;\"      /* copy overflow bit to carry */
                \"addc %0,#0,%0\;\"      /* add in overflow bit */
                \"addc %d0,#0,%d0\";
       } else {
         return 
                \"asr %d1,#%K2,%0\;\"    /* copy high word to low result */
                \"lsr %0,#15,%d0\;\"     /* shift down sign to high result */
                \"btst.c %d1,#(%K2)-1\;\"/* copy overflow bit to carry */
                \"addc %0,#0,%0\;\"      /* add in overflow bit */
                \"addc %d0,#0,%d0\";
       }
     } else
       error(\"Invalid fixed-point round mode specified\n\");
     return \"cannot generate instruction\";
   }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "lshr<mode>3_imm16plus_convergent"
  [(set (match_operand:QUQ31   0 "pic30_register_operand" "=&r")
        (lshiftrt:QUQ31 
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")
          (match_operand:HI    2 "pic30_imm16plus_operand" "i")))
   (clobber (match_scratch:HI  3                          "=r"))
  ]
  ""
  "*
   {
     if (pic30_fp_round_p() == pic30_convergent) {
       if (INTVAL(operands[2]) == 16) {
         return 
                \"mov %d1,%0\;\"         /* copy high word to low result */
                \"lsr %0,#15,%d0\;\"     /* shift down sign to high result */
                \"sl %1,%3\;\"           /* shift up dropped off bits */
                \"btsc _SR,#1\;\"        /* if zero clear carry */
                \"bclr _SR,#0\;\"
                \"addc %0,#0,%0\;\"      /* add in overflow bit */
                \"addc %d0,#0,%d0\";
       } else {
         return 
                \"asr %d1,#%K2,%0\;\"    /* copy high word to low result */
                \"lsr %0,#15,%d0\;\"     /* shift down sign to high result */
                \"sl %d1,#%K2,%3\;\"     /* shift up dropped off bits */
                \"btsc _SR,#1\;\"        /* if zero clear carry */
                \"bclr _SR,#0\;\"
                \"addc %0,#0,%0\;\"      /* add in overflow bit */
                \"addc %d0,#0,%d0\";
       }
     } else
       error(\"Invalid fixed-point round mode specified\n\");
     return \"cannot generate instruction\";
   }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "lshr<mode>3_reg"
  [(set (match_operand:QUQ31   0 "pic30_register_operand" "=r")
        (lshiftrt:QUQ31 
          (match_operand:QUQ31 1 "pic30_register_operand"  "0")
          (match_operand:HI    2 "pic30_register_operand"  "r")))
   (clobber (match_scratch:HI  3                          "=2"))
   (clobber (match_scratch:HI  4                          "=&r"))
  ]
  ""
  "*
  {
    if ((pic30_fp_round_p() == pic30_truncation) ||
        (pic30_fp_round_p() == pic30_fastest)) {
      return \".set ___BP___,0\n\"
             \".LB%=:\;\"
             \"dec %2,%2\;\"
             \"bra n,.LE%=\;\"
             \"lsr %d1,%d0\;\"
             \"rrc %1,%0\;\"
             \"bra .LB%=\n\"
             \".LE%=:\";
    } else if (pic30_fp_round_p() == pic30_conventional) {
      return \".set ___BP___,0\n\"
             \"cp0 %2\;\"
             \"bra z,.LE%=\;\"
             \".LB%=:\;\"
             \"dec %2,%2\;\"
             \"bra z,.LF%=\;\"
             \"lsr %d1,%d0\;\"
             \"rrc %1,%0\;\"
             \"bra .LB%=\n\"
             \".LF%=:\;\"
             \"asr %d1,%d0\;\"
             \"rrc %1,%0\;\"
             \"addc %0,#0,%0\;\"    
             \"addc %d0,#0,%d0\n\"
             \".LE%=:\;\";
    } else if (pic30_fp_round_p() == pic30_convergent) {
      /* I would have liked to have this as a separate pattern; but
         it conflicts with lshr<mode>3_reg even though this would have had
         one more clobber - now they have the same */
      return 
             \"clr %4\;\"              /* clear overflow holder */
             \".set ___BP___,0\n\"
             \".LB%=:\;\"
             \"dec %2,%2\;\"
             \"bra n,.LE%=\;\"
             \"lsr %d1,%d0\;\"
             \"rrc %1,%0\;\"
             \"rrc %4,%4\;\"           /* store overflow bits */
             \"bra .LB%=\n\"
             \".LE%=:\;\"
             \"sl %4,%4\"              /* check overflow */
             \"btsc _SR,#1\;\"         /* if zero clear carry */
             \"bclr _SR,#0\;\"
             \"addc %0,#0,%0\;\"
             \"addc %d0,#0,%d0\";
      
    } else
      error(\"Invalid fixed-point round mode specified\n\");
    return \"cannot generate instruction\";
  }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

; compare

(define_insn "cmp<mode>_imm"
  [(set (cc0)
        (compare
          (match_operand:QUQ15 0 "pic30_register_operand" "r")  
          (match_operand:QUQ15 1 "pic30_M_operand"        "M"))) 
   (clobber (match_dup 0))]
  ""
  "add #%J1,%0"
  [(set_attr "cc" "set")])
   
(define_insn "cmp<mode>_sfr0"
  [(set (cc0)
        (compare 
          (match_operand:QUQ15 0 "pic30_reg_or_near_operand" "U,r")
          (match_operand:QUQ15 1 "pic30_register_operand"    "a,r")))]
  ""
  "@
   cp %0
   sub %0,%1,[w15]"
  [(set_attr "cc" "set")])
  
(define_insn "cmp<mode>"
  [(set (cc0)
        (compare 
          (match_operand:QUQ15 0 "pic30_mode2_operand"   "r,r,  R<>,r,r")
          (match_operand:QUQ15 1 "pic30_mode1PN_operand" "r,R<>,r,  P,N")))]
  ""
  "@
   sub %0,%1,[w15]
   sub %0,%1,[w15]
   subr %1,%0,[w15]
   sub %0,#%1,[w15]
   add %0,#%J1,[w15]"
  [ 
   (set_attr "cc" "set")
   (set_attr "type" "etc,use,use,etc,etc")
  ]
) 

(define_insn "cmp<mode>_helper"
  [(set (cc0)
        (compare 
          (match_operand:QUQ31 0 "pic30_mode2mres_operand" "r,r,R,r,>")
          (match_operand:QUQ31 1 "pic30_mode2mres_operand" "r,R,r,>,r")))]
  ""
  "*
{
  static char *patterns[] = {
     \"sub %0,%1,[w15]\;subb %d0,%d1,[w15]\",
     \"sub %0,%I1,[w15]\;subb %d0,%D1,[w15]\",
     \"subr %1,%I0,[w15]\;subbr %d1,%D0,[w15]\",
     \"sub %0,%1,[w15]\;subb %d0,%1,[w15]\",
     \"subr %1,%0,[w15]\;subbr %d1,%0,[w15]\",
  0 };

  static char *psrd_psrd_patterns[] = {
     \"sub %0,%1,[w15]\;subb %d0,%d1,[w15]\",
     \"sub %0,%I1,[w15]\;nop\;subb %d0,%D1,[w15]\",
     \"subr %1,%I0,[w15]\;nop\;subbr %d1,%D0,[w15]\",
     \"sub %0,%1,[w15]\;nop\;subb %d0,%1,[w15]\",
     \"subr %1,%0,[w15]\;nop\;subbr %d1,%0,[w15]\",
  0 };

  if (pic30_psrd_psrd_errata(operands[0],operands[1])) {
    pic30_rtx_nops++;
    return psrd_psrd_patterns[which_alternative];
  } else {
  return patterns[which_alternative];
  }
}"
  [(set_attr "cc" "set")])

(define_insn "cmp<mode>_zero"
  [(set (cc0)
        (compare 
          (match_operand:QUQ31 0 "pic30_register_operand" "r")
          (match_operand:QUQ31 1 "pic30_O_operand"        "fO")))]
  ""
  "sub %0,#0,[w15]\;subb %d0,#0,[w15]"
  [(set_attr "cc" "set")])

(define_insn "cmp<mode>_immNP"
  [(set (cc0)
        (compare 
          (match_operand:QUQ31 0 "pic30_register_operand"  "r,r,r")
          (match_operand:QUQ31 1 "immediate_operand"       "P,N,i")))]
  "(((-31 <= INTVAL(operands[1])) && (INTVAL(operands[1]) <= 31)) ||
    ((0xFFE1 <= INTVAL(operands[1])) && (INTVAL(operands[1]) <= 0xFFFF))) &&
   (INTVAL(operands[1]) != 0)"
  "@
   sub %0,#%1,[w15]\;subb %d0,#0,[w15]
   add %0,#%J1,[w15]\;addc %d0,#0,[w15]
   add %0,#%j1,[w15]\;subb %d0,#0,[w15]"
  [(set_attr "cc" "set")])

(define_insn "cmp<mode>_imm"
  [(set (cc0)
        (compare 
          (match_operand:QUQ31 0 "pic30_register_operand"  "r")
          (match_operand:QUQ31 1 "immediate_operand"       "i")))
   (clobber (match_scratch:HI  2                         "=&r"))]
  "((1<INTVAL(operands[1])) && (INTVAL(operands[1])<65536))"
  "mov #%1,%2\;sub %0,%2,[w15]\;subb %d0,#0,[w15]"
  [(set_attr "cc" "set")])

(define_expand "cmp<mode>"
  [(set (cc0)
        (compare 
          (match_operand:QUQ31 0 "pic30_mode2mres_operand" "")
          (match_operand:QUQ31 1 "pic30_mode2mres_operand" "")))]
  ""
  "
{
  if (pic30_mode2mres_operand(operands[1], <MODE>mode)) {
    emit(
      gen_cmp<mode>_helper(operands[0],operands[1])
    );
  } else if (immediate_operand(operands[1],VOIDmode)) {
    rtx reg_0 = force_reg(<MODE>mode,operands[0]);
    if (INTVAL(operands[1]) == 0) {
      emit(
        gen_cmp<mode>_zero(reg_0, operands[1])
      );
    } else {
      rtx reg = force_reg(<MODE>mode,operands[1]);
      emit( 
        gen_cmp<mode>_helper(reg_0, reg)
      );
    }
  }
  DONE;
}")

; Fixed Point Accum

;; *** load/store

(define_insn "mov<mode>_rimm"
   [(set (match_operand:AUACC  0 "pic30_accum_or_reg_operand" "=w,?????w,???r")
         (match_operand:AUACC  1 "immediate_operand"           "fO,    i,   i"))
    (clobber (match_scratch:HI 2                              "=X,     &r,  X"))
   ]
   ""
   "*
    {
      int zero = 0;

      zero = (CONST_FIXED_VALUE_LOW(operands[1]) == 0) &&
             (CONST_FIXED_VALUE_HIGH(operands[1]) == 0);
      if (REGNO(operands[0]) == A_REGNO) {
        if (zero) {
          return \"clr A\";
        } else {
          return 
               \"mov #%z1,%2\;\"
               \"mov %2,ACCAL\;\"
               \"mov #%y1,%2\;\"
               \"mov %2,ACCAH\;\"
               \"mov #%x1,%2\;\"
               \"mov %2,ACCAU\";
        }
      } else if (REGNO(operands[0]) == B_REGNO) {
        if (zero) {
          return \"clr B\";
        } else {
          return 
               \"mov #%z1,%2\;\"
               \"mov %2,ACCBL\;\"
               \"mov #%y1,%2\;\"
               \"mov %2,ACCBH\;\"
               \"mov #%x1,%2\;\"
               \"mov %2,ACCBU\";
        }
      } else {
        if (zero) {
          return 
               \"mul.uu %0,#0,%0\;\"
               \"mov.b #%x1,%t0\";
        } else {
          return 
               \"mov #%z1,%0\;\"
               \"mov #%y1,%d0\;\"
               \"mov #%x1,%t0\";
        }
      }
    }"
)

(define_insn "reload<mode>_imm"
   [(set (match_operand:AUACC  0 "pic30_accumulator_operand" "= w")
         (match_operand:AUACC  1 "immediate_operand"         "  i"))
    (clobber (match_operand:HI 2 "pic30_register_operand"    "=&r"))
   ]
   ""
   "*
    {
      int zero = 0;

      zero = (CONST_FIXED_VALUE_LOW(operands[1]) == 0) &&
             (CONST_FIXED_VALUE_HIGH(operands[1]) == 0);
      if (REGNO(operands[0]) == A_REGNO) {
        if (zero) {
          return \"clr A\";
        } else {
          return
               \"mov #%z1,%2\;\"
               \"mov %2,ACCAL\;\"
               \"mov #%y1,%2\;\"
               \"mov %2,ACCAH\;\"
               \"mov #%x1,%2\;\"
               \"mov %2,ACCAU\";
        }
      } else if (REGNO(operands[0]) == B_REGNO) {
        if (zero) {
          return \"clr B\";
        } else {
          return
               \"mov #%z1,%2\;\"
               \"mov %2,ACCBL\;\"
               \"mov #%y1,%2\;\"
               \"mov %2,ACCBH\;\"
               \"mov #%x1,%2\;\"
               \"mov %2,ACCBU\";
        }
      } else {
        gcc_assert(0);
      }
    }"
)

(define_insn "reloadsi_imm"
   [(set (match_operand:SI     0 "pic30_accumulator_operand" "= w")
         (match_operand:SI     1 "immediate_operand"         "  i"))
    (clobber (match_operand:HI 2 "pic30_register_operand"    "=&r"))
   ]
   ""
   "*
    {
      int zero = 0;

      zero = (CONST_FIXED_VALUE_LOW(operands[1]) == 0) &&
             (CONST_FIXED_VALUE_HIGH(operands[1]) == 0);
      if (REGNO(operands[0]) == A_REGNO) {
        if (zero) {
          return \"clr A\";
        } else {
          return
               \"mov #%z1,%2\;\"
               \"mov %2,ACCAL\;\"
               \"mov #%y1,%2\;\"
               \"mov %2,ACCAH\;\";
        }
      } else if (REGNO(operands[0]) == B_REGNO) {
        if (zero) {
          return \"clr B\";
        } else {
          return
               \"mov #%z1,%2\;\"
               \"mov %2,ACCBL\;\"
               \"mov #%y1,%2\;\"
               \"mov %2,ACCBH\;\";
        }
      } else {
        gcc_assert(0);
      }
    }"
)

; NB: like movsi_gen this does not cover all possible versions of move_operand
;     ugh

(define_insn "mov<mode>_gen"
   [(set
      (match_operand:AUACC 0 
         "pic30_move_operand" "=wr,????wr,????wr,????R, >, >, wr,  <, r, Q")
      (match_operand:AUACC 1 
         "pic30_move_operand"  "wr,     R,     >,   wr,wr, >,  <, wr, Q, r"))
   ]
   ""
   "*
    switch (which_alternative) {
      default: gcc_assert(0);

      case 0:  /* wr,wr */
               if (pic30_accumulator_operand(operands[0],
                                             <MODE>mode) &&
                   pic30_accumulator_operand(operands[1],
                                             <MODE>mode)) {
                 /* saturation mode doesn't matter... we won't overflow */
                 if (REGNO(operands[0]) == A_REGNO) {
                   return \"clr A\;\"
                          \"add A\";
                 } else if (REGNO(operands[0]) == B_REGNO) {
                   return \"clr B\;\"
                          \"add B\";
                 } else gcc_assert(0);
               } else if (pic30_accumulator_operand(operands[0],
                                                    <MODE>mode)) {
                 if (REGNO(operands[0]) == A_REGNO) {
                   return \"mov %1,ACCAL\;\"
                          \"mov %d1,ACCAH\;\"
                          \"mov %t1,ACCAU\";
                 } else if (REGNO(operands[0]) == B_REGNO) {
                   return \"mov %1,ACCBL\;\"
                          \"mov %d1,ACCBH\;\"
                          \"mov %t1,ACCBU\";
                 } else gcc_assert(0);
               } else if (pic30_accumulator_operand(operands[1],
                                                    <MODE>mode)) {
                 if (REGNO(operands[1]) == A_REGNO) {
                   return \"mov ACCAL,%0\;\"
                          \"mov ACCAH,%d0\;\"
                          \"mov ACCAU,%t0\";
                 } else if (REGNO(operands[1]) == B_REGNO) {
                   return \"mov ACCBL,%0\;\"
                          \"mov ACCBH,%d0\;\"
                          \"mov ACCBU,%t0\";
                 } else gcc_assert(0);
               } else {
                 /* Try and prevent clobbering, apparently using an &
                    early clobber confuses reload */
                 /* op0 and op1 regnos will only be even ... */
                 if (REGNO(operands[0]) == REGNO(operands[1])) {
                   return \"; nop\";
                 } else if (REGNO(operands[0]) == REGNO(operands[1])+2) {
                   return \"mov.b %t1,%t0\;\"
                          \"mov.d %1,%0\";
                 } /* else the other overlap doesn't matter */ 
                 return \"mov.d %1,%0\;\"
                        \"mov.b %t1,%t0\";
               }
               break;
      case 1:  /* wr,R */
               if (pic30_accumulator_operand(operands[0],
                                             <MODE>mode)) {
                 if (REGNO(operands[0]) == A_REGNO) {
                   return \"mov %I1,[w15++]\;\"
                          \"pop ACCAL\;\"
                          \"mov %I1,[W15++]\;\"
                          \"pop ACCAH\;\"
                          \"mov %D1,[W15++]\;\"
                          \"pop ACCAU\;\"
                          \"dec2 %r1,%r1\";
                 } else if (REGNO(operands[0]) == B_REGNO) {
                   return \"mov %I1,[w15++]\;\"
                          \"pop ACCBL\;\"
                          \"mov %I1,[W15++]\;\"
                          \"pop ACCBH\;\"
                          \"mov %D1,[W15++]\;\"
                          \"pop ACCBU\;\"
                          \"dec2 %r1,%r1\";
                 } else gcc_assert(0);
               } else {
                 /* Try and prevent clobbering, apparently using an
                    & earlyclobber confuses reload */
                 unsigned int index;
                 index = REGNO(XEXP(operands[1],0));
                 if (pic30_psrd_psrd_errata(operands[1],NULL)) {
                   pic30_rtx_nops+=2;
                 if (index == REGNO(operands[0])) {
                   /* write to the index register last */
                   return \"mov %Q1,%d0\;\"
                            \"nop\;\"
                          \"mov.b %R1,%t0\;\"
                            \"nop\;\"
                          \"mov %1,%0\";
                 } else if (index == REGNO(operands[0])+1) {
                   /* write to the index+1 register last */
                   return \"mov.b %R1,%t0\;\"
                            \"nop\;\"
                          \"mov %1,%0\;\"
                            \"nop\;\"
                          \"mov %Q1,%d0\";
                 } else {
                   /* maybe write to the index+2 register last */
                   return \"mov %1,%0\;\"
                            \"nop\;\"
                          \"mov %Q1,%d0\;\"
                            \"nop\;\"
                          \"mov.b %R1,%t0\";
                 }
                 } else {
                   if (index == REGNO(operands[0])) {
                     /* write to the index register last */
                     return \"mov %Q1,%d0\;\"
                            \"mov.b %R1,%t0\;\"
                            \"mov %1,%0\";
                   } else if (index == REGNO(operands[0])+1) {
                     /* write to the index+1 register last */
                     return \"mov.b %R1,%t0\;\"
                            \"mov %1,%0\;\"
                            \"mov %Q1,%d0\";
                   } else {
                     /* maybe write to the index+2 register last */
                     return \"mov %1,%0\;\"
                            \"mov %Q1,%d0\;\"
                            \"mov.b %R1,%t0\";
               }
                 }
               }
               break;
      case 2:  /* wr,> */
               if (pic30_accumulator_operand(operands[0],
                                             <MODE>mode)) {
                 if (REGNO(operands[0]) == A_REGNO) {
                   return \"mov %I1,[w15++]\;\"
                          \"pop ACCAL\;\"
                          \"mov %I1,[W15++]\;\"
                          \"pop ACCAH\;\"
                          \"mov %I1,[W15++]\;\"
                          \"pop ACCAU\";
                 } else if (REGNO(operands[0]) == B_REGNO) {
                   return \"mov %I1,[w15++]\;\"
                          \"pop ACCBL\;\"
                          \"mov %I1,[W15++]\;\"
                          \"pop ACCBU\;\"
                          \"mov %I1,[W15++]\;\"
                          \"pop ACCBH\;\";
                 } else gcc_assert(0);
               } else {
                 /* Try and prevent clobbering, apparently using an
                    & earlyclobber confuses reload */
                 unsigned int index;
                 index = REGNO(XEXP(operands[1],0));
                 if (pic30_psrd_psrd_errata(operands[1],NULL)) {
                   pic30_rtx_nops+=2;
                 if (index == REGNO(operands[0])) {
                   /* write to the index register last */
                   return \"mov %Q1,%d0\;\"
                            \"nop\;\"
                          \"mov.b %R1,%t0\;\"
                            \"nop\;\"
                          \"mov %1,%0\;\"
                          \"add %1,#6,%1\";
                 } else if (index == REGNO(operands[0])+1) {
                   /* write to the index+1 register last */
                   return \"mov.b %R1,%t0\;\"
                            \"nop\;\"
                          \"mov %1,%0\;\"
                            \"nop\;\"
                          \"mov %Q1,%d0\;\"
                          \"add %1,#6,%1\";
                 } else {
                   /* maybe write to the index+2 register last */
                   return \"mov %I1,%0\;\"
                            \"nop\;\"
                          \"mov %I1,%d0\;\"
                            \"nop\;\"
                          \"mov.b %1,%t0\";
                 }
                 } else {
                   if (index == REGNO(operands[0])) {
                     /* write to the index register last */
                     return \"mov %Q1,%d0\;\"
                            \"mov.b %R1,%t0\;\"
                            \"mov %1,%0\;\"
                            \"add %1,#6,%1\";
                   } else if (index == REGNO(operands[0])+1) {
                     /* write to the index+1 register last */
                     return \"mov.b %R1,%t0\;\"
                            \"mov %1,%0\;\"
                            \"mov %Q1,%d0\;\"
                            \"add %1,#6,%1\";
                   } else {
                     /* maybe write to the index+2 register last */
                     return \"mov %I1,%0\;\"
                            \"mov %I1,%d0\;\"
                            \"mov.b %1,%t0\";
               }
                 }
               }
               break;
      case 3:  /* R,wr */
               if (pic30_accumulator_operand(operands[1],
                                             <MODE>mode)) {
                 return \"push %m1U\;\"
                        \"push %m1H\;\"
                        \"push %m1L\;\"
                        \"mov [--w15],%I0\;\"
                        \"mov [--W15],%I0\;\"
                        \"mov [--W15],%D0\;\"
                        \"dec2 %r0,%r0\";
               } else {
                 return \"mov %1,%I0\;\"
                        \"mov %d1,%I0\;\"
                        \"mov.b %t1,%0\;\"
                        \"sub %r0,#4,%r0\";
               }
               break;
      case 4:  /* >,wr */
               if (pic30_accumulator_operand(operands[1],
                                             <MODE>mode)) {
                 rtx reg;
                 rtx post_inc = XEXP(operands[0],0);

                 reg = XEXP(post_inc,0);
                 if (REGNO(reg) == WR15_REGNO) {
                   /* push onto the stack */
                   return \"push %m1L\;\"
                          \"push %m1H\;\"
                          \"push %m1U\";
                 } else {
                   /* push the value backward, so we can pop it the right way
                      round */
                   return \"push %m1U\;\"
                          \"push %m1H\;\"
                          \"push %m1L\;\"
                          \"mov [--w15],%0\;\"
                          \"mov [--W15],%0\;\"
                          \"mov [--W15],%0\";
                 }
               } else {
                 return \"mov %1,%0\;\"
                        \"mov %d1,%0\;\"
                        \"mov %t1,%0\";
               }
               break;
      case 5:  /* >,> */
               if (pic30_psrd_psrd_errata(operands[1],NULL)) {
               return \"mov %1,%0\;\"
                        \"nop\;\"
                      \"mov %1,%0\;\" 
                        \"nop\;\"
                      \"mov %1,%0\;\";
               } else {
                 return \"mov %1,%0\;\"
                        \"mov %1,%0\;\" 
                        \"mov %1,%0\;\";
               }
               break;
      case 6:  /* wr,< */
               if (pic30_accumulator_operand(operands[0],
                                             <MODE>mode)) {
                 rtx reg;
                 rtx pre_dec = XEXP(operands[1],0);

                 reg = XEXP(pre_dec,0);
                 if (REGNO(reg) == WR15_REGNO) {
                   return \"pop %m0U\;\"
                          \"pop %m0H\;\"
                          \"pop %m0L\";
                 } else {
                   return \"mov %1,[w15++]\;\"
                          \"pop %m0U\;\"
                          \"mov %1,[W15++]\;\"
                          \"pop %m0H\;\"
                          \"mov %1,[W15++]\;\"
                          \"pop %m0L\";
                 }
               } else {
                 if (pic30_psrd_psrd_errata(operands[1],NULL)) {
                   pic30_rtx_nops+=2;
                 return \"mov %1,%t0\;\"
                          \"nop\;\"
                        \"mov %1,%d0\;\"
                          \"nop\;\"
                        \"mov %1,%0\";
                 } else {
                   return \"mov %1,%t0\;\"
                          \"mov %1,%d0\;\"
                          \"mov %1,%0\";
               }
               }
               break;
      case 7:  /* <,wr */
               if (pic30_accumulator_operand(operands[1],
                                             <MODE>mode)) {
                 return \"push %m1L\;\"
                        \"push %m1H\;\"
                        \"push %m1U\;\"
                        \"mov [--w15],%0\;\"
                        \"mov [--W15],%0\;\"
                        \"mov [--W15],%0\";
               } else {
                 return \"mov %t1,%0\;\"
                        \"mov %d1,%0\;\"
                        \"mov %1,%0\";
               }
               break;
      case 8:  /* r,Q */
               if (pic30_psrd_psrd_errata(operands[1],NULL)) {
                 pic30_rtx_nops+=2;
               return \"mov %1,%0\;\"
                        \"nop\;\"
                      \"mov %Q1,%d0\;\"
                        \"nop\;\"
                      \"mov %R1,%t0\;\";
               } else {
                 return \"mov %1,%0\;\"
                        \"mov %Q1,%d0\;\"
                        \"mov %R1,%t0\;\";
               }
      case 9:  /* Q,r */
               return \"mov %1,%0\;\"
                      \"mov %d1,%Q0\;\"
                      \"mov %t1,%R0;\";
    }"
)

(define_expand "mov<mode>"
  [(set (match_operand:AUACC 0 "pic30_move2_operand" "")
        (match_operand:AUACC 1 "pic30_move2_operand" ""))]
  ""
  "
{ int result;

  result = pic30_emit_move_sequence(operands, <MODE>mode);

  if (result > 0) DONE;
  if (immediate_operand(operands[1],VOIDmode)) {
    rtx reg = operands[0];

    if (!pic30_accum_or_reg_operand(operands[0],<MODE>mode)) {
      if (reload_in_progress) FAIL;
      reg = gen_reg_rtx(<MODE>mode);
    }

    if (reload_in_progress && 
        pic30_accumulator_operand(operands[0],<MODE>mode)) {
      FAIL; 
    }
    emit(
      gen_mov<mode>_rimm(reg,operands[1])
    );
    if (reg != operands[0])
      emit_move_insn(operands[0], reg);
    DONE;
  }
  emit(
    gen_mov<mode>_gen(operands[0], operands[1])
  );
  DONE;
}")

;; *** add/sub
;(define_insn "add<mode>3_dsp"
;  [(set (match_operand:AUACC    0 "pic30_accumulator2_operand" "=w")
;        (plus:AUACC
;           (match_dup 0)
;           (match_operand:AUACC 1 "pic30_accumulator2_operand" " w")))
;   (use (reg:HI CORCON))
;  ]
;  "(REGNO(operands[0]) != REGNO(operands[1]))"
;  "add %0"
;)

(define_insn "add<mode>3"
  [(set (match_operand:AUACC    0 "pic30_accum_or_reg_operand" "=&r,w")
        (plus:AUACC
           (match_operand:AUACC 1 "pic30_accum_or_reg_operand"  "%r,0")
           (match_operand:AUACC 2 "pic30_accum_or_reg_operand"  " r,w")))
   (use (reg:HI CORCON))
  ]
  ""
  "@
   add %1,%2,%0\;addc %d1,%d2,%d0\;addc.b %t1,%t2,%t0
   add %0"
)

;(define_insn "ssadd<mode>3_dsp"
;  [(set (match_operand:AUACC    0 "pic30_accumulator2_operand" "=w")
;        (ss_plus:AUACC
;           (match_dup 0)
;           (match_operand:AUACC 1 "pic30_accumulator2_operand" " w")))
;   (use (reg:HI CORCON))
;  ]
;  "(REGNO(operands[0]) != REGNO(operands[1]))"
;  "add %0"
;)

(define_insn "ssadd<mode>3"
  [(set (match_operand:AUACC    0 "pic30_accum_or_reg_operand" "=&r,w")
        (ss_plus:AUACC
           (match_operand:AUACC 1 "pic30_accum_or_reg_operand"  "%r,0")
           (match_operand:AUACC 2 "pic30_accum_or_reg_operand"  " r,0")))
   (use (reg:HI CORCON))
  ]
  ""
  "@
   add %1,%2,%0\;addc %d1,%d2,%d0\;addc.b %t1,%t2,%t0\;bra nov,.L1_%=\;setm %0\;setm %d0\;mov.b #0x7F,%t0\;btst.c %t2,#7\;bra nc,.L1_%=\;com.b %t0,%t0\;com %d0,%d0\;com %0,%0\;.L1_%=:
   add %0"
)

;(define_insn "usadd<mode>3_dsp"
;  [(set (match_operand:AUACC    0 "pic30_accumulator2_operand" "=w")
;        (us_plus:AUACC
;           (match_dup 0)
;           (match_operand:AUACC 1 "pic30_accumulator2_operand" " w")))
;   (use (reg:HI CORCON))
;  ]
;  "(REGNO(operands[0]) != REGNO(operands[1]))"
;  "add %0"
;)

(define_insn "usadd<mode>3"
  [(set (match_operand:AUACC    0 "pic30_accum_or_reg_operand" "=&r,w")
        (us_plus:AUACC
           (match_operand:AUACC 1 "pic30_accum_or_reg_operand"  "%r,0")
           (match_operand:AUACC 2 "pic30_accum_or_reg_operand"   "r,w")))
   (use (reg:HI CORCON))
  ]
  ""
  "@
   add %1,%2,%0\;addc %d1,%d2,%d0\;addc.b %t1,%t2,%t0\;bra nov,.L1_%=\;setm %0\;setm %d0\;mov.b #0x7F,%t0\;.L1_%=:
   add %0"
)

;(define_insn "sub<mode>3_dsp"
;  [(set (match_operand:AUACC    0 "pic30_accumulator2_operand" "=w")
;        (minus:AUACC
;           (match_dup 0)
;           (match_operand:AUACC 1 "pic30_accumulator2_operand" " w")))
;   (use (reg:HI CORCON))
;  ]
;  "(REGNO(operands[0]) != REGNO(operands[1]))"
;  "sub %0"
;)

(define_insn "sub<mode>3"
  [(set (match_operand:AUACC    0 "pic30_accum_or_mode1_operand" "=&r,>,r,>,r,R,R,w")
        (minus:AUACC
           (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    " r,r,r,r,r,r,r,0")
           (match_operand:AUACC 2 "pic30_accum_or_mode1_operand"  " r,r,>,>,R,r,R,w")))
   (use (reg:HI CORCON))
  ]
  ""
  "*
{
   const char *patterns[] = {
     \"sub %1,%2,%0\;subb %d1,%d2,%d0\;subb.b %t1,%t2,%t0\",
     \"sub %1,%2,%I0\;subb %d1,%d2,%I0\;subb %t1,%t2,%I0\",
     \"sub %1,%I2,%0\;subb %d1,%I2,%d0\;subb.b %t1,%I2,%t0\",
     \"sub %1,%I2,%I0\;subb %d1,%I2,%I0\;subb %t1,%I2,%I0\",
     \"sub %1,%I2,%0\;subb %d1,%I2,%d0\;subb %t1,%D2,%t0\;dec2 %r2,%r2\",
     \"sub %1,%2,%I0\;subb %d1,%d2,%I0\;subb %t1,%t2,%D0\;dec2 %r0,%r0\",
     \"sub %1,%I2,%I0\;subb %d1,%I2,%I0\;subb %t1,%D2,%D0\;dec2 %r0,%r0\;dec2 %r2,%r2\",
     \"sub %0\"
   };

   const char *psrd_psrd_patterns[] = {
     \"sub %1,%2,%0\;subb %d1,%d2,%d0\;subb.b %t1,%t2,%t0\",
     \"sub %1,%2,%I0\;subb %d1,%d2,%I0\;subb %t1,%t2,%I0\",
     \"sub %1,%I2,%0\;nop\;subb %d1,%I2,%d0\;nop\;subb.b %t1,%I2,%t0\",
     \"sub %1,%I2,%I0\;nop\;subb %d1,%I2,%I0\;nop\;subb %t1,%I2,%I0\",
     \"sub %1,%I2,%0\;nop\;subb %d1,%I2,%d0\;nop\;subb %t1,%D2,%t0\;dec2 %r2,%r2\",
     \"sub %1,%2,%I0\;subb %d1,%d2,%I0\;subb %t1,%t2,%D0\;dec2 %r0,%r0\",
     \"sub %1,%I2,%I0\;nop\;subb %d1,%I2,%I0\;nop\;subb %t1,%D2,%D0\;dec2 %r0,%r0\;dec2 %r2,%r2\",
     \"sub %0\"
   };
   
   if (pic30_psrd_psrd_errata(operands[2],NULL)) {
     pic30_rtx_nops+=2;
     return psrd_psrd_patterns[which_alternative];
   } else {
     return patterns[which_alternative];
   }
}"
)

;(define_insn "sssub<mode>3_dsp"
;  [(set (match_operand:AUACC    0 "pic30_accumulator2_operand" "=w")
;        (ss_minus:AUACC
;           (match_dup 0)
;           (match_operand:AUACC 1 "pic30_accumulator2_operand" " w")))
;   (use (reg:HI CORCON))
;  ]
;  "(REGNO(operands[0]) != REGNO(operands[1]))"
;  "sub %0"
;)

(define_insn "sssub<mode>3"
  [(set (match_operand:AUACC    0 "pic30_accum_or_reg_operand" "=&r,w")
        (ss_minus:AUACC
           (match_operand:AUACC 1 "pic30_accum_or_reg_operand"  " r,0")
           (match_operand:AUACC 2 "pic30_accum_or_reg_operand"  " r,w")))
   (use (reg:HI CORCON))
  ]
  ""
  "@
   sub %1,%2,%0\;subb %d1,%d2,%d0\;subb.b %t1,%t2,%t0\;bra nov,.L1_%=\;setm %0\;setm %d0\;mov.b #0x7F,%t0\;btst.c %t2,#7\;bra c,.L1_%=\;com.b %t0,%t0\;com %d0,%d0\;com %0,%0\;.L1_%=:
   sub %0"
)

;(define_insn "ussub<mode>3_dsp"
;  [(set (match_operand:AUACC    0 "pic30_accumulator2_operand" "=w")
;        (us_minus:AUACC
;           (match_dup 0)
;           (match_operand:AUACC 1 "pic30_accumulator2_operand" " w")))
;   (use (reg:HI CORCON))
;  ]
;  "(REGNO(operands[0]) != REGNO(operands[1]))"
;  "sub %0"
;)

(define_insn "ussub<mode>3"
  [(set (match_operand:AUACC    0 "pic30_accum_or_reg_operand" "=&r,w")
        (us_minus:AUACC
           (match_operand:AUACC 1 "pic30_accum_or_reg_operand"  " r,0")
           (match_operand:AUACC 2 "pic30_accum_or_reg_operand"  " r,w")))
   (use (reg:HI CORCON))
  ]
  ""
  "@
   sub %1,%2,%0\;subb %d1,%d2,%d0\;subb.b %t1,%t2,%t0\;bra nn,.L1_%=\;mul.uu %0,#0,%0\;clr.b %t0\;.L1_%=:
   sub %0"
)

;; multiply of accumulators, ie 8.31*8.31 will be handled by a function

; widening multiply/ multiply accumulate

(define_insn "muluqq<mode>3"
  [(set (match_operand:AUACC   0 "pic30_accumulator2_operand" "=w")
        (mult:AUACC
          (fract_convert:AUACC
            (match_operand:UQQ 1 "pic30_mac_input_operand"     "z"))
          (fract_convert:AUACC
            (match_operand:UQQ 2 "pic30_mac_input_operand"     "z"))))
   (use (reg:HI CORCON))
  ]
  ""
  "mpy %1,%2,%0"
)

(define_insn "mulqq<mode>3"
  [(set (match_operand:AUACC   0 "pic30_accumulator2_operand" "=w")
        (mult:AUACC
          (fract_convert:AUACC
            (match_operand:QQ  1 "pic30_mac_input_operand"     "z"))
          (fract_convert:AUACC
            (match_operand:QQ  2 "pic30_mac_input_operand"     "z"))))
   (use (reg:HI CORCON))
  ]
  ""
  "mpy %1*%2,%0"
)

(define_insn "umadduqq<mode>4"
  [(set (match_operand:AUACC       0 "pic30_accumulator2_operand" "=w")
        (plus:AUACC 
           (match_operand:AUACC    3 "pic30_accumulator2_operand" " 0")
           (mult:AUACC 
              (fract_convert:AUACC
                (match_operand:UQQ 1 "pic30_mac_input_operand"     "z"))
              (fract_convert:AUACC
                (match_operand:UQQ 2 "pic30_mac_input_operand"     "z")))))

   (use (reg:HI CORCON))
  ]
  ""
  "mac %1*%2,%0"
)

(define_insn "maddqq<mode>4"
  [(set (match_operand:AUACC      0 "pic30_accumulator2_operand" "=w")
        (plus:AUACC 
           (match_operand:AUACC   3 "pic30_accumulator2_operand" " 0")
           (mult:AUACC 
              (fract_convert:AUACC
                (match_operand:QQ 1 "pic30_mac_input_operand"     "z"))
              (fract_convert:AUACC
                (match_operand:QQ 2 "pic30_mac_input_operand"     "z")))))
   (use (reg:HI CORCON))
  ]
  ""
  "mac %1*%2,%0"
)

(define_insn "umaddhisi4"
  [(set (match_operand:SI          0 "pic30_accumulator2_operand" "=w")
        (plus:SI
           (match_operand:SI       3 "pic30_accumulator2_operand" " 0")
           (mult:SI
              (zero_extend:SI
                (match_operand:HI  1 "pic30_mac_input_operand"     "z"))
              (zero_extend:SI
                (match_operand:HI  2 "pic30_mac_input_operand"     "z")))))

   (use (reg:HI CORCON))
  ]
  "pic30_integer_mac_support"
  "mac %1*%2,%0"
)

(define_insn "maddhisi4"
  [(set (match_operand:SI         0 "pic30_accumulator2_operand" "=w")
        (plus:SI
           (match_operand:SI      3 "pic30_accumulator2_operand" " 0")
           (mult:SI
              (sign_extend:SI
                (match_operand:HI 1 "pic30_mac_input_operand"     "z"))
              (sign_extend:SI
                (match_operand:HI 2 "pic30_mac_input_operand"     "z")))))
   (use (reg:HI CORCON))
  ]
  "pic30_integer_mac_support"
  "mac %1*%2,%0"
)

(define_insn "umsubuqq<mode>4"
  [(set (match_operand:AUACC       0 "pic30_accumulator2_operand" "=w")
        (minus:AUACC 
           (match_operand:AUACC    3 "pic30_accumulator2_operand" " 0")
           (mult:AUACC 
              (fract_convert:AUACC
                (match_operand:UQQ 1 "pic30_mac_input_operand"     "z"))
              (fract_convert:AUACC
                (match_operand:UQQ 2 "pic30_mac_input_operand"     "z")))))

   (use (reg:HI CORCON))
  ]
  ""
  "msc %1*%2,%0"
)

(define_insn "msubqq<mode>4"
  [(set (match_operand:AUACC      0 "pic30_accumulator2_operand" "=w")
        (minus:AUACC 
           (match_operand:AUACC   3 "pic30_accumulator2_operand" " 0")
           (mult:AUACC 
              (fract_convert:AUACC
                (match_operand:QQ 1 "pic30_mac_input_operand"     "z"))
              (fract_convert:AUACC
                (match_operand:QQ 2 "pic30_mac_input_operand"     "z")))))
   (use (reg:HI CORCON))
  ]
  ""
  "msc %1*%2,%0"
)

;; negate

(define_insn "neg<mode>2"
  [(set (match_operand:ACC   0 "pic30_accum_or_reg_operand" "=w,&r")
        (neg:ACC
          (match_operand:ACC 1 "pic30_accum_or_reg_operand" " 0,r")))
   (use (reg:HI CORCON))]
  ""
  "@
   neg %0
   subr %1,#0,%0\;subbr %d1,#0,%d0\;subbr.b %t1,#0,%t0"
  [
    (set_attr "cc" "math")
  ]
)

(define_insn "ssneg<mode>2"
  [(set (match_operand:ACC   0 "pic30_accum_or_reg_operand" "=w,&r")
        (ss_neg:ACC
          (match_operand:ACC 1 "pic30_accum_or_reg_operand" " 0,r")))
   (use (reg:HI CORCON))
  ]
  ""
  "@
   neg %0
   subr %1,#0,%0\;subbr %d1,#0,%d0\;subbr.b %t1,#0,%t0\;bra nov,.L1_%=\;setm %0\;setm %d0\;mov.b #0x7F,%t0\;btst.c %t1,#7\;bra c,.L1_%=\;com %0,%0\;com %d0,%d0\;com.b %t0,%t0\n.L1_%=:"
  [
    (set_attr "cc" "math")
  ]
)
(define_insn "usneg<mode>2"
  [(set (match_operand:ACC   0 "pic30_accum_or_reg_operand" "=w,&r")
        (us_neg:ACC
          (match_operand:ACC 1 "pic30_accum_or_reg_operand" " 0,r")))
   (use (reg:HI CORCON))
  ]
  ""
  "@
   neg %0
   subr %1,#0,%0\;subbr %d1,#0,%d0\;subbr.b %t1,#0,%t0\;bra nov,.L1_%=\;setm %0\;setm %d0\;mov.b #0x7F,%t0\n.L1_%=:"
  [
    (set_attr "cc" "math")
  ]
)

;; shift

; sftac can only shift +-16 for some unfathomable reason
; this might be better handled in a library fn

(define_insn "ashl<mode>3_imm15"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"  "=w,&r")
        (ashift:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "0,r")
          (match_operand:HI    2 "immediate_operand"             "i,i")))
   (clobber (match_scratch:HI  3                               "=X,&r"))
   (use (reg:HI CORCON))
  ]
  "((INTVAL(operands[2]) > 0) && (INTVAL(operands[2]) < 16))"
  "@
   sftac %0,#%J2
   sl %t1,#%2,%t0\;lsr %d1,#%k2,%3\;ior.b %3,%t0,%t0\;sl %d1,#%2,%d0\;lsr %1,#%k2,%3\;ior %3,%d0,%d0\;sl %1,#%2,%0"
  [
   (set_attr "cc" "clobber")
  ]
)

(define_insn "ashl<mode>3_imm16to31"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"  "=w,&r")
        (ashift:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "0,r")
          (match_operand:HI    2 "immediate_operand"             "i,i")))
   (clobber (match_scratch:HI  3                               "=X,&r"))
   (use (reg:HI CORCON))
  ]
  "((INTVAL(operands[2]) > 15) && (INTVAL(operands[2]) < 31))"
  "@
   sftac %0,#-16\;sftac %0,#-(%2-16)
   sl %d1,#(%2-16),%t0\;lsr %0,#(32-%2),%3\;ior.b %3,%t0,%t0\;sl %0,#(%2-16),%d0\;clr %0"
  [
   (set_attr "cc" "clobber")
  ]
)

(define_insn "ashl<mode>3_imm32to39"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"  "=w,&r")
        (ashift:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "0,r")
          (match_operand:HI    2 "immediate_operand"             "i,i")))
   (clobber (match_scratch:HI  3                               "=X,&r"))
   (use (reg:HI CORCON))
  ]
  "((INTVAL(operands[2]) > 31) && (INTVAL(operands[2]) < 40))"
  "@
   sftac %0,#-16\;sftac %0,#-16\;sftac %0,-#(%2-32)
   sl %1,#(%2-32),%t0\;mul.uu %0,#0,%0"
  [
   (set_attr "cc" "clobber")
  ]
)

(define_insn "ashl<mode>3_gen"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"   "=w,&r")
        (ashift:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "0,0")
          (match_operand:HI    2 "pic30_register_operand"        "r,r")))
   (clobber (match_scratch:HI  3                                "=2,2"))
   (use (reg:HI CORCON))
  ]
  ""
  "@
   .LB%=:\;dec %2,%2\;bra n,.LE%=\;repeat %2\;sftac %1,#-1\n.LE%=:
   .LB%=:\;dec %2,%2\;bra n,.LE%=\;add %1,%1,%0\;addc %d1,%d1,%d0\;addc.b %t1,%t1,%t0\;bra .LB%=\n.LE%=:"
  [
   (set_attr "cc" "clobber")
  ]
)

(define_expand "ashl<mode>3"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"   "=w,r")
        (ashift:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "w,r")
          (match_operand:HI    2 "pic30_reg_or_imm_operand"      "ri,ri")))
  ]
  ""
  "
  {
    if (immediate_operand(operands[2],VOIDmode)) {
      HOST_WIDE_INT shiftval = INTVAL(operands[2]); 
      if (shiftval < 16) {
        emit(
          gen_ashl<mode>3_imm15(operands[0], operands[1], operands[2])
        );
      } else if (shiftval < 32) {
        emit(
          gen_ashl<mode>3_imm16to31(operands[0], operands[1], operands[2])
        );
      } else if (shiftval < 39) {
        emit(
          gen_ashl<mode>3_imm32to39(operands[0], operands[1], operands[2])
        );
      } else {
        emit(
          gen_mov<mode>(operands[0], GEN_INT(0))
        );
      }
      DONE;
    } else {
      emit(
        gen_ashl<mode>3_gen(operands[0], operands[1], operands[2])
      );
      DONE;
    }
  }
  "
)

; ss arithmetic shift left

(define_insn "ssashl<mode>3_imm15"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"  "=w,&r")
        (ss_ashift:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "0,r")
          (match_operand:HI    2 "immediate_operand"             "i,i")))
   (clobber (match_scratch:HI  3                               "=X,&r"))
   (use (reg:HI CORCON))
  ]
  "((INTVAL(operands[2]) > 0) && (INTVAL(operands[2]) < 16))"
  "@
   sftac %0,#%J2
   sl %t1,#%2,%t0\;lsr %d1,#%k2,%3\;ior.b %3,%t0,%t0\;sl %d1,#%2,%d0\;lsr %1,#%k2,%3\;ior %3,%d0,%d0\;sl %1,#%2,%0\;xor %t0,%t1,%3\;btss %3,#7\;bra .LE%=\;mov.b #0x7f,%t0\;setm %d0\;setm %0\;btsc %t1,#7\;bset %t0,#7\;.LE%=:"
  [
   (set_attr "cc" "clobber")
  ]
)

(define_insn "ssashl<mode>3_imm16to31"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"  "=w,&r")
        (ss_ashift:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "0,r")
          (match_operand:HI    2 "immediate_operand"             "i,i")))
   (clobber (match_scratch:HI  3                               "=X,&r"))
   (use (reg:HI CORCON))
  ]
  "((INTVAL(operands[2]) > 15) && (INTVAL(operands[2]) < 31))"
  "@
   sftac %0,#-16\;sftac %0,#-(%2-16)
   sl %d1,#(%2-16),%t0\;lsr %0,#(32-%2),%3\;ior.b %3,%t0,%t0\;sl %0,#(%2-16),%d0\;clr %0\;xor %t0,%t1,%3\;btss %3,#7\;bra .LE%=\;mov.b #0x7f,%t0\;setm %d0\;setm %0\;btsc %t1,#7\;bset %t0,#7\;.LE%=:"
  [
   (set_attr "cc" "clobber")
  ]
)

(define_insn "ssashl<mode>3_imm32to39"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"  "=w,&r")
        (ss_ashift:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "0,r")
          (match_operand:HI    2 "immediate_operand"             "i,i")))
   (clobber (match_scratch:HI  3                               "=X,&r"))
   (use (reg:HI CORCON))
  ]
  "((INTVAL(operands[2]) > 31) && (INTVAL(operands[2]) < 40))"
  "@
   sftac %0,#-16\;sftac %0,#-16\;sftac %0,-#(%2-32)
   sl %1,#(%2-32),%t0\;mul.uu %0,#0,%0\;xor %t0,%t1,%3\;btss %3,#7\;bra .LE%=\;mov.b #0x7f,%t0\;setm %d0\;setm %0\;btsc %t1,#7\;bset %t0,#7\;.LE%=:"
  [
   (set_attr "cc" "clobber")
  ]
)

(define_insn "ssashl<mode>3_imm40"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"  "=w,&r")
        (ss_ashift:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "0,r")
          (match_operand:HI    2 "immediate_operand"             "i,i")))
   (clobber (match_scratch:HI  3                               "=X,&r"))
   (use (reg:HI CORCON))
  ]
  "(INTVAL(operands[2]) == 40)"
  "@
   sftac %0,#-16\;sftac %0,#-16\;sftac %0,-#(%2-32)
   mov.b #0x7f,%t0\;setm %d0\;setm %0\;btsc %t1,#7\;bset %t0,#7"
  [
   (set_attr "cc" "clobber")
  ]
)


(define_insn "ssashl<mode>3_gen"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"   "=w,&r")
        (ss_ashift:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "0,r")
          (match_operand:HI    2 "pic30_register_operand"        "r,r")))
   (clobber (match_scratch:HI  3                                "=2,2"))
   (use (reg:HI CORCON))
  ]
  ""
  "@
   .LB%=:\;dec %2,%2\;bra n,.LE%=\;repeat %2\;sftac %1,#-1\n.LE%=:
   mov.d %1,%0\;mov.b %t1,%t0\;.LB%=:\;dec %2,%2\;bra n,.LE%=\;add %0,%0,%0\;addc %d0,%d0,%d0\;addc.b %t0,%t0,%t0\;bra nov,.LB%=\;mov.b #0x7F,%t0\;btsc %t1,#7\;com.b %t0,%t0\;sl %t0,#9,%d0\;asr %d0,#15,%d0\;asr %d0,#15,%0\n.LE%=:"
  [
   (set_attr "cc" "clobber")
  ]
)

(define_expand "ssashl<mode>3"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"   "=w,r")
        (ss_ashift:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "w,r")
          (match_operand:HI    2 "pic30_reg_or_imm_operand"      "ri,ri")))
  ]
  ""
  "
  {
    if (immediate_operand(operands[2],VOIDmode)) {
      HOST_WIDE_INT shiftval = INTVAL(operands[2]); 
      if (shiftval < 16) {
        emit(
          gen_ssashl<mode>3_imm15(operands[0], operands[1], operands[2])
        );
      } else if (shiftval < 32) {
        emit(
          gen_ssashl<mode>3_imm16to31(operands[0], operands[1], operands[2])
        );
      } else if (shiftval < 39) {
        emit(
          gen_ssashl<mode>3_imm32to39(operands[0], operands[1], operands[2])
        );
      } else {
        emit(
          gen_ssashl<mode>3_imm40(operands[0], operands[1], GEN_INT(40))
        );
      }
      DONE;
    } else {
      emit(
        gen_ssashl<mode>3_gen(operands[0], operands[1], operands[2])
      );
      DONE;
    }
  }
  "
)

; us arithmetic shift left

(define_insn "usashl<mode>3_imm"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"  "=w,&r")
        (us_ashift:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "0,r")
          (match_operand:HI    2 "immediate_operand"             "i,i")))
   (clobber (match_scratch:HI  3                               "=X,&r"))
   (use (reg:HI CORCON))
  ]
  "((INTVAL(operands[2]) > 0) && (INTVAL(operands[2]) <= 16))"
  "@
   sftac %0,#%J2
   sl %t1,#%2,%t0\;lsr %d1,#%k2,%3\;ior.b %3,%t0,%t0\;sl %d1,#%2,%d0\;lsr %1,#%k2,%3\;ior %3,%d0,%d0\;sl %1,#%2,%0\;xor %t0,%t1,%3\;btss %3,#7\;bra .LE%=\;mov.b #0x7f,%t0\;setm %d0\;setm %0\;.LE%=:"

  [
   (set_attr "cc" "clobber")
  ]
)

(define_insn "usashl<mode>3_imm15"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"  "=w,&r")
        (us_ashift:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "0,r")
          (match_operand:HI    2 "immediate_operand"             "i,i")))
   (clobber (match_scratch:HI  3                               "=X,&r"))
   (use (reg:HI CORCON))
  ]
  "((INTVAL(operands[2]) > 0) && (INTVAL(operands[2]) < 16))"
  "@
   sftac %0,#%J2
   sl %t1,#%2,%t0\;lsr %d1,#%k2,%3\;ior.b %3,%t0,%t0\;sl %d1,#%2,%d0\;lsr %1,#%k2,%3\;ior %3,%d0,%d0\;sl %1,#%2,%0\;xor %t0,%t1,%3\;btss %3,#7\;bra .LE%=\;mov.b #0x7f,%t0\;setm %d0\;setm %0\;.LE%=:"
  [
   (set_attr "cc" "clobber")
  ]
)

(define_insn "usashl<mode>3_imm16to31"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"  "=w,&r")
        (us_ashift:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "0,r")
          (match_operand:HI    2 "immediate_operand"             "i,i")))
   (clobber (match_scratch:HI  3                               "=X,&r"))
   (use (reg:HI CORCON))
  ]
  "((INTVAL(operands[2]) > 15) && (INTVAL(operands[2]) < 31))"
  "@
   sftac %0,#-16\;sftac %0,#-(%2-16)
   sl %d1,#(%2-16),%t0\;lsr %0,#(32-%2),%3\;ior.b %3,%t0,%t0\;sl %0,#(%2-16),%d0\;clr %0\;xor %t0,%t1,%3\;btss %3,#7\;bra .LE%=\;mov.b #0x7f,%t0\;setm %d0\;setm %0\;.LE%=:"
  [
   (set_attr "cc" "clobber")
  ]
)

(define_insn "usashl<mode>3_imm32to39"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"  "=w,&r")
        (us_ashift:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "0,r")
          (match_operand:HI    2 "immediate_operand"             "i,i")))
   (clobber (match_scratch:HI  3                               "=X,&r"))
   (use (reg:HI CORCON))
  ]
  "((INTVAL(operands[2]) > 31) && (INTVAL(operands[2]) < 40))"
  "@
   sftac %0,#-16\;sftac %0,#-16\;sftac %0,-#(%2-32)
   sl %1,#(%2-32),%t0\;mul.uu %0,#0,%0\;xor %t0,%t1,%3\;btss %3,#7\;bra .LE%=\;mov.b #0x7f,%t0\;setm %d0\;setm %0\;.LE%=:"
  [
   (set_attr "cc" "clobber")
  ]
)

(define_insn "usashl<mode>3_imm40"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"  "=w,&r")
        (us_ashift:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "0,r")
          (match_operand:HI    2 "immediate_operand"             "i,i")))
   (clobber (match_scratch:HI  3                               "=X,&r"))
   (use (reg:HI CORCON))
  ]
  "(INTVAL(operands[2]) == 40)"
  "@
   sftac %0,#-16\;sftac %0,#-16\;sftac %0,-#(%2-32)
   mov.b #0x7f,%t0\;setm %d0\;setm %0"
  [
   (set_attr "cc" "clobber")
  ]
)

(define_insn "usashl<mode>3_gen"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"   "=w,&r")
        (us_ashift:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "0,r")
          (match_operand:HI    2 "pic30_register_operand"        "r,r")))
   (clobber (match_scratch:HI  3                                "=2,2"))
   (use (reg:HI CORCON))
  ]
  ""
  "@
   dec %2,%2\;bra n,.LE%=\;repeat %2\;sftac %1,#-1\n.LE%=:
   mov.d %1,%0\;mov.b %t1,%t0\;.LB%=:\;dec %2,%2\;bra n,.LE%=\;add %0,%0,%0\;addc %d0,%d0,%d0\;addc.b %t0,%t0,%t0\;bra nov,.LB%=\;mov.b #0x7F,%t0\;setm %d0\;setm %0\n.LE%=:"
  [
   (set_attr "cc" "clobber")
  ]
)

(define_expand "usashl<mode>3"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"   "=w,r")
        (us_ashift:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "w,r")
          (match_operand:HI    2 "pic30_reg_or_imm_operand"      "ri,ri")))
  ]
  ""
  "
  {
    if (immediate_operand(operands[2],VOIDmode)) {
      HOST_WIDE_INT shiftval = INTVAL(operands[2]); 
      if (shiftval < 16) {
        emit(
          gen_usashl<mode>3_imm15(operands[0], operands[1], operands[2])
        );
      } else if (shiftval < 32) {
        emit(
          gen_usashl<mode>3_imm16to31(operands[0], operands[1], operands[2])
        );
      } else if (shiftval < 39) {
        emit(
          gen_usashl<mode>3_imm32to39(operands[0], operands[1], operands[2])
        );
      } else {
        emit(
          gen_usashl<mode>3_imm40(operands[0], operands[1], GEN_INT(40))
        );
      }
      DONE;
    } else {
      emit(
        gen_usashl<mode>3_gen(operands[0], operands[1], operands[2])
      );
      DONE;
    }
  }
  "
)

; logical shift right 

(define_insn "lshr<mode>3_imm"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"  "=w,&r")
        (lshiftrt:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "0,r")
          (match_operand:HI    2 "immediate_operand"             "i,i")))
   (clobber (match_scratch:HI  3                               "=X,&r"))
   (use (reg:HI CORCON))
  ]
  "((INTVAL(operands[2]) > 0) && (INTVAL(operands[2]) <= 16))"
  "@
   sftac %0,#%2
   lsr %1,#%2,%0\;sl %d1,#%k2,%3\;ior %3,%0,%0\;lsr %d1,#%2,%d0\;sl %t1,#%k2,%3\;ior %3,%d0,%d0\;mov %t1,%t0\;and #0xFF,%t0\;lsr %t0,#%2,%t0"
  [
   (set_attr "cc" "clobber")
  ]
)

(define_insn "lshr<mode>3_imm15"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"  "=w,&r")
        (lshiftrt:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "0,r")
          (match_operand:HI    2 "immediate_operand"             "i,i")))
   (clobber (match_scratch:HI  3                               "=X,&r"))
   (use (reg:HI CORCON))
  ]
  "((INTVAL(operands[2]) > 0) && (INTVAL(operands[2]) <= 15))"
  "@
   sftac %0,#%2
   lsr %1,#%2,%0\;sl %d1,#%k2,%3\;ior %3,%0,%0\;lsr %d1,#%2,%d0\;sl %t1,#%k2,%3\;ior %3,%d0,%d0\;mov %t1,%t0\;and #0xFF,%t0\;lsr %t0,#%2,%t0"
  [
   (set_attr "cc" "clobber")
  ]
)

(define_insn "lshr<mode>3_imm16to31"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"  "=w,&r")
        (lshiftrt:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "0,r")
          (match_operand:HI    2 "immediate_operand"             "i,i")))
   (clobber (match_scratch:HI  3                               "=X,&r"))
   (use (reg:HI CORCON))
  ]
  "((INTVAL(operands[2]) > 15) && (INTVAL(operands[2]) <= 31))"
  "@
   sftac %0,#16\;sftac %0,#(%2-16)
   lsr %d1,#(%2-16),%0\;sl %t1,#(32-%2),%3\;ior %3,%0,%0\;lsr %t1,#(%2-16),%d0\;\;and #0x7F,%d0\;clr.b %t0"
  [
   (set_attr "cc" "clobber")
  ]
)

(define_insn "lshr<mode>3_imm32to39"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"  "=w,&r")
        (lshiftrt:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "0,r")
          (match_operand:HI    2 "immediate_operand"             "i,i")))
   (clobber (match_scratch:HI  3                               "=X,&r"))
   (use (reg:HI CORCON))
  ]
  "((INTVAL(operands[2]) > 31) && (INTVAL(operands[2]) <= 39))"
  "@
   sftac %0,#16\;sftac %0,#16\;sftac %0,#(%2-32)
   lsr %t1,#(%2-32),%0\;and #0x7f,%0\;clr %d0\;clr.b %t0"
  [
   (set_attr "cc" "clobber")
  ]
)

(define_insn "lshr<mode>3_gen"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"   "=w,&r")
        (lshiftrt:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "0,0")
          (match_operand:HI    2 "pic30_register_operand"        "r,r")))
   (clobber (match_scratch:HI  3                                "=2,2"))
   (use (reg:HI CORCON))
  ]
  ""
  "@
   .LB%=:\;dec %2,%2\;bra n,.LE%=\;sftac %1,#1\;bra .LB%=\n.LE%=:
   .LB%=:\;dec %2,%2\;bra n,.LE%=\;lsr.b %t1,%t0\;rrc %d1,%d0\;rrc %1,%0\;bra .LB%=\n.LE%=:"
  [
   (set_attr "cc" "clobber")
  ]
)

(define_expand "lshr<mode>3"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"   "=w,r")
        (lshiftrt:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "w,r")
          (match_operand:HI    2 "pic30_reg_or_imm_operand"      "ri,ri")))
  ]
  ""
  "
  {
    if (pic30_fp_round_p() == pic30_conventional) FAIL;
    if (pic30_fp_round_p() == pic30_convergent) FAIL;
    /* truncation or fastest */
    if (immediate_operand(operands[2],VOIDmode)) {
      HOST_WIDE_INT shiftval = INTVAL(operands[2]); 
      if (shiftval < 16) {
        emit(
          gen_lshr<mode>3_imm15(operands[0], operands[1], operands[2])
        );
      } else if (shiftval < 32) {
        emit(
          gen_lshr<mode>3_imm16to31(operands[0], operands[1], operands[2])
        );
      } else if (shiftval < 39) {
        emit(
          gen_lshr<mode>3_imm32to39(operands[0], operands[1], operands[2])
        );
      } else {
        emit(
          gen_mov<mode>(operands[0], GEN_INT(0))
        );
      }
      DONE;
    } else {
      emit(
        gen_lshr<mode>3_gen(operands[0], operands[1], operands[2])
      );
      DONE;
    }
  }
  "
)

; arithemetic shift right

(define_insn "ashr<mode>3_gen"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"   "=w,&r")
        (ashiftrt:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "0,0")
          (match_operand:HI    2 "pic30_register_operand"        "r,r")))
   (clobber (match_scratch:HI  3                                "=2,2"))
   (use (reg:HI CORCON))
  ]
  ""
  "@
   dec %2,%2\;repeat %2\;sftac %1,#1
   .LB%=:\;dec %2,%2\;bra n,.LE%=\;asr.b %t1,%t0\;rrc %d1,%d0\;rrc %1,%0\;bra .LB%=\n.LE%=:"
  [
   (set_attr "cc" "clobber")
  ]
)

(define_expand "ashr<mode>3"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"   "=w,r")
        (ashiftrt:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "w,r")
          (match_operand:HI    2 "pic30_register_operand"        "r,r")))
  ]
  ""
  "
  {
    if (pic30_fp_round_p() == pic30_conventional) {
      FAIL;
    } else if (pic30_fp_round_p() == pic30_convergent) {
      FAIL;
    } else {
      emit(
        gen_ashr<mode>3_gen(operands[0], operands[1], operands[2])
      );
      DONE;
    } 
    FAIL;
  }
  "
)

;; compare

(define_insn "cmp<mode>_helper"
  [(set (cc0)
        (compare 
          (match_operand:AUACC 0 "pic30_accum_or_reg_operand" "w,r")
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand" "w,r")))
   (clobber (match_scratch:HI  2                             "=&a,X"))
  ]
  "" 
  "@
   mov %m1L,w0\;cp %m0L\;mov %m1H,w0\;cpb %m0H\;mov %m1U,w0\;cpb.b %m0U
   cp %0,%1\;cpb %d0,%d1\;cpb.b %t0,%t1"
  [
    (set_attr "cc" "set,set")
  ]
)

(define_expand "cmp<mode>"
  [(set (cc0)
        (compare 
          (match_operand:AUACC 0 "" "w,r")
          (match_operand:AUACC 1 "" "w,r")))
   (clobber (match_scratch:HI  2  "=&a,X"))
  ]
  "" 
  "
  {
    rtx op0, op1;
    op0 = operands[0];
    op1 = operands[1];

    if (!pic30_accum_or_reg_operand(op0, <MODE>mode)) {
      op0 = force_reg(<MODE>mode,op0);
    }
    if (!pic30_accum_or_reg_operand(op1, <MODE>mode)) {
      op1 = force_reg(<MODE>mode,op1);
    }
    emit(
      gen_cmp<mode>_helper(op0,op1)
    );
    DONE;
  }"
)

;; Accum / fract conversions
;  to Q15

(define_insn "fract<mode>qq2_trunc"
  [(set (match_operand:QQ      0 "pic30_register_operand"     "=r,r")
        (fract_convert:QQ
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand" " w,r")))]
  ""
  "@
   sac %1,%0
   mov %d1,%0"
)
  
(define_insn "fract<mode>uqq2_trunc"
  [(set (match_operand:UQQ      0 "pic30_register_operand"     "=r,r")
        (fract_convert:UQQ
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand" " w,r")))]
  ""
  "@
   sac %1,%0
   mov %d1,%0"
)
  
(define_insn "fract<mode>hq2_trunc"
  [(set (match_operand:HQ      0 "pic30_register_operand"     "=r,r")
        (fract_convert:HQ
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand" " w,r")))]
  ""
  "@
   sac %1,%0
   mov %d1,%0"
)
  
(define_insn "fract<mode>uhq2_trunc"
  [(set (match_operand:UHQ      0 "pic30_register_operand"     "=r,r")
        (fract_convert:UHQ
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand" " w,r")))]
  ""
  "@
   sac %1,%0
   mov %d1,%0"
)

(define_insn "fract<mode>qq2_conv"
  [(set (match_operand:QQ      0 "pic30_register_operand"    "=r, &r")
        (fract_convert:QQ
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand" "w, r")))
   (clobber (match_scratch:HI  2                             "=X,&r"))
   (use (reg:HI CORCON))
  ]
  ""
  "*
   if (pic30_fp_round_p() == pic30_conventional) {
     switch (which_alternative) {
       case 0: return \"sac.r %1,%0\";
       case 1: return \"mov %d1,%0\;btsc %1,#15\;inc %0,%0\";
       default: gcc_assert(0);
     }
   } else if (pic30_fp_round_p() == pic30_convergent) {
     switch (which_alternative) {
       case 0: return \"sac.r %1,%0\";
       case 1: return \"mov %d1,%0\;sl %1,%2\;bra nz,.LINC%=\;btsc %0,#0\n.LINC%=:addc %0,#0,%0\";
       default: gcc_assert(0);
     }
   }
   error(\"Cannot generate instruction\");
   return \"cannot generate instruction\";
  "
)

(define_insn "fract<mode>uqq2_conv"
  [(set (match_operand:UQQ     0 "pic30_register_operand"     "=r,&r")
        (fract_convert:UQQ
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand" " w, r")))
   (clobber (match_scratch:HI  2                              "=X,&r"))
   (use (reg:HI CORCON))
  ]
  ""
  "*
   if (pic30_fp_round_p() == pic30_conventional) {
     switch (which_alternative) {
       case 0: return \"sac.r %1,%0\";
       case 1: return \"mov %d1,%0\;btsc %1,#15\;inc %0,%0\";
       default: gcc_assert(0);
     }
   } else if (pic30_fp_round_p() == pic30_convergent) {
     switch (which_alternative) {
       case 0: return \"sac.r %1,%0\";
       case 1: return \"mov %d1,%0\;sl %1,%2\;bra nz,.LINC%=\;btsc %0,#0\n.LINC%=:addc %0,#0,%0\";
       default: gcc_assert(0);
     }
   }
   error(\"Cannot generate instruction\");
   return \"cannot generate instruction\";
  "
)

(define_insn "fract<mode>hq2_conv"
  [(set (match_operand:HQ      0 "pic30_register_operand"     "=r,&r")
        (fract_convert:HQ
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand" " w, r")))
   (clobber (match_scratch:HI  2                              "=X,&r"))
   (use (reg:HI CORCON))
  ]
  ""
  "*
   if (pic30_fp_round_p() == pic30_conventional) {
     switch (which_alternative) {
       case 0: return \"sac.r %1,%0\";
       case 1: return \"mov %d1,%0\;btsc %1,#15\;inc %0,%0\";
       default: gcc_assert(0);
     }
   } else if (pic30_fp_round_p() == pic30_convergent) {
     switch (which_alternative) {
       case 0: return \"sac.r %1,%0\";
       case 1: return \"mov %d1,%0\;sl %1,%2\;bra nz,.LINC%=\;btsc %0,#0\n.LINC%=:addc %0,#0,%0\";
       default: gcc_assert(0);
     }
   }
   error(\"Cannot generate instruction\");
   return \"cannot generate instruction\";
  "
)

(define_insn "fract<mode>uhq2_conv"
  [(set (match_operand:UHQ     0 "pic30_register_operand"    "=r,&r")
        (fract_convert:UHQ
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand" "w, r")))
   (clobber (match_scratch:HI  2                             "=X,&r"))
   (use (reg:HI CORCON))
  ]
  ""
  "*
   if (pic30_fp_round_p() == pic30_conventional) {
     switch (which_alternative) {
       case 0: return \"sac.r %1,%0\";
       case 1: return \"mov %d1,%0;btsc %1,#15\;inc %0,%0\";
       default: gcc_assert(0);
     }
   } else if (pic30_fp_round_p() == pic30_convergent) {
     switch (which_alternative) {
       case 0: return \"sac.r %1,%0\";
       case 1: return \"mov %d1,%0\;sl %1,%2\;bra nz,.LINC%=\;btsc %0,#0\n.LINC%=:addc %0,#0,%0\";
       default: gcc_assert(0);
     }
   }
   error(\"Cannot generate instruction\");
   return \"cannot generate instruction\";
  "
)

(define_expand "fract<mode>qq2"
  [(set (match_operand:QQ    0 "pic30_register_operand"    "=r,r")
      (fract_convert:QQ
        (match_operand:AUACC 1 "pic30_accum_or_reg_operand" "w,r")))
  ]
  ""
  "
  {
    switch (pic30_fp_round_p()) {
      default: gcc_assert(0);

      case pic30_truncation:
      case pic30_fastest:
        emit(
          gen_fract<mode>qq2_trunc(operands[0],operands[1])
        );
        DONE;
        break;
      case pic30_convergent:
      case pic30_conventional:
        emit(
          gen_fract<mode>qq2_conv(operands[0],operands[1])
        );
        DONE;
        break;
    }
    FAIL;
  }
  "
)   

(define_expand "fract<mode>uqq2"
  [(set (match_operand:UQQ   0 "pic30_register_operand"    "=r,r")
      (fract_convert:UQQ
        (match_operand:AUACC 1 "pic30_accum_or_reg_operand" "w,r")))
  ]
  ""
  "
  {
    switch (pic30_fp_round_p()) {
      default: gcc_assert(0);

      case pic30_truncation:
      case pic30_fastest:
        emit(
          gen_fract<mode>uqq2_trunc(operands[0],operands[1])
        );
        DONE;
        break;
      case pic30_convergent:
      case pic30_conventional:
        emit(
          gen_fract<mode>uqq2_conv(operands[0],operands[1])
        );
        DONE;
        break;
    }
    FAIL;
  }
  "
)   

(define_expand "fract<mode>hq2"
  [(set (match_operand:HQ    0 "pic30_register_operand"    "=r,r")
      (fract_convert:QQ
        (match_operand:AUACC 1 "pic30_accum_or_reg_operand" "w,r")))
  ]
  ""
  "
  {
    switch (pic30_fp_round_p()) {
      default: gcc_assert(0);

      case pic30_truncation:
      case pic30_fastest:
        emit(
          gen_fract<mode>hq2_trunc(operands[0],operands[1])
        );
        DONE;
        break;
      case pic30_convergent:
      case pic30_conventional:
        emit(
          gen_fract<mode>hq2_conv(operands[0],operands[1])
        );
        DONE;
        break;
    }
    FAIL;
  }
  "
)   

(define_expand "fract<mode>uhq2"
  [(set (match_operand:UHQ   0 "pic30_register_operand"    "=r,r")
      (fract_convert:UHQ
        (match_operand:AUACC 1 "pic30_accum_or_reg_operand" "w,r")))
  ]
  ""
  "
  {
    switch (pic30_fp_round_p()) {
      default: gcc_assert(0);

      case pic30_truncation:
      case pic30_fastest:
        emit(
          gen_fract<mode>uhq2_trunc(operands[0],operands[1])
        );
        DONE;
        break;
      case pic30_convergent:
      case pic30_conventional:
        emit(
          gen_fract<mode>uhq2_conv(operands[0],operands[1])
        );
        DONE;
        break;
    }
    FAIL;
  }
  "
)   

; to Q31

(define_insn "fract<mode>sq2"
  [(set (match_operand:SQ      0 "pic30_register_operand"     "=r,r")
        (fract_convert:SQ
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand" " w,r")))]
  ""
  "@
   mov %m1L,%0\;mov %m1H,%d0
   mov.d %1,%0"
)
 
(define_insn "fract<mode>usq2"
  [(set (match_operand:USQ      0 "pic30_register_operand"     "=r,r")
        (fract_convert:USQ
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand" " w,r")))]
  ""
  "@
   mov %m1L,%0\;mov %m1H,%d0
   mov.d %1,%0"
)

(define_insn "fract<mode>dq2"
  [(set (match_operand:DQ      0 "pic30_register_operand"     "=r,r")
        (fract_convert:DQ
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand" " w,r")))]
  ""
  "@
   mov %m1L,%0\;mov %m1H,%d0
   mov.d %1,%0"
)
 
(define_insn "fract<mode>udq2"
  [(set (match_operand:UDQ      0 "pic30_register_operand"     "=r,r")
        (fract_convert:UDQ
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand" " w,r")))]
  ""
  "@
   mov %m1L,%0\;mov %m1H,%d0
   mov.d %1,%0"
)

(define_insn "fract<mode>tq2"
  [(set (match_operand:TQ      0 "pic30_register_operand"     "=r,r")
        (fract_convert:TQ
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand" " w,r")))]
  ""
  "@
   mov %m1L,%0\;mov %m1H,%d0
   mov.d %1,%0"
)
 
(define_insn "fract<mode>utq2"
  [(set (match_operand:UTQ      0 "pic30_register_operand"     "=r,r")
        (fract_convert:UTQ
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand" " w,r")))]
  ""
  "@
   mov %m1L,%0\;mov %m1H,%d0
   mov.d %1,%0"
)

;  saturating to Q15

(define_insn "satfract<mode>qq2_trunc"
  [(set (match_operand:QQ      0 "pic30_register_operand"     "=r,&r")
        (sat_fract:QQ
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand" " w,r")))
   (clobber (match_scratch:HI  2                             "=X,&r"))
  ]
  ""
  "@
   sac %1,%0
   mov %d1,%0\;se %t1,%2\;rlc %d1,[w15]\;rlc %2,%2\;bra z,.LOK%=\;inc %2,%2\;bra z,.LOK%=\;mov #0x7FFF,%0\;btsc %t1,#7\;com %0,%0\;.LOK%=:\n"
)
  
(define_insn "satfract<mode>uqq2_trunc"
  [(set (match_operand:UQQ      0 "pic30_register_operand"     "=r,&r")
        (sat_fract:UQQ
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand" " w,r")))
   (clobber (match_scratch:HI  2                             "=X,&r"))
  ]
  ""
  "@
   sac %1,%0
   mov %d1,%0\;se %t1,%2\;rlc %d1,[w15]\;rlc %2,%2\;bra z,.LOK%=\;inc %2,%2\;bra z,.LOK%=\;mov #0x7FFF,%0\;btsc %t1,#7\;clr %0\;.LOK%=:\n"
)
  
(define_insn "satfract<mode>hq2_trunc"
  [(set (match_operand:HQ      0 "pic30_register_operand"     "=r,&r")
        (sat_fract:HQ
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand" " w,r")))
   (clobber (match_scratch:HI  2                             "=X,&r"))
  ]
  ""
  "@
   sac %1,%0
   mov %d1,%0\;se %t1,%2\;rlc %d1,[w15]\;rlc %2,%2\;bra z,.LOK%=\;inc %2,%2\;bra z,.LOK%=\;mov #0x7FFF,%0\;btsc %t1,#7\;com %0,%0\;.LOK%=:\n"
)
  
(define_insn "satfract<mode>uhq2_trunc"
  [(set (match_operand:UHQ      0 "pic30_register_operand"     "=r,&r")
        (sat_fract:UHQ
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand" " w,r")))
   (clobber (match_scratch:HI  2                             "=X,&r"))
  ]
  ""
  "@
   sac %1,%0
   mov %d1,%0\;se %t1,%2\;rlc %d1,[w15]\;rlc %2,%2\;bra z,.LOK%=\;inc %2,%2\;bra z,.LOK%=\;mov #0x7FFF,%0\;btsc %t1,#7\;clr %0\;.LOK%=:\n"
)

(define_insn "satfract<mode>qq2_conv"
  [(set (match_operand:QQ      0 "pic30_register_operand"     "=r,&r")
        (sat_fract:QQ
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand" " w,r")))
   (clobber (match_scratch:HI  2                             "=X,&r"))
   (use (reg:HI CORCON))
  ]
  ""
  "*
   if (pic30_fp_round_p() == pic30_conventional) {
     switch (which_alternative) {
       default: gcc_assert(0);
       case 0: return \"sac.r %1,%0\";
                      /* Like truncating, but ... */
       case 1: return \"mov %d1,%0\;\"            /* copy result */
                      \"sl %1,[w15]\;\"           /* check for round */
                      \"addc %0,#0,%0\;\"
                      \"bra ov,.LOV%=\;\"         /* if 0x7FFF -> 0x8000, OV */
                      \"se %t1,%2\;\"             /* otherwise check for */
                      \"rlc %d1,[w15]\;\"         /*   out of bounds input */
                      \"rlc %2,%2\;\"
                      \"bra z,.LOK%=\;\"
                      \"inc %2,%2\;\"
                      \"bra z,.LOK%=\n\"
                      \".LOV%=:\"
                      \"mov #0x7FFF,%0\;\"
                      \"btsc %t1,#7\;\"
                      \"com %0,%0\n\"
                      \".LOK%=:\n\";
     }
   } else if (pic30_fp_round_p() == pic30_convergent) {
     switch (which_alternative) {
       default: gcc_assert(0);
       case 0: return \"sac.r %1,%0\";
       case 1: return \"mov %d1,%0\;\"            /* copy result */
                      \"sl %1,[w15]\;\"           /* check for round */
                      \"bra nz,.LINC%=\;\"
                      \"btsc %0,#0\n\"
                      \".LINC%=:\"
                      \"addc %0,#0,%0\;\"
                      \"bra ov,.LOV%=\;\"         /* if 0x7FFF -> 0x8000, OV */
                      \"se %t1,%2\;\"             /* otherwise check for */
                      \"rlc %d1,[w15]\;\"         /*   out of bounds input */
                      \"rlc %2,%2\;\"
                      \"bra z,.LOK%=\;\"
                      \"inc %2,%2\;\"
                      \"bra z,.LOK%=\n\"
                      \".LOV%=:\"
                      \"mov #0x7FFF,%0\;\"
                      \"btsc %t1,#7\;\"
                      \"com %0,%0\n\"
                      \".LOK%=:\n\";
     }
   }
   error(\"Invalid fixed-point round mode specified\n\");
   return \"cannot generate instruction\";
   "
)
 
(define_insn "satfract<mode>uqq2_conv"
  [(set (match_operand:UQQ      0 "pic30_register_operand"     "=r,&r")
        (sat_fract:UQQ
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand" " w,r")))
   (clobber (match_scratch:HI  2                             "=X,&r"))
   (use (reg:HI CORCON))
  ]
  ""
  "*
   if (pic30_fp_round_p() == pic30_conventional) {
     switch (which_alternative) {
       default: gcc_assert(0);
       case 0: return \"sac.r %1,%0\";
                      /* Like truncating, but ... */
       case 1: return \"mov %d1,%0\;\"            /* copy result */
                      \"sl %1,[w15]\;\"           /* check for round */
                      \"addc %0,#0,%0\;\"
                      \"bra ov,.LOV%=\;\"         /* if 0x7FFF -> 0x8000, OV */
                      \"se %t1,%2\;\"             /* otherwise check for */
                      \"rlc %d1,[w15]\;\"         /*   out of bounds input */
                      \"rlc %2,%2\;\"
                      \"bra z,.LOK%=\;\"
                      \"inc %2,%2\;\"
                      \"bra z,.LOK%=\n\"
                      \".LOV%=:\"
                      \"mov #0x7FFF,%0\;\"
                      \"btsc %t1,#7\;\"
                      \"clr %0\n\"
                      \".LOK%=:\n\";
     }
   } else if (pic30_fp_round_p() == pic30_convergent) {
     switch (which_alternative) {
       default: gcc_assert(0);
       case 0: return \"sac.r %1,%0\";
       case 1: return \"mov %d1,%0\;\"            /* copy result */
                      \"sl %1,[w15]\;\"           /* check for round */
                      \"bra nz,.LINC%=\;\"
                      \"btsc %0,#0\n\"
                      \".LINC%=:\"
                      \"addc %0,#0,%0\;\"
                      \"bra ov,.LOV%=\;\"         /* if 0x7FFF -> 0x8000, OV */
                      \"se %t1,%2\;\"             /* otherwise check for */
                      \"rlc %d1,[w15]\;\"         /*   out of bounds input */
                      \"rlc %2,%2\;\"
                      \"bra z,.LOK%=\;\"
                      \"inc %2,%2\;\"
                      \"bra z,.LOK%=\n\"
                      \".LOV%=:\"
                      \"mov #0x7FFF,%0\;\"
                      \"btsc %t1,#7\;\"
                      \"clr %0\n\"
                      \".LOK%=:\n\";
     }
   }
   error(\"Invalid fixed-point round mode specified\n\");
   return \"cannot generate instruction\";
   "
)
 
(define_insn "satfract<mode>hq2_conv"
  [(set (match_operand:HQ      0 "pic30_register_operand"     "=r,&r")
        (sat_fract:HQ
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand" " w,r")))
   (clobber (match_scratch:HI  2                             "=X,&r"))
   (use (reg:HI CORCON))
  ]
  ""
  "*
   if (pic30_fp_round_p() == pic30_conventional) {
     switch (which_alternative) {
       default: gcc_assert(0);
       case 0: return \"sac.r %1,%0\";
                      /* Like truncating, but ... */
       case 1: return \"mov %d1,%0\;\"            /* copy result */
                      \"sl %1,[w15]\;\"           /* check for round */
                      \"addc %0,#0,%0\;\"
                      \"bra ov,.LOV%=\;\"         /* if 0x7FFF -> 0x8000, OV */
                      \"se %t1,%2\;\"             /* otherwise check for */
                      \"rlc %d1,[w15]\;\"         /*   out of bounds input */
                      \"rlc %2,%2\;\"
                      \"bra z,.LOK%=\;\"
                      \"inc %2,%2\;\"
                      \"bra z,.LOK%=\n\"
                      \".LOV%=:\"
                      \"mov #0x7FFF,%0\;\"
                      \"btsc %t1,#7\;\"
                      \"com %0,%0\n\"
                      \".LOK%=:\n\";
     }
   } else if (pic30_fp_round_p() == pic30_convergent) {
     switch (which_alternative) {
       default: gcc_assert(0);
       case 0: return \"sac.r %1,%0\";
       case 1: return \"mov %d1,%0\;\"            /* copy result */
                      \"sl %1,[w15]\;\"           /* check for round */
                      \"bra nz,.LINC%=\;\"
                      \"btsc %0,#0\n\"
                      \".LINC%=:\"
                      \"addc %0,#0,%0\;\"
                      \"bra ov,.LOV%=\;\"         /* if 0x7FFF -> 0x8000, OV */
                      \"se %t1,%2\;\"             /* otherwise check for */
                      \"rlc %d1,[w15]\;\"         /*   out of bounds input */
                      \"rlc %2,%2\;\"
                      \"bra z,.LOK%=\;\"
                      \"inc %2,%2\;\"
                      \"bra z,.LOK%=\n\"
                      \".LOV%=:\"
                      \"mov #0x7FFF,%0\;\"
                      \"btsc %t1,#7\;\"
                      \"com %0,%0\n\"
                      \".LOK%=:\n\";
     }
   }
   error(\"Invalid fixed-point round mode specified\n\");
   return \"cannot generate instruction\";
  "
)
 
(define_insn "satfract<mode>uhq2_conv"
  [(set (match_operand:UHQ      0 "pic30_register_operand"     "=r,&r")
        (sat_fract:UHQ
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand" " w,r")))
   (clobber (match_scratch:HI  2                             "=X,&r"))
   (use (reg:HI CORCON))
  ]
  ""
  "*
   if (pic30_fp_round_p() == pic30_conventional) {
     switch (which_alternative) {
       default: gcc_assert(0);
       case 0: return \"sac.r %1,%0\";
                      /* Like truncating, but ... */
       case 1: return \"mov %d1,%0\;\"            /* copy result */
                      \"sl %1,[w15]\;\"           /* check for round */
                      \"addc %0,#0,%0\;\"
                      \"bra ov,.LOV%=\;\"         /* if 0x7FFF -> 0x8000, OV */
                      \"se %t1,%2\;\"             /* otherwise check for */
                      \"rlc %d1,[w15]\;\"         /*   out of bounds input */
                      \"rlc %2,%2\;\"
                      \"bra z,.LOK%=\;\"
                      \"inc %2,%2\;\"
                      \"bra z,.LOK%=\n\"
                      \".LOV%=:\"
                      \"mov #0x7FFF,%0\;\"
                      \"btsc %t1,#7\;\"
                      \"clr %0\n\"
                      \".LOK%=:\n\";
     }
   } else if (pic30_fp_round_p() == pic30_convergent) {
     switch (which_alternative) {
       default: gcc_assert(0);
       case 0: return \"sac.r %1,%0\";
       case 1: return \"mov %d1,%0\;\"            /* copy result */
                      \"sl %1,[w15]\;\"           /* check for round */
                      \"bra nz,.LINC%=\;\"
                      \"btsc %0,#0\n\"
                      \".LINC%=:\"
                      \"addc %0,#0,%0\;\"
                      \"bra ov,.LOV%=\;\"         /* if 0x7FFF -> 0x8000, OV */
                      \"se %t1,%2\;\"             /* otherwise check for */
                      \"rlc %d1,[w15]\;\"         /*   out of bounds input */
                      \"rlc %2,%2\;\"
                      \"bra z,.LOK%=\;\"
                      \"inc %2,%2\;\"
                      \"bra z,.LOK%=\n\"
                      \".LOV%=:\"
                      \"mov #0x7FFF,%0\;\"
                      \"btsc %t1,#7\;\"
                      \"clr %0\n\"
                      \".LOK%=:\n\";
     }
   }
   error(\"Invalid fixed-point round mode specified\n\");
   return \"cannot generate instruction\";
  "
)


(define_expand "satfract<mode>qq2"
  [(set (match_operand:QQ    0 "pic30_register_operand"    "=r,r")
      (sat_fract:QQ
        (match_operand:AUACC 1 "pic30_accum_or_reg_operand" "w,r")))
  ]
  ""
  "
  {
    switch (pic30_fp_round_p()) {
      default: gcc_assert(0);

      case pic30_truncation:
      case pic30_fastest:
        emit(
          gen_satfract<mode>qq2_trunc(operands[0],operands[1])
        );
        DONE;
        break;
      case pic30_convergent:
      case pic30_conventional:
        emit(
          gen_satfract<mode>qq2_conv(operands[0],operands[1])
        );
        DONE;
        break;
    }
    FAIL;
  }
  "
)   

(define_expand "satfract<mode>uqq2"
  [(set (match_operand:UQQ   0 "pic30_register_operand"    "=r,r")
      (sat_fract:UQQ
        (match_operand:AUACC 1 "pic30_accum_or_reg_operand" "w,r")))
  ]
  ""
  "
  {
    switch (pic30_fp_round_p()) {
      default: gcc_assert(0);

      case pic30_truncation:
      case pic30_fastest:
        emit(
          gen_satfract<mode>uqq2_trunc(operands[0],operands[1])
        );
        DONE;
        break;
      case pic30_convergent:
      case pic30_conventional:
        emit(
          gen_satfract<mode>uqq2_conv(operands[0],operands[1])
        );
        DONE;
        break;
    }
    FAIL;
  }
  "
)   

(define_expand "satfract<mode>hq2"
  [(set (match_operand:HQ    0 "pic30_register_operand"    "=r,r")
      (sat_fract:QQ
        (match_operand:AUACC 1 "pic30_accum_or_reg_operand" "w,r")))
  ]
  ""
  "
  {
    switch (pic30_fp_round_p()) {
      default: gcc_assert(0);

      case pic30_truncation:
      case pic30_fastest:
        emit(
          gen_satfract<mode>hq2_trunc(operands[0],operands[1])
        );
        DONE;
        break;
      case pic30_convergent:
      case pic30_conventional:
        emit(
          gen_satfract<mode>hq2_conv(operands[0],operands[1])
        );
        DONE;
        break;
    }
    FAIL;
  }
  "
)   

(define_expand "satfract<mode>uhq2"
  [(set (match_operand:UHQ   0 "pic30_register_operand"    "=r,r")
      (sat_fract:UHQ
        (match_operand:AUACC 1 "pic30_accum_or_reg_operand" "w,r")))
  ]
  ""
  "
  {
    switch (pic30_fp_round_p()) {
      default: gcc_assert(0);

      case pic30_truncation:
      case pic30_fastest:
        emit(
          gen_satfract<mode>uhq2_trunc(operands[0],operands[1])
        );
        DONE;
        break;
      case pic30_convergent:
      case pic30_conventional:
        emit(
          gen_satfract<mode>uhq2_conv(operands[0],operands[1])
        );
        DONE;
        break;
    }
    FAIL;
  }
  "
)   


; to Q31 - done by routine, these patterns are too long (and complex)

;  from Q15

; might be overkill
;
;(define_insn "fractqq<mode>2"
;  [(set (match_operand:AUACC 0 "pic30_accum_or_reg_operand" "=w,r,&w,r")
;        (fract_convert:AUACC
;          (match_operand:QQ  1 "pic30_accum_or_reg_operand" " r,r, w,w")))]
;  ""
;  "*
;   {
;      switch (which_alternative) {
;        default: gcc_assert(0);
;                 return \"cannot generate instruction\";
;        case 0:  return \"lac %1,%0\";
;        case 1:  return \"mov %1,%d0\;clr %0\;clr.b %t0\";
;        case 2:  return \"clr %0\;add %0\";
;        case 3:  if (REGNO(operands[1]) == A_REGNO) {
;                   return \"clr %0\;\"
;                          \"mov _ACCAH,%d0\;\"
;                          \"clr.b %t0\";
;                 } else if (REGNO(operands[1]) == B_REGNO) {
;                   return \"clr %0\;\"
;                          \"mov _ACCBH,%d0\;\"
;                          \"clr.b %t0\";
;                 }
;                 break;
;      }
;   }"
;)

(define_insn "fractqq<mode>2"
  [(set (match_operand:AUACC 0 "pic30_accum_or_reg_operand" "=w,r")
        (fract_convert:AUACC
          (match_operand:QQ  1 "pic30_register_operand"     " r,r")))]
  ""
  "@
   lac %1,%0
   mov %1,%d0\;clr %0\;asr %d0,#15,%t0"
)
  
(define_insn "fractuqq<mode>2"
  [(set (match_operand:AUACC 0 "pic30_accum_or_reg_operand" "=w,r")
        (fract_convert:AUACC
          (match_operand:UQQ 1 "pic30_register_operand"     " r,r")))]
  ""
  "@
   lac %1,%0
   mov %1,%d0\;clr %0\;asr %d0,#15,%t0"
)
  
(define_insn "fracthq<mode>2"
  [(set (match_operand:AUACC 0 "pic30_accum_or_reg_operand" "=w,r")
        (fract_convert:AUACC
          (match_operand:HQ  1 "pic30_register_operand"     " r,r")))]
  ""
  "@
   lac %1,%0
   mov %1,%d0\;clr %0\;asr %d0,#15,%t0"
)
  
(define_insn "fractuhq<mode>2"
  [(set (match_operand:AUACC 0 "pic30_accum_or_reg_operand" "=w,r")
        (fract_convert:AUACC
          (match_operand:UHQ 1 "pic30_register_operand"     " r,r")))]
  ""
  "@
   lac %1,%0
   mov %1,%d0\;clr %0\;asr %d0,#15,%t0"
)

; from Q31

(define_insn "fractsq<mode>2"
  [(set (match_operand:AUACC 0 "pic30_accum_or_reg_operand" "=w,r")
        (fract_convert:AUACC
          (match_operand:SQ  1 "pic30_register_operand"     " r,r")))]
  ""
  "@
   lac %d1,%0\;mov %1,%m0L
   mov.d %1,%0\;asr %d0,#15,%t0"
)
 
(define_insn "fractusq<mode>2"
  [(set (match_operand:AUACC 0 "pic30_accum_or_reg_operand" "=w,r")
        (fract_convert:AUACC
          (match_operand:USQ 1 "pic30_register_operand"     " r,r")))]
  ""
  "@
   lac %d1,%0\;mov %1,%m0L
   mov.d %1,%0\;asr %d0,#15,%t0"
)

(define_insn "fractdq<mode>2"
  [(set (match_operand:AUACC 0 "pic30_accum_or_reg_operand" "=w,r")
        (fract_convert:AUACC
          (match_operand:DQ  1 "pic30_register_operand"     " r,r")))]
  ""
  "@
   lac %d1,%0\;mov %1,%m0L
   mov.d %1,%0\;asr %d0,#15,%t0"
)
 
(define_insn "fractudq<mode>2"
  [(set (match_operand:AUACC 0 "pic30_accum_or_reg_operand" "=w,r")
        (fract_convert:AUACC
          (match_operand:UDQ 1 "pic30_register_operand"     " r,r")))]
  ""
  "@
   lac %d1,%0\;mov %1,%m0L
   mov.d %1,%0\;asr %d0,#15,%t0"
)

(define_insn "fracttq<mode>2"
  [(set (match_operand:AUACC 0 "pic30_accum_or_reg_operand" "=w,r")
        (fract_convert:AUACC
          (match_operand:TQ  1 "pic30_register_operand"     " r,r")))]
  ""
  "@
   lac %d1,%0\;mov %1,%m0L
   mov.d %1,%0\;asr %d0,#15,%t0"
)
 
(define_insn "fractutq<mode>2"
  [(set (match_operand:AUACC 0 "pic30_accum_or_reg_operand" "=w,r")
        (fract_convert:AUACC
          (match_operand:UTQ 1 "pic30_register_operand"     " r,r")))]
  ""
  "@
   lac %d1,%0\;mov %1,%m0L
   mov.d %1,%0\;asr %d0,#15,%t0"
)

;  saturating from Q15
;   these never saturate because AUACC is always bigger than a Qn

(define_insn "satfractqq<mode>2"
  [(set (match_operand:AUACC 0 "pic30_accum_or_reg_operand" "=w,r")
        (sat_fract:AUACC
          (match_operand:QQ  1 "pic30_register_operand"     " r,r")))]
  ""
  "@
   lac %1,%0
   mov %1,%d0\;clr %0\;asr %d0,#15,%t0"

)
  
(define_insn "satfractuqq<mode>2"
  [(set (match_operand:AUACC 0 "pic30_accum_or_reg_operand" "=w,r")
        (sat_fract:AUACC
          (match_operand:UQQ 1 "pic30_register_operand"     " r,r")))]
  ""
  "@
   lac %1,%0
   mov %1,%d0\;clr %0\;asr %d0,#15,%t0"
)
  
(define_insn "satfracthq<mode>2"
  [(set (match_operand:AUACC 0 "pic30_accum_or_reg_operand" "=w,r")
        (sat_fract:AUACC
          (match_operand:HQ  1 "pic30_register_operand"     " r,r")))]
  ""
  "@
   lac %1,%0
   mov %1,%d0\;clr %0\;asr %d0,#15,%t0"
)
  
(define_insn "satfractuhq<mode>2"
  [(set (match_operand:AUACC 0 "pic30_accum_or_reg_operand" "=w,r")
        (sat_fract:AUACC
          (match_operand:UHQ 1 "pic30_register_operand"     " r,r")))]
  ""
  "@
   lac %1,%0
   mov %1,%d0\;clr %0\;asr %d0,#15,%t0"
)

; from Q31

(define_insn "satfractsq<mode>2"
  [(set (match_operand:AUACC 0 "pic30_accum_or_reg_operand" "=w,r")
        (sat_fract:AUACC
          (match_operand:SQ  1 "pic30_register_operand"     " r,r")))]
  ""
  "@
   lac %d1,%0\;mov %1,%m0L
   mov.d %1,%0\;asr %d0,#15,%t0"
)
 
(define_insn "satfractusq<mode>2"
  [(set (match_operand:AUACC 0 "pic30_accum_or_reg_operand" "=w,r")
        (sat_fract:AUACC
          (match_operand:USQ 1 "pic30_register_operand"     " r,r")))]
  ""
  "@
   lac %d1,%0\;mov %1,%m0L
   mov.d %1,%0\;asr %d0,#15,%t0"
)

(define_insn "satfractdq<mode>2"
  [(set (match_operand:AUACC 0 "pic30_accum_or_reg_operand" "=w,r")
        (sat_fract:AUACC
          (match_operand:DQ  1 "pic30_register_operand"     " r,r")))]
  ""
  "@
   lac %d1,%0\;mov %1,%m0L
   mov.d %1,%0\;asr %d0,#15,%t0"
)
 
(define_insn "satfractudq<mode>2"
  [(set (match_operand:AUACC 0 "pic30_accum_or_reg_operand" "=w,r")
        (sat_fract:AUACC
          (match_operand:UDQ 1 "pic30_register_operand"     " r,r")))]
  ""
  "@
   lac %d1,%0\;mov %1,%m0L
   mov.d %1,%0\;asr %d0,#15,%t0"
)

(define_insn "satfracttq<mode>2"
  [(set (match_operand:AUACC 0 "pic30_accum_or_reg_operand" "=w,r")
        (sat_fract:AUACC
          (match_operand:TQ  1 "pic30_register_operand"     " r,r")))]
  ""
  "@
   lac %d1,%0\;mov %1,%m0L
   mov.d %1,%0\;asr %d0,#15,%t0"
)
 
(define_insn "satfractutq<mode>2"
  [(set (match_operand:AUACC 0 "pic30_accum_or_reg_operand" "=w,r")
        (sat_fract:AUACC
          (match_operand:UTQ 1 "pic30_register_operand"     " r,r")))]
  ""
  "@
   lac %d1,%0\;mov %1,%m0L
   mov.d %1,%0\;asr %d0,#15,%t0"
)

; Accum <-> float conversions appear as functions only


;;  Secondary reload functions

(define_insn "Ureload_inQI"
  [(set
     (match_operand:QI 0 "pic30_register_operand" "=r")
     (match_operand:QI 1 "pic30_near_operand"     " U"))
   (clobber 
     (match_operand:HI 2 "pic30_register_operand" "=&r"))
  ]
  ""
  "*
   if (REGNO(operands[0]) == WR0_REGNO)
     return \"mov.b %1,WREG\";
   return \"mov #%1,%2\;mov.b [%2],%0\";
  "
)

(define_insn "Ureload_outQI"
  [(set
     (match_operand:QI 0 "pic30_near_operand"     "=U")
     (match_operand:QI 1 "pic30_register_operand" " r"))
   (clobber 
     (match_operand:HI 2 "pic30_register_operand" "=&r"))
  ]
  ""
  "*
   if (REGNO(operands[1]) == WR0_REGNO) 
     return \"mov.b WREG,%0\";
   else return \"mov #%0,%2\;mov.b %1,[%2]\";
  "
)

(define_insn "Qreload_in<mode>"
  [(set
     (match_operand:QUQ31 0 "pic30_accum_or_reg_operand"  "=w,  r")
     (match_operand:QUQ31 1 "pic30_RQ_operand"           "  RQ, RQ"))
   (clobber (match_operand:HI 2 "pic30_register_operand" "=&r,  X"))
  ]
  ""
  "*
   if (which_alternative == 0) 
     return \"mov %1,%2\;mov %2,%m0L\;mov %Q1,%2\;mov %2,%m0H\;clr %m0U\";
   else {
     rtx Wn = 0;
   
     if (GET_CODE(operands[1]) == MEM) {
       if (GET_CODE(XEXP(operands[1],0)) == REG) {
         Wn = XEXP(operands[1],0);
       } else if (GET_CODE(XEXP(operands[1],0)) == PLUS) {
         Wn = XEXP(XEXP(operands[1],0),0);
       }
     }
     if (Wn) {
       unsigned int regno;

       regno = REGNO(Wn);
       if (regno == REGNO(operands[0]))
         return \"mov %Q1,%d0\;mov %1,%0\";
       else 
         return \"mov %1,%0\;mov %Q1,%d0\";
     }
   }
   gcc_assert(0);
   return \"nop\";
  "
)

(define_insn "Qreload_out<mode>"
  [(set
     (match_operand:QUQ31 0 "pic30_RQ_operand"            "=RQ, RQ")
     (match_operand:QUQ31 1 "pic30_accum_or_reg_operand"  "  w,  r"))
   (clobber (match_operand:HI 2 "pic30_register_operand"  "=&r,  X"))
  ]
  ""
  "@
   mov %m1L,%2\;mov %2,%0\;mov %m1H,%2\;mov %2,%Q0
   mov %1,%0\;mov %d1,%Q0"
)

(define_insn "Qreload_in<mode>"
  [(set
     (match_operand:AUACC 0 "pic30_accum_or_reg_operand"  "=w,  r")
     (match_operand:AUACC 1 "pic30_RQ_operand"           "  RQ, RQ"))
   (clobber (match_operand:HI 2 "pic30_register_operand"  "=&r, X"))
  ]
  ""
  "*
   if (which_alternative == 0)
     return \"mov %1,%2\;mov %2,%m0L\;mov %Q1,%2\;mov %2,%m0H\;mov %R1,%2\;mov %2,%m0U\";
   else {
     rtx Wn = 0;
   
     if (GET_CODE(operands[1]) == MEM) {
       if (GET_CODE(XEXP(operands[1],0)) == REG) {
         Wn = XEXP(operands[1],0);
       } else if (GET_CODE(XEXP(operands[1],0)) == PLUS) {
         Wn = XEXP(XEXP(operands[1],0),0);
       } 
     }
     if (Wn) {
       unsigned int regno;

       regno = REGNO(Wn);
       if (pic30_psrd_psrd_errata(operands[1],NULL)) {
         pic30_rtx_nops+=2;
       if (regno == REGNO(operands[0]))
           return \"mov %Q1,%d0\;nop\;mov.b %R1,%t0\;nop\;mov %1,%0\";
         else if (regno == REGNO(operands[0])+1)
           return \"mov %1,%0\;nop\;mov.b %R1,%t0\;nop\;mov %Q1,%d0\";
         else
           return \"mov %1,%0\;nop\;mov %Q1,%d0\;nop\;mov.b %R1,%t0\";
       } else {
         if (regno == REGNO(operands[0]))
         return \"mov %Q1,%d0\;mov.b %R1,%t0\;mov %1,%0\";
       else if (regno == REGNO(operands[0])+1)
         return \"mov %1,%0\;mov.b %R1,%t0\;mov %Q1,%d0\";
       else
         return \"mov %1,%0\;mov %Q1,%d0\;mov.b %R1,%t0\";
     }
   }
   }
   gcc_assert(0);
   return \"nop\";
  "
)

(define_insn "Qreload_out<mode>"
  [(set
     (match_operand:AUACC 0 "pic30_RQ_operand"           "=RQ, RQ")
     (match_operand:AUACC 1 "pic30_accum_or_reg_operand" "  w,  r"))
   (clobber (match_operand:HI 2 "pic30_register_operand" "=&r,  X"))
  ]
  ""
  "@
   mov %m1L,%2\;mov %2,%0\;mov %m1H,%2\;mov %2,%Q0\;mov %m1U,%2\;mov %2,%R0
   mov %1,%0\;mov %d1,%Q0\;mov.b %t1,%R0"
)

(define_insn "TUreload_in<mode>"
  [(set
     (match_operand:AUACC 0 "pic30_accum_or_reg_operand"  "=w, &r")
     (match_operand:AUACC 1 "pic30_data_operand"          " TU,TU"))
   (clobber (match_operand:HI 2 "pic30_register_operand"  "=&r, X"))
  ]
  ""
  "@
   mov %1,%2\;mov %2,%m0L\;mov %1+2,%2\;mov %2,%m0H\;mov %1+4,%2\;mov %2,%m0U
   mov %1,%0\;mov %1+2,%d0\;mov %1+4,%t0"
)

(define_insn "TUreload_insi"
  [(set
     (match_operand:SI 0 "pic30_accum_or_reg_operand"     "=w, &r")
     (match_operand:SI 1 "pic30_data_operand"             " TU,TU"))
   (clobber (match_operand:HI 2 "pic30_register_operand"  "=&r, X"))
  ]
  ""
  "@
   mov %1,%2\;mov %2,%m0L\;mov %1+2,%2\;mov %2,%m0H
   mov %1,%0\;mov %1+2,%d0"
)
      

(define_insn "TUreload_out<mode>"
  [(set
     (match_operand:AUACC 0 "pic30_data_operand"         "=TU,TU")
     (match_operand:AUACC 1 "pic30_accum_or_reg_operand" " w, r"))
   (clobber (match_operand:HI 2 "pic30_register_operand" "=&r,X"))
  ]
  ""
  "@
   mov %m1L,%2\;mov %2,%0\;mov %m1H,%2\;mov %2,%0+2\;mov %m1U,%2\;mov %2,%0+4
   mov %1,%0\;mov %d1,%0+2\;mov %t1,%0+4"
)

(define_insn "TUreload_outhi"
  [(set
     (match_operand:HI   0 "pic30_data_operand"         "=TU,TU")
     (match_operand:HI   1 "pic30_accum_or_reg_operand" " w, r"))
   (clobber (match_operand:HI 2 "pic30_register_operand" "=&r,X"))
  ]
  ""
  "@
   mov %m1L,%2\;mov %2,%0
   mov %1,%0"
)

(define_insn "TUreload_outsi"
  [(set
     (match_operand:SI   0 "pic30_data_operand"         "=TU,TU")
     (match_operand:SI   1 "pic30_accum_or_reg_operand" " w, r"))
   (clobber (match_operand:HI 2 "pic30_register_operand" "=&r,X"))
  ]
  ""
  "@
   mov %m1L,%2\;mov %2,%0\;mov %m1H,%2\;mov %2,%0+2
   mov %1,%0\;mov %d1,%0+2"
)

(define_mode_iterator QRELOADS [QI HI SI DI SF DF QQ HQ UQQ UHQ SQ USQ DQ UDQ TQ UTQ HA UHA SA USA DA UDA TA UTA])

; reloads because the displacement is too large

(define_insn "Qreloaddisp_out<mode>"
  [(set
      (match_operand:QRELOADS  0 "pic30_any_QR_operand"    "= R, X")
      (match_operand:QRELOADS  1 "pic30_register_operand"  "  r, r"))
   (clobber (match_operand:HI  2 "pic30_register_operand"  "=&r,&r"))
  ]
  ""
  "*
  { 
    if (which_alternative == 1) {
      rtx inner;
      rtx lhs,rhs;
      int offset;
      static char result[256];

      gcc_assert(MEM_P(operands[0]));
      inner = XEXP(operands[0],0);
      gcc_assert((GET_CODE(inner) == PLUS) || (GET_CODE(inner) == MINUS));
      lhs = XEXP(inner,0);
      rhs = XEXP(inner,1);
      gcc_assert(REG_P(lhs));
      gcc_assert(GET_CODE(rhs) == CONST_INT);
      offset = INTVAL(rhs);
      if (GET_CODE(inner) == MINUS) offset = -1*offset;
      
      if (GET_MODE_SIZE(<MODE>mode) == 1) {
        sprintf(result, \"mov #%d,%%2\;\"
                        \"mov.b %%1,[%s+%%2]\", 
                offset, reg_names[REGNO(lhs)]);
      } else if (GET_MODE_SIZE(<MODE>mode) == 2) {
        sprintf(result, \"mov #%d,%%2\;\"
                        \"mov %%1,[%s+%%2]\",
                offset, reg_names[REGNO(lhs)]);
      } else if (GET_MODE_SIZE(<MODE>mode) == 4) {
        sprintf(result, \"mov #%d,%%2\;\"
                        \"add %s,%%2,%%2\;\"
                        \"mov %%1,[%%2++]\;mov %%d1,[%%2]\",
                offset, reg_names[REGNO(lhs)]);
      } else if (GET_MODE_SIZE(<MODE>mode) == 6) {
        sprintf(result, \"mov #%d,%%2\;\"
                        \"add %s,%%2,%%2\;\"
                        \"mov %%1,[%%2++]\;mov %%d1,[%%2++]\;mov %%t1,[%%2]\",
               offset, reg_names[REGNO(lhs)]);
      } else if (GET_MODE_SIZE(<MODE>mode) == 8) {
        sprintf(result, \"mov #%d,%%2\;\"
                        \"add %s,%%2,%%2\;\"
                        \"mov %%1,[%%2++]\;mov %%d1,[%%2++]\;\"
                        \"mov %%t1,[%%2++]\;mov %%q1,[%%2]\", 
              offset, reg_names[REGNO(lhs)]);
      } else gcc_assert(0);
      return result;
    } else {
      if (GET_MODE_SIZE(<MODE>mode) == 1) {
        return \"mov.b %1,%0\";
      } else if (GET_MODE_SIZE(<MODE>mode) == 2) {
        return \"mov %1,%0\";
      } else if (GET_MODE_SIZE(<MODE>mode) == 4) {
        return \"mov %1,%I0\;mov %d1,%D0\";
      } else if (GET_MODE_SIZE(<MODE>mode) == 6) {
        return \"mov %r0,%2\;\"
               \"mov %1,[%2++]\;mov %d1,[%2++]\;mov %t1,[%2]\";
      } else if (GET_MODE_SIZE(<MODE>mode) == 8) {
        return \"mov %r0,%2\;\"
               \"mov %1,[%2++]\;mov %d1,[%2++]\;mov %t1,[%2++]\;mov %q1,[%2]\";
      } else gcc_assert(0);
      return \"nop\";
    }
  }
  "
)

(define_insn "Qreloaddisp_in<mode>"
  [(set
     (match_operand:QRELOADS  0 "pic30_register_operand" "= r, r")
     (match_operand:QRELOADS  1 "pic30_any_QR_operand"   "  R, X"))
   (clobber (match_operand:HI 2 "pic30_register_operand" "=&r,&r"))
  ]
  ""
  "*
  {
    if (which_alternative == 1) {
      rtx inner;
      rtx lhs,rhs;
      int offset;
      static char result[256];

      gcc_assert(MEM_P(operands[1]));
      inner = XEXP(operands[1],0);
      gcc_assert((GET_CODE(inner) == PLUS) || (GET_CODE(inner) == MINUS));
      lhs = XEXP(inner,0);
      rhs = XEXP(inner,1);
      gcc_assert(REG_P(lhs));
      gcc_assert(GET_CODE(rhs) == CONST_INT);
      offset = INTVAL(rhs);
      if (GET_CODE(inner) == MINUS) offset = -1*offset;
      
      if (GET_MODE_SIZE(<MODE>mode) == 1) {
        sprintf(result, \"mov #%d,%%2\;\"
                        \"mov.b [%s+%%2],%%0\",
               offset, reg_names[REGNO(lhs)]);
      } else if (GET_MODE_SIZE(<MODE>mode) == 2) {
        sprintf(result, \"mov #%d,%%2\;\"
                        \"mov [%s+%%2],%%0\",
               offset, reg_names[REGNO(lhs)]);
      } else if (GET_MODE_SIZE(<MODE>mode) == 4) {
        if (pic30_psrd_psrd_errata(operands[1],NULL)) {
          pic30_rtx_nops+=1;
        sprintf(result, \"mov #%d,%%2\;\"
                        \"add %s,%%2,%%2\;\"
                          \"mov [%%2++],%%0\;\"
                          \"\nop\;\"
                          \"mov [%%2],%%d0\",
               offset, reg_names[REGNO(lhs)]);
        } else {
          sprintf(result, \"mov #%d,%%2\;\"
                          \"add %s,%%2,%%2\;\"
                          \"mov [%%2++],%%0\;\"
                          \"mov [%%2],%%d0\",
                 offset, reg_names[REGNO(lhs)]);
        }
      } else if (GET_MODE_SIZE(<MODE>mode) == 6) {
        if (pic30_psrd_psrd_errata(operands[1],NULL)) {
          pic30_rtx_nops+=2;
        sprintf(result, \"mov #%d,%%2\;\"
                        \"add %s,%%2,%%2\;\"
                          \"mov [%%2++],%%0\;\"
                          \"nop\;\"
                          \"mov [%%2++],%%d0\;\"
                          \"nop\;\"
                          \"mov [%%2],%%t0\",
               offset, reg_names[REGNO(lhs)]);
        } else {
          sprintf(result, \"mov #%d,%%2\;\"
                          \"add %s,%%2,%%2\;\"
                          \"mov [%%2++],%%0\;\"
                          \"mov [%%2++],%%d0\;\"
                          \"mov [%%2],%%t0\",
                 offset, reg_names[REGNO(lhs)]);
        }
      } else if (GET_MODE_SIZE(<MODE>mode) == 8) {
        if (pic30_psrd_psrd_errata(operands[1],NULL)) {
          pic30_rtx_nops+=3;
        sprintf(result, \"mov #%d,%%2\;\"
                        \"add %s,%%2,%%2\;\"
                          \"mov [%%2++],%0\;\"
                          \"nop\;\"
                          \"mov [%%2++],%d0\;\"
                          \"nop\;\"
                          \"mov [%%2++],%t0\;\"
                          \"nop\;\"
                          \"mov [%%2],%q0\",
               offset, reg_names[REGNO(lhs)]);
        } else {
          sprintf(result, \"mov #%d,%%2\;\"
                          \"add %s,%%2,%%2\;\"
                          \"mov [%%2++],%0\;\"
                          \"mov [%%2++],%d0\;\"
                          \"mov [%%2++],%t0\;\"
                          \"mov [%%2],%q0\",
                 offset, reg_names[REGNO(lhs)]);
        }
      } else gcc_assert(0);
      return result;
    } else {
      if (GET_MODE_SIZE(<MODE>mode) == 1) {
        return \"mov.b %1,%0\";
      } else if (GET_MODE_SIZE(<MODE>mode) == 2) {
        return \"mov %1,%0\";
      } else if (GET_MODE_SIZE(<MODE>mode) == 4) {
        if (pic30_psrd_psrd_errata(operands[1],NULL)) {
          pic30_rtx_nops+=1;
          return \"mov %I1,%0\;\"
                 \"nop\;\"
                 \"mov %D1,%d0\";
        } else {
          return \"mov %I1,%0\;\"
                 \"mov %D1,%d0\";
        }
      } else if (GET_MODE_SIZE(<MODE>mode) == 6) {
        if (pic30_psrd_psrd_errata(operands[1],NULL)) {
          pic30_rtx_nops+=2;
        return \"mov %r1,%2\;\"
                 \"nop\;\"
                 \"mov [%2++],%0\;\"
                 \"nop\;\"
                 \"mov [%2++],%d0\;\"
                 \"nop\;\"
                 \"mov [%2],%t0\";
        } else {
          return \"mov %r1,%2\;\"
                 \"mov [%2++],%0\;\"
                 \"mov [%2++],%d0\;\"
                 \"mov [%2],%t0\";
        }
      } else if (GET_MODE_SIZE(<MODE>mode) == 8) {
        if (pic30_psrd_psrd_errata(operands[1],NULL)) {
          pic30_rtx_nops+=3;
        return \"mov %r1,%2\;\"
                 \"mov [%2++],%0\;\"
                 \"nop\;\"
                 \"mov [%2++],%d0\;\"
                 \"nop\;\"
                 \"mov [%2++],%t0\;\"
                 \"nop\;\"
                 \"mov [%2],%q0\";
        } else {
          return \"mov %r1,%2\;\"
                 \"mov [%2++],%0\;\"
                 \"mov [%2++],%d0\;\"
                 \"mov [%2++],%t0\;\"
                 \"mov [%2],%q0\";
        }
      } else gcc_assert(0);
    }
  }
  "
)

;(define_insn "PPinc_outhi"
;  [(set
;      (match_operand:HI 0 "pic30_any_ppinc_operand"  "= <>R")
;      (match_operand:HI 1 "pic30_register_operand"   "    r"))
;   (clobber 
;      (match_operand:HI 2 "pic30_register_operand"   "=   r"))
;  ]
;  ""
;  "*
;   {
;     /* handle pre/post inc dec */
;     rtx mem_inner;
;     rtx pp_inner = 0;
;
;     mem_inner = XEXP(operands[0],0);
;     if (!REG_P(mem_inner)) {
;       pp_inner = XEXP(mem_inner,0); 
;     }
;     gcc_assert(pp_inner);
;     switch (GET_CODE(pp_inner)) {
;       default: gcc_assert(0);
;       case PRE_INC:  return \"mov %r0,%2
