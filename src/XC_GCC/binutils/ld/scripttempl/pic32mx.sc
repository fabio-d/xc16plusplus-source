#
# ALIGNMENT - Specifies the default alignment for sections within the output
#             file.  Defaults to ${ELFSIZE} / 8 if not specified
#
# BIG_OUTPUT_FORMAT - Names the BFD format to use for the output file
#                     when producing big endian output
#
# BSS_END_SYMBOLS - Symbols that specify the end of the .bss section
#
# BSS_START_SYMBOLS - Symbols that specify the beginning of the .bss
#                     section
#
# CODE_MEMORY_REGION - The region output specifier for all code sections
#
# DATA_START_LOAD_SYMBOL - The name of the symbol representing the
#                          beginning load address of the .data section.
#                          Defaults to _data_image_begin if not specified
#
# DATA_MEMORY_REGION - The region output specifier for all data sections
#
# ELFSIZE - Specifies the size of the ELF file (e.g., 32, 64).  Defaults to
#           32 if not specified
#
# ENTRY - Provides the symbol name that will be the application's entry point.
#         Defaults to _start if not specified.
#
# EXECUTABLE_SYMBOLS - Symbols that must be defined for an executable
#
# INPUT_FILES - INPUT commands of files to always include in the link
#
# LIB_SEARCH_DIRS - Additional library search directories that should be
#                   checked when searching for libraries specified with
#                   -llib.  This variable is automatically created by the
#                   genscript.sh file from the LIB_PATH specified in the
#                   Makefile, which is originally obtained from the
#                   configure command line's --with-lib-path option
#
# LITTLE_OUTPUT_FORMAT - Names the BFD format to use for the output file
#                        when producing little endian output
#
# NOP - Four byte opcode for no-op.  Defaults to 0
#
# OTHER_BSS_SECTIONS - Other output sections to include in the linker
#                      script after the .bss output section
#
# OTHER_GOT_SYMBOLS - Symbols defined just before .got
#
# OTHER_READONLY_SECTION - Other sections besides the standard read-only
#                          sections that should be placed in the
#                          program flash
#
# OTHER_SDATA_SECTIONS - Other output sections to include in the linker
#                        script after the .sdata output section
#
# OTHER_DEBUG_SECTIONS - Other output sections to include in the linker script
#                        after the DEBUG sections
#
# OTHER_SECTIONS - Other output sections to include in the linker script
#                  before the DEBUG sections
#
# OTHER_TEXT_SECTIONS - Other sections besides the standard text section
#                       (.text, .stub, .text.*, and .gnu.linkonce.t.*)
#                       to allocate in the .text section
#
# OUTPUT_ARCH - Specifies the particular output architecture to use for
#               the output file.  If not specified, defaults to either:
#               - ${ARCH} if MACHINE is not specified
#               - ${ARCH}:${MACHINE} if MACHINE is specified
#
# OUTPUT_FORMAT - Names the BFD format to use for the output file by default.
#                 Will be used to initialize BIG_OUTPUT_FORMAT and
#                 LITTLE_OUTPUT_FORMAT if they have not been previously defined
#
# SBSS_END_SYMBOLS - Symbols that specify the end of the .sbss section
#
# SBSS_START_SYMBOLS - Symbols that specify the beginning of the .sbss
#                      section
#
# SDATA_END_SYMBOLS - Symbols that specify the end of the .sdata section
#
# SDATA_START_SYMBOLS - Symbols that specify the beginning of the .sdata
#                       section
#
# TEXT_END_SYMBOLS - Symbols that specify the end of the .text section
#
# TEXT_START_ADDR - If set, will be used as the address of the first
#                   byte of the .text section
#
# TEXT_START_SYMBOLS - Symbols that specify the beginning of the .text section
#
# WRITABLE_RODATA - If set to yes, the .rodata section will be writable
#
#
#  Many sections come in three flavours.  There is the 'real' section,
#  like ".data".  Then there are the per-procedure or per-variable
#  sections, generated by -ffunction-sections and -fdata-sections in GCC,
#  and useful for --gc-sections, which for a variable "foo" might be
#  ".data.foo".  Then there are the linkonce sections, for which the linker
#  eliminates duplicates, which are named like ".gnu.linkonce.d.foo".
#  The exact correspondences are:
#
#  Section      Linkonce section
#  .text        .gnu.linkonce.t.foo
#  .rodata      .gnu.linkonce.r.foo
#  .data        .gnu.linkonce.d.foo
#  .bss         .gnu.linkonce.b.foo
#  .sdata       .gnu.linkonce.s.foo
#  .sbss        .gnu.linkonce.sb.foo
#  .sdata2      .gnu.linkonce.s2.foo
#  .sbss2       .gnu.linkonce.sb2.foo
#  .debug_info  .gnu.linkonce.wi.foo
#  .tdata       .gnu.linkonce.td.foo
#  .tbss        .gnu.linkonce.tb.foo
#
#  Each of these can also have corresponding .rel.* and .rela.* sections.


test -z "$ENTRY" && ENTRY=_start
test -z "${BIG_OUTPUT_FORMAT}" && BIG_OUTPUT_FORMAT=${OUTPUT_FORMAT}
test -z "${LITTLE_OUTPUT_FORMAT}" && LITTLE_OUTPUT_FORMAT=${OUTPUT_FORMAT}
test -z "${OUTPUT_ARCH}" && if [ -z "$MACHINE" ]; then OUTPUT_ARCH=${ARCH}; else OUTPUT_ARCH=${ARCH}:${MACHINE}; fi
test -z "${ELFSIZE}" && ELFSIZE=32
test -z "${ALIGNMENT}" && ALIGNMENT="${ELFSIZE} / 8"
test -z "${DATA_START_LOAD_SYMBOL}" && DATA_START_LOAD_SYMBOL=_data_image_begin
test -z "${TDATA_START_LOAD_SYMBOL}" && TDATA_START_LOAD_SYMBOL=_tdata_image_begin
test -z "${DATA_IMAGE_MEMORY_REGION}" && test ! -z "${CODE_MEMORY_REGION}" && DATA_IMAGE_MEMORY_REGION="AT>${CODE_MEMORY_REGION}"

# If WRITABLE_RODATA is set to yes, then the .rodata output section is
# considered writable and will be placed after the .data section; therefore,
# the .rodata section must be located in data memory instead of program
# flash
if [ -z ${WRITABLE_RODATA} ]; then
RODATA_MEMORY_REGION=${CODE_MEMORY_REGION}
else
RODATA_MEMORY_REGION="${DATA_MEMORY_REGION} ${DATA_IMAGE_MEMORY_REGION}"
fi

# These sections may be located in different locations for the different
# linker scripts that are generated; therefore, we define them separately
# here so that the scripting can put them in the correct location based on
# whether other variables are set.
RODATA="
  .rodata ${RELOCATING-0} :
  {
    *(.rodata${RELOCATING+ .rodata.* .gnu.linkonce.r.*})
    *(.rodata1)
    ${RELOCATING+. = ALIGN(${ALIGNMENT}) ;}
  } >${RODATA_MEMORY_REGION}
"

SDATA="
  /*
   * We want the small data sections together, so single-instruction offsets
   * can access them all, and initialized data all before uninitialized, so
   * we can shorten the on-disk segment size.
   */
  .sdata ALIGN(4) ${RELOCATING-0} :
  {
    ${RELOCATING+${SDATA_START_SYMBOLS}}
    *(.sdata${RELOCATING+ .sdata.* .gnu.linkonce.s.*})
    ${RELOCATING+${SDATA_END_SYMBOLS}}
  } >${DATA_MEMORY_REGION} ${DATA_IMAGE_MEMORY_REGION}
"

SBSS="
  .sbss ALIGN(4) ${RELOCATING-0} :
  {
    ${RELOCATING+${SBSS_START_SYMBOLS}}
    *(.dynsbss)
    *(.sbss${RELOCATING+ .sbss.* .gnu.linkonce.sb.*})
    *(.scommon)
    ${RELOCATING+${SBSS_END_SYMBOLS}}
  } >${DATA_MEMORY_REGION}
"

SDATA2="
  /*
   * Small initialized constant global and static data can be placed in the
   * .sdata2 section.  This is different from .sdata, which contains small
   * initialized non-constant global and static data.
   */
  .sdata2 ALIGN(4) ${RELOCATING-0} :
  {
    *(.sdata2${RELOCATING+ .sdata2.* .gnu.linkonce.s2.*})
    ${RELOCATING+. = ALIGN(${ALIGNMENT}) ;}
  } >${CODE_MEMORY_REGION}
"

SBSS2="
  /*
   * Uninitialized constant global and static data (i.e., variables which will
   * always be zero).  Again, this is different from .sbss, which contains
   * small non-initialized, non-constant global and static data.
   */
  .sbss2 ALIGN(4) ${RELOCATING-0} :
  {
    *(.sbss2${RELOCATING+ .sbss2.* .gnu.linkonce.sb2.*})
    ${RELOCATING+. = ALIGN(${ALIGNMENT}) ;}
  } >${CODE_MEMORY_REGION}
"

GOT="
  .got ALIGN(4) ${RELOCATING-0} :
  {
     *(.got.plt) *(.got)
  } >${DATA_MEMORY_REGION} ${DATA_IMAGE_MEMORY_REGION}
"

STACKNOTE="
  /DISCARD/ : { *(.note.GNU-stack) }
"

if [ "${BIG_OUTPUT_FORMAT}" = "${LITTLE_OUTPUT_FORMAT}" ]; then
cat <<EOF
OUTPUT_FORMAT("${OUTPUT_FORMAT}")
EOF
else
cat <<EOF
OUTPUT_FORMAT("${OUTPUT_FORMAT}", "${BIG_OUTPUT_FORMAT}",
	      "${LITTLE_OUTPUT_FORMAT}")
EOF
fi

cat <<EOF
OUTPUT_ARCH(${OUTPUT_ARCH})
ENTRY(${ENTRY})

${RELOCATING+${LIB_SEARCH_DIRS}}

${RELOCATING+${EXECUTABLE_SYMBOLS}}

${RELOCATING+${INPUT_FILES}}

SECTIONS
{
  /* Boot Sections */
  ${BOOT_SECTION}

  /* Code Sections */
  .text ${RELOCATING+${TEXT_START_ADDR}}${RELOCATING-0} :
  {
    ${RELOCATING+${TEXT_START_SYMBOLS}}
    *(.text .stub${RELOCATING+ .text.* .gnu.linkonce.t.*})
    KEEP (*(.text.*personality*))
    /* .gnu.warning sections are handled specially by elf32.em.  */
    *(.gnu.warning)
    ${RELOCATING+${OTHER_TEXT_SECTIONS}}
    ${RELOCATING+${TEXT_END_SYMBOLS}}
  } >${CODE_MEMORY_REGION} =${NOP-0}
  /* Read-only sections */
  ${WRITABLE_RODATA-${RODATA}}
  ${CREATE_SHLIB-${SDATA2}}
  ${CREATE_SHLIB-${SBSS2}}
  ${OTHER_READONLY_SECTIONS}
  .eh_frame_hdr : { *(.eh_frame_hdr) }
  .eh_frame     ${RELOCATING-0} : ONLY_IF_RO { KEEP (*(.eh_frame)) }

  ${NO_SMALL_DATA+${GOT}}

  .dbg_data (NOLOAD) :
  {
    . += (DEFINED (_DEBUGGER) ? 0x200 : 0x0);
  } >${DATA_MEMORY_REGION}
  
  /* Persistent data */
  .persist :
  {
    _persist_begin = .;
    *(.persist .persist.*)
    _persist_end = .;
  } >${DATA_MEMORY_REGION}

  .data ${RELOCATING-0} :
  {
    ${RELOCATING+${DATA_START_SYMBOLS}}
    *(.data${RELOCATING+ .data.* .gnu.linkonce.d.*})
    KEEP (*(.gnu.linkonce.d.*personality*))
    *(.data1)
  } >${DATA_MEMORY_REGION} ${DATA_IMAGE_MEMORY_REGION}
  ${DATA_START_LOAD_SYMBOL} = LOADADDR(.data) ;

  ${WRITABLE_RODATA+${RODATA}}
  .eh_frame     ${RELOCATING-0} : ONLY_IF_RW { KEEP (*(.eh_frame)) }
  ${OTHER_READWRITE_SECTIONS}
  ${RELOCATING+${OTHER_GOT_SYMBOLS}}
  ${NO_SMALL_DATA-${GOT}}
  ${OTHER_GOT_SECTIONS}
  ${CREATE_SHLIB+${SDATA2}}
  ${CREATE_SHLIB+${SBSS2}}
  ${NO_SMALL_DATA-${SDATA}}
  ${OTHER_SDATA_SECTIONS}
  ${RELOCATING+${BSS_START_SYMBOLS}}
  ${NO_SMALL_DATA-${SBSS}}
  .bss ${RELOCATING-0} :
  {
    *(.dynbss)
    *(.bss${RELOCATING+ .bss.* .gnu.linkonce.b.*})
    *(COMMON)
    /*
     * Align here to ensure that the .bss section occupies space up to
     * _end.  Align after .bss to ensure correct alignment even if the
     * .bss section disappears because there are no input sections.
     */
    ${RELOCATING+. = ALIGN(${ALIGNMENT}) ;}
  } >${DATA_MEMORY_REGION}
  ${OTHER_BSS_SECTIONS}
  ${RELOCATING+. = ALIGN(${ALIGNMENT}) ;}
  ${RELOCATING+_end = . ;}
  ${RELOCATING+${BSS_END_SYMBOLS}}
  ${OTHER_SECTIONS}
  /* Stabs debugging sections.  */
  .stab          0 : { *(.stab) }
  .stabstr       0 : { *(.stabstr) }
  .stab.excl     0 : { *(.stab.excl) }
  .stab.exclstr  0 : { *(.stab.exclstr) }
  .stab.index    0 : { *(.stab.index) }
  .stab.indexstr 0 : { *(.stab.indexstr) }

  .comment       0 : { *(.comment) }
  
  /* DWARF debug sections.
     Symbols in the DWARF debugging sections are relative to the beginning
     of the section so we begin them at 0.  */

  /* DWARF 1 */
  .debug          0 : { *(.debug) }
  .line           0 : { *(.line) }

  /* GNU DWARF 1 extensions */
  .debug_srcinfo  0 : { *(.debug_srcinfo) }
  .debug_sfnames  0 : { *(.debug_sfnames) }

  /* DWARF 1.1 and DWARF 2 */
  .debug_aranges  0 : { *(.debug_aranges) }
  .debug_pubnames 0 : { *(.debug_pubnames) }

  /* DWARF 2 */
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }
  .debug_abbrev   0 : { *(.debug_abbrev) }
  .debug_line     0 : { *(.debug_line) }
  .debug_frame    0 : { *(.debug_frame) }
  .debug_str      0 : { *(.debug_str) }
  .debug_loc      0 : { *(.debug_loc) }
  .debug_macinfo  0 : { *(.debug_macinfo) }

  /* SGI/MIPS DWARF 2 extensions */
  .debug_weaknames 0 : { *(.debug_weaknames) }
  .debug_funcnames 0 : { *(.debug_funcnames) }
  .debug_typenames 0 : { *(.debug_typenames) }
  .debug_varnames  0 : { *(.debug_varnames) }

  ${OTHER_DEBUG_SECTIONS}
  ${OTHER_GOT_RELOC_SECTIONS}
  
  ${RELOCATING+${OTHER_END_SYMBOLS}}
  ${RELOCATING+${STACKNOTE}}
}
EOF
