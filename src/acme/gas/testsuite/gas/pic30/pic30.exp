################################################################################
#
# This is the unit-test suite for the pic30 architecture.
#


#
# Tracy Kuhrt began implementing the unit tests for the initial release of the
# dsPIC assembler.  Because she did not have enough time to complete the imp-
# lementation of her unit-test plan, she asked Jason Kajita to continue writing
# the unit tests.
#

     # 6/29/2001, Jason Kajita
     #
     # We remove tests from the test plan that call for .pword in
     # in the .data section.  This directive is not applicable to
     # the .data section.
     #
     # Removed: 939, 944, 943, 948, 950, 946, 954, 956, 951, 957,
     # 958, 960
     #
	 # We removed the BRANCH OFFSET relocations.  Therefore, we remove unit test
     # cases 847, 848, 850, 849, 846, 821, 822, 824, 823, & 820.
	 #
     # 8/20/2001, Shirley Curtis
	 # Removed: 782, 783, 784, 785, 786, 787, 788, 789, 790, 791,
	 # 792, 793, 794, 795  Not valid in Rev B.
	 #
	 # Removed: 676, 678, 679, 680, 681  Not valid in Rev B.
	 #
	 # Renamed files as follows:
	 # 969b --> 976   856b --> 977   855b --> 978   854b --> 979
	 # 853b --> 980   852b --> 981   851b --> 982   969c --> 983
	 # 969d --> 984   952a --> 952   952b --> 985   953a --> 953
	 # 953b --> 986   955a --> 955   955b --> 987   970a --> 970
	 # 970b --> 988   830b --> 989   833a --> 833   833b --> 990
	 # 869a --> 869   869b --> 991
	 # Offset was changed to tbloffset and psvoffset, tests have been
	 # expanded from single (a/b) test cases.
	 #
	 # Removed: 683, 684, 687, 799, 812, 811, 809, 808, 971
	 #
     # 12/05/2001, JE
         # Updated to validate DO LOOP restrictions tests.
     # 01/28/2002, JE
         # Added utc240 for long section names.
     # 03/15/2002, JE
         # Added utc62* for extended mnemonics on file-register
         # bit-manipulation instructions.
     # 03/26/2002, JE
         # Removed TRAP tests utc76* (this instruction is obsolete)
     # 08/06/2002, JE
         # Added utc241 for include file annotation.
     # 12/06/2002, GM
         # Added the following new tests for v1.10:
         #
         # 1120 1121 1122 1123 1124 1125 1126 1127 1128
         #
     # 12/06/2002, GM
         # Changed utc245r from XFAIL to PASS
     # 01/02/2003, GM
         # Added utc1129, utc1130 for implicit alignment of program memory
     # 01/03/2003, GM
         # Added utc1130 to utc1142 for data references to code sections
     # 01/13/2003, GM
         # Added utc1143 to utc1145 for non-aligned relocations
     # 03/16/2003, GM
         # Added utc1146, utc1147 for invalid addressing modes - SSR# 20404
     # 03/20/2003, GM
         # Added utc1148, utc1149 for invalid floating pt prefix - SSR#20836
     # 03/20/2003, GM
         # Added utc1150 for invalid assembly in data section - SSR# 21676
     # 03/26/2003, GM
         # Added utc1151, utc1152 for alternate forms of .bss - SSR# 21668
     # 03/27/2003, GM
         # Added utc1153 for .lcomm directive
     # 04/01/2003, GM
         # Updated expected error messages for utc633, 644, 645, 651, 659
     # 04/02/2003, GM
         # Updated expected error messages for 23 more tests; all required
         # the phrase "or readonly" to be added
     # 04/02/2003, GM
         # Updated the expected error messages for the following tests:
         #
         # 825, 938, 938b, 675, 670, 695, 814, 806, 700, 813, 711, 717
         # 728, 732, 739, 995, 1006
     # 09/05/2003, GM
         # added utc1154 for odd assignment to location counter
         # in a code section - SSR#22215
     # 09/05/2003, GM
         # added utc1155 for simple dot expressions in program memory - SSR# 22168
     # 09/05/2003, GM
         # added utc1156 for .porg fill values - SSR# 22099
     # 09/10/2003, GM
         # added utc1157-61 for .org/porg/dot-assign from odd fill points
         # in data and program memory - SSR# 22140
     # 10/06/2003, GM
         # removed utc695,utc806 and edited utc814 .. beginning with v1.20
         # do not detect overflow of file register addressing until link time
     # 10/14/2003, GM
         # added utc1162 for "n" and "x" section flag warning - SSR# 22200
     # 10/14/2003, GM
         # added utc1163,1164 (and modified utc827) for warning on use of
         # executible symbol in a LNK instruction - SSR# 22196
     # 11/04/2003, GM
         # improved text of message "alignment too large.." - SSR# 22039
     # 11/04/2003, GM
         # added utc1165 to test max-skip in non-CODE sections - SSR# 22234
     # 11/05/2003, GM
         # added utc1166 to ensure that undefined symbols in indexed
         # addressing mode operands are detected - SSR# 23044
     # 11/05/2003, GM
         # added utc1167 for indexed addressing mode expressions - SSR# 23014
     # 01/19/2004, GM
         # added utc1168-72 for .incbin, .pincbin directives
     # 04/27/2004, JE
         # Modified run_invalid_section_flag() to check for flag 'H',
	 # instead of 'T'. This change is for compatibility with the 
	 # ELF assembler ('T' is a valid ELF section flag).
     # 04/29/2004, JE
         # Included conditional code for ELF, predicated on
	 # [istarget pic30*-*-elf].
     # 08/13/2004, GM
         # Updated utc1122.l to utc1128.l to reflect new symbol __dsPIC30COFF
     # 08/17/2004, GM
         # removed utc238, since support for subsegments have been dropped
         # revised utc240, bss-type sections are no longer marked HAS_CONTENTS
         # revised utc241,974,1111 to reflect new symbol __dsPIC30COFF
     # 10/26/2004, GM
         # added assembler -W option to many tests to suppress warnings
         #  about quoted section directives
         # changed .const,"x" to foo,"x" in the following tests, because
         #  "x" now conflicts with the implied attribuites of .const:
         # 
         #   203  205  214  217  220  223  226  229  232  235
         #   310  314  316  323  325  334  335  338  342  349
         #   351  354  918  919  925  926 1009 1012 1015 1018
         #  1021 1024 1026 1028 1030 1032 1081 1083 1099 1100
     # 10/26/2004, GM
         # Updated expected error messages for 25 tests.
         #  OLD: "...in an executable or readonly section.""
         #  NEW: "...in a code, psv, or eedata section."
     # 10/27/2004, GM
         # Added utc1173,1174,1175,1176 for GOTO target error checking
         #                                         -- SSR# 24791
         # Updated the following elf-specific tests to reflect
         #  new section attributes:
         #   207  208  237  239  240  245b,d,n,r,w,x  901
         #  1144 1151 1152 1153
     # 10/27/2004, GM
         # Added utc1177 for warning on macro re-definition
     # 10/28/2004, GM
         # Added utc1178 for error on executable symbol re-definition
     # 11/10/2004, GM
         # Modified run_invalid_section_flag() so that expected
         #  result is the same for COFF and ELF. Note: We do not
         #  support elf-specific single character flags.
     # 04/06/2006, GM
         # Updated warning message text for utc1179
         # Added the following new tests for C30 v2.x:
         #
         # 1180    1181    1182    1183    1184    1185    1186
         # 1187(3) 1188(3) 1189(3) 1190(3) 1191(5)
     # 05/05/2006, GM
         # Added 1192 as a second test for constants in dmaoffset()
     # 05/08/2006, GM
         # Added the following tests for processor family symbols:
         #
         # 1193  1194  1195  1196  1197  1198  1199  1200
     # 05/22/2006, GM
         # Added utc1201, 1202, 1203, 1204 for .ifdecl, .ifndecl
     # 06/15/2006, GM
         # Added utc1205 for SSR# 27678
     # 08/09/2006, GM
         # Added utc1206, 1207 for SSR# 28708
     # 08/11/2006, GM
         # Added utc1208 for SSR# 29006
     # 08/17/2006, GM
         # utc243, 244 now generate expected errors
     # 11/19/2006, GM
         # Added the following new tests for C30 v3.0:
         #
         # 1206  1207  1208  1209  1210  1211  1212  1213
         # 1214  1215  1216  1217  1218  1219  1220  1221
         # 1222  1223  1224  1225  1226  1227  1228  1229
         # 1230  1231  1232  1233
     # 11/20/2006, GM
         # Added the following new tests for C30 v3.0:
         #
         # 1234  1235  1236  1237  1238  1239  1240  1241
         # 1242  1243  1244  1245  1246  1247  1248  1249
         # 1250  1251  1252  1253
     # 11/21/2006, GM
         # Added the following new tests for C30 v3.0:
         #
         # 1254  1255  1256  1257  1258  1259  1260  1261
         # 1262  1263  1264  1265  1266  1267  1268  1269
         # 1270  1271  1272  1273  1274  1275  1276  1277
         # 1278  1279  1280  1281
     # 11/22/2006, GM
         # Added the following new tests for C30 v3.0:
         #
         # 1282  1283  1284  1285  1286  1287  1288  1289
         # 1290  1291  1292  1293
     # 12/8/2006, GM
         # resolved some conflicts when the v2_00 branch
         # was merged back to the mainline
         #
         # utc1206.s --> utc1294.s
         # utc1207.s --> utc1295.s
         # utc1208.s --> utc1296.s
     # 01/08/2007, GM
         # Added the following tests for .pascii, .pasciz, .pstring:
         #
         # 1297  1298  1299  1300  1301  1302  1303  1304
     # 04/04/2007, GM
         # Added run_symbol_test()
         #
         # Removed the following elf-specific tests, because
         # pic30-objdump now reports the same section attributes
         # for an assembled source file, regardless of object format:
         #
         #  207  208  245b 245n 245w 245d 245r 245x
         #  237  239  240  921  915  898  899
         #  1111 1144 1151 1152 1153
     # 04/11/2007, GM
         # Added utc1305 for .pushsection, .popsection
     # 04/26/2007, GM
         # Added utc819a,b,d,f,g,i,j,k,l for testing the
         # penultimate instruction in DO loops
     # 04/26/2007, GM
         # Added utc1307,1308 for missing names in .section
         # directives
     # 07/08/2008, GM
         # Revised the following tests, because we now support
         # data directives referencing executable symbols
         #
         #  1134  1135  1136  1140  1141  1142
         #
         # Removed the following tests, because psvptr()
         # operator was dropped from the language
         #  
         #  1282  1283  1284  1285  1286  1287  1288
         #  1289  1290  1291  1292  1293
     # 10/14/2008, GM
         # Revised the following tests to match improvement
         # in disassembler (offsets are displayed as dest address)
         #
         #  9  10  815



proc all_nulls { args } {
    foreach x $args { if [expr $x!=0] { return 0 } }
    return 1
}

#
#  run a test that is supposed to produce no output
#

proc run_to_completion { filename } {
    set output 0
    gas_start $filename ""
    while 1 {
      expect {
        eof { break }
        timeout { perror "timeout\n"; break }
        -re ".*\n" { set output 1 }
      }
    }
    gas_finish
    if [expr $output!=0] then { fail $filename } else { pass $filename }
}

################################################################################
#
# This procedure will ensure that a warning is generated if a .fillupper
# directive is seen in a section that is not a .text or executable section.
#
proc run_fillupper_ignored {} {
   set testname ".fillupper ignored."
   set x1 0
   set x2 0
   gas_start "utc18.s" ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Warning: .fillupper not specified in a code section.  .fillupper ignored\[^\n\]*\n"                           { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that a warning is generated if the optional
# argument for the .fillupper directive exceeds the maximum value.
#
proc run_greater_than_max_fillupper {} {
   set testname ".fillupper Maximum + 1."
   set x1 0
   set x2 0
   gas_start "utc25.s" ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Warning: .fillupper expects a constant positive byte value.  0x00 assumed\[^\n\]*\n"                          { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that a warning is generated if the optional
# argument for the .fillupper directive is less than the minimum value.
#
proc run_less_than_min_fillupper {} {
   set testname ".fillupper Minimum - 1."
   set x1 0
   set x2 0
   gas_start "utc24.s" ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Warning: .fillupper expects a constant positive byte value.  0x00 assumed\[^\n\]*\n"                          { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that a warning is generated if a .fillvalue
# directive is seen in a section that is not a .text or executable section.
#
proc run_fillvalue_ignored {} {
   set testname ".fillvalue ignored."
   set x1 0
   set x2 0
   gas_start "utc26.s" ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Warning: .fillvalue not specified in a code section.  .fillvalue ignored\[^\n\]*\n"                           { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that a warning is generated if the optional
# argument for the .fillvalue directive exceeds the maximum value.
#
proc run_greater_than_max_fillvalue {} {
   set testname ".fillvalue Maximum + 1."
   set x1 0
   set x2 0
   gas_start "utc27.s" ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Warning: .fillvalue expects a constant positive byte value.  0x00 assumed\[^\n\]*\n"                          { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that a warning is generated if the optional
# argument for the .fillvalue directive is less than the minimum value.
#
proc run_less_than_min_fillvalue {} {
   set testname ".fillvalue Minimum - 1."
   set x1 0
   set x2 0
   gas_start "utc32.s" ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Warning: .fillvalue expects a constant positive byte value.  0x00 assumed\[^\n\]*\n"                          { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that an error message is generated if the
# specified directive is used within an assembly source file.
#
proc run_directive_deleted { directive } {
   set testname "$directive deleted"
   set err_msg "Error: $directive directive not supported in pic30 target."

   switch $directive {
      ".balign"   { set tst_src "utc2.s" }
      ".balignl"  { set tst_src "utc3.s" }
      ".balignw"  { set tst_src "utc4.s" }
      ".dcb"      { set tst_src "utc291.s" }
      ".dcb.b"    { set tst_src "utc292.s" }
      ".dcb.d"    { set tst_src "utc294.s" }
      ".dcb.l"    { set tst_src "utc295.s" }
      ".dcb.s"    { set tst_src "utc296.s" }
      ".dcb.w"    { set tst_src "utc297.s" }
      ".dcb.x"    { set tst_src "utc298.s" }
      ".ds"       { set tst_src "utc299.s" }
      ".ds.b"     { set tst_src "utc300.s" }
      ".ds.d"     { set tst_src "utc301.s" }
      ".ds.l"     { set tst_src "utc302.s" }
      ".ds.p"     { set tst_src "utc303.s" }
      ".ds.s"     { set tst_src "utc304.s" }
      ".ds.w"     { set tst_src "utc305.s" }
      ".ds.x"     { set tst_src "utc306.s" }
      ".octa"     { set tst_src "utc74.s" }
      ".p2align"  { set tst_src "utc5.s" }
      ".p2alignl" { set tst_src "utc6.s" }
      ".p2alignw" { set tst_src "utc7.s" }
      ".quad"     { set tst_src "utc75.s" }
      ".zero"     { set tst_src "utc307.s" }
   }

   if {![info exists tst_src]} {
      warning "run_directive_deleted:  $directive not a recognized directive."
      fail $testname
   } else {
      set x1 0
      set x2 0
      gas_start $tst_src ""
      while 1 {
         expect {
             -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
             -re "\[ \t\]*$err_msg\[^\n\]*\n"            { set x2 1 }
             -re "\[^\n\]*\n"                    { }
             timeout                             { perror "timeout\n"; break }
             eof                                 { break }
         }
      }
      gas_finish
      if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
   }
}

################################################################################
#
# This procedure will assemble the program specified by the tst_src argument.
# It will check the output to ensure that an error is generated.
#
proc run_expected_error { tst_src testname } {
   set x1 0
   set x2 0
   gas_start $tst_src ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Error: .*\[^\n\]*\n"           { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that a warning is generated if the argument for
# the .byte directive exceeds the maximum value.
#
proc run_greater_than_max_byte {} {
   set testname ".byte Maximum + 1."
   set x1 0
   set x2 0
   gas_start "utc248.s" ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Warning: value 0x100 truncated to 0x0.\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that a warning is generated if the argument for
# the .byte directive is less than the minimum value.
#
proc run_less_than_min_byte {} {
   set testname ".byte Minimum - 1."
   set x1 0
   set x2 0
   gas_start "utc249.s" ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Warning: value 0xffffff7f truncated to 0x7f.\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that a warning is generated if the argument for
# the .word/.hword directive exceeds the maximum value.
#
proc run_greater_than_max_word { is_hword_variant } {
   if { $is_hword_variant } {
      set testname ".hword Maximum + 1."
      set tst_src "utc250.s"
   } else {
      set testname ".word Maximum + 1."
      set tst_src "utc262.s"
   }
   set x1 0
   set x2 0
   gas_start $tst_src ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Warning: value 0x10000 truncated to 0x0.\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that a warning is generated if the argument for
# the .word/.hword directive is less than the minimum value.
#
proc run_less_than_min_word { is_hword_variant } {
   if { $is_hword_variant } {
      set testname ".hword Minimum - 1."
      set tst_src "utc251.s"
   } else {
      set testname ".word Maximum + 1."
      set tst_src "utc263.s"
   }
   set x1 0
   set x2 0
   gas_start $tst_src ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Warning: value 0xffff7fff truncated to 0x7fff.\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will test the assembler to ensure that all instructions are
# encoded properly.
#
proc run_isa_encoding { is_full srcdir subdir AS OBJDUMP } {
   if { $is_full } {
      set testname "ISA Encoding - full"
      set flag "-f"
   } else {
      set testname "ISA Encoding - partial"
      set flag "-p"
   }

   send_log "perl $srcdir/$subdir/isa_encoding.pl -asm $AS -dump $OBJDUMP $flag $srcdir/$subdir/isa.map\n"
   catch "exec $srcdir/lib/run perl $srcdir/$subdir/isa_encoding.pl -asm $AS -dump $OBJDUMP $flag $srcdir/$subdir/isa.map" comp_output

   send_log "$comp_output\n"

   if { [regexp "Errors found!" $comp_output] || \
        [regexp "Died" $comp_output] ||
        [regexp "bad interpreter" $comp_output] ||
        [regexp "not found" $comp_output] ||
        [regexp "Total Tests Completed = 0." $comp_output] } then {
      fail "$testname"
   } else {
      pass "$testname"
   }
}

################################################################################
#
# This procedure will ensure that a warning is generated if the argument for
# the .int/.long directive exceeds the maximum value.
#
proc run_greater_than_max_int { is_long_variant } {
   if { $is_long_variant } {
      set testname ".long Maximum + 1."
      set tst_src "utc258.s"
   } else {
      set testname ".int Maximum + 1."
      set tst_src "utc254.s"
   }
   set x1 0
   set x2 0
   gas_start $tst_src ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Warning: Value 0x100000000 truncated to 0x0.\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that a warning is generated if the argument for
# the .int/.long directive is less than the minimum value.
#
proc run_less_than_min_int { is_long_variant } {
   if { $is_long_variant } {
      set testname ".long Minimum + 1."
      set tst_src "utc259.s"
   } else {
      set testname ".int Minimum + 1."
      set tst_src "utc255.s"
   }
   set x1 0
   set x2 0
   gas_start $tst_src ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Warning: Value 0xf7fffffff truncated to 0x7fffffff.\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}


################################################################################
#
# This procedure will ensure that a warning is generated if the flag argument
# for the .section directive is invalid.
#
proc run_invalid_section_flag {} {
   set testname ".section - Invalid Flag"
   set x1 0
   set x2 0
   set msg "\[ \t\]*Warning: unknown section attribute 'H'\[^\n\]*\n"
   gas_start utc270.s ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re ${msg} { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that a warning is generated if the fill argument
# for the .skip/.space directive exceeds the maximum value.
#
proc run_greater_than_max_skip_fill { is_space_variant } {
   if { $is_space_variant } {
      set testname ".space directive's fill argument - Maximum + 1."
      set tst_src "utc328.s"
   } else {
      set testname ".skip directive's fill argument - Maximum + 1."
      set tst_src "utc319.s"
   }
   set x1 0
   set x2 0
   gas_start $tst_src ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Warning: Value 0x100 truncated to 0x0.\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that a warning is generated if the fill argument
# for the .skip/.space directive is less than the minimum value.
#
proc run_less_than_min_skip_fill { is_space_variant } {
   if { $is_space_variant } {
      set testname ".space directive's fill argument - Minimum + 1."
      set tst_src "utc321.s"
   } else {
      set testname ".skip directive's fill argument - Minimum + 1."
      set tst_src "utc320.s"
   }
   set x1 0
   set x2 0
   gas_start $tst_src ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Warning: Value 0xffffff7f truncated to 0x7f.\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that a warning is generated if the size argument
# for the .fill directive exceeds the maximum value.
#
proc run_greater_than_max_fill_size { } {
   set testname ".fill directive's size argument - Maximum + 1."
   set tst_src "utc345.s"

   set x1 0
   set x2 0
   gas_start $tst_src ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Warning: .fill size clamped to 8.\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that a warning is generated if the size argument
# for the .fill directive is less than the minimum value.
#
proc run_less_than_min_fill_size { } {
   set testname ".fill directive's size argument - Minimum + 1."
   set tst_src "utc346.s"

   set x1 0
   set x2 0
   gas_start $tst_src ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Warning: Size argument < 0.  .fill ignored\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that a warning is generated if the fill argument
# for the .org directive exceeds the maximum value.
#
proc run_greater_than_max_org_fill { } {
   set testname ".org directive's fill argument - Maximum + 1."
   set tst_src "utc357.s"

   set x1 0
   set x2 0
   gas_start $tst_src ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Warning: Value 0x100 truncated to 0x0.\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that a warning is generated if the fill argument
# for the .org directive is less than the minimum value.
#
proc run_less_than_min_org_fill { } {
   set testname ".org directive's fill argument - Minimum + 1."
   set tst_src "utc358.s"

   set x1 0
   set x2 0
   gas_start $tst_src ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Warning: Value 0xffffff7f truncated to 0x7f.\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}


################################################################################
#
# This procedure will ensure that an error is generated if an attempt to .org
# backwards is made.
#
proc run_org_backwards { testname tst_src } {
   set x1 0
   set x2 0
   gas_start $tst_src ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Error: attempt to .org backwards ignored\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that an error is generated if the value for the
# BFD_RELOC_PIC30_BIT_SELECT_3 relocation exceeds the maximum value.
#
proc run_greater_than_maximum_bit_select_3 { } {
   set testname "BFD_RELOC_PIC30_BIT_SELECT_3 - Maximum Relocation + 1"

   set x1 0
   set x2 0
   gas_start utc633.s ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Error: Invalid value \[(\]8\[)\]\. Operand must be between 0 and 7, inclusive\.\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that an error is generated if the value for the
# BFD_RELOC_PIC30_BIT_SELECT_4 relocation exceeds the maximum value.
#
proc run_greater_than_maximum_bit_select_4 { } {
   set testname "BFD_RELOC_PIC30_BIT_SELECT_4 - Maximum Relocation + 1"

   set x1 0
   set x2 0
   gas_start utc644.s ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Error: Invalid value \[(\]16\[)\]\. Operand must be between 0 and 15, inclusive\.\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that an error is generated if the value for the
# BFD_RELOC_PIC30_BIT_SELECT_4_BYTE relocation exceeds the maximum value.
#
proc run_greater_than_maximum_bit_select_4_byte { } {
   set testname "BFD_RELOC_PIC30_BIT_SELECT_4_BYTE - Maximum Relocation + 1"

   set x1 0
   set x2 0
   gas_start utc645.s ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Error: Invalid value \[(\]8\[)\]\. Operand must be between 0 and 7, inclusive\.\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that an error is generated if the value for the
# BFD_RELOC_PIC30_DSP_6 relocation exceeds the maximum value.
#
proc run_greater_than_maximum_dsp_6 { } {
   set testname "BFD_RELOC_PIC30_DSP_6 - Maximum Relocation + 1"

   set x1 0
   set x2 0
   gas_start utc651.s ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Error: Invalid value \[(\]17\[)\]\. Operand must be between -16 and 16, inclusive\.\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that an error is generated if the value for the
# BFD_RELOC_PIC30_DSP_PRESHIFT relocation exceeds the maximum value.
#
proc run_greater_than_maximum_dsp_preshift { } {
   set testname "BFD_RELOC_PIC30_DSP_PRESHIFT - Maximum Relocation + 1"

   set x1 0
   set x2 0
   gas_start utc659.s ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Error: Invalid value \[(\]8\[)\]\. Operand must be between -8 and 7, inclusive\.\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that an error is generated if handle is used
# on a symbol that is located in .data.
#
proc run_handle_of_local_data_symbol { in_text_section } {
   if { $in_text_section } {
      set testname ".word handle(local .data symbol) in .text"
      set filename "utc771.s"
   } else {
      set testname ".word handle(local .data symbol) in .data"
      set filename "utc773.s"
   }

   set x1 0
   set x2 0
   gas_start $filename ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Error: Cannot use handle on a symbol \[(\]data_symbol\[)\] that is not located in a code, psv, or eedata section\.\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that an error is generated if the operands cannot
# be encoded.
#
proc run_invalid_operands_because_of_encoding { tst_cond tst_src } {
   set testname "$tst_cond - Invalid operands because of encoding"
   set x1 0
   set x2 0
   gas_start $tst_src ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Error: Operands share encoding bits.  The operands must encode identically.\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that a warning is generated if the .palign directive
# is found inside of a .data section.
#
proc run_palign_in_data_section { tst_src } {
   set testname ".palign found in .data section"
   set x1 0
   set x2 0
   gas_start $tst_src ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Warning: .palign not specified in a code section.  .palign ignored.\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that the appropriate warning is generated.
#
proc run_test_warning { tst_src tst_name tst_wrn } {
   set testname "$tst_name"
   set x1 0
   set x2 0
   gas_start $tst_src ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Warning: $tst_wrn\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that the appropriate error message is generated.
#
proc run_test_error { tst_src tst_name tst_err } {
   set testname "$tst_name"
   set x1 0
   set x2 0
   gas_start $tst_src ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Error\: $tst_err\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that the appropriate error message is generated
# with a specific assembler option.
#
proc run_test_error_option { tst_src tst_option tst_name tst_err } {
   set testname "$tst_name"
   set x1 0
   set x2 0
   gas_start $tst_src $tst_option
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Error\: $tst_err\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will run the assembler with the given listing options.
#
# There should be an assembly language file named FILE.s in the test
# suite directory, and a pattern file called FILE.l.  `run_list_test'
# will assemble FILE.s with the given listing options, and then analyze that
# with regexps.
#
# The FILE.l file begins with zero or more option lines which specify  the name
# of the test and flags to pass to the assembler.  The option lines have  the
# syntax:
#
#         # OPTION: VALUE
#
# OPTION is the name of some option, like "name" or "as", and
# VALUE is OPTION's value.  The valid options are described below.
# Whitespace is ignored everywhere, except within VALUE.  The option
# list ends with the first line that doesn't match the above syntax
# (hmm, not great for error detection).
#
# The interesting options are:
#
#   name: TEST-NAME
#       The name of this test, passed to DejaGNU's `pass' and `fail'
#       commands.  If omitted, this defaults to FILE, the root of the
#       .s and .l files' names.
#
#   as: FLAGS
#       When assembling FILE.s, pass FLAGS to the assembler.
#
# Each option may occur at most once.
#
# After the option lines come regexp lines.  `run_list_test' calls
# `regexp_diff' to compare the output of the listing file against the
# regexps in FILE.l.
#
proc run_list_test { name } {
   global srcdir subdir
   global AS
   global ASFLAGS

   if [string match "*/*" $name] {
      set file $name
      set name [file tail $name]
   } else {
      set file "$srcdir/$subdir/$name"
   }
   if [istarget pic30*-*-elf] {
      set listfile "${file}elf.l"
   } else {
      set listfile "${file}.l"
   }
   set opt_array [slurp_options ${listfile}]
   if { $opt_array == -1 } {
      perror "error reading options from $file.l"
      unresolved $subdir/$name
      return
   }

   set opts(as) {}
   set opts(name) {}

   foreach i $opt_array {
      set opt_name [lindex $i 0]
      set opt_val [lindex $i 1]
      if ![info exists opts($opt_name)] {
         perror "unknown option $opt_name in file $file.l"
         unresolved $subdir/$name
         return
      }
      if [string length $opts($opt_name)] {
         perror "option $opt_name multiply set in $file.l"
         unresolved $subdir/$name
         return
      }
      set opts($opt_name) $opt_val
   }

   if { $opts(name) == "" } {
      set testname "$subdir/$name"
   } else {
      set testname $opts(name)
   }

   set sourcefile ${file}.s

   send_log "$AS $ASFLAGS $opts(as) -o dump.o $sourcefile\n"
   catch "exec $srcdir/lib/run $AS $ASFLAGS $opts(as) -o dump.o $sourcefile > dump.out"

   verbose_eval {[file_contents "dump.out"]} 3
   if { [regexp_diff "dump.out" ${listfile}] } then {
      fail $testname
      verbose "output is [file_contents "dump.out"]" 2
      verbose "in pic30.exp" 0
      return
   }

    pass $testname
}

################################################################################
#
# This procedure will ensure that the appropriate error message is generated.
#
proc run_invalid_processor { } {
   set testname "--processor - Invalid Processor Specified"
   set x1 0
   gas_start "utc1112.s" "--processor 30F9999"
   while 1 {
      expect {
          -re "\[ \t\]*Unknown processor 30F9999\[^\n\]*\n" { set x1 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if { $x1 == 1 } then { pass $testname } else { fail $testname }
}

######################################
#
#  This test needs to know the pathname to the test directory...
#  also, currently this test is not expected to work under unix
#

proc run_test_utc1113 { } {
   global srcdir
   global subdir

   set fd [open $srcdir/$subdir/utc1113.s w]
   puts $fd ".include \"$srcdir/$subdir/utc1113\\bug.s\""
   close $fd
   run_to_completion utc1113.s
}
######################################
#
#  This test needs to know the pathname to the test directory.
#

proc run_dump_test_utc241 { } {
   global srcdir
   global subdir

   set fd [open $srcdir/$subdir/utc241.s w]
   puts $fd "\t.include \"$srcdir/$subdir/utc241.inc\""
   close $fd

   if [istarget pic30*-*-elf] {
      run_dump_test utc241elf
   } else {
      run_dump_test utc241
   }

   set fd [open $srcdir/$subdir/utc241.s w]
   puts $fd "\t.include \"utc241.inc\""
   close $fd
}

################################################################################
#
# This procedure will assemble a test file and look for a specified
# symbol in the output file.
#
proc run_symbol_test { sourcefile options testname symname } {
   global srcdir subdir
   global AS
   global ASFLAGS

   if [string match "*/*" $sourcefile] {
      set file $sourcefile
   } else {
      set file "$srcdir/$subdir/$sourcefile"
   }

   send_log "$AS $ASFLAGS $options -o dump.o $file\n"
   catch "exec $srcdir/lib/run $AS $ASFLAGS $options  -o dump.o $file" comp_output
   send_log $comp_output
   send_log "../../binutils/nm-new dump.o\n"
   catch "exec $srcdir/lib/run ../../binutils/nm-new dump.o" comp_output
   send_log $comp_output
   send_log "\n"

   if { [regexp "$symname" $comp_output] } then {
      pass "$testname"
   } else {
      fail "$testname"
   }
}

################################################################################

if [istarget pic30*-*-*] {

   run_test_utc1113

   #
   # This test will check to see that the new assembler directive, .fillupper,
   # exists.
   #
   gas_test "utc17.s" "" "" ".fillupper Exists"

   #
   # This test will ensure that the default value for the .fillupper directive
   # is used when no .fillupper has been specified -- see utc21.[sd].
   #
   run_dump_test utc21

   #
   # This test will ensure that a warning is generated if a .fillupper
   # directive is seen in a section that is not a .text or executable section.
   # -- see utc18.s
   #
   run_fillupper_ignored

   #
   # This test will ensure that the default value is used when .fillupper is
   # found in the source file without an additional argument after having
   # seen a .fillupper directive that set the value.
   #
   run_dump_test utc22

   #
   # This test will ensure that the upper byte of program memory is filled
   # with the specified fillupper value.
   #
   run_dump_test utc19

   #
   # This test will ensure that the maximum value may be specified for the
   # .fillupper directive.
   #
   gas_test "utc20.s" "" "" ".fillupper Maximum"

   #
   # This test will ensure that the minimum value may be specified for the
   # .fillupper directive.
   #
   gas_test "utc23.s" "" "" ".fillupper Minimum"

   #
   # This test will ensure that the .fillupper directive will not accept a
   # value of 0xFF+1 as the optional argument -- see utc25.s
   #
   run_greater_than_max_fillupper

   #
   # This test will ensure that the .fillupper directive will not accept a
   # value of 0x0-1 as the optional argument -- see utc24.s
   #
   run_less_than_min_fillupper

   #
   # This test will check to see that the new assembler directive, .fillvalue,
   # exists.
   #
   gas_test "utc28.s" "" "" ".fillvalue Exists"

   #
   # This test will ensure that the default value for the .fillvalue directive
   # is used when no .fillvalue has been specified -- see utc30.[sd]
   #
   run_dump_test utc30

   #
   # This test will ensure that a warning is generated if a .fillvalue
   # directive is seen in a section that is not a .text or executable section.
   # -- see utc26.s
   #
   run_fillvalue_ignored

   #
   # This test will ensure that the default value is used when .fillvalue is
   # found in the source file without an additional argument after having
   # seen a .fillvalue directive that set the value.
   #
   run_dump_test utc34

   #
   # This test will ensure that the specified value for the .fillvalue
   # directive is used to fill the user-addressable PC locations.
   #
   run_dump_test utc33

   #
   # This test will ensure that the maximum value may be specified for the
   # .fillvalue directive.
   #
   gas_test "utc29.s" "" "" ".fillvalue Maximum"

   #
   # This test will ensure that the minimum value may be specified for the
   # .fillvalue directive.
   #
   gas_test "utc31.s" "" "" ".fillvalue Minimum"

   #
   # This test will ensure that the .fillvalue directive will not accept a
   # value of 0xFF+1 as the optional argument -- see utc27.s
   #
   run_greater_than_max_fillvalue

   #
   # This test will ensure that the .fillvalue directive will not accept a
   # value of 0x0-1 as the optional argument -- see utc32.s
   #
   run_less_than_min_fillvalue

   #
   # The following test will ensure that if the listed directive is found
   # in the assembly source file, then an error message is generated stating
   # that this directive is not supported in the pic30 target -- see utc2.s
   # utc3.s utc4.s utc291.s utc292.s utc294.s utc295.s utc296.s utc297.s
   # utc298.s utc299.s utc300.s utc301.s utc302.s utc303.s utc304.s utc305.s
   # utc306.s utc74.s utc5.s utc6.s utc7.s utc75.s utc307.s.
   #
   run_directive_deleted .balign
   run_directive_deleted .balignl
   run_directive_deleted .balignw
   run_directive_deleted .dcb
   run_directive_deleted .dcb.b
   run_directive_deleted .dcb.d
   run_directive_deleted .dcb.l
   run_directive_deleted .dcb.s
   run_directive_deleted .dcb.w
   run_directive_deleted .dcb.x
   run_directive_deleted .ds
   run_directive_deleted .ds.b
   run_directive_deleted .ds.d
   run_directive_deleted .ds.l
   run_directive_deleted .ds.p
   run_directive_deleted .ds.s
   run_directive_deleted .ds.w
   run_directive_deleted .ds.x
   run_directive_deleted .octa
   run_directive_deleted .p2align
   run_directive_deleted .p2alignl
   run_directive_deleted .p2alignw
   run_directive_deleted .quad
   run_directive_deleted .zero

   #
   # This test will ensure that the .ascii directive is handled correctly in
   # the .data section.
   #
   run_dump_test utc202

   #
   # This test will ensure that the .ascii directive is handled correctly in
   # the .section foo, "x" section.
   #
   run_dump_test utc203

   #
   # This test will ensure that the .ascii directive is handled correctly in
   # the .text section.
   #
   run_dump_test utc201

   #
   # This test will ensure that an error is given when the <> are left off
   # when specifying a .ascii string
   #
   run_expected_error "utc267.s" ".ascii Missing <>"

   #
   # This test will ensure that an error is given when single quotes are used
   # instead of double quotes when specifying a .ascii string.
   #
   run_expected_error "utc266.s" ".ascii Single Quotes instead of Double Quotes"

   #
   # This test will ensure that the .asciz directive is handled correctly in
   # the .data section.
   #
   run_dump_test utc204

   #
   # This test will ensure that the .asciz directive is handled correctly in
   # the .section foo, "x" section.
   #
   run_dump_test utc205

   #
   # This test will ensure that the .asciz directive is handled correctly in
   # the .text section.
   #
   run_dump_test utc206

   #
   # This test will ensure that an error is given when the <> are left off
   # when specifying a .asciz string
   #
   run_expected_error "utc268.s" ".asciz Missing <>"

   #
   # This test will ensure that an error is given when single quotes are used
   # instead of double quotes when specifying a .asciz string.
   #
   run_expected_error "utc269.s" ".asciz Single Quotes instead of Double Quotes"

   #
   # This test will ensure that a .bss directive will assemble the statements
   # that follow it in the .bss section.
   #
   run_dump_test utc207

   #
   # This test will ensure that the .byte directive is handled correctly in
   # the .data section.
   #
   run_dump_test utc213

   #
   # This test will ensure that the .byte directive is handled correctly in
   # an executable section (.section foo, "x")
   #
   run_dump_test utc214

   #
   # This test will ensure that the .byte directive is handled correctly in
   # the .text section.
   #
   run_dump_test utc215

   #
   # This test will ensure that the maximum byte value is accepted by the .byte
   # directive.
   #
   gas_test "utc246.s" "" "" ".byte Maximum"

   #
   # This test will ensure that the minimum byte value is accepted by the .byte
   # directive.
   #
   gas_test "utc247.s" "" "" ".byte Minimum"

   #
   # This test will ensure that a warning is generated when the .byte directive
   # is given a value that is larger than a byte -- see utc248.s.
   #
   run_greater_than_max_byte

   #
   # This test will ensure that a warning is generated when the .byte directive
   # is given a value that is less than the minimum byte -- see utc249.s.
   #
   run_less_than_min_byte

   #
   # This test will ensure that a .data directive will assemble the statements
   # that follow it in the .data section.
   #
   run_dump_test utc208

   #
   # This test will ensure that the optional subsection argument of the .data
   # directive functions properly.
   #
   #run_dump_test utc244
   run_test_error utc244.s \
      "subsection argument of .data rejected" \
      {rest of line ignored; first ignored character is `1'}

   #
   # This test will ensure that the .double directive is handled correctly in
   # the .data section.
   #
   run_dump_test utc216

   #
   # This test will ensure that the .double directive is handled correctly in
   # the .section foo, "x" section.
   #
   run_dump_test utc217

   #
   # This test will ensure that the .double directive is handled correctly in
   # the .text section.
   #
   run_dump_test utc218

   #
   # This test will ensure that the .float directive is handled correctly in
   # the .data section.
   #
   run_dump_test utc219

   #
   # This test will ensure that the .float directive is handled correctly in
   # the .section foo, "x" section.
   #
   run_dump_test utc220

   #
   # This test will ensure that the .float directive is handled correctly in
   # the .text section.
   #
   run_dump_test utc221

   #
   # This test will ensure that the .hword directive is handled correctly in
   # the .data section.
   #
   run_dump_test utc225

   #
   # This test will ensure that the .hword directive is handled correctly in
   # the .section foo, "x" section.
   #
   run_dump_test utc226

   #
   # This test will ensure that the .hword directive is handled correctly in
   # the .text section.
   #
   run_dump_test utc227

   #
   # This test will ensure that the maximum hword value is accepted by the
   # .hword directive.
   #
   gas_test "utc252.s" "" "" ".hword Maximum"

   #
   # This test will ensure that the minimum hword value is accepted by the
   # .hword directive.
   #
   gas_test "utc253.s" "" "" ".hword Minimum"

   #
   # This test will ensure that a warning is generated when the .hword directive
   # is given a value that is larger than a hword -- see utc250.s.
   #
   run_greater_than_max_word true

   #
   # This test will ensure that a warning is generated when the .hword directive
   # is given a value that is less than the minimum hword -- see utc251.s.
   #
   run_less_than_min_word true

   #
   # This test will ensure that the .int directive is handled correctly in
   # the .data section.
   #
   run_dump_test utc228

   #
   # This test will ensure that the .int directive is handled correctly in
   # the .section foo, "x" section.
   #
   run_dump_test utc229

   #
   # This test will ensure that the .int directive is handled correctly in
   # the .text section.
   #
   run_dump_test utc230

   #
   # This test will ensure that the maximum int value is accepted by the
   # .int directive.
   #
   gas_test "utc256.s" "" "" ".int Maximum"

   #
   # This test will ensure that the minimum int value is accepted by the
   # .int directive.
   #
   gas_test "utc257.s" "" "" ".int Minimum"

   #
   # This test will ensure that a warning is generated when the .int directive
   # is given a value that is larger than a int -- see utc254.s.
   #
   setup_xfail pic30*-*-*
   run_greater_than_max_int false

   #
   # This test will ensure that a warning is generated when the .int directive
   # is given a value that is less than the minimum int -- see utc255.s.
   #
   setup_xfail pic30*-*-*
   run_less_than_min_int false

   #
   # This test will ensure that the .long directive is handled correctly in
   # the .data section.
   #
   run_dump_test utc231

   #
   # This test will ensure that the .long directive is handled correctly in
   # the .section foo, "x" section.
   #
   run_dump_test utc232

   #
   # This test will ensure that the .long directive is handled correctly in
   # the .text section.
   #
   run_dump_test utc233

   #
   # This test will ensure that the maximum long value is accepted by the
   # .long directive.
   #
   gas_test "utc260.s" "" "" ".long Maximum"

   #
   # This test will ensure that the minimum long value is accepted by the
   # .long directive.
   #
   gas_test "utc261.s" "-W" "" ".long Minimum"

   #
   # This test will ensure that a warning is generated when the .long directive
   # is given a value that is larger than a long -- see utc258.s.
   #
   setup_xfail pic30*-*-*
   run_greater_than_max_int true

   #
   # This test will ensure that a warning is generated when the .long directive
   # is given a value that is less than the minimum long -- see utc259.s.
   #
   setup_xfail pic30*-*-*
   run_less_than_min_int true

   #
   # This test will test to ensure that all "flags" (b, n, w, d, r, s, x) are
   # accepted by the assembler for the .section name, "flags" directive.
   #
   run_dump_test utc245b
   run_dump_test utc245n
   run_dump_test utc245w
   run_dump_test utc245d
   run_dump_test utc245r

   setup_xfail pic30*-*-*
   run_dump_test utc245s

   run_dump_test utc245x

   #
   # This test will ensure that the .section name directive (without any
   # optional arguments) will create a section of the given name.
   #
   run_dump_test utc237

   #
   # This test will ensure that the optional "flags" argument of the .section
   # directive functions properly.
   #
   run_dump_test utc239

   #
   # This test will ensure that a warning is given when an invalid flag is
   # specified for the .section directive -- see utc270.s.
   #
   run_invalid_section_flag

   #
   # This test will ensure that the .single directive is handled correctly in
   # the .data section.
   #
   run_dump_test utc222

   #
   # This test will ensure that the .single directive is handled correctly in
   # the .section foo, "x" section.
   #
   run_dump_test utc223

   #
   # This test will ensure that the .single directive is handled correctly in
   # the .text section.
   #
   run_dump_test utc224

   #
   # This test will ensure that the .text directive will assemble the
   # statements that follow it in the .text section.
   #
   run_dump_test utc209

   #
   # This test will ensure that the .word directive is handled correctly in
   # the .data section.
   #
   run_dump_test utc234

   #
   # This test will ensure that the .word directive is handled correctly in
   # the .section foo, "x" section.
   #
   run_dump_test utc235

   #
   # This test will ensure that the .word directive is handled correctly in
   # the .text section.
   #
   run_dump_test utc236

   #
   # This test will ensure that the long section names are supported
   #
   run_dump_test utc240

   #
   # This test will ensure that include file annotation is supported
   #
   run_dump_test_utc241

   #
   # This test will ensure that the optional subsection argument of the .text
   # directive functions properly.
   #
   #run_dump_test utc243
   run_test_error utc243.s \
      "subsection argument of .text rejected" \
      {rest of line ignored; first ignored character is `1'}

   #
   # This test will ensure that the maximum word value is accepted by the
   # .word directive.
   #
   gas_test "utc264.s" "" "" ".word Maximum"

   #
   # This test will ensure that the minimum word value is accepted by the
   # .word directive.
   #
   gas_test "utc265.s" "" "" ".word Minimum"

   #
   # This test will ensure that a warning is generated when the .word directive
   # is given a value that is larger than a word -- see utc262.s.
   #
   run_greater_than_max_word false

   #
   # This test will ensure that a warning is generated when the .word directive
   # is given a value that is less than the minimum word -- see utc263.s.
   #
   run_less_than_min_word false

   #
   # This test test all the possible encoding for all instructions.
   #
   #run_isa_encoding false $srcdir $subdir $AS $OBJDUMP

   #
   # This test will ensure that a CALL instruction is relaxed to an RCALL
   # instruction.
   #
   run_dump_test utc8

   #
   # This test will ensure that a CALL to the furthest negative instruction
   # (-32768) will be relaxed to an RCALL instruction.
   #
   run_dump_test utc10

   #
   # This test will ensure that a CALL to the furthest possible instruction
   # (+32767) will be relaxed to an RCALL instruction.
   #
   run_dump_test utc9

   #
   # This test will ensure that a CALL to an instruction that is -32k-1 away
   # will not be relaxed to a RCALL instruction.
   #
   run_dump_test utc13

   #
   # This test will ensure that a CALL to an instruction that is 32k+1 away
   # will not be relaxed to a RCALL instruction.
   #
   run_dump_test utc12

   #
   # This test will ensure that an align in the data section moves the location
   # counter to the next even data address.
   #
   run_dump_test utc308

   #
   # This test will ensure that an align in the text section moves the location
   # counter to the next even program memory address.
   #
   run_dump_test utc309

   #
   # This test will ensure that an align in an "x" section moves the location
   # counter to the next even program memory address.
   #
   run_dump_test utc310

   #
   # This test will ensure that the .skip directive skips the correct number
   # of bytes when in the .data section and that the skipped space is filled
   # with 0x00.
   #
   run_dump_test utc311

   #
   # This test will ensure that the .skip directive skips the correct number of
   # bytes when in the .data section and that the skipped space is filled with
   # the specified fill value.
   #
   run_dump_test utc312

   #
   # This test will ensure that the .skip directive skips the correct number of
   # bytes when in a .text section and that the skipped space is
   # filled with the last specified fill value.  NOTE:  Only the lower two
   # bytes are counted when skipping bytes.  The upper byte and phantom byte
   # are not counted.
   #
   run_dump_test utc315

   #
   # This test will ensure that the .skip directive skips the correct number of
   # bytes when in a .text section and that the skipped space is
   # filled with the specified fill value.  NOTE:  Only the lower two
   # bytes are counted when skipping bytes.  The upper byte and phantom byte
   # are not counted.
   #
   run_dump_test utc313

   #
   # This test will ensure that the .skip directive skips the correct number of
   # bytes when in a .section foo, "x" section and that the skipped space is
   # filled with the last specified fill value.  NOTE:  Only the lower two
   # bytes are counted when skipping bytes.  The upper byte and phantom byte
   # are not counted.
   #
   run_dump_test utc316

   #
   # This test will ensure that the .skip directive skips the correct number of
   # bytes when in a .section foo, "x" section and that the skipped space is
   # filled with the specified fill value.  NOTE:  Only the lower two
   # bytes are counted when skipping bytes.  The upper byte and phantom byte
   # are not counted.
   #
   run_dump_test utc314

   #
   # This test will ensure that the maximum value for the fill argument of
   # the .skip directive is accepted.
   #
   run_dump_test utc317

   #
   # This test will ensure that the minimum value for the fill argument of
   # the .skip directive is accepted.
   #
   run_dump_test utc318

   #
   # This test will ensure that a warning is generated when the fill argument
   # of the .skip directive is given a value that is one more than the maximum
   # byte value -- see utc319.s.
   #
   run_greater_than_max_skip_fill false

   #
   # This test will ensure that a warning is generated when the fill argument
   # of the .skip directive is given a value that is one less than the minimum
   # byte value -- see utc320.s.
   #
   run_less_than_min_skip_fill false

   #
   # This test will ensure that the .space directive skips the correct number
   # of bytes when in the .data section and that the skipped space is filled
   # with 0x00.
   #
   run_dump_test utc324

   #
   # This test will ensure that the .space directive skips the correct number of
   # bytes when in the .data section and that the skipped space is filled with
   # the specified fill value.
   #
   run_dump_test utc329

   #
   # This test will ensure that the .space directive skips the correct number of
   # bytes when in a .text section and that the skipped space is
   # filled with the last specified fill value.  NOTE:  Only PC addressable
   # bytes are counted when skipping bytes.  The upper byte and phantom byte
   # are not counted.
   #
   run_dump_test utc322

   #
   # This test will ensure that the .space directive skips the correct number of
   # bytes when in a .text section and that the skipped space is
   # filled with the specified fill value.  NOTE:  Only PC addressable
   # bytes are counted when skipping bytes.  The upper byte and phantom byte
   # are not counted.
   #
   run_dump_test utc330

   #
   # This test will ensure that the .space directive skips the correct number of
   # bytes when in a .section foo, "x" section and that the skipped space is
   # filled with the last specified fill value.  NOTE:  Only PC addressable
   # bytes are counted when skipping bytes.  The upper byte and phantom byte
   # are not counted.
   #
   run_dump_test utc323

   #
   # This test will ensure that the .space directive skips the correct number of
   # bytes when in a .section foo, "x" section and that the skipped space is
   # filled with the specified fill value.  NOTE:  Only PC addressable
   # bytes are counted when skipping bytes.  The upper byte and phantom byte
   # are not counted.
   #
   run_dump_test utc325

   #
   # This test will ensure that the maximum value for the fill argument of
   # the .space directive is accepted.
   #
   run_dump_test utc326

   #
   # This test will ensure that the minimum value for the fill argument of
   # the .space directive is accepted.
   #
   run_dump_test utc327

   #
   # This test will ensure that a warning is generated when the fill argument
   # of the .space directive is given a value that is one more than the maximum
   # byte value -- see utc328.s.
   #
   run_greater_than_max_skip_fill true

   #
   # This test will ensure that a warning is generated when the fill argument
   # of the .space directive is given a value that is one less than the minimum
   # byte value -- see utc329.s.
   #
   run_less_than_min_skip_fill true

   #
   # This test will ensure that the .fill directive with no optional arguments
   # fills the correct number of bytes in the .data section.
   #
   run_dump_test utc331

   #
   # This test will ensure that the .fill directive with no optional arguments
   # fills the correct number of bytes in the .text section.
   #
   run_dump_test utc332

   #
   # This test will ensure that the .fill directive with no optional arguments
   # fills the bytes correctly in the .text section.  This includes a
   # .fillvalue and .fillupper directive.
   #
   run_dump_test utc333

   #
   # This test will ensure that the .fill directive with no optional arguments
   # fills the correct number of bytes in a .section foo, "x" section.
   #
   run_dump_test utc334

   #
   # This test will ensure that the .fill directive with no optional arguments
   # fills the bytes correctly in a .section foo, "x" section.  This includes
   # a .fillvalue and .fillupper directive.
   #
   run_dump_test utc335

   #
   # This test will ensure that the .fill directive given a size parameter
   # fills repeat * size bytes with 0x00 inside of the .data section.
   #
   run_dump_test utc336

   #
   # This test will ensure that the .fill directive given a size parameter
   # fills repeat * size user-addressable PC bytes with 0x00 inside of the
   # .text section.
   #
   run_dump_test utc337

   #
   # This test will ensure that the .fill directive given a size parameter
   # fills repeat * size user-addressable PC bytes with 0x00 inside of a
   # .section foo, "x" section.
   #
   run_dump_test utc338

   #
   # This test will ensure the .fill directive given both a size and value
   # parameter fills repeat * size bytes in the .data section with the value
   # specified.
   #
   run_dump_test utc339

   #
   # This test will ensure that the .fill directive given both a size and value
   # parameter fills repeat * size user-addressable PC bytes in the .text
   # section with the value specified.
   #
   run_dump_test utc340

   #
   # This test will ensure that the .fill directive given both a size and value
   # parameter fills repeat * size user-addressable PC bytes in a
   # .section foo, "x" section with the value specified.
   #
   run_dump_test utc342

   #
   # This test will ensure that the maximum size parameter (8) for the .fill
   # directive is accepted.
   #
   gas_test "utc343.s" "" "" ".fill Maximum Size"

   #
   # This test will ensure that the minimum size parameter (0) for the .fill
   # directive is accepted.
   #
   gas_test "utc344.s" "" "" ".fill Minimum Size"

   #
   # This test will ensure that a warning is generated when the size argument
   # of the .fill directive is given a value that is one more than the maximum
   # value -- see utc345.s.
   #
   run_greater_than_max_fill_size

   #
   # This test will ensure that a warning is generated when the size argument
   # of the .fill directive is given a value that is one less than the minimum
   # value -- see utc346.s.
   #
   run_less_than_min_fill_size

   #
   # This test will ensure that the .org directive in the .data section
   # moves the location counter to the correct position and fills all
   # intervening bytes with 0x00.
   #
   run_dump_test utc347

   #
   # This test will ensure that the .org directive in the .text section
   # moves the location counter to the correct position and fills all
   # intervening bytes with 0x00.
   #
   run_dump_test utc348

   #
   # This test will ensure that the .org directive in a .section foo, "x"
   # section moves the location counter to the correct position and fills
   # all intervening bytes with 0x00.
   #
   run_dump_test utc349

   #
   # This test will ensure that the .org directive in the .text section
   # moves the location counter to the correct position and fills the
   # intervening bytes with the .fillvalue and .fillupper values specified.
   #
   run_dump_test utc350

   #
   # This test will ensure that the .org directive in the .section foo, "x"
   # section moves the location counter to the correct position and fills the
   # intervening bytes with the .fillvalue and .fillupper values specified.
   #
   run_dump_test utc351

   #
   # This test will ensure that the .org directive in the .data section moves
   # the location counter to the correct position and fills the intervening
   # bytes with the fill value specified.
   #
   run_dump_test utc352

   #
   # This test will ensure that the .org directive in the .text section moves
   # the location counter to the correct position and fills the intervening
   # user-addressable PC bytes with the fill value specified.
   #
   run_dump_test utc353

   #
   # This test will ensure that the .org directive in a .section foo, "x"
   # section moves the location counter to the correct position and fills the
   # intervening user-addressable PC bytes with the fill value specified.
   #
   run_dump_test utc354

   #
   # This test will ensure that the maximum fill parameter (0xFF) for the .org
   # directive is accepted.
   #
   gas_test "utc355.s" "" "" ".org Maximum Fill"

   #
   # This test will ensure that the minimum fill parameter (-128) for the .org
   # directive is accepted.
   #
   gas_test "utc356.s" "" "" ".org Minimum Fill"

   #
   # This test will ensure that a warning is generated when the fill argument
   # of the .org directive is given a value that is one more than the maximum
   # byte value -- see utc357.s.
   #
   run_greater_than_max_org_fill

   #
   # This test will ensure that a warning is generated when the fill argument
   # of the .org directive is given a value that is one less than the minimum
   # byte value -- see utc358.s.
   #
   run_less_than_min_org_fill

   #
   # This test will ensure than an error is generated when an attempt is made
   # to .org backwards in a section.
   #
   setup_xfail pic30*-*-*
   run_org_backwards ".org Backwards" "utc359.s"

   #
   # This test validates that BCLR[.W] is translated to BCLR.B
   #
   run_dump_test utc620
   #
   # This test validates that BSET[.W] is translated to BSET.B
   #
   run_dump_test utc621
   #
   # This test validates that BTG[.W] is translated to BTG.B
   #
   run_dump_test utc622
   #
   # This test validates that BTST[.W] is translated to BTST.B
   #
   run_dump_test utc623
   #
   # This test validates that BTSS[.W] is translated to BTSS.B
   #
   run_dump_test utc623a
   #
   # This test validates that BTSC[.W] is translated to BTSC.B
   #
   run_dump_test utc623b
   #
   # This test validates that BTSTS[.W] is translated to BTSTS.B
   #
   run_dump_test utc624

   #
   # This test validates that BCLR[.W] requires a constant bit no.
   #
   run_test_error "utc625.s" "BCLR Constant Operand Restrictions" \
      {Invalid operands specified .*}
   #
   # This test validates that BSET[.W] requires a constant bit no.
   #
   run_test_error "utc626.s" "BSET Constant Operand Restrictions" \
      {Invalid operands specified .*}
   #
   # This test validates that BTG[.W] requires a constant bit no.
   #
   run_test_error "utc627.s" "BTG Constant Operand Restrictions" \
      {Invalid operands specified .*}
   #
   # This test validates that BTST[.W] requires a constant bit no.
   #
   run_test_error "utc628.s" "BTST Constant Operand Restrictions" \
      {Invalid operands specified .*}
   #
   # This test validates that BTSTS[.W] requires a constant bit no.
   #
   run_test_error "utc629.s" "BTSTS Constant Operand Restrictions" \
      {Invalid operands specified .*}

   #
   # This test will ensure that a BIT SELECT 3 relocation is created for an
   # instruction that takes a 3-bit bit selection operand which references an
   # external variable.
   #
   run_dump_test utc637

   #
   # This test will ensure that a BIT SELECT 3 relocation is created for an
   # instruction that takes a 3-bit bit selection operand which references a
   # local variable.
   #
   run_dump_test utc638

   #
   # This test will ensure that a BIT SELECT 3 relocation is created for an
   # instruction that takes a 3-bit bit selection operand which references a
   # local variable with the maximum value of 7.
   #
   run_dump_test utc635

   #
   # This test will ensure that a BIT SELECT 3 relocation is created for an
   # instruction that takes a 3-bit bit selection operand which references a
   # local variable with the minimum value of 0.
   #
   run_dump_test utc634

   #
   # This test will ensure that an error is generated for an instruction
   # that takes a 3-bit bit selection operand which references a local
   # variable that exceeds the maximum value of 7 -- see utc633.s.
   #
   run_greater_than_maximum_bit_select_3

   #
   # This test will ensure that a BIT SELECT 4 relocation is created for an
   # instruction that takes a 4-bit bit selection operand which references an
   # external variable.
   #
   run_dump_test utc641

   #
   # This test will ensure that a BIT SELECT 4 relocation is created for an
   # instruction that takes a 4-bit bit selection operand which references a
   # local variable.
   #
   run_dump_test utc642

   #
   # This test will ensure that a BIT SELECT 4 relocation is created for an
   # instruction that takes a 4-bit bit selection operand which references a
   # local variable with the maximum value of 15.
   #
   run_dump_test utc640

   #
   # This test will ensure that a BIT SELECT 4 relocation is created for an
   # instruction that takes a 4-bit bit selection operand which references a
   # local variable with the minimum value of 0.
   #
   run_dump_test utc639

   #
   # This test will ensure that an error is generated for an instruction
   # that takes a 4-bit bit selection operand which references a local
   # variable that exceeds the maximum value of 15 -- see utc644.s.
   #
   run_greater_than_maximum_bit_select_4

   #
   # This test will ensure that a BIT SELECT 4 BYTE relocation is created for
   # a byte instruction that takes a 4-bit bit selection operand which
   # references an external variable.
   #
   run_dump_test utc649

   #
   # This test will ensure that a BIT SELECT 4 BYTE relocation is created for
   # a byte instruction that takes a 4-bit bit selection operand which
   # references a local variable.
   #
   run_dump_test utc650

   #
   # This test will ensure that a BIT SELECT 4 BYTE relocation is created for
   # byte instruction that takes a 4-bit bit selection operand which
   # references a local variable with the maximum value of 7.
   #
   run_dump_test utc648

   #
   # This test will ensure that a BIT SELECT 4 BYTE relocation is created for
   # a byte instruction that takes a 4-bit bit selection operand which
   # references a local variable with the minimum value of 0.
   #
   run_dump_test utc647

   #
   # This test will ensure that an error is generated for a byte instruction
   # that takes a 4-bit bit selection operand which references a local
   # variable that exceeds the maximum value of 7 -- see utc645.s.
   #
   run_greater_than_maximum_bit_select_4_byte

   #
   # This test will ensure that a relocation is generated for a DSP instruction
   # that takes a 6-bit operand for a variable that is declared externally to
   # the assembly source file.
   #
   run_dump_test utc652

   #
   # This test will ensure that a relocation is generated for a DSP instruction
   # that takes a 6-bit operand for a variable that is declared locally to
   # the assembly source file.
   #
   run_dump_test utc656

   #
   # This test will ensure that a relocation is generated for a DSP instruction
   # that takes a 6-bit operand for a variable that is declared locally to
   # the assembly source file with a value of 16.
   #
   run_dump_test utc654

   #
   # This test will ensure that an error is generated for a DSP instruction
   # that takes a 6-bit operand which references a local variable that exceeds
   # the maximum value of 16 -- see utc651.s.
   #
   run_greater_than_maximum_dsp_6

   #
   # This test will ensure that a relocation is generated for a DSP instruction
   # that takes a 6-bit operand for a variable that is declared locally to
   # the assembly source file with a value of 0.
   #
   run_dump_test utc655

   #
   # This test will ensure that a relocation is generated for a DSP instruction
   # that takes a 4-bit preshift operand for a variable that is declared
   # externally to the assembly source file.
   #
   run_dump_test utc658

   #
   # This test will ensure that a relocation is generated for a DSP instruction
   # that takes a 4-bit preshift operand for a variable that is declared locally
   # to the assembly source file.
   #
   run_dump_test utc657

   #
   # This test will ensure that a relocation is generated for a DSP instruction
   # that takes a 4-bit preshift operand for a variable that is declared locally
   # to the assembly source file with a value of 7.
   #
   run_dump_test utc660

   #
   # This test will ensure that a relocation is generated for a DSP instruction
   # that takes a 4-bit preshift operand for a variable that is declared locally
   # to the assembly source file with a value of 0.
   #
   run_dump_test utc661

   #
   # This test will ensure that a relocation is generated for a .word directive
   # located in the .text section that contains a #handle(foo) where foo is
   # a local .text symbol.
   #
   run_dump_test utc767

   #
   # This test will ensure that a relocation is generated for a .word directive
   # located in the .data section that contains a #handle(foo) where foo is
   # a local .text symbol.
   #
   run_dump_test utc768

   #
   # This test will ensure that a relocation is generated for a .word directive
   # located in the .text section that contains a #handle(foo) where foo is
   # an external symbol.
   #
   run_dump_test utc769

   #
   # This test will ensure that a relocation is generated for a .word directive
   # located in the .data section that contains a #handle(foo) where foo is
   # an external symbol.
   #
   run_dump_test utc770

   #
   # This test will ensure that an error is generated for a .word directive
   # located in the .text section that contains a #handle(foo) where foo is
   # a local symbol located in the .data section.
   #
   run_handle_of_local_data_symbol true

   # Removed: 782, 783, 784, 785, 786, 787, 788, 789, 790, 791,
   # 792, 793, 794, 795  Not valid in Rev B.

   #
   # This test will ensure that an error is generated for a .word directive
   # located in the .data section that contains a #handle(foo) where foo is
   # a local symbol located in the .data section.
   #
   run_handle_of_local_data_symbol false

   #
   # The following test cases will test to ensure that an error is generated
   # when the operands are invalid because they cannot be encoded together.
   #
   run_invalid_operands_because_of_encoding "\[Wn+Wb\], \[Wn+Wb\]" "utc779.s"

   #
   # The following test cases will test to ensure that the instructions
   # are encoded properly.  This is for the G_OR_H submodes that share encoding
   # bits.
   #
   run_dump_test utc778
   run_dump_test utc780
   run_dump_test utc781

   #
   # The following tests the --relax command-line option.
   #
   run_dump_test utc775

   #
   # The following tests the --no-relax command-line option.
   #
   run_dump_test utc777

   #
   # Test to ensure that the changes made to the equals() function properly
   # changes the current location counter.
   #
   run_dump_test utc796

   #
   # Test to ensure that an attempt to org backwards using the . = new-lc
   # syntax results in an error.
   #
   setup_xfail pic30*-*-*
   run_org_backwards ". = new-lc Backwards" "utc797.s"

   #
   # Test to ensure that we cannot set the location counter to a location
   # smaller than the current location using the equals() function.
   #
   setup_xfail pic30*-*-*
   run_org_backwards ". = new-lc Zero" "utc797b.s"

   #
   # Test to ensure that the .palign directive in an "x" section after a
   # .byte directive properly aligns and fills memory.
   #
   run_dump_test utc892

   #
   # Test to ensure that the .palign directive in an "x" section after a
   # .pbyte directive properly aligns and fills memory.
   #
   run_dump_test utc893

   #
   # Test to ensure that the .palign directive in the .text section after a
   # .byte directive properly aligns and fills memory.
   #
   run_dump_test utc890

   #
   # Test to ensure that the .palign directive in the .text section after a
   # .pbyte directive properly aligns and fills memory.
   #
   run_dump_test utc891

   #
   # This tests ensures that the .palign directive will cause a warning if found
   # inside of a .data section.
   #
   run_palign_in_data_section "utc889.s"

   #
   # This test ensures that the .pbyte directive will be accepted when in an
   # "x" section.
   #
   run_dump_test utc908

   #
   # This test ensures that the .pbyte directive will be accepted when in the
   # .text section.
   #
   run_dump_test utc905

   #
   # This test ensures that the .pbyte directive writes to the upper byte
   # of program memory.
   #
   run_dump_test utc937

   #
   # This test ensures that the .pbyte directive writes the maximum value
   # in the .text section.
   #
   run_dump_test utc907

   #
   # This test ensures that the .pbyte directive writes the minimum value
   # in the .text section.
   #
   run_dump_test utc904

   #
   # This test ensures that the .pbyte directive causes a warning if found
   # inside of a .data section.
   #
   run_test_warning "utc906.s" ".pbyte Directive Ignored" \
     ".pbyte not specified in a code section.  .pbyte ignored."

   #
   # These tests ensure that the assembler generates a warning when the .pbyte
   # directive is given a value that is larger than a byte.  The assembler
   # should continue to assemble the file with a truncated value.
   #
   run_test_warning "utc903.s" ".pbyte Maximum + 1" \
     "value 0x100 truncated to 0x0."
   run_dump_test utc903b

   #
   # These tests ensure that the assembler generates a warning when the .pbyte
   # directive is given a value that is one less than the minimum byte value.
   # The assembler should continue to assemble the file with a truncated value.
   #
   run_test_warning "utc902.s" ".pbyte Minimum + 1" \
     "value 0xffffff7f truncated to 0x7f."
   run_dump_test utc902b

   #
   # This tests ensures that the .pfill directive fills in the correct
   # number of bytes in a .section foo, "x" section.
   #
   run_dump_test utc926

   #
   # This test ensures that the .pfill directive correctly fills the
   # bytes in a .section foo, "x" section with the values
   # specified in .pfillvalue.
   #
   run_dump_test utc918

   #
   # This test ensures that the .pfill directive with the size and value
   # parameters specified functions properly inside of a .section foo,
   # "x" section
   #
   run_dump_test utc919

   #
   # This test ensures that the .pfill directive with the size parameter
   # functions properly inside of a .section foo, "x" section.
   #
   run_dump_test utc925

   #
   # This test ensures that the .pfill directive correctly fills
   # the bytes in the .text section with the values specified in
   # .pfillvalue.
   #
   run_dump_test utc927

   #
   # This test ensures that the .pfill directive works as expected
   # in the .text section when only a repeat value has been
   # specified.
   #
   run_dump_test utc928

   #
   # This test ensures the the .pfill directive with the size and
   # value parameters specified functions properly inside of a
   # .text section.
   #
   run_dump_test utc923

   #
   # This test ensures that the .pfill directive with the size
   # parameter functions properly inside of a .text section.
   #
   run_dump_test utc929

   #
   # This test ensures that the max size parameter (8) for the
   # .pfill directive is accepted.
   #
   run_dump_test utc930

   #
   # This test ensures that the minimum size parameter (0) for the
   # .pfill directive is accepted.
   #
   run_dump_test utc921

   #
   # This test ensures that the assembler generates a warning when the
   # .pfill directive's size parameter is given a vlue of max + 1 (9).
   #
   run_test_warning "utc922.s" ".pfill Maximum+1 Size" \
     ".pfill size clamped to 8."

   #
   # This test ensures that the assembler generates a warning when the
   # .pfill directive's size parameter is given a vlue of max + 1 (9).
   #
   run_test_warning "utc920.s" ".pfill Minimum-1 Size" \
     "Size argument < 0.  .pfill ignored"

   #
   # This test ensures that the .pfill directive causes a warning if
   # found within a .data section.
   #
   run_test_warning "utc894.s" ".pfill Directive Ignored" \
     ".pfill not specified in a code section.  .pfill ignored."

   #
   # This tests ensures that the new assembler directive, .pfillvalue,
   # exists.
   #
   run_dump_test utc915

   #
   # This test ensures that the assembler uses the default value for
   # .pfillvalue when .pfillvalue is not specified by the user.
   #
   run_dump_test utc916

   #
   # This test ensures that the assembler generates a warning if a
   # .pfillvalue assembly directive is seen in a section that is
   # not part of a .text section.
   #
   run_test_warning "utc913.s" ".pfillvalue Directive Ignored" \
      ".pfillvalue not specified in a code section.  .pfillvalue ignored."

   #
   # This test ensures that the assembler uses the default value
   # when we use .pfillvalue without an additional argument.
   #
   run_dump_test utc917

   #
   # This test ensures that the assembler uses the specified value
   # for the .pfillvalue directive when filling memory, including
   # the phantom byte.
   #
   run_dump_test utc914

   #
   # This test ensures that the assembler can handle the maximum
   # byte value as an argment to the .pfillvalue directive.
   #
   run_dump_test utc909

   #
   # This test ensures that the assembler can handle the minimum
   # byte value as an argment to the .pfillvalue directive.
   #
   run_dump_test utc911

   #
   # This test ensures that the .pfillvalue directive will not accept
   # a value of 0xFF+1 as the optional argument.
   #
   run_test_warning "utc910.s" ".pfillvalue Maximum + 1" \
      ".pfillvalue expects a constant positive byte value.  0x00 assumed"

   #
   # This test ensures that the .pfillvalue directive will not accept
   # a value of 0x00-1 as the optional argument.
   #
   run_test_warning "utc912.s" ".pfillvalue Minimum - 1" \
      ".pfillvalue expects a constant positive byte value.  0x00 assumed"

   #
   # This test ensures that the assembler accepts the .pword directive
   # in the .text section.
   #
   run_dump_test utc900

   #
   # This test ensures that the assembler accepts the .pword directive
   # in an executable section.
   #
   run_dump_test utc901


   #
   # This test ensures that the assembler accepts the max value for the
   # .pword directive in a .text section.
   #
   run_dump_test utc898

   #
   # This test ensures that the assembler accepts the min value for the
   # .pword directive in a .text section.
   #
   run_dump_test utc899

   #
   # This test ensures that the assembler generates a warning when we
   # try to use the .pword directive in the .data section.
   #
   run_test_warning "utc895.s" ".pword Directive Ignored" \
      ".pword not specified in a code section.  .pword ignored."

   #
   # These tests ensure that the assembler generates a warning when we try
   # to pass an out-of-range parameter to the .pword directive.
   #
   run_test_warning "utc896.s" ".pword Maximum + 1" \
      "value 0x1000000 truncated to 0x0."
   run_test_warning "utc897.s" ".pword Minimum - 1" \
      "value 0xff7fffff truncated to 0x7fffff."

   #
   # Test to ensure that the changes made to the s_set() function properly
   # changes the current location counter.
   #
   run_dump_test utc798

   #
   # This test ensures that we cannot equate the location counter to a
   # location smaller than the current location counter using the .equ
   # directive.
   #
   setup_xfail pic30*-*-*
   run_test_error "utc931.s" ".equ ., new-lc - Out-of-Range new-lc" \
                  {attempt to .org backwards ignored}

   #
   # This test ensures that changes made to the s_set() function properly
   # change the current location counter.
   #
   run_dump_test utc935

   # This test ensures that the assembler generates an error when the user
   # tries to use the .equiv directive to set the location counter to an
   # illegal value.
   #
   setup_xfail pic30*-*-*
   run_test_error "utc932.s" ".equiv ., new-lc - Out-of-Range new-lc" \
                  {attempt to .org backwards ignored}
   setup_xfail pic30*-*-*
   run_test_error "utc932b.s" ".equiv ., new-lc - Out-of-Range new-lc (2)" \
                  {attempt to .org backwards ignored}

   #
   # This test ensures that the changes made to the s_set() function properly
   # change the location counter for the .set directive.
   #
   run_dump_test utc936

   #
   # This test ensures that the assembler generates an error when the user
   # tries to use the .set directive to set the location counter to an
   # illegal value.
   #
   setup_xfail pic30*-*-*
   run_test_error "utc933.s" ".set ., new-lc - Out-of-Range new-lc" \
                  {attempt to .org backwards ignored}

   #
   # This test ensures that, by default, CALL instructions within 32k words are
   # not relaxed to an RCALL.
   #
   run_dump_test utc888

   #
   # This test ensures that the assembler creates a relocation for a BRANCH
   # instruction that references an absolute address.
   #
   run_dump_test utc841

   #
   # This test ensures that the assembler creates a relocation for the
   # maximum value allowed for the branch absolute relocation.
   #
   run_dump_test utc842

   #
   # This test ensures that the assembler creates a relocation for the
   # minimum value allowed for the branch absolute relocation.
   #
   run_dump_test utc843

# We removed the BRANCH OFFSET relocations.  Therefore, we remove unit test
# cases 847, 848, 850, 849, 846, 821, 822, 824, 823, & 820.

   #
   # This test ensures that the assembler creates a relocation for a
   # DO instruction that specifies a literal value for the offset operand.
   #
   run_dump_test utc815
   #
   # Run the test again, this time to check the warning messages.
   #
   run_test_warning "utc815.s" "Absolute DO LOOP end address." \
      "DO loop target is not simple relocatable expression."

   #
   # This test ensures that the assembler creates a relocation for the
   # maximum value allowed for the DO ABSOLUTE relocation.
   #
   run_dump_test utc816
   #
   # Run the test again, this time to check the warning messages.
   #
   run_test_warning "utc816.s" "DO LOOP maximum displacement." \
      "DO loop target is not defined in current module."

   #
   # This test ensures that the assembler creates a relocation for the
   # minimum value allowed for the DO ABSOLUTE relocation.
   #
   run_dump_test utc817
   #
   # Run the test again, this time to check the warning messages.
   #
   run_test_warning "utc817.s" "DO LOOP minimum displacement." \
      "DO loop target is not defined in current module."

   #
   # This test validates the loop end instruction restrictions.
   # 1. Flow control (branch)
   #
   run_test_error "utc818a.s" "DO Loop End Instruction Restrictions BRANCH" \
      {DO loop end instruction is not valid.}
   #
   # This test validates the loop end instruction restrictions.
   # 1. Flow control (compare and skip)
   #
   run_test_error "utc818b.s" "DO Loop End Instruction Restrictions CMPSKIP" \
      {DO loop end instruction is not valid.}
   #
   # This test validates the loop end instruction restrictions.
   # 1. Flow control (GOTO)
   #
   run_test_error "utc818c.s" "DO Loop End Instruction Restrictions GOTO" \
      {DO loop end instruction is not valid.}
   #
   # This test validates the loop end instruction restrictions.
   # 1. Flow control (GOTOW)
   #
   run_test_error "utc818d.s" "DO Loop End Instruction Restrictions GOTOW" \
      {DO loop end instruction is not valid.}
   #
   # This test validates the loop end instruction restrictions.
   # 1. Flow control (CALL)
   #
   run_test_error "utc818e.s" "DO Loop End Instruction Restrictions CALL" \
      {DO loop end instruction is not valid.}
   #
   # This test validates the loop end instruction restrictions.
   # 1. Flow control (RCALL)
   #
   run_test_error "utc818f.s" "DO Loop End Instruction Restrictions RCALL" \
      {DO loop end instruction is not valid.}
   #
   # This test validates the loop end instruction restrictions.
   # 1. Flow control (RCALLW)
   #
   run_test_error "utc818g.s" "DO Loop End Instruction Restrictions RCALLW" \
      {DO loop end instruction is not valid.}
   #
   # This test validates the loop end instruction restrictions.
   # 2. RETFIE, RETURN, RETLW
   #
   run_test_error "utc818i.s" "DO Loop End Instruction Restrictions" \
      {DO loop end instruction is not valid.}
   run_test_error "utc818j.s" "DO Loop End Instruction Restrictions" \
      {DO loop end instruction is not valid.}
   run_test_error "utc818k.s" "DO Loop End Instruction Restrictions" \
      {DO loop end instruction is not valid.}
   #
   # This test validates the loop end instruction restrictions.
   # 3. REPEAT or DO
   #
   run_test_error "utc818l.s" "DO Loop End Instruction Restrictions" \
      {DO loop end instruction is not valid.}
   run_test_error "utc818m.s" "DO Loop End Instruction Restrictions" \
      {DO loop end instruction is not valid.}
   #
   # This test validates the loop end instruction restrictions.
   # 4. Instruction within a repeat loop.
   #
   run_test_warning "utc818n.s" "DO Loop End Instruction Restrictions." \
      "DO loop penultimate instruction may not be valid."

   #
   # Repeat above tests (a-l) for the penultimate instruction
   # except for two-word instructions such as CALL, GOTO, DO
   #
   run_test_warning "utc819a.s" "DO Loop End Instruction Restrictions." \
      "DO loop penultimate instruction may not be valid."
   run_test_warning "utc819b.s" "DO Loop End Instruction Restrictions." \
      "DO loop penultimate instruction may not be valid."
   run_test_warning "utc819d.s" "DO Loop End Instruction Restrictions." \
      "DO loop penultimate instruction may not be valid."
   run_test_warning "utc819f.s" "DO Loop End Instruction Restrictions." \
      "DO loop penultimate instruction may not be valid."
   run_test_warning "utc819g.s" "DO Loop End Instruction Restrictions." \
      "DO loop penultimate instruction may not be valid."
   run_test_warning "utc819i.s" "DO Loop End Instruction Restrictions." \
      "DO loop penultimate instruction may not be valid."
   run_test_warning "utc819j.s" "DO Loop End Instruction Restrictions." \
      "DO loop penultimate instruction may not be valid."
   run_test_warning "utc819k.s" "DO Loop End Instruction Restrictions." \
      "DO loop penultimate instruction may not be valid."
   run_test_warning "utc819l.s" "DO Loop End Instruction Restrictions." \
      "DO loop penultimate instruction may not be valid."
   
   #
   # Test to ensure that taking the psvpage() of an external symbol in
   # an allocation directive in the .data section creates a
   # BFD_RELOC_PIC30_DPAGE relocation.
   #
   run_dump_test utc866

   #
   # Test to ensure that taking the psvpage() of an external symbol in
   # an allocation directive in the .text section creates a
   # BFD_RELOC_PIC30_DPAGE relocation.
   #
   run_dump_test utc864

   #
   # This test ensures that taking the psvpage() of a local .data symbol in
   # an allocation directive in the .data section creates an error.
   #
   run_test_error "utc868.s" "psvpage(local .data) in data" \
      {Cannot use psvpage on a symbol \(.+\) that is not located in a code, psv, or eedata section\.}

   #
   # This test ensures that taking the psvpage() of a local .data symbol in
   # an allocation directive in the .text section creates an error.
   #
   run_test_error "utc867.s" "psvpage(local .data) in .text" \
      {Cannot use psvpage on a symbol \(.+\) that is not located in a code, psv, or eedata section\.}

   #
   # Test to ensure that taking the psvpage() of an local .text symbol in an
   # allocation directive in the .data section creates a BFD_RELOC_PIC30_DPAGE
   # relocation.
   #
   run_dump_test utc863

   #
   # Test to ensure that taking the psvpage() of an local .text symbol in an
   # allocation directive in the .text section creates a BFD_RELOC_PIC30_DPAGE
   # relocation.
   #
   run_dump_test utc865

   #
   # This test ensures that taking the psvpage() of a local .text symbol in
   # an allocation directive in the .text section creates an error.
   #
   run_test_error "utc963.s" ".byte psvpage() error" \
      {Cannot use psvpage with this directive.}

   #
   # This test will ensure that an error is generated for a DSP instruction
   # that takes a 4-bit preshift operand which references a local variable that
   # exceeds the maximum value of 7 -- see utc659.s.
   #
   run_greater_than_maximum_dsp_preshift

   #
   # Test to ensure that the assembler creates a relocation for a link
   # instruction that references a variable that is declared externally to
   # the assembly source file.
   #
   run_dump_test utc826

   #
   # Test to ensure that the assembler creates a relocation for a link
   # instruction that references a variable that is declared locally to
   # the assembly source file.
   #
   run_dump_test utc827

   #
   # Test to ensure that the assembler creates a relocation for a LNK
   # instruction given the maximum value for this relocation.
   # Note: We use 16382 instead of 16383 because this operand does
   # not allow odd values.
   #
   run_dump_test utc829

   #
   # Test to ensure that the assembler creates a relocation for a LNK
   # instruction given the minimum value for this relocation.
   #
   run_dump_test utc828

   #
   # Test to ensure that the assember generates an error indicating that
   # the LNK-instruction operand is greater than the 14-bits allowed.
   #
   run_test_error "utc825.s" "BFD_RELOC_PIC30_FRAME_SIZE - Maximum + 1" \
      {Invalid value \(16384\)\. Operand must be even and between 0 and 16382, inclusive\.}

   #
   # These tests ensure that the assembler does not create a Frame Size
   # relocation for an odd value.
   #
   run_test_error "utc938.s" "BFD_RELOC_PIC30_FRAME_SIZE - Odd Relocation" \
      {Invalid value \([0-9]+\)\. Operand must be even and between 0 and 16382, inclusive\.}
   run_test_error "utc938b.s" "BFD_RELOC_PIC30_FRAME_SIZE - Odd Relocation (b)" \
      {Invalid value \([0-9]+\)\. Operand must be even and between 0 and 16382, inclusive\.}

   #
   # This test ensures that the assembler generates an error if the user
   # tries to use the handle() operator with a .byte directive.
   #
   run_test_error "utc967.s" ".byte handle" \
      {Cannot use handle with this directive.}

   #
   # This test ensures that the assembler creates a relocation for an
   # instruction that takes a loop-count operand for a variable that is
   # declared externally to the assembly source file.
   #
   run_dump_test utc671

   #
   # This test ensures that the assembler creates a relocation for an
   # instruction that takes a loop-count operand for a variable that is
   # declared internally to the assembly source file.
   #
   run_dump_test utc672

   #
   # This test ensures that the assembler creates a relocation for an
   # instruction that takes a loop-count operand for a variable whose
   # value is the maximum value allowed for this relocation.
   #
   run_dump_test utc674

   #
   # This test ensures that the assembler creates a relocation for an
   # instruction that takes a loop-count operand for a variable whose
   # value is the minimum value allowed for this relocation.
   #
   run_dump_test utc673

   #
   # This test ensures that the assembler generates an error and will
   # not accept an out-of-range parameter for the loop-count operand.
   # (maximum + 1)
   #
   run_test_error "utc675.s" "BFD_RELOC_PIC30_UNSIGNED_14 - Maximum + 1" \
      {Invalid value \(16384\)\. Operand must be between 0 and 16383, inclusive\.}

   #
   # This test ensures that the assembler generates an error and will
   # not accept an out-of-range parameter for the loop-count operand.
   # (minimum -1)
   #
   run_test_error "utc670.s" "BFD_RELOC_PIC30_UNSIGNED_14 - Minimum - 1" \
      {Invalid value \(-1\)\. Operand must be between 0 and 16383, inclusive\.}

   # Removed: 676, 678, 679, 680, 681  Not valid in Rev B.

   #
   # These tests ensure that the assembler creates relocations when
   # taking the psvoffset() and tbloffset() of a symbol in an allocation
   # directive in the .data section.
   #
   run_dump_test utc854
   run_dump_test utc979

   #
   # These tests ensure that the assembler creates relocations when
   # taking the psvoffset() and tbloffset() of a symbol in an allocation
   # directive in the .text section.
   #
   run_dump_test utc852
   run_dump_test utc981

   #
   # These tests ensure that the assembler generates an error when we
   # try to take the psvoffset() or tbloffset() of a local .data symbol
   # in an allocation directive.
   #
   run_test_error "utc856.s"  "psvoffset(local .data) in .data" \
      {Cannot use psvoffset on a symbol \(.+\) that is not located in a code, psv, or eedata section\.}
   run_test_error "utc977.s" "tbloffset(local .data) in .data" \
      {Cannot use tbloffset on a symbol \(.+\) that is not located in a code, psv, or eedata section\.}
   run_test_error "utc855.s"  "psvoffset(local .data) in .text" \
      {Cannot use psvoffset on a symbol \(.+\) that is not located in a code, psv, or eedata section\.}
   run_test_error "utc978.s" "tbloffset(local .data) in .text" \
      {Cannot use tbloffset on a symbol \(.+\) that is not located in a code, psv, or eedata section\.}

   #
   # These tests ensure that the assembler creates a relocation when
   # we take the psvoffset() and tbloffset() of a local .text symbol in an
   # allocation directive in the .data section.
   #
   run_dump_test utc851
   run_dump_test utc982

   #
   # These tests ensure that the assembler creates a reloction when
   # we take the psvoffset and tbloffset of a local .text symbol in an
   # allocation directive in the .text section.
   #
   run_dump_test utc853
   run_dump_test utc980

   #
   # These test ensure that the assembler generates an error when
   # we try to use the psvoffset or tbloffset operator with the
   # .byte directive in both the .data and .text sections.
   #
   run_test_error "utc969.s"  ".byte psvoffset()" \
      {Cannot use psvoffset with this directive.}
   run_test_error "utc976.s" ".byte tbloffset()" \
      {Cannot use tbloffset with this directive.}
   run_test_error "utc983.s" ".byte tbloffset()" \
      {Cannot use tbloffset with this directive.}
   run_test_error "utc984.s" ".byte tbloffset()" \
      {Cannot use psvoffset with this directive.}

   #
   # We remove tests from the test plan that call for .pword in
   # in the .data section.  This directive is not applicable to
   # the .data section.
   #
   # Removed: 939, 944, 943, 948, 950, 946, 954, 956, 951, 957,
   # 958, 960
   #

   #
   # This test ensures that taking the psvpage() of an external
   # symbol in a .pword allocation directive in the .text
   # section creates the appropriate relocation.
   #
   run_dump_test utc942

   #
   # This test ensures that taking the psvpage() of a local .data
   # symbol in a .pword allocation directive in the .text section
   # causes the assembler to generate an error.
   #
   run_test_error "utc940.s" "psvpage(local .data) in .text" \
      {Cannot use psvpage on a symbol \(.+\) that is not located in a code, psv, or eedata section\.}

   #
   # This test ensures that taking the psvpage of a local .text symbol
   # in a .pword allocation directive in the .text section creates
   # the appropriate relocation.
   #
   run_dump_test utc941

   #
   # This test ensures that the assembler generates an error if we try
   # to use the psvpage() operator with the .pbyte directive.
   #
   run_test_error "utc964.s" ".pbyte psvpage()" \
      {Cannot use psvpage with this directive.}

   #
   # This test ensures that the assembler creates the appropriate
   # relocation when we take the handle of an external symbol in
   # a .pword allocation directive in the .text section.
   #
   run_dump_test utc949

   #
   # This test ensures that the assembler generates an error when
   # we try to take the handle() of a local .data symbol in a
   # .pword allocation directive in the .text section.
   #
   run_test_error "utc945.s" "handle(local .data) in .data" \
      {Cannot use handle on a symbol \(.+\) that is not located in a code, psv, or eedata section\.}

   #
   # This test will ensure that the assembler creates the appropriate
   # relocation when we take the handle of a local .text symbol in a
   # .pword allocation directive in the .text section.
   #
   run_dump_test utc947

   #
   # This test ensures that the assembler generates an error if we
   # attempt to use the handle() operator with the .pbyte directive.
   #
   run_test_error "utc968.s" ".pbyte handle()" \
      {Cannot use handle with this directive.}

   #
   # These tests ensure that the assembler creates the appropriate
   # relocations when taking the tbloffset() and psvoffset() of an
   # external symbol in a .pword allocation directive in the .text
   # section.
   #
   run_dump_test utc952
   run_dump_test utc985

   #
   # These tests ensure that the assembler generates an error when
   # we attepmt to take the psvoffset() and tbloffset() of a local
   # .data symbol in a .pword allocation directive in the .text
   # section.
   #
   run_test_error "utc955.s" "psvoffset(local .data) in .text" \
      {Cannot use psvoffset on a symbol \(.+\) that is not located in a code, psv, or eedata section\.}
   run_test_error "utc987.s" "tbloffset(local .data) in .text" \
      {Cannot use tbloffset on a symbol \(.+\) that is not located in a code, psv, or eedata section\.}

   #
   # These tests ensure that the assembler creates the appropriate
   # relocation when we take the psvoffset() and tbloffset() of a local
   # .text symbol in a .pword allocation directive in the .text
   # section.
   #
   run_dump_test utc953
   run_dump_test utc986

   #
   # These tests ensure that the assembler generates the appropriate
   # error when we attempt to use the psvoffset() or tbloffset()
   # operator with a .pbyte directive.
   #
   run_test_error "utc970.s" ".pbyte psvoffset()" \
      {Cannot use psvoffset with this directive.}
   run_test_error "utc988.s" ".pbyte tbloffset()" \
      {Cannot use tbloffset with this directive.}

   #
   # This test ensures that the assembler creates the P-TPAGE
   # relocation when we take the tblpage() of an external symbol in
   # the .text section.
   #
   run_dump_test utc962

   #
   # This test ensures that the assembler generates an error when we
   # attempt to take the tblpage() of a local .data symbol in a .pword
   # allocation directive in the .text section.
   #
   run_test_error "utc961.s" "tblpage(local .data) in .text" \
      {Cannot use tblpage on a symbol \(.+\) that is not located in a code, psv, or eedata section\.}

   #
   # This test ensures that the assembler creates a P-TPAGE reloc
   # when we take the tblpage() of a local .text symbol in a .pword
   # allocation directive in the .text section.
   #
   run_dump_test utc959

   #
   # This test ensures that the assembler generates an error when we
   # attempt to use the tblpage() operator with a .pbyte directive.
   #
   run_test_error "utc966.s" ".pbyte tblpage()" \
      {Cannot use tblpage with this directive.}

   #
   # This test ensures that the assembler creates a relocation for
   # a .pbyte data allocation directive for a variable that is
   # declared externally to the assembly source file.
   #
   run_dump_test utc877

   #
   # These tests ensure that the assembler creates a relocation for
   # a .pbyte data allocation directive for a variable that is
   # declared locally in either the .data or .text section.
   #
   run_dump_test utc879a
   run_dump_test utc879b

   #
   # These tests ensure that the assembler creates a relocation for
   # a .pbyte data allocation directive for a variable that is
   # declared locally in either the .data or .text section.  We
   # assign the maximum values to the symbols for this relocation.
   #
   run_dump_test utc876a
   run_dump_test utc876b

   #
   # These tests ensure that the assembler creates a relocation for
   # a .pbyte data allocation directive for the minimum value of this
   # relocation type.
   #
   run_dump_test utc880a
   run_dump_test utc880b

   #
   # This test ensures that the assembler generates an error when we
   # try to use the .pbyte data allocation relocation with a value of
   # 0xFF+1.
   #
   #run_test_error "utc878.s" "BFD_RELOC_PIC30_PBYTE - Maximum + 1 Relocation" \
   #   {Invalid value (256) for relocation BFD_RELOC_PIC30_PBYTE.}
   run_test_error "utc878.s" "BFD_RELOC_PIC30_PBYTE - Maximum + 1 Relocation" \
      {value of 256 too large for field of 1 bytes at [0-9]+}
   #verbose "NOTE: Error message (BFD_RELOC_PIC30_PBYTE - Maximum + 1 Relocation) differs from the error message given in the test plan." 0

   #
   # This test ensures that the assembler creates a relocation for a
   # PC Relative Branch instruction that branches to a variable that
   # is declared externally to the assembly source file.
   #
   run_dump_test utc682

   #
   # This test ensures that the assembler creates a relocation for a
   # PC Relative Branch instruction that branches to a variable that
   # is declared locally to the assembly source file.
   #
   run_dump_test utc686

   #
   # This test ensures that the assembler creates a relocation for a
   # do instruction that references a label that is declared externally
   # to the source file.
   #
   run_dump_test utc807
   #
   # Run the test again, this time to check the warning messages.
   #
   run_test_warning "utc807.s" "External DO LOOP end address." \
      "DO loop target is not simple relocatable expression."

   #
   # This test ensures that the assembler creates a relocation for the
   # do instruction that references a label that is declared locally
   # to the source file.
   #
   run_dump_test utc810

   #
   # This test ensures that the assembler creates the
   # BFD_RELOC_PIC30_PGM_ADDR_LSB for a CALL instruction.
   #
   run_dump_test utc886

   #
   # This test ensures that the assembler creates the
   # BFD_RELOC_PIC30_PGM_ADDR_MSB for a CALL instruction.
   #
   run_dump_test utc887

   #
   # This test ensures that the assembler creates a
   # relocation for a .pword data allocation directive
   # for a variable that is declared externally to the
   # assembly source file.
   #
   run_dump_test utc882

   #
   # This test ensures that the assembler creates a
   # relocation for a .pword data allocation directive
   # for a variable that is declared locally to the
   # assembly source file.
   #
   run_dump_test utc884

   #
   # This test ensures that the assembler creates a relocation
   # for .pword with the maximum addend allowed for this reloc.
   #
   run_dump_test utc881

   #
   # This test ensures that the assembler creates a relocation
   # for .pword with the minimum addend allowed for this reloc.
   #
   run_dump_test utc885

   #
   # This test ensures that the assembler generates an error when
   # we give the .pword directive a greater-than-maximum value.
   #
   # NOTE: The error that the assembler currently generates does not
   # match the error message given in the test plan.
   #
   #run_test_error "utc883.s" "BFD_RELOC_PIC30_PWORD - Maximum + 1 Relocation" \
   #   {Invalid value (16777216) for relocation BFD_RELOC_PIC30_PWORD.}
   run_test_error "utc883.s" "BFD_RELOC_PIC30_PWORD - Maximum + 1 Relocation" \
      {value of 16777216 too large for field of 3 bytes at [0-9]+}
   #verbose "NOTE: Error message (BFD_RELOC_PIC30_PWORD - Maximum + 1 Relocation) differs from the error message given in the test plan." 0

   #
   # This test ensures that the assembler generates a relocation
   # for an instruction that takes a 13-bit file register.
   #
   run_dump_test utc691

   #
   # This test ensures that the assembler creates a relocation for
   # an instruction that takes a 13-bit File Register
   #
   run_dump_test utc690

   #
   # This test ensures that the assembler creates a relocation for
   # the maximum value allowed for the file-register relocation.
   #
   run_dump_test utc693

   #
   # This test ensures that the assembler creates a relocation for
   # the minimum value allowed for the file-register relocation.
   #
   run_dump_test utc692

   #
   # This test ensures that the assembler generates an error when
   # we give it an odd value for the 13-bit file register
   # relocation.
   #
   run_test_error "utc814.s" "BFD_RELOC_PIC30_FILE_REG - Odd value" \
      {Invalid value \(8191\)\. Operand must be even. Specify .b to access data memory at an odd address\.}

   #
   # This test ensures that the assembler creates a relocation
   # for a byte instruction that takes at 13-bit file register
   # for a variable that is declared externally to the assembly
   # source file.
   #
   run_dump_test utc802

   #
   # This test ensures that the assembler creates a relocation
   # for a byte instruction that takes at 13-bit file register
   # for a variable that is declared locally to the assembly
   # source file.
   #
   run_dump_test utc803

   #
   # This test ensures that the assembler creates a relocation
   # for a byte instruction that takes at 13-bit file register
   # for a variable that is declared locally to the assembly
   # source file.  Here we test the maximum value.
   #
   run_dump_test utc804

   #
   # This test ensures that the assembler creates a relocation
   # for a byte intstruction that takes at 13-bit file register
   # for a variable that is declared locally to the assembly
   # source file.  Here we test the minimum (0) value.
   #
   run_dump_test utc805

   #
   # This test ensures that the assembler generates a relocation
   # for an instruction that takes a 16-bit file register for a variable
   # that is declared externally to the assembly source file.
   #
   run_dump_test utc697

   #
   # This test ensures that the assembler generates a relocation
   # for an instruction that takes a 16-bit file register for a variable
   # that is declared locally to the assembly source file.
   #
   run_dump_test utc699

   #
   # This test ensures that the assembler generates a relocation
   # for an instruction that takes a16-bit file register for a variable
   # that is declared locally to the assembly source file.
   # Here we test the maximum addend for this relocation.
   #
   run_dump_test utc701

   #
   # This test ensures that the assembler generates a relocation
   # for an instruction that takes a 16-bit file register for a variable
   # that is declared locally to the assembly source file.
   # Here we test the minimum addend for this relocation.
   #
   run_dump_test utc696

   #
   # This test ensures that the assembler generates an error when
   # we give an instruction that takes a 16-bit file register for a variable,
   # and we use an out-of-range addend (max + 1).
   #
   run_test_error "utc700.s" "BFD_RELOC_PIC30_FILE_REG_WORD - Maximum Value + 1" \
      {Invalid value \(65536\)\. Operand must be even and less than 65536\.}

   #
   # This test ensures that the assembler generates an error when
   # we give it an instruction that takes a 16-bit file register for a variable,
   # and we use an odd addend.
   #
   run_test_error "utc813.s" "BFD_RELOC_PIC30_FILE_REG_WORD - Odd value" \
      {Invalid value \(65535\)\. Operand must be even and less than 65536\.}

   #
   # This test ensures that the assembler creates a relocation for an
   # instruction that takes a 16-bit file register for a variable that is
   # declared externally to the assembly source file. FILE REG WORD with DST
   #
   run_dump_test utc704

   #
   # This test ensures that the assembler creates a relocation for an
   # instruction that takes a 16-bit file register for a variable that is
   # declared locally to the assembly source file. FILE REG WORD with DST
   #
   run_dump_test utc702

   #
   # This test ensures that the assembler creates a relocation for an
   # instruction that takes a 16-bit file register for a variable that is
   # declared locally to the assembly source file. FILE REG WORD with DST,
   # maximum value
   #
   run_dump_test utc703

   #
   # This test ensures that the assembler creates a relocation for an
   # instruction that takes a 16-bit file register for a variable that is
   # declared locally to the assembly source file. FILE REG WORD with DST,
   # minimum value
   #
   run_dump_test utc800

   #
   # This test ensures that the assembler generates an error for an
   # out-of-range (max+1) value for the BFD_PIC30_FILE_REG_WORD_WITH_DST reloc.
   #
if 0 {
   run_test_error "utc706.s" "BFD_PIC30_FILE_REG_WORD_WITH_DST, Maximum value + 1" \
      {Invalid value \(65536\) for relocation BFD_RELOC_PIC30_FILE_REG_WORD_WITH_DST\.}

   #
   # This test ensures that the assembler generates an error for an
   # odd value for the BFD_PIC30_FILE_REG_WORD_WITH_DST reloc.
   #
   run_test_error "utc801.s" "BFD_PIC30_FILE_REG_WORD_WITH_DST - Odd value" \
      {Invalid value \(65535\) for relocation BFD_RELOC_PIC30_FILE_REG_WORD_WITH_DST\.}
}

   #
   # This test ensures that the assembler creates a relocation
   # for an instruction that takes a 10-bit signed operand for
   # a variable.  The variable is declared externally to the
   # assembly source file.
   #
   run_dump_test utc709

   #
   # This test ensures that the assembler creates a relocation
   # for an instruction that takes a 10-bit signed operand for
   # a variable.  The variable is declared locally to the
   # assembly source file.
   #
   run_dump_test utc712

   #
   # This test ensures that the assembler creates a relocation
   # for an instruction that takes a 10-bit signed operand for
   # a variable.  This test ensures that the relocation
   # accepts the maximum value.
   #
   run_dump_test utc710

   #
   # This test ensures that the assembler creates a relocation
   # for an instruction that takes a 10-bit signed operand for
   # a variable.  This test ensures that the relocation
   # accepts the minimum value.
   #
   run_dump_test utc707

   #
   # This test ensures that the assembler generates an error for an
   # out-of-range (511+1) value for the SIGNED_10 relocation.
   #
   run_test_error "utc711.s" \
      "BFD_RELOC_PIC30_UNSIGNED_10 -  Maximum value + 1" \
      {Invalid value \(1024\)\. Operand must be between 0 and 1023, inclusive\.}

   #
   # This test ensures that the assembler creates a relocation
   # for an instruction that takes a 10-bit signed operand for
   # a variable.  In this test case, the variable is declared
   # externally.
   #
   run_dump_test utc715

   #
   # This test ensures that the assembler creates a relocation
   # for an instruction that takes a 10-bit signed operand for
   # a variable.  In this test case, the variable is declared
   # locally.  BFD_RELOC_PIC30_SIGNED_10_BYTE
   #
   run_dump_test utc713

   #
   # This test ensures that the assembler creates a relocation
   # for an instruction that takes a 10-bit signed operand for
   # a variable.  In this test case, the variable is declared
   # locally.  BFD_RELOC_PIC30_SIGNED_10_BYTE, Maximum value
   #
   run_dump_test utc716

   #
   # This test ensures that the assembler creates a relocation
   # for an instruction that takes a 10-bit signed operand for
   # a variable.  In this test case, the variable is declared
   # locally.  BFD_RELOC_PIC30_SIGNED_10_BYTE, Minimum value
   #
   run_dump_test utc718

   #
   # This test ensures that the assembler generates an error
   # when we use an out-of-range value for the BFD_RELOC_PIC30_SIGNED_10_BYTE
   # relocation. (max+1)
   #
   run_test_error "utc717.s" \
      "BFD_RELOC_PIC30_SIGNED_10_BYTE - Maximum Value + 1"\
      {Invalid value \(256\)\. Operand must be between -128 and 255, inclusive\.}

   #
   # This test ensures that the assembler creates a relocation
   # when we take the tblpage() of an external symbol in a .data
   # allocation directive.
   #
   run_dump_test utc860

   #
   # This test ensures that the assembler creates a relocation
   # when we take the tblpage() of an external symbol in a .text
   # allocation directive.
   #
   run_dump_test utc858

   #
   # This test ensures that the assembler generates an error
   # when we take the tblpage() of a local .data symbol in a
   # .data section.
   #
   run_test_error "utc862.s" "tblpage(local .data) in .data"\
      {Cannot use tblpage on a symbol \(loc\) that is not located in a code, psv, or eedata section\.}

   #
   # This test ensures that the assembler generates an error
   # when we take the tblpage() of a local .data symbol in a
   # .text section.
   #
   run_test_error "utc861.s" "tblpage(local .data) in .data"\
      {Cannot use tblpage on a symbol \(loc\) that is not located in a code, psv, or eedata section\.}

   #
   # This test ensures that the assembler creates a
   # relocation when we take the tblpage() of a local .text
   # symbol in an allocation directive in the .data section.
   #
   run_dump_test utc857

   #
   # This test ensures that the assembler creates a
   # relocation when we take the tblpage() of a local .text
   # symbol in an allocation directive in the .text section.
   #
   run_dump_test utc859

   #
   # This test ensures that the assembler generates an error
   # when we try to use the tblpage() handle with the .byte
   # allocation directive.
   #
   run_test_error "utc965.s" ".byte tblpage()" \
      {Cannot use tblpage with this directive.}

   #
   # This test ensures that the assembler generates a relocation
   # for instructions that that take a 14-bit unsigned literal.
   # In this test case, the the symbol is defined externally
   # to the assembly source file.
   #
   run_dump_test utc725

   #
   # This test ensures that the assembler generates a relocation
   # for an instruction that takes a 14-bit unsigned literal.
   # In this test case, the symbol is defined locally to the
   # assembly source file.
   #
   run_dump_test utc726

   #
   # This test ensures that the assembler generates a relocation
   # for a 14-bit unsigned literal when we use the maximum value.
   #
   run_dump_test utc727

   #
   # This test ensures that the assembler generates a relocation
   # for a 14-bit unsigned literal when we use the minimum value.
   #
   run_dump_test utc730

   #
   # This test ensures that the assembler generates an error when
   # we try to use a max+1 value with the 14-bit unsigned literal
   # relocation.
   #
   run_test_error "utc728.s" "BFD_RELOC_PIC30_UNSIGNED_14 - Maximum + 1" \
      {Invalid value \(16384\)\. Operand must be between 0 and 16383, inclusive\.}

   #
   # This test ensures that the assembler creates a relocation
   # for unsigned 5-bit literals declared externally to the
   # assembly source file.
   #
   run_dump_test utc735

   #
   # This test ensures that the assembler creates a relocation
   # for unsigned 5-bit literals declared locally to the
   # assembly source file.
   #
   run_dump_test utc736

   #
   # This test ensures that the assembler creates a relocation for
   # unsigned 5-bit literals when we use the maximum value allowed
   # for this relocation.
   #
   run_dump_test utc733

   #
   # This test ensures that the assembler creates a relocation for
   # unsigned 5-bit literals when we use the minimum value allowed
   # for this relocation.
   #
   run_dump_test utc731

   #
   # This test ensures that the assembler generates an error when
   # we try to use a max+1 value for an unsigned 5-bit literal
   # relocation.
   #
   run_test_error "utc732.s" \
      "BFD_RELOC_PIC30_UNSIGNED_5 - Maximum + 1 Relocation" \
      {Invalid value \(32\)\. Operand must be between 0 and 31, inclusive\.}

   #
   # This test ensures that the assembler creates a relocation when
   # we use an instruction that takes a 16-bit operand for a variable
   # that is declared externally to the source file.
   #
   run_dump_test utc740

   #
   # This test ensures that the assembler creates a relocation when
   # we use an instruction that takes a 16-bit operand for a variable
   # that is declared locally to the assembly source file.
   #
   run_dump_test utc738

   #
   # This test ensures that the assembler creates a relocation when
   # we use an instruction that takes a 16-bit operand for a variable
   # and use the maximum addend allowed for this relocation.
   #
   run_dump_test utc737

   #
   # This test ensures that the assembler creates a WORD relocation
   # when we use the minimum addend allowed for this relocation.
   #
   run_dump_test utc742

   #
   # This test ensures that the assembler generates an error when
   # we try to use an out-of-range (max+1) addend with the WORD
   # relocation.
   #
   run_test_error "utc739.s" "BFD_RELOC_PIC30_WORD - Maximum + 1 Relocation" \
      {Invalid value \(65536\)\. Operand must be between -32768 and 65535, inclusive\.}

   #
   # This test ensures that the assembler creates a BFD_RELOC_PIC30_WORD_DPAGE
   # relocation for an external variable.  NOTE: Unit test cases utc838 and
   # utc873 are redundant because external variables are not specified to be
   # in a section.
   #
   run_dump_test utc838

   #
   # This test ensures that the assembler generates an error when we use
   # psvpage on a symbol that is not located in an executable section.
   #
   run_test_error "utc872.s" "BFD_RELOC_PIC30_WORD_DPAGE - psvpage(local .data)" \
      {Cannot use psvpage on a symbol \(_foo\) that is not located in a code, psv, or eedata section\.}

   #
   # This test ensures that the assembler creates a BFD_RELOC_PIC30_WORD_DPAGE
   # relocation for a variable declared locally to the assembly source file in
   # the .text section.
   #
   run_dump_test utc837

   #
   # This test ensures that the assembler creates a BFD_RELOC_PIC30_WORD_HANDLE
   # relocation for the handle() operator with an external variable.  NOTE:
   # Unit test cases 839 and 870 are redundant because the assembler does not
   # differentiate between an extern .text and an extern .data variable.
   #
   run_dump_test utc839

   #
   # This test ensures that the assembler generates an error when we use
   # handle on a symbol that is not located in an executable section.
   #
   run_test_error "utc871.s" \
      "BFD_RELOC_PIC30_WORD_HANDLE - handle(local .data)" \
      {Cannot use handle on a symbol \(_foo\) that is not located in a code, psv, or eedata section\.}

   #
   # This test ensures that the assembler creates a BFD_RELOC_PIC30_WORD_HANDLE
   # relocation on a symbol that is located in the .text section.
   #
   run_dump_test utc840

   #
   # This test ensures that the tbloffset and psvoffset operators create relocations
   # when the variables are declared externally to the assembly source file.
   #
   run_dump_test utc830
   run_dump_test utc989

   #
   # These tests ensure that the assembler generates errors when we try to
   # use tbloffset() and psvoffset() operators with local symbols located in
   # the .data section.
   #
   run_test_error "utc869.s" \
      "BFD_RELOC_PIC30_WORD_TOFFSET - tbloffset(local .data)" \
      {Cannot use tbloffset on a symbol \(\_foo\) that is not located in a code, psv, or eedata section\.}
   run_test_error "utc991.s" \
      "BFD_RELOC_PIC30_WORD_DOFFSET - psvoffset(local .data)" \
      {Cannot use psvoffset on a symbol \(\_foo\) that is not located in a code, psv, or eedata section\.}

   #
   # These tests ensure that the assembler creates the tbloffset and psvoffset
   # relocations when we use the tbloffset() and psvoffset() operators
   # respectively.  We use the operators on symbols that are located
   # in the .text section.
   #
   run_dump_test utc833
   run_dump_test utc990

   #
   # This test ensures that the assembler creates a BFD_RELOC_PIC30_WORD_TPAGE
   # relocation when we use tblpage() with an externally defined variable.
   # NOTE: Unit test cases 835 and 875 are redundant because the assembler
   # does not differentiate between external symbols in the .data and .text
   # sections.
   #
   run_dump_test utc835

   #
   # This test ensures that the assembler generates an error when we try to
   # use the tblpage operator on a symbol located in the .data section.
   #
   run_test_error "utc874.s" "BFD_RELOC_PIC30_WORD_TPAGE - tblpage(local .data)" \
      {Cannot use tblpage on a symbol \(_foo\) that is not located in a code, psv, or eedata section\.}

   #
   # This test ensures that the assembler creates a relocation when we use the
   # tblpage operator on a symbol located in the .text section.
   #
   run_dump_test utc836

   #
   # This test ensures that the assembler creates a relocation when we use the
   # .byte data allocation directive with a symbol declared externally to
   # the assembly source file.
   #
   run_dump_test utc746

   #
   # This test ensures that the assembler creates a relocation when we use the
   # .byte data allocation directive with a symbol declared locally to
   # the assembly source file.
   #
   run_dump_test utc744

   #
   # This test ensures that the assembler creates a relocation when we use the
   # .byte data allocation directive with a symbol declared locally to
   # the assembly source file. MAX ADDEND
   #
   run_dump_test utc745

   #
   # This test ensures that the assembler creates a relocation when we use the
   # .byte data allocation directive with a symbol declared locally to
   # the assembly source file. MIN ADDEND
   #
   run_dump_test utc743

   #
   # This test ensures that the assembler generates an error when we try to
   # use the BFD_RELOC_8 relocation with an out-of-range (max+1) addend.
   #
   #run_test_error "utc747.s" "BFD_RELOC_8 - Maximum + 1 Relocation" \
   #     {Invalid value \(256\) for relocation BFD_RELOC_RELBYTE\.}
   run_test_error "utc747.s" "BFD_RELOC_8 - Maximum + 1 Relocation" \
      {value of 256 too large for field of 1 bytes at 0}
   #verbose "NOTE: Error message (BFD_RELOC_8 - Maximum + 1 Relocation) differs from the error message given in the test plan." 0

   #
   # This test ensures that the assembler creates a RELLONG relocation for
   # the .long directive with a symbol defined externally to the assembler
   # source file.
   #
   run_dump_test utc754

   #
   # This test ensures that the assembler create a RELLONG relocation for
   # the .long directive with a symbol defined locally to the assembler
   # source file.
   #
   run_dump_test utc749

   #
   # This test ensures that the assembler creates a RELLONG relocation for
   # the .long directive when we use the minimum value allowed for this
   # relocation.
   #
   run_dump_test utc752

   #
   # This test ensures that the assembler creates a RELWORD relocation
   # when we use the .word data allocation directive with an
   # externally defined symbol.
   #
   run_dump_test utc758

   #
   # This test ensures that the assembler creates a RELWORD relocation
   # when we use the .word data allocation directive with a locally
   # defined symbol.
   #
   run_dump_test utc760

   #
   # This test ensures that the assembler creates a RELWORD relocation
   # when we use the .word data allocation directive with the max
   # addend allowed for this relocation.
   #
   run_dump_test utc759

   #
   # This test ensures that the assembler creates a RELWORD relocation
   # when we use the .word data allocation directive with the min
   # addend allowed for this relocation.
   #
   run_dump_test utc756

   #
   # This test ensures that the assembler generates an error when we
   # try to use the RELWORD relocation with an out-of-range (MAX+1)
   # addend.
   #
   #   {Invalid value \(65536\) for relocation BFD_RELOC_8\.}
   run_test_error "utc755.s" "BFD_RELOC_16 - Maximum + 1 Relocation" \
      {value of 65536 too large for field of 2 bytes at 0}
   #verbose "NOTE: Error message (BFD_RELOC_16 - Maximum + 1 Relocation) differs from the error message given in the test plan." 0

   #
   # This test ensures the SSR 15714 has not been re-opened.
   #
   gas_test "utc972.s" "" "" "SSR 15714"

   #
   # This test ensures the SSR 15726 has not been re-opened.
   #
   gas_test "utc973.s" "" "" "SSR 15726"

   #
   # This test ensures the SSR 15771 has not been re-opened.
   #
   run_list_test utc974

   #
   # This test ensures the SSR 15808 has not been re-opened.
   #
   run_test_error "utc975.s" "SSR 15808" {Invalid operands specified .*}

   # This test will ensure that a relocation is created for a
   # PWRSAV instruction for a variable that is declared externally
   # to the assembly source file.
   run_dump_test utc992

   # This test will ensure that a relocation is created for
   # the maximum value allowed for this relocation (1).
   run_dump_test utc993

   # This test will ensure that a relocation is created for
   # the minimum value allowed for this relocation (0).
   run_dump_test utc994

   # This test will ensure that a power save mode relocation will not accept a value of 1+1.
   run_test_error "utc995.s" "BFD_RELOC_PIC30_PWRSAV_MODE - Maximum Relocation +1" \
      {Invalid value \(2\)\. Operand must be 0 or 1\.}

   # This test will ensure that a relocation is created for a
   # PWRSAV instruction that is declared locally in the assembly
   # source file.
   run_dump_test utc996
   #
   # This test ensures that psvoffset cannot be used in a MOVLW instruction if
   # it references a local variable in the .data section.
   #
   run_test_error "utc997.s" "BFD_RELOC_PIC30_WORD_DOFFSET - Local .data" \
      {Cannot use psvoffset on a symbol \(.*\) that is not located in a code, psv, or eedata section.}

   #
   # This test ensures that tbloffset cannot be used in a MOVLW instruction if
   # it references a local variable in the .data section.
   #
   run_test_error "utc998.s" "BFD_RELOC_PIC30_WORD_TOFFSET - Local .data" \
      {Cannot use tbloffset on a symbol \(.*\) that is not located in a code, psv, or eedata section.}

   #
   # This test ensures that psvpage cannot be used in a MOVLW instruction if
   # it references a local variable in the .data section.
   #
   run_test_error "utc999.s" "BFD_RELOC_PIC30_WORD_DPAGE - Local .data" \
      {Cannot use psvpage on a symbol \(.*\) that is not located in a code, psv, or eedata section.}

   #
   # This test ensures that tblpage cannot be used in a MOVLW instruction if
   # it references a local variable in the .data section.
   #
   run_test_error "utc1000.s" "BFD_RELOC_PIC30_WORD_TPAGE - Local .data" \
      {Cannot use tblpage on a symbol \(.*\) that is not located in a code, psv, or eedata section.}

   #
   # This test ensures that handle cannot be used in a MOVLW instruction if
   # it references a local variable in the .data section.
   #
   run_test_error "utc1001.s" "BFD_RELOC_PIC30_WORD_HANDLE - Local .data" \
      {Cannot use handle on a symbol \(.*\) that is not located in a code, psv, or eedata section.}

   #
   # This test ensures that the assembler creates a relocation
   # for unsigned 4-bit shift literals declared externally to the
   # assembly source file.
   #
   run_dump_test utc1004

   #
   # This test ensures that the assembler creates a relocation
   # for unsigned 4-bit shift literals declared locally to the
   # assembly source file.
   #
   run_dump_test utc1003

   #
   # This test ensures that the assembler creates a relocation for
   # unsigned 4-bit shift literals when we use the maximum value allowed
   # for this relocation.
   #
   run_dump_test utc1005

   #
   # This test ensures that the assembler creates a relocation for
   # unsigned 4-bit shift literals when we use the minimum value allowed
   # for this relocation.
   #
   run_dump_test utc1007

   #
   # This test ensures that the assembler generates an error when
   # we try to use a max+1 value for an unsigned 4-bit shift literal
   # relocation.
   #
   run_test_error "utc1006.s" \
      "BFD_RELOC_PIC30_UNSIGNED_4 - Maximum + 1 Relocation" \
      {Invalid value \(16\)\. Operand must be between 0 and 15, inclusive\.}

   #
   # This test ensures that an error is given if an alignment request of less
   # than 2 is made in the .text section.
   #
   run_test_error "utc1008.s" \
      ".align - Minimum - 1 alignment in .text" \
      {Alignment in CODE section must be at least 2 units.  Alignment ignored.}

   #
   # This test ensures that an error is given if an alignment request of less
   # than 2 is made in the .section foo, "x" section.
   #
   run_test_error "utc1009.s" \
      ".align - Minimum - 1 alignment in .section foo, \"x\"" \
      {Alignment in CODE section must be at least 2 units.  Alignment ignored.}

   #
   # This test ensures that an error is given if an alignment request of less
   # than 0 is made in the .data section.
   #
   run_test_error "utc1010.s" \
      ".align - Minimum - 1 alignment in .data" {alignment not a power of 2}

   #
   # This test ensures that an error is given if an alignment request that is
   # not a power of 2 is made in the .text section.
   #
   run_test_error "utc1011.s" \
      ".align - Not power of 2 alignment in .text" {alignment not a power of 2}

   #
   # This test ensures that an error is given if an alignment request that is
   # not a power of 2 is made in the .section foo, "x" section.
   #
   run_test_error "utc1012.s" \
      ".align - Not power of 2 alignment in .section foo, \"x\"" \
      {alignment not a power of 2}

   #
   # This test ensures that an error is given if an alignment request that is
   # not a power of 2 is made in the .data section.
   #
   run_test_error "utc1013.s" \
      ".align - Not power of 2 alignment in .data" {alignment not a power of 2}

   #
   # This test ensures that a warning is given if an alignment requrest of 2^16
   # is made in the .text section.
   #
   run_test_warning "utc1014.s" ".align - Maximum + 1 alignment in .text" \
      {alignment too large: 2\^15 assumed}

   #
   # This test ensures that a warning is given if an alignment requrest of 2^16
   # is made in the .section foo, "x" section.
   #
   run_test_warning "utc1015.s" \
      ".align - Maximum + 1 alignment in .section foo, \"x\"" \
      {alignment too large: 2\^15 assumed}

   #
   # This test ensures that a warning is given if an alignment requrest of 2^16
   # is made in the .data section.
   #
   run_test_warning "utc1016.s" ".align - Maximum + 1 alignment in .data" \
      {alignment too large: 2\^15 assumed}

   #
   # This test ensures that the maximum alignment required is accepted for the
   # .align directive located in the .text section.
   #
   run_dump_test utc1017

   #
   # This test ensures that the maximum alignment required is accepted for the
   # .align directive located in the .section foo, "x" section.
   #
   run_dump_test utc1018

   #
   # This test ensures that the maximum alignment required is accepted for the
   # .align directive located in the .data section.
   #
   run_dump_test utc1019

   #
   # This test ensures that the minimum alignment required is accepted for the
   # .align directive located in the the .text section.
   #
   run_dump_test utc1020

   #
   # This test ensures that the minimum alignment required is accepted for the
   # .align directive located in the the .section foo, "x" section.
   #
   run_dump_test utc1021

   #
   # This test ensures that the minimum alignment required is accepted for the
   # .align directive located in the the .data section.
   #
   run_dump_test utc1022

   #
   # This test ensures that an error is given if an alignment request of less
   # than 2 is made in a .palign directive in the .text section.
   #
   run_test_error "utc1023.s" \
      ".palign - Minimum - 1 alignment in .text" \
      {Alignment in CODE section must be at least 2 units.  Alignment ignored.}

   #
   # This test ensures that an error is given if an alignment request of less
   # than 2 is made in a .palign directive in the .section foo, "x" section.
   #
   run_test_error "utc1024.s" \
      ".palign - Minimum - 1 alignment in .section .const, \"x\"" \
      {Alignment in CODE section must be at least 2 units.  Alignment ignored.}

   #
   # This test ensures that an error is given if an alignment request that is
   # not a power of 2 is made in a .palign directive in the .text section.
   #
   run_test_error "utc1025.s" \
      ".palign - Not power of 2 alignment in .text" {alignment not a power of 2}

   #
   # This test ensures that an error is given if an alignment request that is
   # not a power of 2 is made in a .palign directive in the .section foo, "x"
   # section.
   #
   run_test_error "utc1026.s" \
      ".palign - Not power of 2 alignment in .section foo, \"x\"" \
      {alignment not a power of 2}

   #
   # This test ensures that a warning is given if an alignment requrest of 2^16
   # is made in a .palign directive in the .text section.
   #
   run_test_warning "utc1027.s" ".palign - Maximum + 1 alignment in .text" \
      {alignment too large: 2\^15 assumed}

   #
   # This test ensures that a warning is given if an alignment requrest of 2^16
   # is made in a .palign directive in the .section foo, "x" section.
   #
   run_test_warning "utc1028.s" \
      ".palign - Maximum + 1 alignment in .section foo, \"x\"" \
      {alignment too large: 2\^15 assumed}

   #
   # This test ensures that the maximum alignment required is accepted for the
   # .palign directive located in the .text section.
   #
   run_dump_test utc1029

   #
   # This test ensures that the maximum alignment required is accepted for the
   # .palign directive located in the .section foo, "x" section.
   #
   run_dump_test utc1030

   #
   # This test ensures that the minimum alignment required is accepted for the
   # .palign directive located in the the .text section.
   #
   run_dump_test utc1031

   #
   # This test ensures that the minimum alignment required is accepted for the
   # .palign directive located in the the .section foo, "x" section.
   #
   run_dump_test utc1032

   #
   # This test ensures that the .align directive without a fill uses the
   # last specified .fillupper and .fillvalue to fill in the skipped spaces.
   #
   run_dump_test utc1033

   #
   # This test ensures that the .align directive without a fill uses the
   # zeroes to fill in the skipped spaces if neither a .fillupper or .fillvalue
   # were specified.
   #
   run_dump_test utc1034

   #
   # This test ensures that the .align directive without a fill uses zeroes to
   # fill in the skipped space in the .data section.
   #
   run_dump_test utc1035

   #
   # This test ensures that the fill value is used to fill the lower two bytes
   # of program memory when a .fillvalue and .fillupper have not been used.
   #
   run_dump_test utc1036

   #
   # This test ensures that the fill value is used to fill the lower two bytes
   # of program memory when a .fillvalue has been used and fill the upper byte
   # with the specified .fillupper.
   #
   run_dump_test utc1037

   #
   # This test ensures that the specified fill value in a .align directive in
   # the .data section is used to fill all bytes skipped.
   #
   run_dump_test utc1038

   #
   # This test ensures that the maximum fill value for the .align directive is
   # accepted.
   #
   run_dump_test utc1039

   #
   # This test ensures that the minimum fill value for the .align directive is
   # accepted.
   #
   run_dump_test utc1040

   #
   # This test ensures that the .align directive is carried out when the MAX
   # argument is 0.
   #
   run_dump_test utc1041

   #
   # This test ensures that the .align directive is carried out when the MAX
   # argument exceeds the number of bytes being skipped.
   #
   run_dump_test utc1042

   #
   # This test ensures that the .align directive is carried out when the MAX
   # argument is equal to the number of bytes being skipped.
   #
   run_dump_test utc1043

   #
   # This test ensures that the .align directive is NOT carried out when the MAX
   # argument is less than the number of bytes being skipped.
   #
   run_dump_test utc1044

   #
   # This test ensures that the .palign directive without a fill uses the
   # last specified .pfillvalue to fill in the skipped spaces.
   #
   run_dump_test utc1069

   #
   # This test ensures that the .palign directive without a fill uses the
   # zeroes to fill in the skipped spaces if a .pfillvalue was not specified.
   #
   run_dump_test utc1070

   #
   # This test ensures that the fill value is used to fill all three bytes
   # of program memory when a .pfillvalue has not been used.
   #
   run_dump_test utc1071

   #
   # This test ensures that the fill value is used to fill all three bytes
   # of program memory when a .pfillvalue has been used.
   #
   run_dump_test utc1072

   #
   # This test ensures that the maximum fill value for the .palign directive is
   # accepted.
   #
   run_dump_test utc1073

   #
   # This test ensures that the minimum fill value for the .palign directive is
   # accepted.
   #
   run_dump_test utc1074

   #
   # This test ensures that the .palign directive is carried out when the MAX
   # argument is 0.
   #
   run_dump_test utc1075

   #
   # This test ensures that the .palign directive is carried out when the MAX
   # argument exceeds the number of bytes being skipped.
   #
   run_dump_test utc1076

   #
   # This test ensures that the .palign directive is carried out when the MAX
   # argument is equal to the number of bytes being skipped.
   #
   run_dump_test utc1077

   #
   # This test ensures that the .palign directive is NOT carried out when the
   # MAX argument is less than the number of bytes being skipped.
   #
   run_dump_test utc1078

   #
   # This test will ensure that a warning is generated if the .pskip directive
   # is used in a .data section.
   #
   run_test_warning utc1079.s ".pskip in .data" \
      "Directive not specified in a code section.  Directive ignored."

   #
   # This test ensures that the .pskip directive skips the correct number of
   # bytes when in the .text section and the skipped space is filled with the
   # specified fill value.
   #
   run_dump_test utc1080

   #
   # This test ensures that the .pskip directive skips the correct number of
   # bytes in a .section foo, "x" section and that the skipped space is
   # filled with the specified fill value.
   #
   run_dump_test utc1081

   #
   # This test ensures that the .pskip directie skips the correct number of
   # bytes when in the .text section and that the skipped space is filled with
   # the last specified .pfillvalue.
   #
   run_dump_test utc1082

   #
   # This test ensures that the .pskip directive skips the correct number of
   # bytes when in a .section foo, "x" section and that the skipped space
   # is filled with the last specified .pfillvalue.
   #
   run_dump_test utc1083

   #
   # This test ensures that the maximum value for the fill argument is
   # accepted.
   #
   run_dump_test utc1084

   #
   # This test ensures that the minimum value for the fill argument is
   # accepted.
   #
   run_dump_test utc1085

   #
   # This test ensures that a warning is generated when the fill argument of
   # the .pskip directive is given a value that is one more than the maximum.
   #
   run_test_warning utc1086.s ".pskip - Maximum + 1 Fill" \
      "Value 0x100 truncated to 0x0."

   #
   # This test ensures that a warning is generated when the fill argument of
   # the .pskip directive is given a value that is one less than the minimum.
   #
   run_test_warning utc1087.s ".pskip - Minimum - 1 Fill" \
      "Value 0xffffff7f truncated to 0x7f."

   #
   # This test will ensure that a warning is generated if the .pspace directive
   # is used in a .data section.
   #
   run_test_warning utc1088.s ".pspace in .data" \
      "Directive not specified in a code section.  Directive ignored."

   #
   # This test ensures that the .pspace directive skips the correct number
   # of bytes when in the .text section and that the skipped space is filled
   # with the specified fill value.
   #
   run_dump_test utc1089

   #
   # This test ensures that the .pspace directive skips the correct number
   # of bytes when in the .text section and that the skipped space is filled
   # with the last specified .pfillvalue.
   #
   run_dump_test utc1091

   #
   # This test will ensure that the maximum value for the fill argument is
   # accepted.
   #
   run_dump_test utc1093

   #
   # This test will ensure that the minimum value for the fill argument is
   # accepted.
   #
   run_dump_test utc1094

   #
   # This test ensures that the .pspace directive skips the correct number of
   # bytes when in a .section foo, "x" section and that the skipped space
   # is filled with the specified fill value.
   #
   run_dump_test utc1099

   #
   # This test ensures that the .pspace directive skips the correct number of
   # bytes when in a .section foo, "x" section and that the skipped space
   # is filled with the last specified .pfillvalue.
   #
   run_dump_test utc1100

   #
   # This test ensures that a warning is generated when the fill argument of
   # the .pspace directive is given a value that is one more than the maximum.
   #
   run_test_warning utc1095.s ".pspace - Maximum + 1 Fill" \
      "Value 0x100 truncated to 0x0."

   #
   # This test ensures that a warning is generated when the fill argument of
   # the .pspace directive is given a value that is one less than the minimum.
   #
   run_test_warning utc1096.s ".pspace - Minimum - 1 Fill" \
      "Value 0xffffff7f truncated to 0x7f."

   #
   # This test ensures that a relocation is generated for .pword paddr(foo).
   #
   run_dump_test utc1101

   #
   # This test ensures that a relocation is generated for .long paddr(foo).
   #
   run_dump_test utc1102

   #
   # This test will ensure that the paddr operator is not allowed in a .pbyte
   # directive.
   #
   run_test_error utc1103.s ".pbyte paddr(foo)" \
      "Cannot use paddr with this directive."

   #
   # This test will ensure that the paddr operator is not allowed in a .byte
   # directive.
   #
   run_test_error utc1104.s ".byte paddr(foo)" \
      "Cannot use paddr with this directive."

   #
   # This test will ensure that the paddr operator is not allowed in a .word
   # directive.
   #
   run_test_error utc1105.s ".word paddr(foo)" \
      "Cannot use paddr with this directive."

   #
   # This test will ensure that the paddr operator is not allowed in an
   # instruction.
   #
   run_test_error utc1106.s "paddr in Instruction" \
      "paddr modifier not allowed in instruction."

   #
   # This test will ensure that a constant value used with a paddr operator in
   # a .pword directive is interpreted as a valid PC address.
   #
   run_dump_test utc1107

   #
   # This test will ensure that a constant value used with a paddr operator in
   # a .pword directive is interpreted as a valid PC address.
   #
   run_dump_test utc1108

   #
   # This test will ensure that a BFD_RELOC_PIC30_PGM_ADDR_LSB is created when
   # an absolute address is given to a CALL instruction.
   #
   run_dump_test utc1109

   #
   # This test will ensure that a BFD_RELOC_PIC30_PGM_ADDR_MSB is created when
   # an absolute address is given to a GOTO instruction.
   #
   run_dump_test utc1110

   #
   # This test will ensure that a symbol is created when the --processor
   # command-line option is used.
   #
   run_symbol_test utc1111.s "--processor 30F2010" \
      "--processor - Target Processor Specified" \
      {__30F2010}

   #
   # This test will ensure that an error is given if an invalid processor is
   # specified with the --processor command-line option.
   #
   run_invalid_processor

   #
   # This test ensures that a label in program memory forces alignment to
   # the next addressable location.
   #
   run_dump_test utc1120

   #
   # This test ensures that in the absence of a label, program memory
   # is packed tightly.
   #
   run_dump_test utc1121

   #
   # This test ensures that only valid PC addresses are displayed
   # as section offsets in the listing file.
   #
   run_list_test utc1122

   #
   # This test ensures that each section offset in the listing file
   # corresponds to 3 bytes of program memory
   #
   run_list_test utc1123

   #
   # This test ensures that program memory addresses in the listing file
   # are displayed as 24 bits
   #
   run_list_test utc1124

   #
   # This test ensures that data memory addresses in the listing file
   # are displayed as 16 bits
   #
   run_list_test utc1125

   #
   # This test ensures that padding in program memory is displayed
   # in the listing file after incomplete program words, rather
   # than before the next data directive.
   #
   run_list_test utc1126

   #
   # This test ensures that non-aligned bytes in program memory
   # are translated in the listing file to indicate byte position
   # in the current program word.
   #
   run_list_test utc1127

   #
   # This test ensures that labels in program memory are displayed
   # on a new line, after alignment padding is inserted.
   #
   run_list_test utc1128

   #
   # This test ensures that implicit alignment (as defined in
   # MPLAB C30 v1.10 DOS, section 2.4.3.4) occurs properly
   # when no listing file is enabled.
   #
   run_dump_test utc1129

   #
   # This test ensures that implicit alignment (as defined in
   # MPLAB C30 v1.10 DOS, section 2.4.3.4) occurs properly
   # when a listing file is enabled.
   #
   run_dump_test utc1130

   #
   # This test ensures that an error is given if a data reference
   # is made to a symbol in the .text section (variant #1)
   #
   run_test_error "utc1131.s" \
      "data reference to .text section (BFD_RELOC_PIC30_FILE_REG_WORD)" \
      {Cannot reference executable symbol .* in a data context}

   #
   # This test ensures that an error is given if a data reference
   # is made to a symbol in the .text section (variant #2)
   #
   run_test_error "utc1132.s" \
      "data reference to .text section (BFD_RELOC_PIC30_FILE_REG_WORD_WITH_DST)" \
      {Cannot reference executable symbol .* in a data context}

   #
   # This test ensures that an error is given if a data reference
   # is made to a symbol in the .text section (variant #3)
   #
   run_test_error "utc1133.s" \
      "data reference to .text section (BFD_RELOC_PIC30_WORD)" \
      {Cannot reference executable symbol .* in a data context}

   #
   # This test ensures that a data directive can reference
   # a symbol in the .text section (variant #1)
   #
   run_dump_test utc1134

   #
   # This test ensures that a data directive can reference
   # a symbol in the .text section (variant #2)
   #
   run_dump_test utc1135

   #
   # This test ensures that a data directive can reference
   # a symbol in the .text section (variant #3)
   #
   run_dump_test utc1136

   #
   # This test ensures that an error is given if a data reference
   # is made to a symbol in an "x" section (variant #1)
   #
   run_test_error "utc1137.s" \
      "data reference to \"x\" section (BFD_RELOC_PIC30_FILE_REG_WORD)" \
      {Cannot reference executable symbol .* in a data context}

   #
   # This test ensures that an error is given if a data reference
   # is made to a symbol in an "x" section (variant #2)
   #
   run_test_error "utc1138.s" \
      "data reference to \"x\" section (BFD_RELOC_PIC30_FILE_REG_WORD_WITH_DST)" \
      {Cannot reference executable symbol .* in a data context}

   #
   # This test ensures that an error is given if a data reference
   # is made to a symbol in an "x" section (variant #3)
   #
   run_test_error "utc1139.s" \
      "data reference to \"x\" section (BFD_RELOC_PIC30_WORD)" \
      {Cannot reference executable symbol .* in a data context}

   #
   # This test ensures that a data directive can reference
   # a symbol in a code section (variant #1)
   #
   run_dump_test utc1140

   #
   # This test ensures that a data directive can reference
   # a symbol in a code section (variant #2)
   #
   run_dump_test utc1141

   #
   # This test ensures that a data directive can reference
   # a symbol in a code section (variant #3)
   #
   run_dump_test utc1142

   #
   # This test ensures that non-aligned relocations in CODE sections
   # are displayed with valid PC addresses.
   #
   run_dump_test utc1143

   #
   # This test ensures that non-aligned relocations in READONLY sections
   # are displayed with correct data addresses.
   #
   run_dump_test utc1144

   #
   # This test ensures that non-aligned relocations in DATA sections
   # are displayed with correct data addresses.
   #
   run_dump_test utc1145

   #
   # This test ensures that an error is given if the invalid
   # addressing mode ++[Wn] is used (SSR# 20404)
   #
   setup_xfail pic30*-*-*
   run_test_error "utc1146.s" \
      "invalid addressing mode ++\[Wn\] (SSR# 20404)" \
      {Invalid operand syntax ('\+\+\[w0\]')}

   #
   # This test ensures that an error is given if the invalid
   # addressing mode --[Wn] is used (SSR# 20404)
   #
   setup_xfail pic30*-*-*
   run_test_error "utc1147.s" \
      "invalid addressing mode --\[Wn\] (SSR# 20404)" \
      {Invalid operand syntax ('\-\-\[w0\]')}

   #
   # This test ensures that an error is given if an invalid
   # prefix is used on a floating point constant with the
   # .float directive (SSR# 20836)
   #
   run_test_error "utc1148.s" \
      ".float - invalid floating point prefix (SSR# 20836)" \
      {Prefix .* is not valid for a floating point constant.}

   #
   # This test ensures that an error is given if an invalid
   # prefix is used on a floating point constant with the
   # .double directive (SSR# 20836)
   #
   run_test_error "utc1149.s" \
      ".double - invalid floating point prefix (SSR# 20836)" \
      {Prefix .* is not valid for a floating point constant.}

   #
   # This test ensures that an error is given if an attempt
   # is made to locate executable code in a data section.
   # (SSR# 21676)
   #
   run_test_error "utc1150.s" \
      "attempt to locate code in a data section (SSR# 21676)" \
       {Cannot locate executable code in a data section}

   #
   # This test ensures that the 2-argument form of .bss directive
   # allocates the correct amount of space in the .bss section.
   #
   run_dump_test utc1151

   #
   # This test ensures that the 3-argument form of .bss directive
   # allocates a correctly aligned object and that the .bss section
   # is also aligned.
   #
   run_dump_test utc1152

   #
   # This test ensures that the .lcomm directive allocates
   # the correct amount of space in the .bss section.
   #
   run_dump_test utc1153

   #
   # This test ensures that an error is given if an attempt
   # is made to assign an odd value to the location counter
   # in a code section. (SSR# 22215)
   #
   run_test_error "utc1154.s" \
      "attempt to assign odd value to the location counter(SSR# 22215)" \
       {Odd values are not permitted for new location counter}

   #
   # This test ensures that simple dot expressions are supported
   # in code sections. (SSR# 22168)
   #
   run_dump_test utc1155

   #
   # This test ensures that .porg fill values are used to fill
   # all three bytes of a program memory word. (SSR# 22099)
   #
   run_dump_test utc1156

   #
   # This test ensures that .org from an odd fill point
   # in data memory works properly. (SSR# 22140)
   #
   run_dump_test utc1157

   #
   # This test ensures that dot-assign from an odd fill point
   # in data memory works properly. (SSR# 22140)
   #
   run_dump_test utc1158

   #
   # This test ensures that .org from an odd fill point
   # in program memory works properly.
   #
   run_dump_test utc1159

   #
   # This test ensures that .porg from an odd fill point
   # in program memory works properly.
   #
   run_dump_test utc1160

   #
   # This test ensures that dot-assign from an odd fill point
   # in program memory works properly.
   #
   run_dump_test utc1161

   #
   # This test will ensure that a warning is generated if the "n" and "x"
   # flags are used together in a section definition.
   #
   run_test_warning utc1162.s "'n' and 'x' section flag warning" \
      "This executable section is not loadable"

   #
   # This test ensures that an error is given if a data reference
   # is made to a symbol in the .text section (variant #7)
   #
   run_test_error "utc1163.s" \
      "data reference to .text section (BFD_RELOC_FRAME_SIZE)" \
      {Cannot reference executable symbol .* in a data context}

   #
   # This test ensures that an error is given if a data reference
   # is made to a symbol in an "x" section (variant #7)
   #
   run_test_error "utc1164.s" \
      "data reference to \"x\" section (BFD_RELOC_FRAME_SIZE)" \
      {Cannot reference executable symbol .* in a data context}

   #
   # This test ensures that .align,fill,max_skip works correctly
   # in a non-CODE section (SSR# 22234)
   #
   run_dump_test utc1165

   #
   # This test ensures that an error is given if an undefined
   # symbol is used in an indexed addressing mode operand (SSR# 23044)
   #
   run_test_error "utc1166.s" \
      "undefined symbol in indexed addressing mode operand -- SSR\# 23044" \
      {Register or constant literal expected as second operand of expression}

   #
   # This test ensures that constant expressions may be used in
   # indexing mode operands (SSR# 23014)
   #
   run_dump_test utc1167

   #
   # This test ensures that .incbin, .pincbin can be used in the .text section
   #
   run_dump_test utc1168

   #
   # This test ensures that .incbin, .pincbin can be used in an "x" section
   #
   run_dump_test utc1169

   #
   # This test ensures that .incbin can be used in the .data section
   #
   run_dump_test utc1170

   #
   # This test ensures that .incbin can be used in a "d" section
   #
   run_dump_test utc1171

   #
   # This test ensures that .incbin can be used in an "r" section
   #
   run_dump_test utc1172

   #
   # This test will ensure that an error is given when a dot expression
   # is used as the target of a GOTO
   #
   run_test_error "utc1173.s" \
      "dot expression as GOTO target (SSR\#24791)" \
      {PC Relative expression is not a valid GOTO target.}

   #
   # This test will ensure that an error is given when a dollar expression
   # is used as the target of a GOTO
   #
   run_test_error "utc1174.s" \
      "dollar expression as GOTO target (SSR\#24791)" \
      {PC Relative expression is not a valid GOTO target.}

   #
   # This test will ensure that an error is given when a symbol+constant
   # is used as the target of a GOTO
   #
   run_test_error "utc1175.s" \
      "symbol+constant as GOTO target (SSR\#24791)" \
      {PC Relative expression is not a valid GOTO target.}

   #
   # This test will ensure that an error is given when a symbol+symbol
   # is used as the target of a GOTO
   #
   run_test_error "utc1176.s" \
      "symbol+symbol as GOTO target (SSR\#24791)" \
      {This expression is not a valid GOTO target.}

   #
   # This test will ensure that a warning is generated if a macro
   # is re-defined.                            -- SSR# 23761
   #
   run_test_warning utc1177.s "macro re-defined warning" \
      "Macro \'foo\' has a previous definition."

   #
   # This test will ensure that an error is given if an executable
   # symbol is re-defined                      -- SSR# 22090
   #
   run_test_error "utc1178.s" \
      "redefine executable symbol error (SSR\#22090)" \
      {Cannot re-define executable symbol \'foo\'.}

   #
   # This test will ensure that a warning is generated if a large
   # negative number is used with a .long directive.  -- SSR# 22027
   #
   run_test_warning utc1179.s "large negative numbers (SSR\#22027)" \
      "Overflow/ underflow for \.long may lose significant bits."

  #
  # This test will ensure that dmaoffset() works when the relocation
  # site is in program memory.
  #
   run_dump_test utc1180

  #
  # This test will ensure that dmaoffset() works when the relocation
  # site is in data memory.
  #
   run_dump_test utc1181

  #
  # This test will ensure that dmaoffset() works when the relocation
  # site is in eedata memory.
  #
   run_dump_test utc1182

  #
  # This test will ensure that an error is flagged if the target
  # of dmaoffset() is not defined in a dma section.
  #
   run_test_error utc1183.s \
      "dmaoffset target not in dma section" \
      {Cannot use dmaoffset on a symbol .* that is not located in a dma section.}

  #
  # This test will ensure that the target of dmaoffset()
  # can be a locally defined, global symbol.
  #
   run_dump_test utc1184

  #
  # This test will ensure that the target of dmaoffset()
  # can be an external symbol.
  #
   run_dump_test utc1185

  #
  # This test will ensure that an error is flagged if the argument
  # of dmaoffset() is a constant, when it appears in a data directive.
  #
   run_test_error utc1186.s \
      "constant argument to dmaoffset (data directive)" \
      {Cannot use a constant as the argument of dmaoffset.}

#
# This test will ensure that an error is flagged if the argument
# of dmaoffset() is a constant, when it appears in an instruction.
#
   run_test_error utc1192.s \
      "constant argument to dmaoffset (instruction)" \
      {Cannot use a constant as the argument of dmaoffset.}

  #
  # This test will ensure that the dma section attribute is accepted
  # when a valid processor ID is provided.
  #
   gas_test "utc1187.s" "-p24HJ128GP206" "" "dma attribute with valid procID"

  #
  # This test will ensure that an error is flagged if the dma section
  # attribute is used with an processor ID that does not support dma.
  #
   run_test_error_option utc1187.s "-p30F6014" \
      "dma attribute with invalid procID" \
      {processor .* does not support dma memory.}


  #
  # This test will ensure that an error is flagged if the dma section
  # attribute is used with the generic-16bit proc ID.
  #
   run_test_error_option utc1187.s "-pgeneric-16bit" \
      "dma attribute with generic-16bit  procID" \
      {processor GENERIC-16BIT does not support dma memory.}

  #
  # This test will ensure that the eedata section attribute is accepted
  # when a valid processor ID is provided.
  #
   gas_test "utc1188.s" "-p30F2010" "" "eedata attribute with valid procID"

  #
  # This test will ensure that an error is flagged if the eedata section
  # is used with an processor ID that does not support eedata.
  #
   run_test_error_option utc1188.s "-p30F2011" \
      "eedata attribute with invalid procID" \
      {processor .* does not support eedata memory.}

  #
  # This test will ensure that an error is flagged if the eedata section
  # is used with the generic-16bit proc ID.
  #
   run_test_error_option utc1188.s "-pgeneric-16bit" \
      "eedata attribute with generic-16bit procID" \
      {processor GENERIC-16BIT does not support eedata memory.}

  #
  # This test will ensure that the xmemory section attribute is accepted
  # when a valid processor ID is provided.
  #
   gas_test "utc1189.s" "-p30F2010" "" "xmemory attribute with valid procID"

  #
  # This test will ensure that an error is flagged if the xmemory section
  # is used with an processor ID that does not support xmemory.
  #
   run_test_error_option utc1189.s "-p24HJ128GP206" \
      "xmemory attribute with invalid procID" \
      {processor .* does not support X memory.}

  #
  # This test will ensure that an error is flagged if the xmemory section
  # is used with the generic-16bit proc ID.
  #
   run_test_error_option utc1189.s "-pgeneric-16bit" \
      "xmemory attribute with generic-16bit procID" \
      {processor GENERIC-16BIT does not support X memory.}

  #
  # This test will ensure that the ymemory section attribute is accepted
  # when a valid processor ID is provided.
  #
   gas_test "utc1190.s" "-p30F2010" "" "ymemory attribute with valid procID"

  #
  # This test will ensure that an error is flagged if the ymemory section
  # is used with an processor ID that does not support ymemory.
  #
   run_test_error_option utc1190.s "-p24HJ128GP206" \
      "ymemory attribute with invalid procID" \
      {processor .* does not support Y memory.}

  #
  # This test will ensure that an error is flagged if the ymemory section
  # is used with the generic-16bit proc ID.
  #
   run_test_error_option utc1190.s "-pgeneric-16bit" \
      "ymemory attribute with generic-16bit procID" \
      {processor GENERIC-16BIT does not support Y memory.}

  #
  # This test will ensure that MAC instructions are accepted
  # for a 30F device.
  #
   gas_test "utc1191.s" "-p30F2010" "" "MAC instruction with valid procID"

  #
  # This test will ensure that MAC instructions are accepted
  # for a 33F device.
  #
   gas_test "utc1191.s" "-p33FJ128GP706" "" "MAC instruction with valid procID"

  #
  # This test will ensure that an error is flagged if a MAC instruction
  # is used with a 24F device.
  #
   run_test_error_option utc1191.s "-p24FJ128GA006" \
      "MAC instruction with invalid procID" \
      {This instruction is not supported in the .* device.}

  #
  # This test will ensure that an error is flagged if a MAC instruction
  # is used with a 24H device.
  #
   run_test_error_option utc1191.s "-p24HJ128GP206" \
      "MAC instruction with invalid procID" \
      {This instruction is not supported in the .* device.}

  #
  # This test will ensure that an error is flagged if a MAC instruction
  # is used with a generic-16bit device.
  #
   run_test_error_option utc1191.s "-pgeneric-16bit" \
      "MAC instruction with invalid procID" \
      {This instruction is not supported in the GENERIC-16BIT device.}

  #
  # This test will ensure that the __dsPIC30F symbol is defined
  # if a family member processor is specified
  #
   run_dump_test utc1193

  #
  # This test will ensure that the __dsPIC30F symbol is not defined
  # if a different family member processor is specified
  #
   run_dump_test utc1194

  #
  # This test will ensure that the __dsPIC33F symbol is defined
  # if a family member processor is specified
  #
   run_dump_test utc1195

  #
  # This test will ensure that the __dsPIC33F symbol is not defined
  # if a different family member processor is specified
  #
   run_dump_test utc1196

  #
  # This test will ensure that the __PIC24F symbol is defined
  # if a family member processor is specified
  #
   run_dump_test utc1197

  #
  # This test will ensure that the __PIC24F symbol is not defined
  # if a different family member processor is specified
  #
   run_dump_test utc1198

  #
  # This test will ensure that the __PIC24H symbol is defined
  # if a family member processor is specified
  #
   run_dump_test utc1199

  #
  # This test will ensure that the __PIC24H symbol is not defined
  # if a different family member processor is specified
  #
   run_dump_test utc1200

  #
  # This test will ensure that .ifdecl recognizes
  # an extern symbol
  #
   run_dump_test utc1201

  #
  # This test will ensure that .ifdecl recognizes
  # a defined symbol
  #
   run_dump_test utc1202

  #
  # This test will ensure that .ifdecl recognizes
  # a symbol that is not extern or defined (negative)
  #
   run_dump_test utc1203

  #
  # This test will ensure that .ifndecl recognizes
  # that a symbol has not been declared extern or defined
  #
   run_dump_test utc1204

  #
  # This test will ensure that w5*w4 can be accepted as
  # an operand to the mac instruction (SSR# 27678)
  #
   run_dump_test utc1205

  #
  # This test will ensure that boot is accepted
  # in a code section
  #
   run_dump_test utc1206

  #
  # This test will ensure that boot is accepted
  # in a psv section
  #
   run_dump_test utc1207

  #
  # This test will ensure that boot is accepted
  # in a bss section
  #
   run_dump_test utc1208

  #
  # This test will ensure that boot is accepted
  # in a eedata section
  #
   run_dump_test utc1209

  #
  # This test will ensure that secure is accepted
  # in a code section
  #
   run_dump_test utc1210

  #
  # This test will ensure that secure is accepted
  # in a psv section
  #
   run_dump_test utc1211

  #
  # This test will ensure that secure is accepted
  # in a bss section
  #
   run_dump_test utc1212

  #
  # This test will ensure that secure is accepted
  # in a eedata section
  #
   run_dump_test utc1213

  #
  # This test will ensure that an error is flagged if the
  # boot attribute is applied to a data section.
  #
   run_test_error utc1214.s \
      "boot applied to data section" \
      {invalid attribute combination for test}

  #
  # This test will ensure that an error is flagged if the
  # boot attribute is applied to a persist section.
  #
   run_test_error utc1215.s \
      "boot applied to persist section" \
      {invalid attribute combination for test}

  #
  # This test will ensure that an error is flagged if the
  # secure attribute is applied to a data section.
  #
   run_test_error utc1216.s \
      "secure applied to data section" \
      {invalid attribute combination for test}

  #
  # This test will ensure that an error is flagged if the
  # secure attribute is applied to a persist section.
  #
   run_test_error utc1217.s \
      "secure applied to persist section" \
      {invalid attribute combination for test}

  #
  # This test will ensure that an error is flagged if
  # boot(n) is used with out-of-range value 0.
  #
   run_test_error utc1218.s \
      "boot(n) range error: -1" \
      {Argument to boot\(\) must be in the range 0..15 or 17..31}

  #
  # This test will ensure that the range 1..15 is accepted
  # with boot(n)
  #
   run_dump_test utc1219

  #
  # This test will ensure that an error is flagged if
  # boot(n) is used in a bss section
  #
   run_test_error utc1220.s \
      "boot(n) in bss section" \
      {Access entry points are supported only in CODE and in AUXFLASH sections}

  #
  # This test will ensure that an error is flagged if
  # boot(n) is used in a psv section
  #
   run_test_error utc1221.s \
      "boot(n) in psv section" \
      {Access entry points are supported only in CODE and in AUXFLASH sections}

  #
  # This test will ensure that an error is flagged if
  # boot(n) is used in an eedata section
  #
   run_test_error utc1222.s \
      "boot(n) in eedata section" \
      {Access entry points are supported only in CODE and in AUXFLASH sections}

  #
  # This test will ensure that an error is flagged if
  # boot(n) is used with out-of-range value 16.
  #
   run_test_error utc1223.s \
      "boot(n) range error: 16" \
      {Argument to boot\(\) must be in the range 0..15 or 17..31}

  #
  # This test will ensure that the range 17..31 is accepted
  # with boot(n)
  #
   run_dump_test utc1224

  #
  # This test will ensure that an error is flagged if
  # boot(n) is used with out-of-range value 33.
  #
   run_test_error utc1225.s \
      "boot(n) range error: 32" \
      {Argument to boot\(\) must be in the range 0..15 or 17..31}

  #
  # This test will ensure that an error is flagged if
  # secure(n) is used with out-of-range value 0.
  #
   run_test_error utc1226.s \
      "secure(n) range error: -1" \
      {Argument to secure\(\) must be in the range 0..15 or 17..31}

  #
  # This test will ensure that the range 1..15 is accepted
  # with secure(n)
  #
   run_dump_test utc1227

  #
  # This test will ensure that an error is flagged if
  # secure(n) is used in a bss section
  #
   run_test_error utc1228.s \
      "secure(n) in bss section" \
      {Access entry points are supported only in CODE and in AUXFLASH sections}

  #
  # This test will ensure that an error is flagged if
  # secure(n) is used in a psv section
  #
   run_test_error utc1229.s \
      "secure(n) in psv section" \
      {Access entry points are supported only in CODE and in AUXFLASH sections}

  #
  # This test will ensure that an error is flagged if
  # secure(n) is used in a psv section
  #
   run_test_error utc1230.s \
      "secure(n) in eedata section" \
      {Access entry points are supported only in CODE and in AUXFLASH sections}

  #
  # This test will ensure that an error is flagged if
  # boot(n) is used with out-of-range value 16.
  #
   run_test_error utc1231.s \
      "secure(n) range error: 16" \
      {Argument to secure\(\) must be in the range 0..15 or 17..31}

  #
  # This test will ensure that the range 17..31 is accepted
  # with secure(n)
  #
   run_dump_test utc1232

  #
  # This test will ensure that an error is flagged if
  # boot(n) is used with out-of-range value 33.
  #
   run_test_error utc1233.s \
      "secure(n) range error: 32" \
      {Argument to secure\(\) must be in the range 0..15 or 17..31}

  #
  # This test will ensure that boot(unused) is supported
  # in a code section
  #
   run_symbol_test utc1234.s "" \
      "boot(unused)" \
      {__boot_func:unused}

  #
  # This test will ensure that an error is flagged if
  # boot(unused) is used in a bss section
  #
   run_test_error utc1235.s \
      "boot(unused) in bss section" \
      {Access entry points are supported only in CODE and in AUXFLASH sections}

  #
  # This test will ensure that an error is flagged if
  # boot(unused) is used in a psv section
  #
   run_test_error utc1236.s \
      "boot(unused) in psv section" \
      {Access entry points are supported only in CODE and in AUXFLASH sections}

  #
  # This test will ensure that an error is flagged if
  # boot(unused) is used in an eedata section
  #
   run_test_error utc1237.s \
      "boot(unused) in eedata section" \
      {Access entry points are supported only in CODE and in AUXFLASH sections}

  #
  # This test will ensure that boot(isr) is supported
  # in a code section
  #
   #run_dump_test utc1238
   run_symbol_test utc1238.s "" \
      "boot(isr)" \
      {__boot_func:isr}

  #
  # This test will ensure that an error is flagged if
  # boot(isr) is used in a bss section
  #
   run_test_error utc1239.s \
      "boot(isr) in bss section" \
      {Access entry points are supported only in CODE and in AUXFLASH sections}

  #
  # This test will ensure that an error is flagged if
  # boot(isr) is used in a psv section
  #
   run_test_error utc1240.s \
      "boot(isr) in psv section" \
      {Access entry points are supported only in CODE and in AUXFLASH sections}

  #
  # This test will ensure that an error is flagged if
  # boot(isr) is used in an eedata section
  #
   run_test_error utc1241.s \
      "boot(isr) in eedata section" \
      {Access entry points are supported only in CODE and in AUXFLASH sections}

  #
  # This test will ensure that an error is flagged if
  # boot(foo) is used in a code section
  #
   run_test_error utc1242.s \
      "boot(foo): unrecognized argument" \
      {bad or irreducible absolute expression}

  #
  # This test will ensure that secure(unused) is supported
  # in a code section
  #
   #run_dump_test utc1243
   run_symbol_test utc1243.s "" \
      "secure(unused)" \
      {__secure_func:unused}

  #
  # This test will ensure that an error is flagged if
  # secure(unused) is used in a bss section
  #
   run_test_error utc1244.s \
      "secure(unused) in bss section" \
      {Access entry points are supported only in CODE and in AUXFLASH sections}

  #
  # This test will ensure that an error is flagged if
  # secure(unused) is used in a psv section
  #
   run_test_error utc1245.s \
      "secure(unused) in psv section" \
      {Access entry points are supported only in CODE and in AUXFLASH sections}

  #
  # This test will ensure that an error is flagged if
  # secure(unused) is used in an eedata section
  #
   run_test_error utc1246.s \
      "secure(unused) in eedata section" \
      {Access entry points are supported only in CODE and in AUXFLASH sections}

  #
  # This test will ensure that secure(isr) is supported
  # in a code section
  #
   #run_dump_test utc1247
   run_symbol_test utc1247.s "" \
      "secure(isr)" \
      {__secure_func:isr}

  #
  # This test will ensure that an error is flagged if
  # secure(isr) is used in a bss section
  #
   run_test_error utc1248.s \
      "secure(isr) in bss section" \
      {Access entry points are supported only in CODE and in AUXFLASH sections}

  #
  # This test will ensure that an error is flagged if
  # secure(isr) is used in a psv section
  #
   run_test_error utc1249.s \
      "secure(isr) in psv section" \
      {Access entry points are supported only in CODE and in AUXFLASH sections}

  #
  # This test will ensure that an error is flagged if
  # secure(isr) is used in an eedata section
  #
   run_test_error utc1250.s \
      "secure(isr) in eedata section" \
      {Access entry points are supported only in CODE and in AUXFLASH sections}

  #
  # This test will ensure that an error is flagged if
  # secure(foo) is used in a code section
  #
   run_test_error utc1251.s \
      "secure(foo): unrecognized argument" \
      {bad or irreducible absolute expression}

  #
  # This test will ensure that an error is flagged if
  # initial values are specified in a bss section
  #
   run_test_warning utc1252.s \
      "initial values in bss section" \
      {Initial values are not supported in bss section \'test\'.}

  #
  # This test will ensure that an error is flagged if
  # initial values are specified in a persist section
  #
   run_test_warning utc1253.s \
      "initial values in persist section" \
      {Initial values are not supported in persist section \'test\'.}

  #
  # This test will ensure that an error is flagged if
  # special operator boot() is used without an argument
  #
   run_test_error utc1254.s \
      "boot(n): missing argument" \
      {boot\(\) requires an argument}

  #
  # This test will ensure that an error is flagged if
  # special operator boot(0) is used
  #
   run_test_error utc1255.s \
      "boot(n): argument -1" \
      {Argument to boot\(\) must be in range 0..15 or 17..31}

  #
  # This test will ensure that the range 0..15 is accepted
  # with special operator boot(n)
  #
   run_dump_test utc1256

  #
  # This test will ensure that an error is flagged if
  # special operator boot(16) is used
  #
   run_test_error utc1257.s \
      "boot(n): argument 16" \
      {Argument to boot\(\) must be in range 0..15 or 17..31}

  #
  # This test will ensure that the range 17..31 is accepted
  # with special operator boot(n)
  #
   run_dump_test utc1258

  #
  # This test will ensure that an error is flagged if
  # special operator boot(32) is used
  #
   run_test_error utc1259.s \
      "boot(n): argument 32" \
      {Argument to boot\(\) must be in range 0..15 or 17..31}

  #
  # This test will ensure that special operator boot(n)
  # can be used in an rcall instruction
  #
   run_dump_test utc1260

  #
  # This test will ensure that special operator boot(n)
  # can be used in a mov instruction
  #
   run_dump_test utc1261

  #
  # This test will ensure that special operator boot(n)
  # can be used in a .word directive
  #
   run_dump_test utc1262

  #
  # This test will ensure that special operator boot(n)
  # can be used in a .pword directive
  #
   run_dump_test utc1263

  #
  # This test will ensure that special operator boot(n)
  # can be used in a .long directive
  #
   run_dump_test utc1264

  #
  # This test will ensure that special operator boot(n)
  # can be used in a goto instruction
  #
   run_dump_test utc1265

  #
  # This test will ensure that special operator boot(n)
  # can be used in a bra instruction
  #
   run_dump_test utc1266

  #
  # This test will ensure that special operator boot(n)
  # can be used in a bra cc instruction
  #
   run_dump_test utc1267

  #
  # This test will ensure that an error is flagged if
  # special operator secure() is used without an argument
  #
   run_test_error utc1268.s \
      "secure(n): missing argument" \
      {secure\(\) requires an argument}

  #
  # This test will ensure that an error is flagged if
  # special operator secure(0) is used
  #
   run_test_error utc1269.s \
      "secure(n): argument -1" \
      {Argument to secure\(\) must be in range 0..15 or 17..31}

  #
  # This test will ensure that the range 1..15 is accepted
  # with special operator secure(n)
  #
   run_dump_test utc1270

  #
  # This test will ensure that an error is flagged if
  # special operator secure(16) is used
  #
   run_test_error utc1271.s \
      "secure(n): argument 16" \
      {Argument to secure\(\) must be in range 0..15 or 17..31}

  #
  # This test will ensure that the range 17..31 is accepted
  # with special operator boot(n)
  #
   run_dump_test utc1272

  #
  # This test will ensure that an error is flagged if
  # special operator secure(32) is used
  #
   run_test_error utc1273.s \
      "secure(n): argument 32" \
      {Argument to secure\(\) must be in range 0..15 or 17..31}

  #
  # This test will ensure that special operator secure(n)
  # can be used in an rcall instruction
  #
   run_dump_test utc1274

  #
  # This test will ensure that special operator secure(n)
  # can be used in a mov instruction
  #
   run_dump_test utc1275

  #
  # This test will ensure that special operator secure(n)
  # can be used in a .word directive
  #
   run_dump_test utc1276

  #
  # This test will ensure that special operator secure(n)
  # can be used in a .pword directive
  #
   run_dump_test utc1277

  #
  # This test will ensure that special operator secure(n)
  # can be used in a .long directive
  #
   run_dump_test utc1278

  #
  # This test will ensure that special operator secure(n)
  # can be used in a goto instruction
  #
   run_dump_test utc1279

  #
  # This test will ensure that special operator secure(n)
  # can be used in a bra instruction
  #
   run_dump_test utc1280

  #
  # This test will ensure that special operator secure(n)
  # can be used in a bra cc instruction
  #
   run_dump_test utc1281

  #
  # This test will ensure that special operator psvptr()
  # can be used with a target in a code section
  #
  # run_dump_test utc1282

  #
  # This test will ensure that special operator psvptr()
  # can be used with a target in a psv section
  #
  # run_dump_test utc1283

  #
  # This test will ensure that special operator psvptr()
  # can be used with a target in an eedata section
  #
  # run_dump_test utc1284

  #
  # This test will ensure that an error is flagged if
  # special operator psvptr() is applied to a bss target
  #
  # run_test_error utc1285.s \
  #    "psvptr: target in bss section" \
  #    {Cannot use psvptr on a symbol \(here\) that is not located in a code, psv, or eedata section.}

  #
  # This test will ensure that an error is flagged if
  # special operator psvptr() is applied to a persist target
  #
  # run_test_error utc1286.s \
  #    "psvptr: target in persist section" \
  #    {Cannot use psvptr on a symbol \(here\) that is not located in a code, psv, or eedata section.}

  #
  # This test will ensure that an error is flagged if
  # special operator psvptr() is applied to a data target
  #
  # run_test_error utc1287.s \
  #    "psvptr: target in data section" \
  #    {Cannot use psvptr on a symbol \(here\) that is not located in a code, psv, or eedata section.}

  #
  # This test will ensure that special operator psvptr()
  # can be used with in a .word directive in data memory
  # with an external symbol target
  #
  # run_dump_test utc1288

  #
  # This test will ensure that special operator psvptr()
  # can be used with in a .word directive in program memory
  # with a constant
  #
  # run_dump_test utc1289

  #
  # This test will ensure that special operator psvptr()
  # can be used with in a .pword directive
  # with an external symbol target
  #
  # run_dump_test utc1290

  #
  # This test will ensure that special operator psvptr()
  # can be used with in a .pword directive
  # with a constant
  #
  # run_dump_test utc1291

  #
  # This test will ensure that special operator psvptr()
  # can be used with in a .long directive
  # with an external symbol target
  #
  # run_dump_test utc1292

  #
  # This test will ensure that special operator psvptr()
  # can be used with in a .long directive in program memory
  # with a constant
  #
  # run_dump_test utc1293

  #
  # This test will ensure that the maximum value of 32768
  # is accepted as the argument to the align() attribute
  # in a section directive,
  #
   gas_test "utc1294.s" "" "" "max value of align() in .section directive"

  #
  # This test will ensure that an error is flagged if the argument
  # to the align attribute in .section directive exceeds 32768.
  #
   run_test_error utc1295.s \
      "align(max++) in a .section directive" \
      {section alignment cannot exceed 32768.}

  #
  # This test will ensure that an error is flagged if two
  # different addresses are specified for the same section.
  #
   run_test_error utc1296.s \
      "conflicting address() in multiple .section directives" \
      {section address 0x900 conflicts with previous value 0x800.}

  #
  # Basic test of the .pascii directive
  #
  run_dump_test utc1297

  #
  # This test will ensure that padding is inserted when
  # .pascii follows .byte
  #
  run_dump_test utc1298

  #
  # This test will ensure that no padding is inserted when
  # .pascii follows .pbyte
  #
  run_dump_test utc1299

  #
  # This test will ensure that padding is inserted when
  # .byte follows .pascii
  #
  run_dump_test utc1300

  #
  # This test will ensure that no padding is inserted when
  # .pbyte follows .pascii
  #
  run_dump_test utc1301

  #
  # Basic test of the .pasciz directive
  #
  run_dump_test utc1302

  #
  # Basic test of the .pstring directive
  #
  run_dump_test utc1303

  #
  # This test will ensure that an error is flagged if
  # .pascii is specified in a non-code section
  #
   run_test_warning utc1304.s \
      ".pascii in non-code section" \
      {.pascii, .pasciz, or .pstring not specified in a code section.}

  #
  # Basic test of the .pushsection, .popsection directives
  #
  run_dump_test utc1305

  #
  # This test will ensure that the correct error is reported
  # for an add instruction with many permutations.
  #
   run_test_error utc1306.s \
      "regression test of SSR BIN30-65" \
      {Invalid operands specified \('add w0,#52,w0'\).}

  #
  # These tests will ensure that the correct error is reported
  # if the section name is omitted from a .section directive.
  #
  run_test_error utc1307.s \
     "missing name in .section directive" \
     {invalid section name \(none\)}
  run_test_error utc1308.s \
     "missing name in .section directive (legacy section flags)" \
     {invalid section name \(none\)}

}
