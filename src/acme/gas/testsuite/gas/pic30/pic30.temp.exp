################################################################################
#
# This is the unit-test suite for the pic30 architecture.
#

# pic30.sub1.exp
#
# Updated 3/20/2003, Guy McCarthy
#
# This is a subset of the unit-test suite that is designed to test
# functional changes to the assembler for v1.10. The following unit
# tests are included in the subset:

# utc17   utc18   utc19   utc20   utc21   utc22   utc23   utc24
# utc25   utc26   utc27   utc28   utc29   utc30   utc31   utc32
# utc33   utc34   utc309  utc310  utc348  utc349  utc350  utc351
# utc353  utc354  utc355  utc356  utc357  utc358  utc359  utc796
# utc797  utc798  utc889  utc890  utc891  utc892  utc893  utc931
# utc932  utc933  utc935  utc936  utc1008 utc1009 utc1011 utc1012
# utc1014 utc1015 utc1017 utc1018 utc1020 utc1021 utc1023 utc1024
# utc1025 utc1026 utc1027 utc1028 utc1029 utc1030 utc1031 utc1032
# utc1033 utc1034 utc1036 utc1037 utc1039 utc1040 utc1041 utc1042
# utc1043 utc1044 utc1069 utc1070 utc1071 utc1072 utc1073 utc1074
# utc1075 utc1076 utc1077 utc1078

#
# The following new unit tests were written:

# utc1120 utc1121 utc1122 utc1123 utc1124 utc1125 utc1126 utc1127
# utc1128 utc1129 utc1130 utc1131 utc1132 utc1133 utc1134 utc1135
# utc1136 utc1137 utc1138 utc1139 utc1140 utc1141 utc1142 utc1143
# utc1144 utc1145 utc1146 utc1147 utc1148 utc1149 utc1150 utc1151
# utc1152 utc1153

#
# For the complete unit-test suite, see pic30.exp.
#



proc all_nulls { args } {
    foreach x $args { if [expr $x!=0] { return 0 } }
    return 1
}

#
#  run a test that is supposed to produce no output
#

proc run_to_completion { filename } {
    set output 0
    gas_start $filename ""
    while 1 {
      expect {
        eof { break }
        timeout { perror "timeout\n"; break }
        -re ".*\n" { set output 1 }
      }
    }
    gas_finish
    if [expr $output!=0] then { fail $filename } else { pass $filename }
}

################################################################################
#
# This procedure will ensure that a warning is generated if a .fillupper
# directive is seen in a section that is not a .text or executable section.
#
proc run_fillupper_ignored {} {
   set testname ".fillupper ignored."
   set x1 0
   set x2 0
   gas_start "utc18.s" ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Warning: .fillupper not specified in a code section.  .fillupper ignored\[^\n\]*\n"                           { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that a warning is generated if the optional
# argument for the .fillupper directive exceeds the maximum value.
#
proc run_greater_than_max_fillupper {} {
   set testname ".fillupper Maximum + 1."
   set x1 0
   set x2 0
   gas_start "utc25.s" ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Warning: .fillupper expects a constant positive byte value.  0x00 assumed\[^\n\]*\n"                          { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that a warning is generated if the optional
# argument for the .fillupper directive is less than the minimum value.
#
proc run_less_than_min_fillupper {} {
   set testname ".fillupper Minimum - 1."
   set x1 0
   set x2 0
   gas_start "utc24.s" ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Warning: .fillupper expects a constant positive byte value.  0x00 assumed\[^\n\]*\n"                          { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that a warning is generated if a .fillvalue
# directive is seen in a section that is not a .text or executable section.
#
proc run_fillvalue_ignored {} {
   set testname ".fillvalue ignored."
   set x1 0
   set x2 0
   gas_start "utc26.s" ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Warning: .fillvalue not specified in a code section.  .fillvalue ignored\[^\n\]*\n"                           { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that a warning is generated if the optional
# argument for the .fillvalue directive exceeds the maximum value.
#
proc run_greater_than_max_fillvalue {} {
   set testname ".fillvalue Maximum + 1."
   set x1 0
   set x2 0
   gas_start "utc27.s" ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Warning: .fillvalue expects a constant positive byte value.  0x00 assumed\[^\n\]*\n"                          { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that a warning is generated if the optional
# argument for the .fillvalue directive is less than the minimum value.
#
proc run_less_than_min_fillvalue {} {
   set testname ".fillvalue Minimum - 1."
   set x1 0
   set x2 0
   gas_start "utc32.s" ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Warning: .fillvalue expects a constant positive byte value.  0x00 assumed\[^\n\]*\n"                          { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that an error message is generated if the
# specified directive is used within an assembly source file.
#
proc run_directive_deleted { directive } {
   set testname "$directive deleted"
   set err_msg "Error: $directive directive not supported in pic30 target."

   switch $directive {
      ".balign"   { set tst_src "utc2.s" }
      ".balignl"  { set tst_src "utc3.s" }
      ".balignw"  { set tst_src "utc4.s" }
      ".dcb"      { set tst_src "utc291.s" }
      ".dcb.b"    { set tst_src "utc292.s" }
      ".dcb.d"    { set tst_src "utc294.s" }
      ".dcb.l"    { set tst_src "utc295.s" }
      ".dcb.s"    { set tst_src "utc296.s" }
      ".dcb.w"    { set tst_src "utc297.s" }
      ".dcb.x"    { set tst_src "utc298.s" }
      ".ds"       { set tst_src "utc299.s" }
      ".ds.b"     { set tst_src "utc300.s" }
      ".ds.d"     { set tst_src "utc301.s" }
      ".ds.l"     { set tst_src "utc302.s" }
      ".ds.p"     { set tst_src "utc303.s" }
      ".ds.s"     { set tst_src "utc304.s" }
      ".ds.w"     { set tst_src "utc305.s" }
      ".ds.x"     { set tst_src "utc306.s" }
      ".octa"     { set tst_src "utc74.s" }
      ".p2align"  { set tst_src "utc5.s" }
      ".p2alignl" { set tst_src "utc6.s" }
      ".p2alignw" { set tst_src "utc7.s" }
      ".quad"     { set tst_src "utc75.s" }
      ".zero"     { set tst_src "utc307.s" }
   }

   if {![info exists tst_src]} {
      warning "run_directive_deleted:  $directive not a recognized directive."
      fail $testname
   } else {
      set x1 0
      set x2 0
      gas_start $tst_src ""
      while 1 {
         expect {
             -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
             -re "\[ \t\]*$err_msg\[^\n\]*\n"            { set x2 1 }
             -re "\[^\n\]*\n"                    { }
             timeout                             { perror "timeout\n"; break }
             eof                                 { break }
         }
      }
      gas_finish
      if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
   }
}

################################################################################
#
# This procedure will assemble the program specified by the tst_src argument.
# It will check the output to ensure that an error is generated.
#
proc run_expected_error { tst_src testname } {
   set x1 0
   set x2 0
   gas_start $tst_src ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Error: .*\[^\n\]*\n"           { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that a warning is generated if the argument for
# the .byte directive exceeds the maximum value.
#
proc run_greater_than_max_byte {} {
   set testname ".byte Maximum + 1."
   set x1 0
   set x2 0
   gas_start "utc248.s" ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Warning: Value 0x100 truncated to 0x0.\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that a warning is generated if the argument for
# the .byte directive is less than the minimum value.
#
proc run_less_than_min_byte {} {
   set testname ".byte Minimum - 1."
   set x1 0
   set x2 0
   gas_start "utc249.s" ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Warning: Value 0xffffff7f truncated to 0x7f.\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that a warning is generated if the argument for
# the .word/.hword directive exceeds the maximum value.
#
proc run_greater_than_max_word { is_hword_variant } {
   if { $is_hword_variant } {
      set testname ".hword Maximum + 1."
      set tst_src "utc250.s"
   } else {
      set testname ".word Maximum + 1."
      set tst_src "utc262.s"
   }
   set x1 0
   set x2 0
   gas_start $tst_src ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Warning: Value 0x10000 truncated to 0x0.\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that a warning is generated if the argument for
# the .word/.hword directive is less than the minimum value.
#
proc run_less_than_min_word { is_hword_variant } {
   if { $is_hword_variant } {
      set testname ".hword Minimum - 1."
      set tst_src "utc251.s"
   } else {
      set testname ".word Maximum + 1."
      set tst_src "utc263.s"
   }
   set x1 0
   set x2 0
   gas_start $tst_src ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Warning: Value 0xffff7fff truncated to 0x7fff.\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will test the assembler to ensure that all instructions are
# encoded properly.
#
proc run_isa_encoding { is_full srcdir subdir AS OBJDUMP } {
   if { $is_full } {
      set testname "ISA Encoding - full"
      set flag "-f"
   } else {
      set testname "ISA Encoding - partial"
      set flag "-p"
   }

   send_log "$srcdir/$subdir/isa_encoding.pl -asm $AS -dump $OBJDUMP $flag $srcdir/$subdir/isa.map\n"
   catch "exec $srcdir/lib/run $srcdir/$subdir/isa_encoding.pl -asm $AS -dump $OBJDUMP $flag $srcdir/$subdir/isa.map" comp_output

   send_log "$comp_output\n"

   if { [regexp "Errors found!" $comp_output] || \
        [regexp "Died" $comp_output] ||
        [regexp "bad interpreter" $comp_output] ||
        [regexp "not found" $comp_output] ||
        [regexp "Total Tests Completed = 0." $comp_output] } then {
      fail "$testname"
   } else {
      pass "$testname"
   }
}

################################################################################
#
# This procedure will ensure that a warning is generated if the argument for
# the .int/.long directive exceeds the maximum value.
#
proc run_greater_than_max_int { is_long_variant } {
   if { $is_long_variant } {
      set testname ".long Maximum + 1."
      set tst_src "utc258.s"
   } else {
      set testname ".int Maximum + 1."
      set tst_src "utc254.s"
   }
   set x1 0
   set x2 0
   gas_start $tst_src ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Warning: Value 0x100000000 truncated to 0x0.\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that a warning is generated if the argument for
# the .int/.long directive is less than the minimum value.
#
proc run_less_than_min_int { is_long_variant } {
   if { $is_long_variant } {
      set testname ".long Minimum + 1."
      set tst_src "utc259.s"
   } else {
      set testname ".int Minimum + 1."
      set tst_src "utc255.s"
   }
   set x1 0
   set x2 0
   gas_start $tst_src ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Warning: Value 0xf7fffffff truncated to 0x7fffffff.\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}


################################################################################
#
# This procedure will ensure that a warning is generated if the flag argument
# for the .section directive is invalid.
#
proc run_invalid_section_flag {} {
   set testname ".section - Invalid Flag"
   set x1 0
   set x2 0
   gas_start utc270.s ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Warning: unknown section attribute 'T'\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that a warning is generated if the fill argument
# for the .skip/.space directive exceeds the maximum value.
#
proc run_greater_than_max_skip_fill { is_space_variant } {
   if { $is_space_variant } {
      set testname ".space directive's fill argument - Maximum + 1."
      set tst_src "utc328.s"
   } else {
      set testname ".skip directive's fill argument - Maximum + 1."
      set tst_src "utc319.s"
   }
   set x1 0
   set x2 0
   gas_start $tst_src ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Warning: Value 0x100 truncated to 0x0.\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that a warning is generated if the fill argument
# for the .skip/.space directive is less than the minimum value.
#
proc run_less_than_min_skip_fill { is_space_variant } {
   if { $is_space_variant } {
      set testname ".space directive's fill argument - Minimum + 1."
      set tst_src "utc321.s"
   } else {
      set testname ".skip directive's fill argument - Minimum + 1."
      set tst_src "utc320.s"
   }
   set x1 0
   set x2 0
   gas_start $tst_src ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Warning: Value 0xffffff7f truncated to 0x7f.\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that a warning is generated if the size argument
# for the .fill directive exceeds the maximum value.
#
proc run_greater_than_max_fill_size { } {
   set testname ".fill directive's size argument - Maximum + 1."
   set tst_src "utc345.s"

   set x1 0
   set x2 0
   gas_start $tst_src ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Warning: .fill size clamped to 8.\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that a warning is generated if the size argument
# for the .fill directive is less than the minimum value.
#
proc run_less_than_min_fill_size { } {
   set testname ".fill directive's size argument - Minimum + 1."
   set tst_src "utc346.s"

   set x1 0
   set x2 0
   gas_start $tst_src ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Warning: Size argument < 0.  .fill ignored\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that a warning is generated if the fill argument
# for the .org directive exceeds the maximum value.
#
proc run_greater_than_max_org_fill { } {
   set testname ".org directive's fill argument - Maximum + 1."
   set tst_src "utc357.s"

   set x1 0
   set x2 0
   gas_start $tst_src ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Warning: Value 0x100 truncated to 0x0.\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that a warning is generated if the fill argument
# for the .org directive is less than the minimum value.
#
proc run_less_than_min_org_fill { } {
   set testname ".org directive's fill argument - Minimum + 1."
   set tst_src "utc358.s"

   set x1 0
   set x2 0
   gas_start $tst_src ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Warning: Value 0xffffff7f truncated to 0x7f.\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}


################################################################################
#
# This procedure will ensure that an error is generated if an attempt to .org
# backwards is made.
#
proc run_org_backwards { testname tst_src } {
   set x1 0
   set x2 0
   gas_start $tst_src ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Error: attempt to .org backwards ignored\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that an error is generated if the value for the
# BFD_RELOC_PIC30_BIT_SELECT_3 relocation exceeds the maximum value.
#
proc run_greater_than_maximum_bit_select_3 { } {
   set testname "BFD_RELOC_PIC30_BIT_SELECT_3 - Maximum Relocation + 1"

   set x1 0
   set x2 0
   gas_start utc633.s ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Error: Invalid value \[(\]8\[)\] for relocation BFD_RELOC_PIC30_BIT_SELECT_3\.\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that an error is generated if the value for the
# BFD_RELOC_PIC30_BIT_SELECT_4 relocation exceeds the maximum value.
#
proc run_greater_than_maximum_bit_select_4 { } {
   set testname "BFD_RELOC_PIC30_BIT_SELECT_4 - Maximum Relocation + 1"

   set x1 0
   set x2 0
   gas_start utc644.s ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Error: Invalid value \[(\]16\[)\] for relocation BFD_RELOC_PIC30_BIT_SELECT_4\.\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that an error is generated if the value for the
# BFD_RELOC_PIC30_BIT_SELECT_4_BYTE relocation exceeds the maximum value.
#
proc run_greater_than_maximum_bit_select_4_byte { } {
   set testname "BFD_RELOC_PIC30_BIT_SELECT_4_BYTE - Maximum Relocation + 1"

   set x1 0
   set x2 0
   gas_start utc645.s ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Error: Invalid value \[(\]8\[)\] for relocation BFD_RELOC_PIC30_BIT_SELECT_4_BYTE\.\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that an error is generated if the value for the
# BFD_RELOC_PIC30_DSP_5 relocation exceeds the maximum value.
#
proc run_greater_than_maximum_dsp_5 { } {
   set testname "BFD_RELOC_PIC30_DSP_5 - Maximum Relocation + 1"

   set x1 0
   set x2 0
   gas_start utc651.s ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Error: Invalid value \[(\]16\[)\] for relocation BFD_RELOC_PIC30_DSP_5\.\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that an error is generated if the value for the
# BFD_RELOC_PIC30_DSP_PRESHIFT relocation exceeds the maximum value.
#
proc run_greater_than_maximum_dsp_preshift { } {
   set testname "BFD_RELOC_PIC30_DSP_PRESHIFT - Maximum Relocation + 1"

   set x1 0
   set x2 0
   gas_start utc659.s ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Error: Invalid value \[(\]8\[)\] for relocation BFD_RELOC_PIC30_DSP_PRESHIFT\.\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that an error is generated if handle is used
# on a symbol that is located in .data.
#
proc run_handle_of_local_data_symbol { in_text_section } {
   if { $in_text_section } {
      set testname ".word handle(local .data symbol) in .text"
      set filename "utc771.s"
   } else {
      set testname ".word handle(local .data symbol) in .data"
      set filename "utc773.s"
   }

   set x1 0
   set x2 0
   gas_start $filename ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Error: Cannot use handle on a symbol \[(\]data_symbol\[)\] that is not located in an executable section\.\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that an error is generated if the operands cannot
# be encoded.
#
proc run_invalid_operands_because_of_encoding { tst_cond tst_src } {
   set testname "$tst_cond - Invalid operands because of encoding"
   set x1 0
   set x2 0
   gas_start $tst_src ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Error: Operands share encoding bits.  The operands must encode identically.\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that a warning is generated if the .palign directive
# is found inside of a .data section.
#
proc run_palign_in_data_section { tst_src } {
   set testname ".palign found in .data section"
   set x1 0
   set x2 0
   gas_start $tst_src ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Warning: .palign not specified in a code section.  .palign ignored.\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that the appropriate warning is generated.
#
proc run_test_warning { tst_src tst_name tst_wrn } {
   set testname "$tst_name"
   set x1 0
   set x2 0
   gas_start $tst_src ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Warning: $tst_wrn\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that the appropriate error message is generated.
#
proc run_test_error { tst_src tst_name tst_err } {
   set testname "$tst_name"
   set x1 0
   set x2 0
   gas_start $tst_src ""
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Error\: $tst_err\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will ensure that the appropriate error message is generated
# with a specific assembler option.
#
proc run_test_error_option { tst_src tst_option tst_name tst_err } {
   set testname "$tst_name"
   set x1 0
   set x2 0
   gas_start $tst_src $tst_option
   while 1 {
      expect {
          -re "\[ \t\]*Assembler messages:\[^\n\]*\n" { set x1 1 }
          -re "\[ \t\]*Error\: $tst_err\[^\n\]*\n"
                                                      { set x2 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if [all_ones $x1 $x2] then { pass $testname } else { fail $testname }
}

################################################################################
#
# This procedure will run the assembler with the given listing options.
#
# There should be an assembly language file named FILE.s in the test
# suite directory, and a pattern file called FILE.l.  `run_list_test'
# will assemble FILE.s with the given listing options, and then analyze that
# with regexps.
#
# The FILE.l file begins with zero or more option lines which specify  the name
# of the test and flags to pass to the assembler.  The option lines have  the
# syntax:
#
#         # OPTION: VALUE
#
# OPTION is the name of some option, like "name" or "as", and
# VALUE is OPTION's value.  The valid options are described below.
# Whitespace is ignored everywhere, except within VALUE.  The option
# list ends with the first line that doesn't match the above syntax
# (hmm, not great for error detection).
#
# The interesting options are:
#
#   name: TEST-NAME
#       The name of this test, passed to DejaGNU's `pass' and `fail'
#       commands.  If omitted, this defaults to FILE, the root of the
#       .s and .l files' names.
#
#   as: FLAGS
#       When assembling FILE.s, pass FLAGS to the assembler.
#
# Each option may occur at most once.
#
# After the option lines come regexp lines.  `run_list_test' calls
# `regexp_diff' to compare the output of the listing file against the
# regexps in FILE.l.
#
proc run_list_test { name } {
   global srcdir subdir
   global AS
   global ASFLAGS

   if [string match "*/*" $name] {
      set file $name
      set name [file tail $name]
   } else {
      set file "$srcdir/$subdir/$name"
   }
   set opt_array [slurp_options "${file}.l"]
   if { $opt_array == -1 } {
      perror "error reading options from $file.l"
      unresolved $subdir/$name
      return
   }

   set opts(as) {}
   set opts(name) {}

   foreach i $opt_array {
      set opt_name [lindex $i 0]
      set opt_val [lindex $i 1]
      if ![info exists opts($opt_name)] {
         perror "unknown option $opt_name in file $file.l"
         unresolved $subdir/$name
         return
      }
      if [string length $opts($opt_name)] {
         perror "option $opt_name multiply set in $file.l"
         unresolved $subdir/$name
         return
      }
      set opts($opt_name) $opt_val
   }

   if { $opts(name) == "" } {
      set testname "$subdir/$name"
   } else {
      set testname $opts(name)
   }

   set sourcefile ${file}.s

   send_log "$AS $ASFLAGS $opts(as) -o dump.o $sourcefile\n"
   catch "exec $srcdir/lib/run $AS $ASFLAGS $opts(as) -o dump.o $sourcefile > dump.out"

   verbose_eval {[file_contents "dump.out"]} 3
   if { [regexp_diff "dump.out" "${file}.l"] } then {
      fail $testname
      verbose "output is [file_contents "dump.out"]" 2
      verbose "in pic30.exp" 0
      return
   }

    pass $testname
}

################################################################################
#
# This procedure will ensure that the appropriate error message is generated.
#
proc run_invalid_processor { } {
   set testname "--processor - Invalid Processor Specified"
   set x1 0
   gas_start "utc1112.s" "--processor 30F9999"
   while 1 {
      expect {
          -re "\[ \t\]*Unknown processor 30F9999\[^\n\]*\n" { set x1 1 }
          -re "\[^\n\]*\n"                    { }
          timeout                             { perror "timeout\n"; break }
          eof                                 { break }
      }
   }
   gas_finish
   if { $x1 == 1 } then { pass $testname } else { fail $testname }
}

######################################
#
#  This test needs to know the pathname to the test directory...
#  also, currently this test is not expected to work under unix
#

proc run_test_utc1113 { } {
   global srcdir
   global subdir

   set fd [open $srcdir/$subdir/utc1113.s w]
   puts $fd ".include \"$srcdir/$subdir/utc1113\\bug.s\""
   close $fd
   run_to_completion utc1113.s
}
######################################
#
#  This test needs to know the pathname to the test directory.
#

proc run_dump_test_utc241 { } {
   global srcdir
   global subdir

   set fd [open $srcdir/$subdir/utc241.s w]
   puts $fd "\t.include \"$srcdir/$subdir/utc241.inc\""
   close $fd

   run_dump_test utc241

   set fd [open $srcdir/$subdir/utc241.s w]
   puts $fd "\t.include \"utc241.inc\""
   close $fd
}

################################################################################

if [istarget pic30*-*-*] {


# Black Magic..
#
# This test must remain in the file or Bad Things Happen. Go figure.
   run_fillupper_ignored


#
# This test will ensure that dmaoffset() works when the relocation
# site is in program memory.
#
   run_dump_test utc1180

#
# This test will ensure that dmaoffset() works when the relocation
# site is in data memory.
#
   run_dump_test utc1181

#
# This test will ensure that dmaoffset() works when the relocation
# site is in eedata memory.
#
   run_dump_test utc1182

#
# This test will ensure that an error is flagged if the target
# of dmaoffset() is not defined in a dma section.
#
   run_test_error utc1183.s \
      "dmaoffset target not in dma section" \
      {Cannot use dmaoffset on a symbol .* that is not located in a dma section.}

#
# This test will ensure that the target of dmaoffset()
# can be a locally defined, global symbol.
#
   run_dump_test utc1184

#
# This test will ensure that the target of dmaoffset()
# can be an external symbol.
#
   run_dump_test utc1185

#
# This test will ensure that an error is flagged if the argument
# of dmaoffset() is a constant, when it appears in a data directive.
#
   run_test_error utc1186.s \
      "constant argument to dmaoffset (data directive)" \
      {Cannot use a constant as the argument of dmaoffset.}

#
# This test will ensure that an error is flagged if the argument
# of dmaoffset() is a constant, when it appears in an instruction.
#
   run_test_error utc1192.s \
      "constant argument to dmaoffset (instruction)" \
      {Cannot use a constant as the argument of dmaoffset.}

#
# This test will ensure that the dma section attribute is accepted
# when a valid processor ID is provided.
#
   gas_test "utc1187.s" "-p24HJ128GP206" "" "dma attribute with valid procID"

#
# This test will ensure that an error is flagged if the dma section
# attribute is used with an processor ID that does not support dma.
#
   run_test_error_option utc1187.s "-p30F6014" \
      "dma attribute with invalid procID" \
      {processor .* does not support dma memory.}


#
# This test will ensure that an error is flagged if the dma section
# attribute is used with the generic-16bit proc ID.
#
   run_test_error_option utc1187.s "-pgeneric-16bit" \
      "dma attribute with generic-16bit  procID" \
      {processor GENERIC-16BIT does not support dma memory.}

#
# This test will ensure that the eedata section attribute is accepted
# when a valid processor ID is provided.
#
   gas_test "utc1188.s" "-p30F2010" "" "eedata attribute with valid procID"

#
# This test will ensure that an error is flagged if the eedata section
# is used with an processor ID that does not support eedata.
#
   run_test_error_option utc1188.s "-p30F2011" \
      "eedata attribute with invalid procID" \
      {processor .* does not support eedata memory.}

#
# This test will ensure that an error is flagged if the eedata section
# is used with the generic-16bit proc ID.
#
   run_test_error_option utc1188.s "-pgeneric-16bit" \
      "eedata attribute with generic-16bit procID" \
      {processor GENERIC-16BIT does not support eedata memory.}

#
# This test will ensure that the xmemory section attribute is accepted
# when a valid processor ID is provided.
#
   gas_test "utc1189.s" "-p30F2010" "" "xmemory attribute with valid procID"

#
# This test will ensure that an error is flagged if the xmemory section
# is used with an processor ID that does not support xmemory.
#
   run_test_error_option utc1189.s "-p24HJ128GP206" \
      "xmemory attribute with invalid procID" \
      {processor .* does not support X memory.}

#
# This test will ensure that an error is flagged if the xmemory section
# is used with the generic-16bit proc ID.
#
   run_test_error_option utc1189.s "-pgeneric-16bit" \
      "xmemory attribute with generic-16bit procID" \
      {processor GENERIC-16BIT does not support X memory.}

#
# This test will ensure that the ymemory section attribute is accepted
# when a valid processor ID is provided.
#
   gas_test "utc1190.s" "-p30F2010" "" "ymemory attribute with valid procID"

#
# This test will ensure that an error is flagged if the ymemory section
# is used with an processor ID that does not support ymemory.
#
   run_test_error_option utc1190.s "-p24HJ128GP206" \
      "ymemory attribute with invalid procID" \
      {processor .* does not support Y memory.}

#
# This test will ensure that an error is flagged if the ymemory section
# is used with the generic-16bit proc ID.
#
   run_test_error_option utc1190.s "-pgeneric-16bit" \
      "ymemory attribute with generic-16bit procID" \
      {processor GENERIC-16BIT does not support Y memory.}

#
# This test will ensure that MAC instructions are accepted
# for a 30F device.
#
   gas_test "utc1191.s" "-p30F2010" "" "MAC instruction with valid procID"

#
# This test will ensure that MAC instructions are accepted
# for a 33F device.
#
   gas_test "utc1191.s" "-p33FJ128GP706" "" "MAC instruction with valid procID"

#
# This test will ensure that an error is flagged if a MAC instruction
# is used with a 24F device.
#
   run_test_error_option utc1191.s "-p24FJ128GA006" \
      "MAC instruction with invalid procID" \
      {This instruction is not supported in the .* device.}

#
# This test will ensure that an error is flagged if a MAC instruction
# is used with a 24H device.
#
   run_test_error_option utc1191.s "-p24HJ128GP206" \
      "MAC instruction with invalid procID" \
      {This instruction is not supported in the .* device.}

#
# This test will ensure that an error is flagged if a MAC instruction
# is used with a generic-16bit device.
#
   run_test_error_option utc1191.s "-pgeneric-16bit" \
      "MAC instruction with invalid procID" \
      {This instruction is not supported in the GENERIC-16BIT device.}

#
# This test will ensure that the __dsPIC30F symbol is defined
# if a family member processor is specified
#
   run_dump_test utc1193

#
# This test will ensure that the __dsPIC30F symbol is not defined
# if a different family member processor is specified
#
   run_dump_test utc1194

#
# This test will ensure that the __dsPIC33F symbol is defined
# if a family member processor is specified
#
   run_dump_test utc1195

#
# This test will ensure that the __dsPIC33F symbol is not defined
# if a different family member processor is specified
#
   run_dump_test utc1196

#
# This test will ensure that the __PIC24F symbol is defined
# if a family member processor is specified
#
   run_dump_test utc1197

#
# This test will ensure that the __PIC24F symbol is not defined
# if a different family member processor is specified
#
   run_dump_test utc1198

#
# This test will ensure that the __PIC24H symbol is defined
# if a family member processor is specified
#
   run_dump_test utc1199

#
# This test will ensure that the __PIC24H symbol is not defined
# if a different family member processor is specified
#
   run_dump_test utc1200

#
# This test will ensure that .ifdecl recognizes
# an extern symbol
#
   run_dump_test utc1201

#
# This test will ensure that .ifdecl recognizes
# a defined symbol
#
   run_dump_test utc1202

#
# This test will ensure that .ifdecl recognizes
# a symbol that is not extern or defined (negative)
#
   run_dump_test utc1203

#
# This test will ensure that .ifndecl recognizes
# that a symbol has not been declared extern or defined
#
   run_dump_test utc1204

#
# This test will ensure that w5*w4 can be accepted as
# an operand to the mac instruction (SSR# 27678)
#
   run_dump_test utc1205


  #
  # Basic test of the .pascii directive
  #
  run_dump_test utc1297

  #
  # This test will ensure that padding is inserted when
  # .pascii follows .byte
  #
  run_dump_test utc1298

  #
  # This test will ensure that no padding is inserted when
  # .pascii follows .pbyte
  #
  run_dump_test utc1299

  #
  # This test will ensure that padding is inserted when
  # .byte follows .pascii
  #
  run_dump_test utc1300

  #
  # This test will ensure that no padding is inserted when
  # .pbyte follows .pascii
  #
  run_dump_test utc1301

  #
  # Basic test of the .pasciz directive
  #
  run_dump_test utc1302

  #
  # Basic test of the .pstring directive
  #
  run_dump_test utc1303

  #
  # This test will ensure that an error is flagged if
  # .pascii is specified in a non-code section
  #
   run_test_warning utc1304.s \
      ".pascii in non-code section" \
      {.pascii, .pasciz, or .pstring not specified in a code section.}
}
